function _mergeNamespaces(n10, m10) {
  for (var i10 = 0; i10 < m10.length; i10++) {
    const e10 = m10[i10];
    if (typeof e10 !== "string" && !Array.isArray(e10)) {
      for (const k10 in e10) {
        if (k10 !== "default" && !(k10 in n10)) {
          const d10 = Object.getOwnPropertyDescriptor(e10, k10);
          if (d10) {
            Object.defineProperty(n10, k10, d10.get ? d10 : {
              enumerable: true,
              get: () => e10[k10]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n10, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function getDefaultExportFromCjs(x10) {
  return x10 && x10.__esModule && Object.prototype.hasOwnProperty.call(x10, "default") ? x10["default"] : x10;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react$1 = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  var l10 = Symbol.for("react.element"), n10 = Symbol.for("react.portal"), p10 = Symbol.for("react.fragment"), q10 = Symbol.for("react.strict_mode"), r10 = Symbol.for("react.profiler"), t10 = Symbol.for("react.provider"), u10 = Symbol.for("react.context"), v10 = Symbol.for("react.forward_ref"), w10 = Symbol.for("react.suspense"), x10 = Symbol.for("react.memo"), y10 = Symbol.for("react.lazy"), z10 = Symbol.iterator;
  function A10(a10) {
    if (null === a10 || "object" !== typeof a10) return null;
    a10 = z10 && a10[z10] || a10["@@iterator"];
    return "function" === typeof a10 ? a10 : null;
  }
  var B10 = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C10 = Object.assign, D10 = {};
  function E10(a10, b10, e10) {
    this.props = a10;
    this.context = b10;
    this.refs = D10;
    this.updater = e10 || B10;
  }
  E10.prototype.isReactComponent = {};
  E10.prototype.setState = function(a10, b10) {
    if ("object" !== typeof a10 && "function" !== typeof a10 && null != a10) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a10, b10, "setState");
  };
  E10.prototype.forceUpdate = function(a10) {
    this.updater.enqueueForceUpdate(this, a10, "forceUpdate");
  };
  function F10() {
  }
  F10.prototype = E10.prototype;
  function G10(a10, b10, e10) {
    this.props = a10;
    this.context = b10;
    this.refs = D10;
    this.updater = e10 || B10;
  }
  var H10 = G10.prototype = new F10();
  H10.constructor = G10;
  C10(H10, E10.prototype);
  H10.isPureReactComponent = true;
  var I10 = Array.isArray, J10 = Object.prototype.hasOwnProperty, K10 = { current: null }, L10 = { key: true, ref: true, __self: true, __source: true };
  function M10(a10, b10, e10) {
    var d10, c10 = {}, k10 = null, h10 = null;
    if (null != b10) for (d10 in void 0 !== b10.ref && (h10 = b10.ref), void 0 !== b10.key && (k10 = "" + b10.key), b10) J10.call(b10, d10) && !L10.hasOwnProperty(d10) && (c10[d10] = b10[d10]);
    var g10 = arguments.length - 2;
    if (1 === g10) c10.children = e10;
    else if (1 < g10) {
      for (var f10 = Array(g10), m10 = 0; m10 < g10; m10++) f10[m10] = arguments[m10 + 2];
      c10.children = f10;
    }
    if (a10 && a10.defaultProps) for (d10 in g10 = a10.defaultProps, g10) void 0 === c10[d10] && (c10[d10] = g10[d10]);
    return { $$typeof: l10, type: a10, key: k10, ref: h10, props: c10, _owner: K10.current };
  }
  function N10(a10, b10) {
    return { $$typeof: l10, type: a10.type, key: b10, ref: a10.ref, props: a10.props, _owner: a10._owner };
  }
  function O10(a10) {
    return "object" === typeof a10 && null !== a10 && a10.$$typeof === l10;
  }
  function escape(a10) {
    var b10 = { "=": "=0", ":": "=2" };
    return "$" + a10.replace(/[=:]/g, function(a11) {
      return b10[a11];
    });
  }
  var P10 = /\/+/g;
  function Q10(a10, b10) {
    return "object" === typeof a10 && null !== a10 && null != a10.key ? escape("" + a10.key) : b10.toString(36);
  }
  function R10(a10, b10, e10, d10, c10) {
    var k10 = typeof a10;
    if ("undefined" === k10 || "boolean" === k10) a10 = null;
    var h10 = false;
    if (null === a10) h10 = true;
    else switch (k10) {
      case "string":
      case "number":
        h10 = true;
        break;
      case "object":
        switch (a10.$$typeof) {
          case l10:
          case n10:
            h10 = true;
        }
    }
    if (h10) return h10 = a10, c10 = c10(h10), a10 = "" === d10 ? "." + Q10(h10, 0) : d10, I10(c10) ? (e10 = "", null != a10 && (e10 = a10.replace(P10, "$&/") + "/"), R10(c10, b10, e10, "", function(a11) {
      return a11;
    })) : null != c10 && (O10(c10) && (c10 = N10(c10, e10 + (!c10.key || h10 && h10.key === c10.key ? "" : ("" + c10.key).replace(P10, "$&/") + "/") + a10)), b10.push(c10)), 1;
    h10 = 0;
    d10 = "" === d10 ? "." : d10 + ":";
    if (I10(a10)) for (var g10 = 0; g10 < a10.length; g10++) {
      k10 = a10[g10];
      var f10 = d10 + Q10(k10, g10);
      h10 += R10(k10, b10, e10, f10, c10);
    }
    else if (f10 = A10(a10), "function" === typeof f10) for (a10 = f10.call(a10), g10 = 0; !(k10 = a10.next()).done; ) k10 = k10.value, f10 = d10 + Q10(k10, g10++), h10 += R10(k10, b10, e10, f10, c10);
    else if ("object" === k10) throw b10 = String(a10), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b10 ? "object with keys {" + Object.keys(a10).join(", ") + "}" : b10) + "). If you meant to render a collection of children, use an array instead.");
    return h10;
  }
  function S10(a10, b10, e10) {
    if (null == a10) return a10;
    var d10 = [], c10 = 0;
    R10(a10, d10, "", "", function(a11) {
      return b10.call(e10, a11, c10++);
    });
    return d10;
  }
  function T10(a10) {
    if (-1 === a10._status) {
      var b10 = a10._result;
      b10 = b10();
      b10.then(function(b11) {
        if (0 === a10._status || -1 === a10._status) a10._status = 1, a10._result = b11;
      }, function(b11) {
        if (0 === a10._status || -1 === a10._status) a10._status = 2, a10._result = b11;
      });
      -1 === a10._status && (a10._status = 0, a10._result = b10);
    }
    if (1 === a10._status) return a10._result.default;
    throw a10._result;
  }
  var U10 = { current: null }, V10 = { transition: null }, W10 = { ReactCurrentDispatcher: U10, ReactCurrentBatchConfig: V10, ReactCurrentOwner: K10 };
  function X10() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S10, forEach: function(a10, b10, e10) {
    S10(a10, function() {
      b10.apply(this, arguments);
    }, e10);
  }, count: function(a10) {
    var b10 = 0;
    S10(a10, function() {
      b10++;
    });
    return b10;
  }, toArray: function(a10) {
    return S10(a10, function(a11) {
      return a11;
    }) || [];
  }, only: function(a10) {
    if (!O10(a10)) throw Error("React.Children.only expected to receive a single React element child.");
    return a10;
  } };
  react_production_min.Component = E10;
  react_production_min.Fragment = p10;
  react_production_min.Profiler = r10;
  react_production_min.PureComponent = G10;
  react_production_min.StrictMode = q10;
  react_production_min.Suspense = w10;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W10;
  react_production_min.act = X10;
  react_production_min.cloneElement = function(a10, b10, e10) {
    if (null === a10 || void 0 === a10) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a10 + ".");
    var d10 = C10({}, a10.props), c10 = a10.key, k10 = a10.ref, h10 = a10._owner;
    if (null != b10) {
      void 0 !== b10.ref && (k10 = b10.ref, h10 = K10.current);
      void 0 !== b10.key && (c10 = "" + b10.key);
      if (a10.type && a10.type.defaultProps) var g10 = a10.type.defaultProps;
      for (f10 in b10) J10.call(b10, f10) && !L10.hasOwnProperty(f10) && (d10[f10] = void 0 === b10[f10] && void 0 !== g10 ? g10[f10] : b10[f10]);
    }
    var f10 = arguments.length - 2;
    if (1 === f10) d10.children = e10;
    else if (1 < f10) {
      g10 = Array(f10);
      for (var m10 = 0; m10 < f10; m10++) g10[m10] = arguments[m10 + 2];
      d10.children = g10;
    }
    return { $$typeof: l10, type: a10.type, key: c10, ref: k10, props: d10, _owner: h10 };
  };
  react_production_min.createContext = function(a10) {
    a10 = { $$typeof: u10, _currentValue: a10, _currentValue2: a10, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a10.Provider = { $$typeof: t10, _context: a10 };
    return a10.Consumer = a10;
  };
  react_production_min.createElement = M10;
  react_production_min.createFactory = function(a10) {
    var b10 = M10.bind(null, a10);
    b10.type = a10;
    return b10;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a10) {
    return { $$typeof: v10, render: a10 };
  };
  react_production_min.isValidElement = O10;
  react_production_min.lazy = function(a10) {
    return { $$typeof: y10, _payload: { _status: -1, _result: a10 }, _init: T10 };
  };
  react_production_min.memo = function(a10, b10) {
    return { $$typeof: x10, type: a10, compare: void 0 === b10 ? null : b10 };
  };
  react_production_min.startTransition = function(a10) {
    var b10 = V10.transition;
    V10.transition = {};
    try {
      a10();
    } finally {
      V10.transition = b10;
    }
  };
  react_production_min.unstable_act = X10;
  react_production_min.useCallback = function(a10, b10) {
    return U10.current.useCallback(a10, b10);
  };
  react_production_min.useContext = function(a10) {
    return U10.current.useContext(a10);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a10) {
    return U10.current.useDeferredValue(a10);
  };
  react_production_min.useEffect = function(a10, b10) {
    return U10.current.useEffect(a10, b10);
  };
  react_production_min.useId = function() {
    return U10.current.useId();
  };
  react_production_min.useImperativeHandle = function(a10, b10, e10) {
    return U10.current.useImperativeHandle(a10, b10, e10);
  };
  react_production_min.useInsertionEffect = function(a10, b10) {
    return U10.current.useInsertionEffect(a10, b10);
  };
  react_production_min.useLayoutEffect = function(a10, b10) {
    return U10.current.useLayoutEffect(a10, b10);
  };
  react_production_min.useMemo = function(a10, b10) {
    return U10.current.useMemo(a10, b10);
  };
  react_production_min.useReducer = function(a10, b10, e10) {
    return U10.current.useReducer(a10, b10, e10);
  };
  react_production_min.useRef = function(a10) {
    return U10.current.useRef(a10);
  };
  react_production_min.useState = function(a10) {
    return U10.current.useState(a10);
  };
  react_production_min.useSyncExternalStore = function(a10, b10, e10) {
    return U10.current.useSyncExternalStore(a10, b10, e10);
  };
  react_production_min.useTransition = function() {
    return U10.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  return react_production_min;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react$1.exports;
  hasRequiredReact = 1;
  {
    react$1.exports = requireReact_production_min();
  }
  return react$1.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f10 = requireReact(), k10 = Symbol.for("react.element"), l10 = Symbol.for("react.fragment"), m10 = Object.prototype.hasOwnProperty, n10 = f10.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p10 = { key: true, ref: true, __self: true, __source: true };
  function q10(c10, a10, g10) {
    var b10, d10 = {}, e10 = null, h10 = null;
    void 0 !== g10 && (e10 = "" + g10);
    void 0 !== a10.key && (e10 = "" + a10.key);
    void 0 !== a10.ref && (h10 = a10.ref);
    for (b10 in a10) m10.call(a10, b10) && !p10.hasOwnProperty(b10) && (d10[b10] = a10[b10]);
    if (c10 && c10.defaultProps) for (b10 in a10 = c10.defaultProps, a10) void 0 === d10[b10] && (d10[b10] = a10[b10]);
    return { $$typeof: k10, type: c10, key: e10, ref: h10, props: d10, _owner: n10.current };
  }
  reactJsxRuntime_production_min.Fragment = l10;
  reactJsxRuntime_production_min.jsx = q10;
  reactJsxRuntime_production_min.jsxs = q10;
  return reactJsxRuntime_production_min;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  if (hasRequiredScheduler_production_min) return scheduler_production_min;
  hasRequiredScheduler_production_min = 1;
  (function(exports) {
    function f10(a10, b10) {
      var c10 = a10.length;
      a10.push(b10);
      a: for (; 0 < c10; ) {
        var d10 = c10 - 1 >>> 1, e10 = a10[d10];
        if (0 < g10(e10, b10)) a10[d10] = b10, a10[c10] = e10, c10 = d10;
        else break a;
      }
    }
    function h10(a10) {
      return 0 === a10.length ? null : a10[0];
    }
    function k10(a10) {
      if (0 === a10.length) return null;
      var b10 = a10[0], c10 = a10.pop();
      if (c10 !== b10) {
        a10[0] = c10;
        a: for (var d10 = 0, e10 = a10.length, w10 = e10 >>> 1; d10 < w10; ) {
          var m10 = 2 * (d10 + 1) - 1, C10 = a10[m10], n10 = m10 + 1, x10 = a10[n10];
          if (0 > g10(C10, c10)) n10 < e10 && 0 > g10(x10, C10) ? (a10[d10] = x10, a10[n10] = c10, d10 = n10) : (a10[d10] = C10, a10[m10] = c10, d10 = m10);
          else if (n10 < e10 && 0 > g10(x10, c10)) a10[d10] = x10, a10[n10] = c10, d10 = n10;
          else break a;
        }
      }
      return b10;
    }
    function g10(a10, b10) {
      var c10 = a10.sortIndex - b10.sortIndex;
      return 0 !== c10 ? c10 : a10.id - b10.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l10 = performance;
      exports.unstable_now = function() {
        return l10.now();
      };
    } else {
      var p10 = Date, q10 = p10.now();
      exports.unstable_now = function() {
        return p10.now() - q10;
      };
    }
    var r10 = [], t10 = [], u10 = 1, v10 = null, y10 = 3, z10 = false, A10 = false, B10 = false, D10 = "function" === typeof setTimeout ? setTimeout : null, E10 = "function" === typeof clearTimeout ? clearTimeout : null, F10 = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G10(a10) {
      for (var b10 = h10(t10); null !== b10; ) {
        if (null === b10.callback) k10(t10);
        else if (b10.startTime <= a10) k10(t10), b10.sortIndex = b10.expirationTime, f10(r10, b10);
        else break;
        b10 = h10(t10);
      }
    }
    function H10(a10) {
      B10 = false;
      G10(a10);
      if (!A10) if (null !== h10(r10)) A10 = true, I10(J10);
      else {
        var b10 = h10(t10);
        null !== b10 && K10(H10, b10.startTime - a10);
      }
    }
    function J10(a10, b10) {
      A10 = false;
      B10 && (B10 = false, E10(L10), L10 = -1);
      z10 = true;
      var c10 = y10;
      try {
        G10(b10);
        for (v10 = h10(r10); null !== v10 && (!(v10.expirationTime > b10) || a10 && !M10()); ) {
          var d10 = v10.callback;
          if ("function" === typeof d10) {
            v10.callback = null;
            y10 = v10.priorityLevel;
            var e10 = d10(v10.expirationTime <= b10);
            b10 = exports.unstable_now();
            "function" === typeof e10 ? v10.callback = e10 : v10 === h10(r10) && k10(r10);
            G10(b10);
          } else k10(r10);
          v10 = h10(r10);
        }
        if (null !== v10) var w10 = true;
        else {
          var m10 = h10(t10);
          null !== m10 && K10(H10, m10.startTime - b10);
          w10 = false;
        }
        return w10;
      } finally {
        v10 = null, y10 = c10, z10 = false;
      }
    }
    var N10 = false, O10 = null, L10 = -1, P10 = 5, Q10 = -1;
    function M10() {
      return exports.unstable_now() - Q10 < P10 ? false : true;
    }
    function R10() {
      if (null !== O10) {
        var a10 = exports.unstable_now();
        Q10 = a10;
        var b10 = true;
        try {
          b10 = O10(true, a10);
        } finally {
          b10 ? S10() : (N10 = false, O10 = null);
        }
      } else N10 = false;
    }
    var S10;
    if ("function" === typeof F10) S10 = function() {
      F10(R10);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T10 = new MessageChannel(), U10 = T10.port2;
      T10.port1.onmessage = R10;
      S10 = function() {
        U10.postMessage(null);
      };
    } else S10 = function() {
      D10(R10, 0);
    };
    function I10(a10) {
      O10 = a10;
      N10 || (N10 = true, S10());
    }
    function K10(a10, b10) {
      L10 = D10(function() {
        a10(exports.unstable_now());
      }, b10);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a10) {
      a10.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A10 || z10 || (A10 = true, I10(J10));
    };
    exports.unstable_forceFrameRate = function(a10) {
      0 > a10 || 125 < a10 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P10 = 0 < a10 ? Math.floor(1e3 / a10) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y10;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h10(r10);
    };
    exports.unstable_next = function(a10) {
      switch (y10) {
        case 1:
        case 2:
        case 3:
          var b10 = 3;
          break;
        default:
          b10 = y10;
      }
      var c10 = y10;
      y10 = b10;
      try {
        return a10();
      } finally {
        y10 = c10;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a10, b10) {
      switch (a10) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a10 = 3;
      }
      var c10 = y10;
      y10 = a10;
      try {
        return b10();
      } finally {
        y10 = c10;
      }
    };
    exports.unstable_scheduleCallback = function(a10, b10, c10) {
      var d10 = exports.unstable_now();
      "object" === typeof c10 && null !== c10 ? (c10 = c10.delay, c10 = "number" === typeof c10 && 0 < c10 ? d10 + c10 : d10) : c10 = d10;
      switch (a10) {
        case 1:
          var e10 = -1;
          break;
        case 2:
          e10 = 250;
          break;
        case 5:
          e10 = 1073741823;
          break;
        case 4:
          e10 = 1e4;
          break;
        default:
          e10 = 5e3;
      }
      e10 = c10 + e10;
      a10 = { id: u10++, callback: b10, priorityLevel: a10, startTime: c10, expirationTime: e10, sortIndex: -1 };
      c10 > d10 ? (a10.sortIndex = c10, f10(t10, a10), null === h10(r10) && a10 === h10(t10) && (B10 ? (E10(L10), L10 = -1) : B10 = true, K10(H10, c10 - d10))) : (a10.sortIndex = e10, f10(r10, a10), A10 || z10 || (A10 = true, I10(J10)));
      return a10;
    };
    exports.unstable_shouldYield = M10;
    exports.unstable_wrapCallback = function(a10) {
      var b10 = y10;
      return function() {
        var c10 = y10;
        y10 = b10;
        try {
          return a10.apply(this, arguments);
        } finally {
          y10 = c10;
        }
      };
    };
  })(scheduler_production_min);
  return scheduler_production_min;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production_min();
  }
  return scheduler.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa2 = requireReact(), ca2 = requireScheduler();
  function p10(a10) {
    for (var b10 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a10, c10 = 1; c10 < arguments.length; c10++) b10 += "&args[]=" + encodeURIComponent(arguments[c10]);
    return "Minified React error #" + a10 + "; visit " + b10 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da2 = /* @__PURE__ */ new Set(), ea2 = {};
  function fa2(a10, b10) {
    ha2(a10, b10);
    ha2(a10 + "Capture", b10);
  }
  function ha2(a10, b10) {
    ea2[a10] = b10;
    for (a10 = 0; a10 < b10.length; a10++) da2.add(b10[a10]);
  }
  var ia2 = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja2 = Object.prototype.hasOwnProperty, ka2 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la2 = {}, ma2 = {};
  function oa2(a10) {
    if (ja2.call(ma2, a10)) return true;
    if (ja2.call(la2, a10)) return false;
    if (ka2.test(a10)) return ma2[a10] = true;
    la2[a10] = true;
    return false;
  }
  function pa2(a10, b10, c10, d10) {
    if (null !== c10 && 0 === c10.type) return false;
    switch (typeof b10) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d10) return false;
        if (null !== c10) return !c10.acceptsBooleans;
        a10 = a10.toLowerCase().slice(0, 5);
        return "data-" !== a10 && "aria-" !== a10;
      default:
        return false;
    }
  }
  function qa2(a10, b10, c10, d10) {
    if (null === b10 || "undefined" === typeof b10 || pa2(a10, b10, c10, d10)) return true;
    if (d10) return false;
    if (null !== c10) switch (c10.type) {
      case 3:
        return !b10;
      case 4:
        return false === b10;
      case 5:
        return isNaN(b10);
      case 6:
        return isNaN(b10) || 1 > b10;
    }
    return false;
  }
  function v10(a10, b10, c10, d10, e10, f10, g10) {
    this.acceptsBooleans = 2 === b10 || 3 === b10 || 4 === b10;
    this.attributeName = d10;
    this.attributeNamespace = e10;
    this.mustUseProperty = c10;
    this.propertyName = a10;
    this.type = b10;
    this.sanitizeURL = f10;
    this.removeEmptyString = g10;
  }
  var z10 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a10) {
    z10[a10] = new v10(a10, 0, false, a10, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a10) {
    var b10 = a10[0];
    z10[b10] = new v10(b10, 1, false, a10[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a10) {
    z10[a10] = new v10(a10, 2, false, a10.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a10) {
    z10[a10] = new v10(a10, 2, false, a10, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a10) {
    z10[a10] = new v10(a10, 3, false, a10.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a10) {
    z10[a10] = new v10(a10, 3, true, a10, null, false, false);
  });
  ["capture", "download"].forEach(function(a10) {
    z10[a10] = new v10(a10, 4, false, a10, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a10) {
    z10[a10] = new v10(a10, 6, false, a10, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a10) {
    z10[a10] = new v10(a10, 5, false, a10.toLowerCase(), null, false, false);
  });
  var ra2 = /[\-:]([a-z])/g;
  function sa2(a10) {
    return a10[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a10) {
    var b10 = a10.replace(
      ra2,
      sa2
    );
    z10[b10] = new v10(b10, 1, false, a10, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a10) {
    var b10 = a10.replace(ra2, sa2);
    z10[b10] = new v10(b10, 1, false, a10, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a10) {
    var b10 = a10.replace(ra2, sa2);
    z10[b10] = new v10(b10, 1, false, a10, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a10) {
    z10[a10] = new v10(a10, 1, false, a10.toLowerCase(), null, false, false);
  });
  z10.xlinkHref = new v10("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a10) {
    z10[a10] = new v10(a10, 1, false, a10.toLowerCase(), null, true, true);
  });
  function ta2(a10, b10, c10, d10) {
    var e10 = z10.hasOwnProperty(b10) ? z10[b10] : null;
    if (null !== e10 ? 0 !== e10.type : d10 || !(2 < b10.length) || "o" !== b10[0] && "O" !== b10[0] || "n" !== b10[1] && "N" !== b10[1]) qa2(b10, c10, e10, d10) && (c10 = null), d10 || null === e10 ? oa2(b10) && (null === c10 ? a10.removeAttribute(b10) : a10.setAttribute(b10, "" + c10)) : e10.mustUseProperty ? a10[e10.propertyName] = null === c10 ? 3 === e10.type ? false : "" : c10 : (b10 = e10.attributeName, d10 = e10.attributeNamespace, null === c10 ? a10.removeAttribute(b10) : (e10 = e10.type, c10 = 3 === e10 || 4 === e10 && true === c10 ? "" : "" + c10, d10 ? a10.setAttributeNS(d10, b10, c10) : a10.setAttribute(b10, c10)));
  }
  var ua2 = aa2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va2 = Symbol.for("react.element"), wa2 = Symbol.for("react.portal"), ya2 = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa2 = Symbol.for("react.profiler"), Ba2 = Symbol.for("react.provider"), Ca2 = Symbol.for("react.context"), Da2 = Symbol.for("react.forward_ref"), Ea2 = Symbol.for("react.suspense"), Fa2 = Symbol.for("react.suspense_list"), Ga2 = Symbol.for("react.memo"), Ha2 = Symbol.for("react.lazy");
  var Ia2 = Symbol.for("react.offscreen");
  var Ja2 = Symbol.iterator;
  function Ka2(a10) {
    if (null === a10 || "object" !== typeof a10) return null;
    a10 = Ja2 && a10[Ja2] || a10["@@iterator"];
    return "function" === typeof a10 ? a10 : null;
  }
  var A10 = Object.assign, La2;
  function Ma(a10) {
    if (void 0 === La2) try {
      throw Error();
    } catch (c10) {
      var b10 = c10.stack.trim().match(/\n( *(at )?)/);
      La2 = b10 && b10[1] || "";
    }
    return "\n" + La2 + a10;
  }
  var Na2 = false;
  function Oa2(a10, b10) {
    if (!a10 || Na2) return "";
    Na2 = true;
    var c10 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b10) if (b10 = function() {
        throw Error();
      }, Object.defineProperty(b10.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b10, []);
        } catch (l10) {
          var d10 = l10;
        }
        Reflect.construct(a10, [], b10);
      } else {
        try {
          b10.call();
        } catch (l10) {
          d10 = l10;
        }
        a10.call(b10.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l10) {
          d10 = l10;
        }
        a10();
      }
    } catch (l10) {
      if (l10 && d10 && "string" === typeof l10.stack) {
        for (var e10 = l10.stack.split("\n"), f10 = d10.stack.split("\n"), g10 = e10.length - 1, h10 = f10.length - 1; 1 <= g10 && 0 <= h10 && e10[g10] !== f10[h10]; ) h10--;
        for (; 1 <= g10 && 0 <= h10; g10--, h10--) if (e10[g10] !== f10[h10]) {
          if (1 !== g10 || 1 !== h10) {
            do
              if (g10--, h10--, 0 > h10 || e10[g10] !== f10[h10]) {
                var k10 = "\n" + e10[g10].replace(" at new ", " at ");
                a10.displayName && k10.includes("<anonymous>") && (k10 = k10.replace("<anonymous>", a10.displayName));
                return k10;
              }
            while (1 <= g10 && 0 <= h10);
          }
          break;
        }
      }
    } finally {
      Na2 = false, Error.prepareStackTrace = c10;
    }
    return (a10 = a10 ? a10.displayName || a10.name : "") ? Ma(a10) : "";
  }
  function Pa2(a10) {
    switch (a10.tag) {
      case 5:
        return Ma(a10.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a10 = Oa2(a10.type, false), a10;
      case 11:
        return a10 = Oa2(a10.type.render, false), a10;
      case 1:
        return a10 = Oa2(a10.type, true), a10;
      default:
        return "";
    }
  }
  function Qa2(a10) {
    if (null == a10) return null;
    if ("function" === typeof a10) return a10.displayName || a10.name || null;
    if ("string" === typeof a10) return a10;
    switch (a10) {
      case ya2:
        return "Fragment";
      case wa2:
        return "Portal";
      case Aa2:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea2:
        return "Suspense";
      case Fa2:
        return "SuspenseList";
    }
    if ("object" === typeof a10) switch (a10.$$typeof) {
      case Ca2:
        return (a10.displayName || "Context") + ".Consumer";
      case Ba2:
        return (a10._context.displayName || "Context") + ".Provider";
      case Da2:
        var b10 = a10.render;
        a10 = a10.displayName;
        a10 || (a10 = b10.displayName || b10.name || "", a10 = "" !== a10 ? "ForwardRef(" + a10 + ")" : "ForwardRef");
        return a10;
      case Ga2:
        return b10 = a10.displayName || null, null !== b10 ? b10 : Qa2(a10.type) || "Memo";
      case Ha2:
        b10 = a10._payload;
        a10 = a10._init;
        try {
          return Qa2(a10(b10));
        } catch (c10) {
        }
    }
    return null;
  }
  function Ra2(a10) {
    var b10 = a10.type;
    switch (a10.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b10.displayName || "Context") + ".Consumer";
      case 10:
        return (b10._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a10 = b10.render, a10 = a10.displayName || a10.name || "", b10.displayName || ("" !== a10 ? "ForwardRef(" + a10 + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b10;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa2(b10);
      case 8:
        return b10 === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b10) return b10.displayName || b10.name || null;
        if ("string" === typeof b10) return b10;
    }
    return null;
  }
  function Sa2(a10) {
    switch (typeof a10) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a10;
      case "object":
        return a10;
      default:
        return "";
    }
  }
  function Ta2(a10) {
    var b10 = a10.type;
    return (a10 = a10.nodeName) && "input" === a10.toLowerCase() && ("checkbox" === b10 || "radio" === b10);
  }
  function Ua2(a10) {
    var b10 = Ta2(a10) ? "checked" : "value", c10 = Object.getOwnPropertyDescriptor(a10.constructor.prototype, b10), d10 = "" + a10[b10];
    if (!a10.hasOwnProperty(b10) && "undefined" !== typeof c10 && "function" === typeof c10.get && "function" === typeof c10.set) {
      var e10 = c10.get, f10 = c10.set;
      Object.defineProperty(a10, b10, { configurable: true, get: function() {
        return e10.call(this);
      }, set: function(a11) {
        d10 = "" + a11;
        f10.call(this, a11);
      } });
      Object.defineProperty(a10, b10, { enumerable: c10.enumerable });
      return { getValue: function() {
        return d10;
      }, setValue: function(a11) {
        d10 = "" + a11;
      }, stopTracking: function() {
        a10._valueTracker = null;
        delete a10[b10];
      } };
    }
  }
  function Va2(a10) {
    a10._valueTracker || (a10._valueTracker = Ua2(a10));
  }
  function Wa2(a10) {
    if (!a10) return false;
    var b10 = a10._valueTracker;
    if (!b10) return true;
    var c10 = b10.getValue();
    var d10 = "";
    a10 && (d10 = Ta2(a10) ? a10.checked ? "true" : "false" : a10.value);
    a10 = d10;
    return a10 !== c10 ? (b10.setValue(a10), true) : false;
  }
  function Xa2(a10) {
    a10 = a10 || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a10) return null;
    try {
      return a10.activeElement || a10.body;
    } catch (b10) {
      return a10.body;
    }
  }
  function Ya2(a10, b10) {
    var c10 = b10.checked;
    return A10({}, b10, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c10 ? c10 : a10._wrapperState.initialChecked });
  }
  function Za2(a10, b10) {
    var c10 = null == b10.defaultValue ? "" : b10.defaultValue, d10 = null != b10.checked ? b10.checked : b10.defaultChecked;
    c10 = Sa2(null != b10.value ? b10.value : c10);
    a10._wrapperState = { initialChecked: d10, initialValue: c10, controlled: "checkbox" === b10.type || "radio" === b10.type ? null != b10.checked : null != b10.value };
  }
  function ab2(a10, b10) {
    b10 = b10.checked;
    null != b10 && ta2(a10, "checked", b10, false);
  }
  function bb2(a10, b10) {
    ab2(a10, b10);
    var c10 = Sa2(b10.value), d10 = b10.type;
    if (null != c10) if ("number" === d10) {
      if (0 === c10 && "" === a10.value || a10.value != c10) a10.value = "" + c10;
    } else a10.value !== "" + c10 && (a10.value = "" + c10);
    else if ("submit" === d10 || "reset" === d10) {
      a10.removeAttribute("value");
      return;
    }
    b10.hasOwnProperty("value") ? cb2(a10, b10.type, c10) : b10.hasOwnProperty("defaultValue") && cb2(a10, b10.type, Sa2(b10.defaultValue));
    null == b10.checked && null != b10.defaultChecked && (a10.defaultChecked = !!b10.defaultChecked);
  }
  function db2(a10, b10, c10) {
    if (b10.hasOwnProperty("value") || b10.hasOwnProperty("defaultValue")) {
      var d10 = b10.type;
      if (!("submit" !== d10 && "reset" !== d10 || void 0 !== b10.value && null !== b10.value)) return;
      b10 = "" + a10._wrapperState.initialValue;
      c10 || b10 === a10.value || (a10.value = b10);
      a10.defaultValue = b10;
    }
    c10 = a10.name;
    "" !== c10 && (a10.name = "");
    a10.defaultChecked = !!a10._wrapperState.initialChecked;
    "" !== c10 && (a10.name = c10);
  }
  function cb2(a10, b10, c10) {
    if ("number" !== b10 || Xa2(a10.ownerDocument) !== a10) null == c10 ? a10.defaultValue = "" + a10._wrapperState.initialValue : a10.defaultValue !== "" + c10 && (a10.defaultValue = "" + c10);
  }
  var eb2 = Array.isArray;
  function fb2(a10, b10, c10, d10) {
    a10 = a10.options;
    if (b10) {
      b10 = {};
      for (var e10 = 0; e10 < c10.length; e10++) b10["$" + c10[e10]] = true;
      for (c10 = 0; c10 < a10.length; c10++) e10 = b10.hasOwnProperty("$" + a10[c10].value), a10[c10].selected !== e10 && (a10[c10].selected = e10), e10 && d10 && (a10[c10].defaultSelected = true);
    } else {
      c10 = "" + Sa2(c10);
      b10 = null;
      for (e10 = 0; e10 < a10.length; e10++) {
        if (a10[e10].value === c10) {
          a10[e10].selected = true;
          d10 && (a10[e10].defaultSelected = true);
          return;
        }
        null !== b10 || a10[e10].disabled || (b10 = a10[e10]);
      }
      null !== b10 && (b10.selected = true);
    }
  }
  function gb2(a10, b10) {
    if (null != b10.dangerouslySetInnerHTML) throw Error(p10(91));
    return A10({}, b10, { value: void 0, defaultValue: void 0, children: "" + a10._wrapperState.initialValue });
  }
  function hb2(a10, b10) {
    var c10 = b10.value;
    if (null == c10) {
      c10 = b10.children;
      b10 = b10.defaultValue;
      if (null != c10) {
        if (null != b10) throw Error(p10(92));
        if (eb2(c10)) {
          if (1 < c10.length) throw Error(p10(93));
          c10 = c10[0];
        }
        b10 = c10;
      }
      null == b10 && (b10 = "");
      c10 = b10;
    }
    a10._wrapperState = { initialValue: Sa2(c10) };
  }
  function ib2(a10, b10) {
    var c10 = Sa2(b10.value), d10 = Sa2(b10.defaultValue);
    null != c10 && (c10 = "" + c10, c10 !== a10.value && (a10.value = c10), null == b10.defaultValue && a10.defaultValue !== c10 && (a10.defaultValue = c10));
    null != d10 && (a10.defaultValue = "" + d10);
  }
  function jb2(a10) {
    var b10 = a10.textContent;
    b10 === a10._wrapperState.initialValue && "" !== b10 && null !== b10 && (a10.value = b10);
  }
  function kb2(a10) {
    switch (a10) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb2(a10, b10) {
    return null == a10 || "http://www.w3.org/1999/xhtml" === a10 ? kb2(b10) : "http://www.w3.org/2000/svg" === a10 && "foreignObject" === b10 ? "http://www.w3.org/1999/xhtml" : a10;
  }
  var mb2, nb2 = function(a10) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b10, c10, d10, e10) {
      MSApp.execUnsafeLocalFunction(function() {
        return a10(b10, c10, d10, e10);
      });
    } : a10;
  }(function(a10, b10) {
    if ("http://www.w3.org/2000/svg" !== a10.namespaceURI || "innerHTML" in a10) a10.innerHTML = b10;
    else {
      mb2 = mb2 || document.createElement("div");
      mb2.innerHTML = "<svg>" + b10.valueOf().toString() + "</svg>";
      for (b10 = mb2.firstChild; a10.firstChild; ) a10.removeChild(a10.firstChild);
      for (; b10.firstChild; ) a10.appendChild(b10.firstChild);
    }
  });
  function ob2(a10, b10) {
    if (b10) {
      var c10 = a10.firstChild;
      if (c10 && c10 === a10.lastChild && 3 === c10.nodeType) {
        c10.nodeValue = b10;
        return;
      }
    }
    a10.textContent = b10;
  }
  var pb2 = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb2 = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb2).forEach(function(a10) {
    qb2.forEach(function(b10) {
      b10 = b10 + a10.charAt(0).toUpperCase() + a10.substring(1);
      pb2[b10] = pb2[a10];
    });
  });
  function rb2(a10, b10, c10) {
    return null == b10 || "boolean" === typeof b10 || "" === b10 ? "" : c10 || "number" !== typeof b10 || 0 === b10 || pb2.hasOwnProperty(a10) && pb2[a10] ? ("" + b10).trim() : b10 + "px";
  }
  function sb2(a10, b10) {
    a10 = a10.style;
    for (var c10 in b10) if (b10.hasOwnProperty(c10)) {
      var d10 = 0 === c10.indexOf("--"), e10 = rb2(c10, b10[c10], d10);
      "float" === c10 && (c10 = "cssFloat");
      d10 ? a10.setProperty(c10, e10) : a10[c10] = e10;
    }
  }
  var tb2 = A10({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub2(a10, b10) {
    if (b10) {
      if (tb2[a10] && (null != b10.children || null != b10.dangerouslySetInnerHTML)) throw Error(p10(137, a10));
      if (null != b10.dangerouslySetInnerHTML) {
        if (null != b10.children) throw Error(p10(60));
        if ("object" !== typeof b10.dangerouslySetInnerHTML || !("__html" in b10.dangerouslySetInnerHTML)) throw Error(p10(61));
      }
      if (null != b10.style && "object" !== typeof b10.style) throw Error(p10(62));
    }
  }
  function vb2(a10, b10) {
    if (-1 === a10.indexOf("-")) return "string" === typeof b10.is;
    switch (a10) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb2 = null;
  function xb2(a10) {
    a10 = a10.target || a10.srcElement || window;
    a10.correspondingUseElement && (a10 = a10.correspondingUseElement);
    return 3 === a10.nodeType ? a10.parentNode : a10;
  }
  var yb2 = null, zb2 = null, Ab2 = null;
  function Bb2(a10) {
    if (a10 = Cb2(a10)) {
      if ("function" !== typeof yb2) throw Error(p10(280));
      var b10 = a10.stateNode;
      b10 && (b10 = Db2(b10), yb2(a10.stateNode, a10.type, b10));
    }
  }
  function Eb2(a10) {
    zb2 ? Ab2 ? Ab2.push(a10) : Ab2 = [a10] : zb2 = a10;
  }
  function Fb2() {
    if (zb2) {
      var a10 = zb2, b10 = Ab2;
      Ab2 = zb2 = null;
      Bb2(a10);
      if (b10) for (a10 = 0; a10 < b10.length; a10++) Bb2(b10[a10]);
    }
  }
  function Gb2(a10, b10) {
    return a10(b10);
  }
  function Hb2() {
  }
  var Ib2 = false;
  function Jb2(a10, b10, c10) {
    if (Ib2) return a10(b10, c10);
    Ib2 = true;
    try {
      return Gb2(a10, b10, c10);
    } finally {
      if (Ib2 = false, null !== zb2 || null !== Ab2) Hb2(), Fb2();
    }
  }
  function Kb2(a10, b10) {
    var c10 = a10.stateNode;
    if (null === c10) return null;
    var d10 = Db2(c10);
    if (null === d10) return null;
    c10 = d10[b10];
    a: switch (b10) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d10 = !d10.disabled) || (a10 = a10.type, d10 = !("button" === a10 || "input" === a10 || "select" === a10 || "textarea" === a10));
        a10 = !d10;
        break a;
      default:
        a10 = false;
    }
    if (a10) return null;
    if (c10 && "function" !== typeof c10) throw Error(p10(231, b10, typeof c10));
    return c10;
  }
  var Lb2 = false;
  if (ia2) try {
    var Mb2 = {};
    Object.defineProperty(Mb2, "passive", { get: function() {
      Lb2 = true;
    } });
    window.addEventListener("test", Mb2, Mb2);
    window.removeEventListener("test", Mb2, Mb2);
  } catch (a10) {
    Lb2 = false;
  }
  function Nb2(a10, b10, c10, d10, e10, f10, g10, h10, k10) {
    var l10 = Array.prototype.slice.call(arguments, 3);
    try {
      b10.apply(c10, l10);
    } catch (m10) {
      this.onError(m10);
    }
  }
  var Ob2 = false, Pb2 = null, Qb2 = false, Rb2 = null, Sb2 = { onError: function(a10) {
    Ob2 = true;
    Pb2 = a10;
  } };
  function Tb2(a10, b10, c10, d10, e10, f10, g10, h10, k10) {
    Ob2 = false;
    Pb2 = null;
    Nb2.apply(Sb2, arguments);
  }
  function Ub2(a10, b10, c10, d10, e10, f10, g10, h10, k10) {
    Tb2.apply(this, arguments);
    if (Ob2) {
      if (Ob2) {
        var l10 = Pb2;
        Ob2 = false;
        Pb2 = null;
      } else throw Error(p10(198));
      Qb2 || (Qb2 = true, Rb2 = l10);
    }
  }
  function Vb2(a10) {
    var b10 = a10, c10 = a10;
    if (a10.alternate) for (; b10.return; ) b10 = b10.return;
    else {
      a10 = b10;
      do
        b10 = a10, 0 !== (b10.flags & 4098) && (c10 = b10.return), a10 = b10.return;
      while (a10);
    }
    return 3 === b10.tag ? c10 : null;
  }
  function Wb2(a10) {
    if (13 === a10.tag) {
      var b10 = a10.memoizedState;
      null === b10 && (a10 = a10.alternate, null !== a10 && (b10 = a10.memoizedState));
      if (null !== b10) return b10.dehydrated;
    }
    return null;
  }
  function Xb2(a10) {
    if (Vb2(a10) !== a10) throw Error(p10(188));
  }
  function Yb2(a10) {
    var b10 = a10.alternate;
    if (!b10) {
      b10 = Vb2(a10);
      if (null === b10) throw Error(p10(188));
      return b10 !== a10 ? null : a10;
    }
    for (var c10 = a10, d10 = b10; ; ) {
      var e10 = c10.return;
      if (null === e10) break;
      var f10 = e10.alternate;
      if (null === f10) {
        d10 = e10.return;
        if (null !== d10) {
          c10 = d10;
          continue;
        }
        break;
      }
      if (e10.child === f10.child) {
        for (f10 = e10.child; f10; ) {
          if (f10 === c10) return Xb2(e10), a10;
          if (f10 === d10) return Xb2(e10), b10;
          f10 = f10.sibling;
        }
        throw Error(p10(188));
      }
      if (c10.return !== d10.return) c10 = e10, d10 = f10;
      else {
        for (var g10 = false, h10 = e10.child; h10; ) {
          if (h10 === c10) {
            g10 = true;
            c10 = e10;
            d10 = f10;
            break;
          }
          if (h10 === d10) {
            g10 = true;
            d10 = e10;
            c10 = f10;
            break;
          }
          h10 = h10.sibling;
        }
        if (!g10) {
          for (h10 = f10.child; h10; ) {
            if (h10 === c10) {
              g10 = true;
              c10 = f10;
              d10 = e10;
              break;
            }
            if (h10 === d10) {
              g10 = true;
              d10 = f10;
              c10 = e10;
              break;
            }
            h10 = h10.sibling;
          }
          if (!g10) throw Error(p10(189));
        }
      }
      if (c10.alternate !== d10) throw Error(p10(190));
    }
    if (3 !== c10.tag) throw Error(p10(188));
    return c10.stateNode.current === c10 ? a10 : b10;
  }
  function Zb2(a10) {
    a10 = Yb2(a10);
    return null !== a10 ? $b2(a10) : null;
  }
  function $b2(a10) {
    if (5 === a10.tag || 6 === a10.tag) return a10;
    for (a10 = a10.child; null !== a10; ) {
      var b10 = $b2(a10);
      if (null !== b10) return b10;
      a10 = a10.sibling;
    }
    return null;
  }
  var ac = ca2.unstable_scheduleCallback, bc2 = ca2.unstable_cancelCallback, cc = ca2.unstable_shouldYield, dc2 = ca2.unstable_requestPaint, B10 = ca2.unstable_now, ec2 = ca2.unstable_getCurrentPriorityLevel, fc2 = ca2.unstable_ImmediatePriority, gc = ca2.unstable_UserBlockingPriority, hc = ca2.unstable_NormalPriority, ic = ca2.unstable_LowPriority, jc2 = ca2.unstable_IdlePriority, kc2 = null, lc = null;
  function mc(a10) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc2, a10, void 0, 128 === (a10.current.flags & 128));
    } catch (b10) {
    }
  }
  var oc2 = Math.clz32 ? Math.clz32 : nc2, pc = Math.log, qc2 = Math.LN2;
  function nc2(a10) {
    a10 >>>= 0;
    return 0 === a10 ? 32 : 31 - (pc(a10) / qc2 | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc2(a10) {
    switch (a10 & -a10) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a10 & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a10 & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a10;
    }
  }
  function uc(a10, b10) {
    var c10 = a10.pendingLanes;
    if (0 === c10) return 0;
    var d10 = 0, e10 = a10.suspendedLanes, f10 = a10.pingedLanes, g10 = c10 & 268435455;
    if (0 !== g10) {
      var h10 = g10 & ~e10;
      0 !== h10 ? d10 = tc2(h10) : (f10 &= g10, 0 !== f10 && (d10 = tc2(f10)));
    } else g10 = c10 & ~e10, 0 !== g10 ? d10 = tc2(g10) : 0 !== f10 && (d10 = tc2(f10));
    if (0 === d10) return 0;
    if (0 !== b10 && b10 !== d10 && 0 === (b10 & e10) && (e10 = d10 & -d10, f10 = b10 & -b10, e10 >= f10 || 16 === e10 && 0 !== (f10 & 4194240))) return b10;
    0 !== (d10 & 4) && (d10 |= c10 & 16);
    b10 = a10.entangledLanes;
    if (0 !== b10) for (a10 = a10.entanglements, b10 &= d10; 0 < b10; ) c10 = 31 - oc2(b10), e10 = 1 << c10, d10 |= a10[c10], b10 &= ~e10;
    return d10;
  }
  function vc(a10, b10) {
    switch (a10) {
      case 1:
      case 2:
      case 4:
        return b10 + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b10 + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a10, b10) {
    for (var c10 = a10.suspendedLanes, d10 = a10.pingedLanes, e10 = a10.expirationTimes, f10 = a10.pendingLanes; 0 < f10; ) {
      var g10 = 31 - oc2(f10), h10 = 1 << g10, k10 = e10[g10];
      if (-1 === k10) {
        if (0 === (h10 & c10) || 0 !== (h10 & d10)) e10[g10] = vc(h10, b10);
      } else k10 <= b10 && (a10.expiredLanes |= h10);
      f10 &= ~h10;
    }
  }
  function xc(a10) {
    a10 = a10.pendingLanes & -1073741825;
    return 0 !== a10 ? a10 : a10 & 1073741824 ? 1073741824 : 0;
  }
  function yc2() {
    var a10 = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a10;
  }
  function zc2(a10) {
    for (var b10 = [], c10 = 0; 31 > c10; c10++) b10.push(a10);
    return b10;
  }
  function Ac(a10, b10, c10) {
    a10.pendingLanes |= b10;
    536870912 !== b10 && (a10.suspendedLanes = 0, a10.pingedLanes = 0);
    a10 = a10.eventTimes;
    b10 = 31 - oc2(b10);
    a10[b10] = c10;
  }
  function Bc2(a10, b10) {
    var c10 = a10.pendingLanes & ~b10;
    a10.pendingLanes = b10;
    a10.suspendedLanes = 0;
    a10.pingedLanes = 0;
    a10.expiredLanes &= b10;
    a10.mutableReadLanes &= b10;
    a10.entangledLanes &= b10;
    b10 = a10.entanglements;
    var d10 = a10.eventTimes;
    for (a10 = a10.expirationTimes; 0 < c10; ) {
      var e10 = 31 - oc2(c10), f10 = 1 << e10;
      b10[e10] = 0;
      d10[e10] = -1;
      a10[e10] = -1;
      c10 &= ~f10;
    }
  }
  function Cc2(a10, b10) {
    var c10 = a10.entangledLanes |= b10;
    for (a10 = a10.entanglements; c10; ) {
      var d10 = 31 - oc2(c10), e10 = 1 << d10;
      e10 & b10 | a10[d10] & b10 && (a10[d10] |= b10);
      c10 &= ~e10;
    }
  }
  var C10 = 0;
  function Dc(a10) {
    a10 &= -a10;
    return 1 < a10 ? 4 < a10 ? 0 !== (a10 & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec2, Fc2, Gc2, Hc2, Ic2, Jc2 = false, Kc2 = [], Lc2 = null, Mc = null, Nc2 = null, Oc2 = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc2 = [], Rc2 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc2(a10, b10) {
    switch (a10) {
      case "focusin":
      case "focusout":
        Lc2 = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc2 = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc2.delete(b10.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b10.pointerId);
    }
  }
  function Tc2(a10, b10, c10, d10, e10, f10) {
    if (null === a10 || a10.nativeEvent !== f10) return a10 = { blockedOn: b10, domEventName: c10, eventSystemFlags: d10, nativeEvent: f10, targetContainers: [e10] }, null !== b10 && (b10 = Cb2(b10), null !== b10 && Fc2(b10)), a10;
    a10.eventSystemFlags |= d10;
    b10 = a10.targetContainers;
    null !== e10 && -1 === b10.indexOf(e10) && b10.push(e10);
    return a10;
  }
  function Uc2(a10, b10, c10, d10, e10) {
    switch (b10) {
      case "focusin":
        return Lc2 = Tc2(Lc2, a10, b10, c10, d10, e10), true;
      case "dragenter":
        return Mc = Tc2(Mc, a10, b10, c10, d10, e10), true;
      case "mouseover":
        return Nc2 = Tc2(Nc2, a10, b10, c10, d10, e10), true;
      case "pointerover":
        var f10 = e10.pointerId;
        Oc2.set(f10, Tc2(Oc2.get(f10) || null, a10, b10, c10, d10, e10));
        return true;
      case "gotpointercapture":
        return f10 = e10.pointerId, Pc.set(f10, Tc2(Pc.get(f10) || null, a10, b10, c10, d10, e10)), true;
    }
    return false;
  }
  function Vc2(a10) {
    var b10 = Wc2(a10.target);
    if (null !== b10) {
      var c10 = Vb2(b10);
      if (null !== c10) {
        if (b10 = c10.tag, 13 === b10) {
          if (b10 = Wb2(c10), null !== b10) {
            a10.blockedOn = b10;
            Ic2(a10.priority, function() {
              Gc2(c10);
            });
            return;
          }
        } else if (3 === b10 && c10.stateNode.current.memoizedState.isDehydrated) {
          a10.blockedOn = 3 === c10.tag ? c10.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a10.blockedOn = null;
  }
  function Xc2(a10) {
    if (null !== a10.blockedOn) return false;
    for (var b10 = a10.targetContainers; 0 < b10.length; ) {
      var c10 = Yc2(a10.domEventName, a10.eventSystemFlags, b10[0], a10.nativeEvent);
      if (null === c10) {
        c10 = a10.nativeEvent;
        var d10 = new c10.constructor(c10.type, c10);
        wb2 = d10;
        c10.target.dispatchEvent(d10);
        wb2 = null;
      } else return b10 = Cb2(c10), null !== b10 && Fc2(b10), a10.blockedOn = c10, false;
      b10.shift();
    }
    return true;
  }
  function Zc2(a10, b10, c10) {
    Xc2(a10) && c10.delete(b10);
  }
  function $c2() {
    Jc2 = false;
    null !== Lc2 && Xc2(Lc2) && (Lc2 = null);
    null !== Mc && Xc2(Mc) && (Mc = null);
    null !== Nc2 && Xc2(Nc2) && (Nc2 = null);
    Oc2.forEach(Zc2);
    Pc.forEach(Zc2);
  }
  function ad2(a10, b10) {
    a10.blockedOn === b10 && (a10.blockedOn = null, Jc2 || (Jc2 = true, ca2.unstable_scheduleCallback(ca2.unstable_NormalPriority, $c2)));
  }
  function bd2(a10) {
    function b10(b11) {
      return ad2(b11, a10);
    }
    if (0 < Kc2.length) {
      ad2(Kc2[0], a10);
      for (var c10 = 1; c10 < Kc2.length; c10++) {
        var d10 = Kc2[c10];
        d10.blockedOn === a10 && (d10.blockedOn = null);
      }
    }
    null !== Lc2 && ad2(Lc2, a10);
    null !== Mc && ad2(Mc, a10);
    null !== Nc2 && ad2(Nc2, a10);
    Oc2.forEach(b10);
    Pc.forEach(b10);
    for (c10 = 0; c10 < Qc2.length; c10++) d10 = Qc2[c10], d10.blockedOn === a10 && (d10.blockedOn = null);
    for (; 0 < Qc2.length && (c10 = Qc2[0], null === c10.blockedOn); ) Vc2(c10), null === c10.blockedOn && Qc2.shift();
  }
  var cd2 = ua2.ReactCurrentBatchConfig, dd = true;
  function ed2(a10, b10, c10, d10) {
    var e10 = C10, f10 = cd2.transition;
    cd2.transition = null;
    try {
      C10 = 1, fd(a10, b10, c10, d10);
    } finally {
      C10 = e10, cd2.transition = f10;
    }
  }
  function gd(a10, b10, c10, d10) {
    var e10 = C10, f10 = cd2.transition;
    cd2.transition = null;
    try {
      C10 = 4, fd(a10, b10, c10, d10);
    } finally {
      C10 = e10, cd2.transition = f10;
    }
  }
  function fd(a10, b10, c10, d10) {
    if (dd) {
      var e10 = Yc2(a10, b10, c10, d10);
      if (null === e10) hd(a10, b10, d10, id, c10), Sc2(a10, d10);
      else if (Uc2(e10, a10, b10, c10, d10)) d10.stopPropagation();
      else if (Sc2(a10, d10), b10 & 4 && -1 < Rc2.indexOf(a10)) {
        for (; null !== e10; ) {
          var f10 = Cb2(e10);
          null !== f10 && Ec2(f10);
          f10 = Yc2(a10, b10, c10, d10);
          null === f10 && hd(a10, b10, d10, id, c10);
          if (f10 === e10) break;
          e10 = f10;
        }
        null !== e10 && d10.stopPropagation();
      } else hd(a10, b10, d10, null, c10);
    }
  }
  var id = null;
  function Yc2(a10, b10, c10, d10) {
    id = null;
    a10 = xb2(d10);
    a10 = Wc2(a10);
    if (null !== a10) if (b10 = Vb2(a10), null === b10) a10 = null;
    else if (c10 = b10.tag, 13 === c10) {
      a10 = Wb2(b10);
      if (null !== a10) return a10;
      a10 = null;
    } else if (3 === c10) {
      if (b10.stateNode.current.memoizedState.isDehydrated) return 3 === b10.tag ? b10.stateNode.containerInfo : null;
      a10 = null;
    } else b10 !== a10 && (a10 = null);
    id = a10;
    return null;
  }
  function jd2(a10) {
    switch (a10) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec2()) {
          case fc2:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc2:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd2 = null, ld2 = null, md = null;
  function nd2() {
    if (md) return md;
    var a10, b10 = ld2, c10 = b10.length, d10, e10 = "value" in kd2 ? kd2.value : kd2.textContent, f10 = e10.length;
    for (a10 = 0; a10 < c10 && b10[a10] === e10[a10]; a10++) ;
    var g10 = c10 - a10;
    for (d10 = 1; d10 <= g10 && b10[c10 - d10] === e10[f10 - d10]; d10++) ;
    return md = e10.slice(a10, 1 < d10 ? 1 - d10 : void 0);
  }
  function od2(a10) {
    var b10 = a10.keyCode;
    "charCode" in a10 ? (a10 = a10.charCode, 0 === a10 && 13 === b10 && (a10 = 13)) : a10 = b10;
    10 === a10 && (a10 = 13);
    return 32 <= a10 || 13 === a10 ? a10 : 0;
  }
  function pd() {
    return true;
  }
  function qd2() {
    return false;
  }
  function rd2(a10) {
    function b10(b11, d10, e10, f10, g10) {
      this._reactName = b11;
      this._targetInst = e10;
      this.type = d10;
      this.nativeEvent = f10;
      this.target = g10;
      this.currentTarget = null;
      for (var c10 in a10) a10.hasOwnProperty(c10) && (b11 = a10[c10], this[c10] = b11 ? b11(f10) : f10[c10]);
      this.isDefaultPrevented = (null != f10.defaultPrevented ? f10.defaultPrevented : false === f10.returnValue) ? pd : qd2;
      this.isPropagationStopped = qd2;
      return this;
    }
    A10(b10.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a11 = this.nativeEvent;
      a11 && (a11.preventDefault ? a11.preventDefault() : "unknown" !== typeof a11.returnValue && (a11.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a11 = this.nativeEvent;
      a11 && (a11.stopPropagation ? a11.stopPropagation() : "unknown" !== typeof a11.cancelBubble && (a11.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b10;
  }
  var sd2 = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a10) {
    return a10.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td2 = rd2(sd2), ud2 = A10({}, sd2, { view: 0, detail: 0 }), vd2 = rd2(ud2), wd2, xd2, yd, Ad2 = A10({}, ud2, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd2, button: 0, buttons: 0, relatedTarget: function(a10) {
    return void 0 === a10.relatedTarget ? a10.fromElement === a10.srcElement ? a10.toElement : a10.fromElement : a10.relatedTarget;
  }, movementX: function(a10) {
    if ("movementX" in a10) return a10.movementX;
    a10 !== yd && (yd && "mousemove" === a10.type ? (wd2 = a10.screenX - yd.screenX, xd2 = a10.screenY - yd.screenY) : xd2 = wd2 = 0, yd = a10);
    return wd2;
  }, movementY: function(a10) {
    return "movementY" in a10 ? a10.movementY : xd2;
  } }), Bd2 = rd2(Ad2), Cd2 = A10({}, Ad2, { dataTransfer: 0 }), Dd2 = rd2(Cd2), Ed = A10({}, ud2, { relatedTarget: 0 }), Fd2 = rd2(Ed), Gd2 = A10({}, sd2, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd2 = rd2(Gd2), Id2 = A10({}, sd2, { clipboardData: function(a10) {
    return "clipboardData" in a10 ? a10.clipboardData : window.clipboardData;
  } }), Jd = rd2(Id2), Kd = A10({}, sd2, { data: 0 }), Ld2 = rd2(Kd), Md2 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd2 = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd2(a10) {
    var b10 = this.nativeEvent;
    return b10.getModifierState ? b10.getModifierState(a10) : (a10 = Od[a10]) ? !!b10[a10] : false;
  }
  function zd2() {
    return Pd2;
  }
  var Qd2 = A10({}, ud2, { key: function(a10) {
    if (a10.key) {
      var b10 = Md2[a10.key] || a10.key;
      if ("Unidentified" !== b10) return b10;
    }
    return "keypress" === a10.type ? (a10 = od2(a10), 13 === a10 ? "Enter" : String.fromCharCode(a10)) : "keydown" === a10.type || "keyup" === a10.type ? Nd2[a10.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd2, charCode: function(a10) {
    return "keypress" === a10.type ? od2(a10) : 0;
  }, keyCode: function(a10) {
    return "keydown" === a10.type || "keyup" === a10.type ? a10.keyCode : 0;
  }, which: function(a10) {
    return "keypress" === a10.type ? od2(a10) : "keydown" === a10.type || "keyup" === a10.type ? a10.keyCode : 0;
  } }), Rd2 = rd2(Qd2), Sd2 = A10({}, Ad2, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td2 = rd2(Sd2), Ud2 = A10({}, ud2, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd2 }), Vd2 = rd2(Ud2), Wd2 = A10({}, sd2, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd2 = rd2(Wd2), Yd = A10({}, Ad2, {
    deltaX: function(a10) {
      return "deltaX" in a10 ? a10.deltaX : "wheelDeltaX" in a10 ? -a10.wheelDeltaX : 0;
    },
    deltaY: function(a10) {
      return "deltaY" in a10 ? a10.deltaY : "wheelDeltaY" in a10 ? -a10.wheelDeltaY : "wheelDelta" in a10 ? -a10.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd2 = rd2(Yd), $d = [9, 13, 27, 32], ae2 = ia2 && "CompositionEvent" in window, be2 = null;
  ia2 && "documentMode" in document && (be2 = document.documentMode);
  var ce2 = ia2 && "TextEvent" in window && !be2, de2 = ia2 && (!ae2 || be2 && 8 < be2 && 11 >= be2), ee2 = String.fromCharCode(32), fe = false;
  function ge2(a10, b10) {
    switch (a10) {
      case "keyup":
        return -1 !== $d.indexOf(b10.keyCode);
      case "keydown":
        return 229 !== b10.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he2(a10) {
    a10 = a10.detail;
    return "object" === typeof a10 && "data" in a10 ? a10.data : null;
  }
  var ie2 = false;
  function je2(a10, b10) {
    switch (a10) {
      case "compositionend":
        return he2(b10);
      case "keypress":
        if (32 !== b10.which) return null;
        fe = true;
        return ee2;
      case "textInput":
        return a10 = b10.data, a10 === ee2 && fe ? null : a10;
      default:
        return null;
    }
  }
  function ke2(a10, b10) {
    if (ie2) return "compositionend" === a10 || !ae2 && ge2(a10, b10) ? (a10 = nd2(), md = ld2 = kd2 = null, ie2 = false, a10) : null;
    switch (a10) {
      case "paste":
        return null;
      case "keypress":
        if (!(b10.ctrlKey || b10.altKey || b10.metaKey) || b10.ctrlKey && b10.altKey) {
          if (b10.char && 1 < b10.char.length) return b10.char;
          if (b10.which) return String.fromCharCode(b10.which);
        }
        return null;
      case "compositionend":
        return de2 && "ko" !== b10.locale ? null : b10.data;
      default:
        return null;
    }
  }
  var le2 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me2(a10) {
    var b10 = a10 && a10.nodeName && a10.nodeName.toLowerCase();
    return "input" === b10 ? !!le2[a10.type] : "textarea" === b10 ? true : false;
  }
  function ne(a10, b10, c10, d10) {
    Eb2(d10);
    b10 = oe(b10, "onChange");
    0 < b10.length && (c10 = new td2("onChange", "change", null, c10, d10), a10.push({ event: c10, listeners: b10 }));
  }
  var pe2 = null, qe2 = null;
  function re2(a10) {
    se2(a10, 0);
  }
  function te2(a10) {
    var b10 = ue2(a10);
    if (Wa2(b10)) return a10;
  }
  function ve(a10, b10) {
    if ("change" === a10) return b10;
  }
  var we2 = false;
  if (ia2) {
    var xe2;
    if (ia2) {
      var ye2 = "oninput" in document;
      if (!ye2) {
        var ze2 = document.createElement("div");
        ze2.setAttribute("oninput", "return;");
        ye2 = "function" === typeof ze2.oninput;
      }
      xe2 = ye2;
    } else xe2 = false;
    we2 = xe2 && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe2 && (pe2.detachEvent("onpropertychange", Be), qe2 = pe2 = null);
  }
  function Be(a10) {
    if ("value" === a10.propertyName && te2(qe2)) {
      var b10 = [];
      ne(b10, qe2, a10, xb2(a10));
      Jb2(re2, b10);
    }
  }
  function Ce2(a10, b10, c10) {
    "focusin" === a10 ? (Ae(), pe2 = b10, qe2 = c10, pe2.attachEvent("onpropertychange", Be)) : "focusout" === a10 && Ae();
  }
  function De2(a10) {
    if ("selectionchange" === a10 || "keyup" === a10 || "keydown" === a10) return te2(qe2);
  }
  function Ee2(a10, b10) {
    if ("click" === a10) return te2(b10);
  }
  function Fe2(a10, b10) {
    if ("input" === a10 || "change" === a10) return te2(b10);
  }
  function Ge(a10, b10) {
    return a10 === b10 && (0 !== a10 || 1 / a10 === 1 / b10) || a10 !== a10 && b10 !== b10;
  }
  var He2 = "function" === typeof Object.is ? Object.is : Ge;
  function Ie2(a10, b10) {
    if (He2(a10, b10)) return true;
    if ("object" !== typeof a10 || null === a10 || "object" !== typeof b10 || null === b10) return false;
    var c10 = Object.keys(a10), d10 = Object.keys(b10);
    if (c10.length !== d10.length) return false;
    for (d10 = 0; d10 < c10.length; d10++) {
      var e10 = c10[d10];
      if (!ja2.call(b10, e10) || !He2(a10[e10], b10[e10])) return false;
    }
    return true;
  }
  function Je2(a10) {
    for (; a10 && a10.firstChild; ) a10 = a10.firstChild;
    return a10;
  }
  function Ke(a10, b10) {
    var c10 = Je2(a10);
    a10 = 0;
    for (var d10; c10; ) {
      if (3 === c10.nodeType) {
        d10 = a10 + c10.textContent.length;
        if (a10 <= b10 && d10 >= b10) return { node: c10, offset: b10 - a10 };
        a10 = d10;
      }
      a: {
        for (; c10; ) {
          if (c10.nextSibling) {
            c10 = c10.nextSibling;
            break a;
          }
          c10 = c10.parentNode;
        }
        c10 = void 0;
      }
      c10 = Je2(c10);
    }
  }
  function Le2(a10, b10) {
    return a10 && b10 ? a10 === b10 ? true : a10 && 3 === a10.nodeType ? false : b10 && 3 === b10.nodeType ? Le2(a10, b10.parentNode) : "contains" in a10 ? a10.contains(b10) : a10.compareDocumentPosition ? !!(a10.compareDocumentPosition(b10) & 16) : false : false;
  }
  function Me() {
    for (var a10 = window, b10 = Xa2(); b10 instanceof a10.HTMLIFrameElement; ) {
      try {
        var c10 = "string" === typeof b10.contentWindow.location.href;
      } catch (d10) {
        c10 = false;
      }
      if (c10) a10 = b10.contentWindow;
      else break;
      b10 = Xa2(a10.document);
    }
    return b10;
  }
  function Ne(a10) {
    var b10 = a10 && a10.nodeName && a10.nodeName.toLowerCase();
    return b10 && ("input" === b10 && ("text" === a10.type || "search" === a10.type || "tel" === a10.type || "url" === a10.type || "password" === a10.type) || "textarea" === b10 || "true" === a10.contentEditable);
  }
  function Oe2(a10) {
    var b10 = Me(), c10 = a10.focusedElem, d10 = a10.selectionRange;
    if (b10 !== c10 && c10 && c10.ownerDocument && Le2(c10.ownerDocument.documentElement, c10)) {
      if (null !== d10 && Ne(c10)) {
        if (b10 = d10.start, a10 = d10.end, void 0 === a10 && (a10 = b10), "selectionStart" in c10) c10.selectionStart = b10, c10.selectionEnd = Math.min(a10, c10.value.length);
        else if (a10 = (b10 = c10.ownerDocument || document) && b10.defaultView || window, a10.getSelection) {
          a10 = a10.getSelection();
          var e10 = c10.textContent.length, f10 = Math.min(d10.start, e10);
          d10 = void 0 === d10.end ? f10 : Math.min(d10.end, e10);
          !a10.extend && f10 > d10 && (e10 = d10, d10 = f10, f10 = e10);
          e10 = Ke(c10, f10);
          var g10 = Ke(
            c10,
            d10
          );
          e10 && g10 && (1 !== a10.rangeCount || a10.anchorNode !== e10.node || a10.anchorOffset !== e10.offset || a10.focusNode !== g10.node || a10.focusOffset !== g10.offset) && (b10 = b10.createRange(), b10.setStart(e10.node, e10.offset), a10.removeAllRanges(), f10 > d10 ? (a10.addRange(b10), a10.extend(g10.node, g10.offset)) : (b10.setEnd(g10.node, g10.offset), a10.addRange(b10)));
        }
      }
      b10 = [];
      for (a10 = c10; a10 = a10.parentNode; ) 1 === a10.nodeType && b10.push({ element: a10, left: a10.scrollLeft, top: a10.scrollTop });
      "function" === typeof c10.focus && c10.focus();
      for (c10 = 0; c10 < b10.length; c10++) a10 = b10[c10], a10.element.scrollLeft = a10.left, a10.element.scrollTop = a10.top;
    }
  }
  var Pe2 = ia2 && "documentMode" in document && 11 >= document.documentMode, Qe2 = null, Re = null, Se2 = null, Te2 = false;
  function Ue(a10, b10, c10) {
    var d10 = c10.window === c10 ? c10.document : 9 === c10.nodeType ? c10 : c10.ownerDocument;
    Te2 || null == Qe2 || Qe2 !== Xa2(d10) || (d10 = Qe2, "selectionStart" in d10 && Ne(d10) ? d10 = { start: d10.selectionStart, end: d10.selectionEnd } : (d10 = (d10.ownerDocument && d10.ownerDocument.defaultView || window).getSelection(), d10 = { anchorNode: d10.anchorNode, anchorOffset: d10.anchorOffset, focusNode: d10.focusNode, focusOffset: d10.focusOffset }), Se2 && Ie2(Se2, d10) || (Se2 = d10, d10 = oe(Re, "onSelect"), 0 < d10.length && (b10 = new td2("onSelect", "select", null, b10, c10), a10.push({ event: b10, listeners: d10 }), b10.target = Qe2)));
  }
  function Ve(a10, b10) {
    var c10 = {};
    c10[a10.toLowerCase()] = b10.toLowerCase();
    c10["Webkit" + a10] = "webkit" + b10;
    c10["Moz" + a10] = "moz" + b10;
    return c10;
  }
  var We2 = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe2 = {}, Ye2 = {};
  ia2 && (Ye2 = document.createElement("div").style, "AnimationEvent" in window || (delete We2.animationend.animation, delete We2.animationiteration.animation, delete We2.animationstart.animation), "TransitionEvent" in window || delete We2.transitionend.transition);
  function Ze2(a10) {
    if (Xe2[a10]) return Xe2[a10];
    if (!We2[a10]) return a10;
    var b10 = We2[a10], c10;
    for (c10 in b10) if (b10.hasOwnProperty(c10) && c10 in Ye2) return Xe2[a10] = b10[c10];
    return a10;
  }
  var $e = Ze2("animationend"), af2 = Ze2("animationiteration"), bf2 = Ze2("animationstart"), cf2 = Ze2("transitionend"), df2 = /* @__PURE__ */ new Map(), ef2 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff2(a10, b10) {
    df2.set(a10, b10);
    fa2(b10, [a10]);
  }
  for (var gf2 = 0; gf2 < ef2.length; gf2++) {
    var hf2 = ef2[gf2], jf2 = hf2.toLowerCase(), kf2 = hf2[0].toUpperCase() + hf2.slice(1);
    ff2(jf2, "on" + kf2);
  }
  ff2($e, "onAnimationEnd");
  ff2(af2, "onAnimationIteration");
  ff2(bf2, "onAnimationStart");
  ff2("dblclick", "onDoubleClick");
  ff2("focusin", "onFocus");
  ff2("focusout", "onBlur");
  ff2(cf2, "onTransitionEnd");
  ha2("onMouseEnter", ["mouseout", "mouseover"]);
  ha2("onMouseLeave", ["mouseout", "mouseover"]);
  ha2("onPointerEnter", ["pointerout", "pointerover"]);
  ha2("onPointerLeave", ["pointerout", "pointerover"]);
  fa2("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa2("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa2("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa2("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa2("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa2("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf2 = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf2 = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf2));
  function nf2(a10, b10, c10) {
    var d10 = a10.type || "unknown-event";
    a10.currentTarget = c10;
    Ub2(d10, b10, void 0, a10);
    a10.currentTarget = null;
  }
  function se2(a10, b10) {
    b10 = 0 !== (b10 & 4);
    for (var c10 = 0; c10 < a10.length; c10++) {
      var d10 = a10[c10], e10 = d10.event;
      d10 = d10.listeners;
      a: {
        var f10 = void 0;
        if (b10) for (var g10 = d10.length - 1; 0 <= g10; g10--) {
          var h10 = d10[g10], k10 = h10.instance, l10 = h10.currentTarget;
          h10 = h10.listener;
          if (k10 !== f10 && e10.isPropagationStopped()) break a;
          nf2(e10, h10, l10);
          f10 = k10;
        }
        else for (g10 = 0; g10 < d10.length; g10++) {
          h10 = d10[g10];
          k10 = h10.instance;
          l10 = h10.currentTarget;
          h10 = h10.listener;
          if (k10 !== f10 && e10.isPropagationStopped()) break a;
          nf2(e10, h10, l10);
          f10 = k10;
        }
      }
    }
    if (Qb2) throw a10 = Rb2, Qb2 = false, Rb2 = null, a10;
  }
  function D10(a10, b10) {
    var c10 = b10[of2];
    void 0 === c10 && (c10 = b10[of2] = /* @__PURE__ */ new Set());
    var d10 = a10 + "__bubble";
    c10.has(d10) || (pf2(b10, a10, 2, false), c10.add(d10));
  }
  function qf2(a10, b10, c10) {
    var d10 = 0;
    b10 && (d10 |= 4);
    pf2(c10, a10, d10, b10);
  }
  var rf2 = "_reactListening" + Math.random().toString(36).slice(2);
  function sf2(a10) {
    if (!a10[rf2]) {
      a10[rf2] = true;
      da2.forEach(function(b11) {
        "selectionchange" !== b11 && (mf2.has(b11) || qf2(b11, false, a10), qf2(b11, true, a10));
      });
      var b10 = 9 === a10.nodeType ? a10 : a10.ownerDocument;
      null === b10 || b10[rf2] || (b10[rf2] = true, qf2("selectionchange", false, b10));
    }
  }
  function pf2(a10, b10, c10, d10) {
    switch (jd2(b10)) {
      case 1:
        var e10 = ed2;
        break;
      case 4:
        e10 = gd;
        break;
      default:
        e10 = fd;
    }
    c10 = e10.bind(null, b10, c10, a10);
    e10 = void 0;
    !Lb2 || "touchstart" !== b10 && "touchmove" !== b10 && "wheel" !== b10 || (e10 = true);
    d10 ? void 0 !== e10 ? a10.addEventListener(b10, c10, { capture: true, passive: e10 }) : a10.addEventListener(b10, c10, true) : void 0 !== e10 ? a10.addEventListener(b10, c10, { passive: e10 }) : a10.addEventListener(b10, c10, false);
  }
  function hd(a10, b10, c10, d10, e10) {
    var f10 = d10;
    if (0 === (b10 & 1) && 0 === (b10 & 2) && null !== d10) a: for (; ; ) {
      if (null === d10) return;
      var g10 = d10.tag;
      if (3 === g10 || 4 === g10) {
        var h10 = d10.stateNode.containerInfo;
        if (h10 === e10 || 8 === h10.nodeType && h10.parentNode === e10) break;
        if (4 === g10) for (g10 = d10.return; null !== g10; ) {
          var k10 = g10.tag;
          if (3 === k10 || 4 === k10) {
            if (k10 = g10.stateNode.containerInfo, k10 === e10 || 8 === k10.nodeType && k10.parentNode === e10) return;
          }
          g10 = g10.return;
        }
        for (; null !== h10; ) {
          g10 = Wc2(h10);
          if (null === g10) return;
          k10 = g10.tag;
          if (5 === k10 || 6 === k10) {
            d10 = f10 = g10;
            continue a;
          }
          h10 = h10.parentNode;
        }
      }
      d10 = d10.return;
    }
    Jb2(function() {
      var d11 = f10, e11 = xb2(c10), g11 = [];
      a: {
        var h11 = df2.get(a10);
        if (void 0 !== h11) {
          var k11 = td2, n10 = a10;
          switch (a10) {
            case "keypress":
              if (0 === od2(c10)) break a;
            case "keydown":
            case "keyup":
              k11 = Rd2;
              break;
            case "focusin":
              n10 = "focus";
              k11 = Fd2;
              break;
            case "focusout":
              n10 = "blur";
              k11 = Fd2;
              break;
            case "beforeblur":
            case "afterblur":
              k11 = Fd2;
              break;
            case "click":
              if (2 === c10.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k11 = Bd2;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k11 = Dd2;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k11 = Vd2;
              break;
            case $e:
            case af2:
            case bf2:
              k11 = Hd2;
              break;
            case cf2:
              k11 = Xd2;
              break;
            case "scroll":
              k11 = vd2;
              break;
            case "wheel":
              k11 = Zd2;
              break;
            case "copy":
            case "cut":
            case "paste":
              k11 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k11 = Td2;
          }
          var t10 = 0 !== (b10 & 4), J10 = !t10 && "scroll" === a10, x10 = t10 ? null !== h11 ? h11 + "Capture" : null : h11;
          t10 = [];
          for (var w10 = d11, u10; null !== w10; ) {
            u10 = w10;
            var F10 = u10.stateNode;
            5 === u10.tag && null !== F10 && (u10 = F10, null !== x10 && (F10 = Kb2(w10, x10), null != F10 && t10.push(tf2(w10, F10, u10))));
            if (J10) break;
            w10 = w10.return;
          }
          0 < t10.length && (h11 = new k11(h11, n10, null, c10, e11), g11.push({ event: h11, listeners: t10 }));
        }
      }
      if (0 === (b10 & 7)) {
        a: {
          h11 = "mouseover" === a10 || "pointerover" === a10;
          k11 = "mouseout" === a10 || "pointerout" === a10;
          if (h11 && c10 !== wb2 && (n10 = c10.relatedTarget || c10.fromElement) && (Wc2(n10) || n10[uf2])) break a;
          if (k11 || h11) {
            h11 = e11.window === e11 ? e11 : (h11 = e11.ownerDocument) ? h11.defaultView || h11.parentWindow : window;
            if (k11) {
              if (n10 = c10.relatedTarget || c10.toElement, k11 = d11, n10 = n10 ? Wc2(n10) : null, null !== n10 && (J10 = Vb2(n10), n10 !== J10 || 5 !== n10.tag && 6 !== n10.tag)) n10 = null;
            } else k11 = null, n10 = d11;
            if (k11 !== n10) {
              t10 = Bd2;
              F10 = "onMouseLeave";
              x10 = "onMouseEnter";
              w10 = "mouse";
              if ("pointerout" === a10 || "pointerover" === a10) t10 = Td2, F10 = "onPointerLeave", x10 = "onPointerEnter", w10 = "pointer";
              J10 = null == k11 ? h11 : ue2(k11);
              u10 = null == n10 ? h11 : ue2(n10);
              h11 = new t10(F10, w10 + "leave", k11, c10, e11);
              h11.target = J10;
              h11.relatedTarget = u10;
              F10 = null;
              Wc2(e11) === d11 && (t10 = new t10(x10, w10 + "enter", n10, c10, e11), t10.target = u10, t10.relatedTarget = J10, F10 = t10);
              J10 = F10;
              if (k11 && n10) b: {
                t10 = k11;
                x10 = n10;
                w10 = 0;
                for (u10 = t10; u10; u10 = vf2(u10)) w10++;
                u10 = 0;
                for (F10 = x10; F10; F10 = vf2(F10)) u10++;
                for (; 0 < w10 - u10; ) t10 = vf2(t10), w10--;
                for (; 0 < u10 - w10; ) x10 = vf2(x10), u10--;
                for (; w10--; ) {
                  if (t10 === x10 || null !== x10 && t10 === x10.alternate) break b;
                  t10 = vf2(t10);
                  x10 = vf2(x10);
                }
                t10 = null;
              }
              else t10 = null;
              null !== k11 && wf2(g11, h11, k11, t10, false);
              null !== n10 && null !== J10 && wf2(g11, J10, n10, t10, true);
            }
          }
        }
        a: {
          h11 = d11 ? ue2(d11) : window;
          k11 = h11.nodeName && h11.nodeName.toLowerCase();
          if ("select" === k11 || "input" === k11 && "file" === h11.type) var na2 = ve;
          else if (me2(h11)) if (we2) na2 = Fe2;
          else {
            na2 = De2;
            var xa2 = Ce2;
          }
          else (k11 = h11.nodeName) && "input" === k11.toLowerCase() && ("checkbox" === h11.type || "radio" === h11.type) && (na2 = Ee2);
          if (na2 && (na2 = na2(a10, d11))) {
            ne(g11, na2, c10, e11);
            break a;
          }
          xa2 && xa2(a10, h11, d11);
          "focusout" === a10 && (xa2 = h11._wrapperState) && xa2.controlled && "number" === h11.type && cb2(h11, "number", h11.value);
        }
        xa2 = d11 ? ue2(d11) : window;
        switch (a10) {
          case "focusin":
            if (me2(xa2) || "true" === xa2.contentEditable) Qe2 = xa2, Re = d11, Se2 = null;
            break;
          case "focusout":
            Se2 = Re = Qe2 = null;
            break;
          case "mousedown":
            Te2 = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te2 = false;
            Ue(g11, c10, e11);
            break;
          case "selectionchange":
            if (Pe2) break;
          case "keydown":
          case "keyup":
            Ue(g11, c10, e11);
        }
        var $a2;
        if (ae2) b: {
          switch (a10) {
            case "compositionstart":
              var ba2 = "onCompositionStart";
              break b;
            case "compositionend":
              ba2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba2 = "onCompositionUpdate";
              break b;
          }
          ba2 = void 0;
        }
        else ie2 ? ge2(a10, c10) && (ba2 = "onCompositionEnd") : "keydown" === a10 && 229 === c10.keyCode && (ba2 = "onCompositionStart");
        ba2 && (de2 && "ko" !== c10.locale && (ie2 || "onCompositionStart" !== ba2 ? "onCompositionEnd" === ba2 && ie2 && ($a2 = nd2()) : (kd2 = e11, ld2 = "value" in kd2 ? kd2.value : kd2.textContent, ie2 = true)), xa2 = oe(d11, ba2), 0 < xa2.length && (ba2 = new Ld2(ba2, a10, null, c10, e11), g11.push({ event: ba2, listeners: xa2 }), $a2 ? ba2.data = $a2 : ($a2 = he2(c10), null !== $a2 && (ba2.data = $a2))));
        if ($a2 = ce2 ? je2(a10, c10) : ke2(a10, c10)) d11 = oe(d11, "onBeforeInput"), 0 < d11.length && (e11 = new Ld2("onBeforeInput", "beforeinput", null, c10, e11), g11.push({ event: e11, listeners: d11 }), e11.data = $a2);
      }
      se2(g11, b10);
    });
  }
  function tf2(a10, b10, c10) {
    return { instance: a10, listener: b10, currentTarget: c10 };
  }
  function oe(a10, b10) {
    for (var c10 = b10 + "Capture", d10 = []; null !== a10; ) {
      var e10 = a10, f10 = e10.stateNode;
      5 === e10.tag && null !== f10 && (e10 = f10, f10 = Kb2(a10, c10), null != f10 && d10.unshift(tf2(a10, f10, e10)), f10 = Kb2(a10, b10), null != f10 && d10.push(tf2(a10, f10, e10)));
      a10 = a10.return;
    }
    return d10;
  }
  function vf2(a10) {
    if (null === a10) return null;
    do
      a10 = a10.return;
    while (a10 && 5 !== a10.tag);
    return a10 ? a10 : null;
  }
  function wf2(a10, b10, c10, d10, e10) {
    for (var f10 = b10._reactName, g10 = []; null !== c10 && c10 !== d10; ) {
      var h10 = c10, k10 = h10.alternate, l10 = h10.stateNode;
      if (null !== k10 && k10 === d10) break;
      5 === h10.tag && null !== l10 && (h10 = l10, e10 ? (k10 = Kb2(c10, f10), null != k10 && g10.unshift(tf2(c10, k10, h10))) : e10 || (k10 = Kb2(c10, f10), null != k10 && g10.push(tf2(c10, k10, h10))));
      c10 = c10.return;
    }
    0 !== g10.length && a10.push({ event: b10, listeners: g10 });
  }
  var xf2 = /\r\n?/g, yf2 = /\u0000|\uFFFD/g;
  function zf2(a10) {
    return ("string" === typeof a10 ? a10 : "" + a10).replace(xf2, "\n").replace(yf2, "");
  }
  function Af2(a10, b10, c10) {
    b10 = zf2(b10);
    if (zf2(a10) !== b10 && c10) throw Error(p10(425));
  }
  function Bf2() {
  }
  var Cf2 = null, Df2 = null;
  function Ef2(a10, b10) {
    return "textarea" === a10 || "noscript" === a10 || "string" === typeof b10.children || "number" === typeof b10.children || "object" === typeof b10.dangerouslySetInnerHTML && null !== b10.dangerouslySetInnerHTML && null != b10.dangerouslySetInnerHTML.__html;
  }
  var Ff2 = "function" === typeof setTimeout ? setTimeout : void 0, Gf2 = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf2 = "function" === typeof Promise ? Promise : void 0, Jf2 = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf2 ? function(a10) {
    return Hf2.resolve(null).then(a10).catch(If2);
  } : Ff2;
  function If2(a10) {
    setTimeout(function() {
      throw a10;
    });
  }
  function Kf2(a10, b10) {
    var c10 = b10, d10 = 0;
    do {
      var e10 = c10.nextSibling;
      a10.removeChild(c10);
      if (e10 && 8 === e10.nodeType) if (c10 = e10.data, "/$" === c10) {
        if (0 === d10) {
          a10.removeChild(e10);
          bd2(b10);
          return;
        }
        d10--;
      } else "$" !== c10 && "$?" !== c10 && "$!" !== c10 || d10++;
      c10 = e10;
    } while (c10);
    bd2(b10);
  }
  function Lf2(a10) {
    for (; null != a10; a10 = a10.nextSibling) {
      var b10 = a10.nodeType;
      if (1 === b10 || 3 === b10) break;
      if (8 === b10) {
        b10 = a10.data;
        if ("$" === b10 || "$!" === b10 || "$?" === b10) break;
        if ("/$" === b10) return null;
      }
    }
    return a10;
  }
  function Mf2(a10) {
    a10 = a10.previousSibling;
    for (var b10 = 0; a10; ) {
      if (8 === a10.nodeType) {
        var c10 = a10.data;
        if ("$" === c10 || "$!" === c10 || "$?" === c10) {
          if (0 === b10) return a10;
          b10--;
        } else "/$" === c10 && b10++;
      }
      a10 = a10.previousSibling;
    }
    return null;
  }
  var Nf2 = Math.random().toString(36).slice(2), Of2 = "__reactFiber$" + Nf2, Pf2 = "__reactProps$" + Nf2, uf2 = "__reactContainer$" + Nf2, of2 = "__reactEvents$" + Nf2, Qf2 = "__reactListeners$" + Nf2, Rf2 = "__reactHandles$" + Nf2;
  function Wc2(a10) {
    var b10 = a10[Of2];
    if (b10) return b10;
    for (var c10 = a10.parentNode; c10; ) {
      if (b10 = c10[uf2] || c10[Of2]) {
        c10 = b10.alternate;
        if (null !== b10.child || null !== c10 && null !== c10.child) for (a10 = Mf2(a10); null !== a10; ) {
          if (c10 = a10[Of2]) return c10;
          a10 = Mf2(a10);
        }
        return b10;
      }
      a10 = c10;
      c10 = a10.parentNode;
    }
    return null;
  }
  function Cb2(a10) {
    a10 = a10[Of2] || a10[uf2];
    return !a10 || 5 !== a10.tag && 6 !== a10.tag && 13 !== a10.tag && 3 !== a10.tag ? null : a10;
  }
  function ue2(a10) {
    if (5 === a10.tag || 6 === a10.tag) return a10.stateNode;
    throw Error(p10(33));
  }
  function Db2(a10) {
    return a10[Pf2] || null;
  }
  var Sf2 = [], Tf2 = -1;
  function Uf2(a10) {
    return { current: a10 };
  }
  function E10(a10) {
    0 > Tf2 || (a10.current = Sf2[Tf2], Sf2[Tf2] = null, Tf2--);
  }
  function G10(a10, b10) {
    Tf2++;
    Sf2[Tf2] = a10.current;
    a10.current = b10;
  }
  var Vf2 = {}, H10 = Uf2(Vf2), Wf2 = Uf2(false), Xf2 = Vf2;
  function Yf2(a10, b10) {
    var c10 = a10.type.contextTypes;
    if (!c10) return Vf2;
    var d10 = a10.stateNode;
    if (d10 && d10.__reactInternalMemoizedUnmaskedChildContext === b10) return d10.__reactInternalMemoizedMaskedChildContext;
    var e10 = {}, f10;
    for (f10 in c10) e10[f10] = b10[f10];
    d10 && (a10 = a10.stateNode, a10.__reactInternalMemoizedUnmaskedChildContext = b10, a10.__reactInternalMemoizedMaskedChildContext = e10);
    return e10;
  }
  function Zf2(a10) {
    a10 = a10.childContextTypes;
    return null !== a10 && void 0 !== a10;
  }
  function $f2() {
    E10(Wf2);
    E10(H10);
  }
  function ag2(a10, b10, c10) {
    if (H10.current !== Vf2) throw Error(p10(168));
    G10(H10, b10);
    G10(Wf2, c10);
  }
  function bg2(a10, b10, c10) {
    var d10 = a10.stateNode;
    b10 = b10.childContextTypes;
    if ("function" !== typeof d10.getChildContext) return c10;
    d10 = d10.getChildContext();
    for (var e10 in d10) if (!(e10 in b10)) throw Error(p10(108, Ra2(a10) || "Unknown", e10));
    return A10({}, c10, d10);
  }
  function cg2(a10) {
    a10 = (a10 = a10.stateNode) && a10.__reactInternalMemoizedMergedChildContext || Vf2;
    Xf2 = H10.current;
    G10(H10, a10);
    G10(Wf2, Wf2.current);
    return true;
  }
  function dg2(a10, b10, c10) {
    var d10 = a10.stateNode;
    if (!d10) throw Error(p10(169));
    c10 ? (a10 = bg2(a10, b10, Xf2), d10.__reactInternalMemoizedMergedChildContext = a10, E10(Wf2), E10(H10), G10(H10, a10)) : E10(Wf2);
    G10(Wf2, c10);
  }
  var eg2 = null, fg2 = false, gg2 = false;
  function hg2(a10) {
    null === eg2 ? eg2 = [a10] : eg2.push(a10);
  }
  function ig2(a10) {
    fg2 = true;
    hg2(a10);
  }
  function jg2() {
    if (!gg2 && null !== eg2) {
      gg2 = true;
      var a10 = 0, b10 = C10;
      try {
        var c10 = eg2;
        for (C10 = 1; a10 < c10.length; a10++) {
          var d10 = c10[a10];
          do
            d10 = d10(true);
          while (null !== d10);
        }
        eg2 = null;
        fg2 = false;
      } catch (e10) {
        throw null !== eg2 && (eg2 = eg2.slice(a10 + 1)), ac(fc2, jg2), e10;
      } finally {
        C10 = b10, gg2 = false;
      }
    }
    return null;
  }
  var kg2 = [], lg2 = 0, mg2 = null, ng2 = 0, og2 = [], pg2 = 0, qg2 = null, rg2 = 1, sg2 = "";
  function tg2(a10, b10) {
    kg2[lg2++] = ng2;
    kg2[lg2++] = mg2;
    mg2 = a10;
    ng2 = b10;
  }
  function ug2(a10, b10, c10) {
    og2[pg2++] = rg2;
    og2[pg2++] = sg2;
    og2[pg2++] = qg2;
    qg2 = a10;
    var d10 = rg2;
    a10 = sg2;
    var e10 = 32 - oc2(d10) - 1;
    d10 &= ~(1 << e10);
    c10 += 1;
    var f10 = 32 - oc2(b10) + e10;
    if (30 < f10) {
      var g10 = e10 - e10 % 5;
      f10 = (d10 & (1 << g10) - 1).toString(32);
      d10 >>= g10;
      e10 -= g10;
      rg2 = 1 << 32 - oc2(b10) + e10 | c10 << e10 | d10;
      sg2 = f10 + a10;
    } else rg2 = 1 << f10 | c10 << e10 | d10, sg2 = a10;
  }
  function vg2(a10) {
    null !== a10.return && (tg2(a10, 1), ug2(a10, 1, 0));
  }
  function wg2(a10) {
    for (; a10 === mg2; ) mg2 = kg2[--lg2], kg2[lg2] = null, ng2 = kg2[--lg2], kg2[lg2] = null;
    for (; a10 === qg2; ) qg2 = og2[--pg2], og2[pg2] = null, sg2 = og2[--pg2], og2[pg2] = null, rg2 = og2[--pg2], og2[pg2] = null;
  }
  var xg2 = null, yg2 = null, I10 = false, zg2 = null;
  function Ag2(a10, b10) {
    var c10 = Bg2(5, null, null, 0);
    c10.elementType = "DELETED";
    c10.stateNode = b10;
    c10.return = a10;
    b10 = a10.deletions;
    null === b10 ? (a10.deletions = [c10], a10.flags |= 16) : b10.push(c10);
  }
  function Cg2(a10, b10) {
    switch (a10.tag) {
      case 5:
        var c10 = a10.type;
        b10 = 1 !== b10.nodeType || c10.toLowerCase() !== b10.nodeName.toLowerCase() ? null : b10;
        return null !== b10 ? (a10.stateNode = b10, xg2 = a10, yg2 = Lf2(b10.firstChild), true) : false;
      case 6:
        return b10 = "" === a10.pendingProps || 3 !== b10.nodeType ? null : b10, null !== b10 ? (a10.stateNode = b10, xg2 = a10, yg2 = null, true) : false;
      case 13:
        return b10 = 8 !== b10.nodeType ? null : b10, null !== b10 ? (c10 = null !== qg2 ? { id: rg2, overflow: sg2 } : null, a10.memoizedState = { dehydrated: b10, treeContext: c10, retryLane: 1073741824 }, c10 = Bg2(18, null, null, 0), c10.stateNode = b10, c10.return = a10, a10.child = c10, xg2 = a10, yg2 = null, true) : false;
      default:
        return false;
    }
  }
  function Dg2(a10) {
    return 0 !== (a10.mode & 1) && 0 === (a10.flags & 128);
  }
  function Eg2(a10) {
    if (I10) {
      var b10 = yg2;
      if (b10) {
        var c10 = b10;
        if (!Cg2(a10, b10)) {
          if (Dg2(a10)) throw Error(p10(418));
          b10 = Lf2(c10.nextSibling);
          var d10 = xg2;
          b10 && Cg2(a10, b10) ? Ag2(d10, c10) : (a10.flags = a10.flags & -4097 | 2, I10 = false, xg2 = a10);
        }
      } else {
        if (Dg2(a10)) throw Error(p10(418));
        a10.flags = a10.flags & -4097 | 2;
        I10 = false;
        xg2 = a10;
      }
    }
  }
  function Fg2(a10) {
    for (a10 = a10.return; null !== a10 && 5 !== a10.tag && 3 !== a10.tag && 13 !== a10.tag; ) a10 = a10.return;
    xg2 = a10;
  }
  function Gg2(a10) {
    if (a10 !== xg2) return false;
    if (!I10) return Fg2(a10), I10 = true, false;
    var b10;
    (b10 = 3 !== a10.tag) && !(b10 = 5 !== a10.tag) && (b10 = a10.type, b10 = "head" !== b10 && "body" !== b10 && !Ef2(a10.type, a10.memoizedProps));
    if (b10 && (b10 = yg2)) {
      if (Dg2(a10)) throw Hg2(), Error(p10(418));
      for (; b10; ) Ag2(a10, b10), b10 = Lf2(b10.nextSibling);
    }
    Fg2(a10);
    if (13 === a10.tag) {
      a10 = a10.memoizedState;
      a10 = null !== a10 ? a10.dehydrated : null;
      if (!a10) throw Error(p10(317));
      a: {
        a10 = a10.nextSibling;
        for (b10 = 0; a10; ) {
          if (8 === a10.nodeType) {
            var c10 = a10.data;
            if ("/$" === c10) {
              if (0 === b10) {
                yg2 = Lf2(a10.nextSibling);
                break a;
              }
              b10--;
            } else "$" !== c10 && "$!" !== c10 && "$?" !== c10 || b10++;
          }
          a10 = a10.nextSibling;
        }
        yg2 = null;
      }
    } else yg2 = xg2 ? Lf2(a10.stateNode.nextSibling) : null;
    return true;
  }
  function Hg2() {
    for (var a10 = yg2; a10; ) a10 = Lf2(a10.nextSibling);
  }
  function Ig2() {
    yg2 = xg2 = null;
    I10 = false;
  }
  function Jg2(a10) {
    null === zg2 ? zg2 = [a10] : zg2.push(a10);
  }
  var Kg2 = ua2.ReactCurrentBatchConfig;
  function Lg2(a10, b10, c10) {
    a10 = c10.ref;
    if (null !== a10 && "function" !== typeof a10 && "object" !== typeof a10) {
      if (c10._owner) {
        c10 = c10._owner;
        if (c10) {
          if (1 !== c10.tag) throw Error(p10(309));
          var d10 = c10.stateNode;
        }
        if (!d10) throw Error(p10(147, a10));
        var e10 = d10, f10 = "" + a10;
        if (null !== b10 && null !== b10.ref && "function" === typeof b10.ref && b10.ref._stringRef === f10) return b10.ref;
        b10 = function(a11) {
          var b11 = e10.refs;
          null === a11 ? delete b11[f10] : b11[f10] = a11;
        };
        b10._stringRef = f10;
        return b10;
      }
      if ("string" !== typeof a10) throw Error(p10(284));
      if (!c10._owner) throw Error(p10(290, a10));
    }
    return a10;
  }
  function Mg2(a10, b10) {
    a10 = Object.prototype.toString.call(b10);
    throw Error(p10(31, "[object Object]" === a10 ? "object with keys {" + Object.keys(b10).join(", ") + "}" : a10));
  }
  function Ng2(a10) {
    var b10 = a10._init;
    return b10(a10._payload);
  }
  function Og2(a10) {
    function b10(b11, c11) {
      if (a10) {
        var d11 = b11.deletions;
        null === d11 ? (b11.deletions = [c11], b11.flags |= 16) : d11.push(c11);
      }
    }
    function c10(c11, d11) {
      if (!a10) return null;
      for (; null !== d11; ) b10(c11, d11), d11 = d11.sibling;
      return null;
    }
    function d10(a11, b11) {
      for (a11 = /* @__PURE__ */ new Map(); null !== b11; ) null !== b11.key ? a11.set(b11.key, b11) : a11.set(b11.index, b11), b11 = b11.sibling;
      return a11;
    }
    function e10(a11, b11) {
      a11 = Pg2(a11, b11);
      a11.index = 0;
      a11.sibling = null;
      return a11;
    }
    function f10(b11, c11, d11) {
      b11.index = d11;
      if (!a10) return b11.flags |= 1048576, c11;
      d11 = b11.alternate;
      if (null !== d11) return d11 = d11.index, d11 < c11 ? (b11.flags |= 2, c11) : d11;
      b11.flags |= 2;
      return c11;
    }
    function g10(b11) {
      a10 && null === b11.alternate && (b11.flags |= 2);
      return b11;
    }
    function h10(a11, b11, c11, d11) {
      if (null === b11 || 6 !== b11.tag) return b11 = Qg2(c11, a11.mode, d11), b11.return = a11, b11;
      b11 = e10(b11, c11);
      b11.return = a11;
      return b11;
    }
    function k10(a11, b11, c11, d11) {
      var f11 = c11.type;
      if (f11 === ya2) return m10(a11, b11, c11.props.children, d11, c11.key);
      if (null !== b11 && (b11.elementType === f11 || "object" === typeof f11 && null !== f11 && f11.$$typeof === Ha2 && Ng2(f11) === b11.type)) return d11 = e10(b11, c11.props), d11.ref = Lg2(a11, b11, c11), d11.return = a11, d11;
      d11 = Rg2(c11.type, c11.key, c11.props, null, a11.mode, d11);
      d11.ref = Lg2(a11, b11, c11);
      d11.return = a11;
      return d11;
    }
    function l10(a11, b11, c11, d11) {
      if (null === b11 || 4 !== b11.tag || b11.stateNode.containerInfo !== c11.containerInfo || b11.stateNode.implementation !== c11.implementation) return b11 = Sg2(c11, a11.mode, d11), b11.return = a11, b11;
      b11 = e10(b11, c11.children || []);
      b11.return = a11;
      return b11;
    }
    function m10(a11, b11, c11, d11, f11) {
      if (null === b11 || 7 !== b11.tag) return b11 = Tg2(c11, a11.mode, d11, f11), b11.return = a11, b11;
      b11 = e10(b11, c11);
      b11.return = a11;
      return b11;
    }
    function q10(a11, b11, c11) {
      if ("string" === typeof b11 && "" !== b11 || "number" === typeof b11) return b11 = Qg2("" + b11, a11.mode, c11), b11.return = a11, b11;
      if ("object" === typeof b11 && null !== b11) {
        switch (b11.$$typeof) {
          case va2:
            return c11 = Rg2(b11.type, b11.key, b11.props, null, a11.mode, c11), c11.ref = Lg2(a11, null, b11), c11.return = a11, c11;
          case wa2:
            return b11 = Sg2(b11, a11.mode, c11), b11.return = a11, b11;
          case Ha2:
            var d11 = b11._init;
            return q10(a11, d11(b11._payload), c11);
        }
        if (eb2(b11) || Ka2(b11)) return b11 = Tg2(b11, a11.mode, c11, null), b11.return = a11, b11;
        Mg2(a11, b11);
      }
      return null;
    }
    function r10(a11, b11, c11, d11) {
      var e11 = null !== b11 ? b11.key : null;
      if ("string" === typeof c11 && "" !== c11 || "number" === typeof c11) return null !== e11 ? null : h10(a11, b11, "" + c11, d11);
      if ("object" === typeof c11 && null !== c11) {
        switch (c11.$$typeof) {
          case va2:
            return c11.key === e11 ? k10(a11, b11, c11, d11) : null;
          case wa2:
            return c11.key === e11 ? l10(a11, b11, c11, d11) : null;
          case Ha2:
            return e11 = c11._init, r10(
              a11,
              b11,
              e11(c11._payload),
              d11
            );
        }
        if (eb2(c11) || Ka2(c11)) return null !== e11 ? null : m10(a11, b11, c11, d11, null);
        Mg2(a11, c11);
      }
      return null;
    }
    function y10(a11, b11, c11, d11, e11) {
      if ("string" === typeof d11 && "" !== d11 || "number" === typeof d11) return a11 = a11.get(c11) || null, h10(b11, a11, "" + d11, e11);
      if ("object" === typeof d11 && null !== d11) {
        switch (d11.$$typeof) {
          case va2:
            return a11 = a11.get(null === d11.key ? c11 : d11.key) || null, k10(b11, a11, d11, e11);
          case wa2:
            return a11 = a11.get(null === d11.key ? c11 : d11.key) || null, l10(b11, a11, d11, e11);
          case Ha2:
            var f11 = d11._init;
            return y10(a11, b11, c11, f11(d11._payload), e11);
        }
        if (eb2(d11) || Ka2(d11)) return a11 = a11.get(c11) || null, m10(b11, a11, d11, e11, null);
        Mg2(b11, d11);
      }
      return null;
    }
    function n10(e11, g11, h11, k11) {
      for (var l11 = null, m11 = null, u10 = g11, w10 = g11 = 0, x10 = null; null !== u10 && w10 < h11.length; w10++) {
        u10.index > w10 ? (x10 = u10, u10 = null) : x10 = u10.sibling;
        var n11 = r10(e11, u10, h11[w10], k11);
        if (null === n11) {
          null === u10 && (u10 = x10);
          break;
        }
        a10 && u10 && null === n11.alternate && b10(e11, u10);
        g11 = f10(n11, g11, w10);
        null === m11 ? l11 = n11 : m11.sibling = n11;
        m11 = n11;
        u10 = x10;
      }
      if (w10 === h11.length) return c10(e11, u10), I10 && tg2(e11, w10), l11;
      if (null === u10) {
        for (; w10 < h11.length; w10++) u10 = q10(e11, h11[w10], k11), null !== u10 && (g11 = f10(u10, g11, w10), null === m11 ? l11 = u10 : m11.sibling = u10, m11 = u10);
        I10 && tg2(e11, w10);
        return l11;
      }
      for (u10 = d10(e11, u10); w10 < h11.length; w10++) x10 = y10(u10, e11, w10, h11[w10], k11), null !== x10 && (a10 && null !== x10.alternate && u10.delete(null === x10.key ? w10 : x10.key), g11 = f10(x10, g11, w10), null === m11 ? l11 = x10 : m11.sibling = x10, m11 = x10);
      a10 && u10.forEach(function(a11) {
        return b10(e11, a11);
      });
      I10 && tg2(e11, w10);
      return l11;
    }
    function t10(e11, g11, h11, k11) {
      var l11 = Ka2(h11);
      if ("function" !== typeof l11) throw Error(p10(150));
      h11 = l11.call(h11);
      if (null == h11) throw Error(p10(151));
      for (var u10 = l11 = null, m11 = g11, w10 = g11 = 0, x10 = null, n11 = h11.next(); null !== m11 && !n11.done; w10++, n11 = h11.next()) {
        m11.index > w10 ? (x10 = m11, m11 = null) : x10 = m11.sibling;
        var t11 = r10(e11, m11, n11.value, k11);
        if (null === t11) {
          null === m11 && (m11 = x10);
          break;
        }
        a10 && m11 && null === t11.alternate && b10(e11, m11);
        g11 = f10(t11, g11, w10);
        null === u10 ? l11 = t11 : u10.sibling = t11;
        u10 = t11;
        m11 = x10;
      }
      if (n11.done) return c10(
        e11,
        m11
      ), I10 && tg2(e11, w10), l11;
      if (null === m11) {
        for (; !n11.done; w10++, n11 = h11.next()) n11 = q10(e11, n11.value, k11), null !== n11 && (g11 = f10(n11, g11, w10), null === u10 ? l11 = n11 : u10.sibling = n11, u10 = n11);
        I10 && tg2(e11, w10);
        return l11;
      }
      for (m11 = d10(e11, m11); !n11.done; w10++, n11 = h11.next()) n11 = y10(m11, e11, w10, n11.value, k11), null !== n11 && (a10 && null !== n11.alternate && m11.delete(null === n11.key ? w10 : n11.key), g11 = f10(n11, g11, w10), null === u10 ? l11 = n11 : u10.sibling = n11, u10 = n11);
      a10 && m11.forEach(function(a11) {
        return b10(e11, a11);
      });
      I10 && tg2(e11, w10);
      return l11;
    }
    function J10(a11, d11, f11, h11) {
      "object" === typeof f11 && null !== f11 && f11.type === ya2 && null === f11.key && (f11 = f11.props.children);
      if ("object" === typeof f11 && null !== f11) {
        switch (f11.$$typeof) {
          case va2:
            a: {
              for (var k11 = f11.key, l11 = d11; null !== l11; ) {
                if (l11.key === k11) {
                  k11 = f11.type;
                  if (k11 === ya2) {
                    if (7 === l11.tag) {
                      c10(a11, l11.sibling);
                      d11 = e10(l11, f11.props.children);
                      d11.return = a11;
                      a11 = d11;
                      break a;
                    }
                  } else if (l11.elementType === k11 || "object" === typeof k11 && null !== k11 && k11.$$typeof === Ha2 && Ng2(k11) === l11.type) {
                    c10(a11, l11.sibling);
                    d11 = e10(l11, f11.props);
                    d11.ref = Lg2(a11, l11, f11);
                    d11.return = a11;
                    a11 = d11;
                    break a;
                  }
                  c10(a11, l11);
                  break;
                } else b10(a11, l11);
                l11 = l11.sibling;
              }
              f11.type === ya2 ? (d11 = Tg2(f11.props.children, a11.mode, h11, f11.key), d11.return = a11, a11 = d11) : (h11 = Rg2(f11.type, f11.key, f11.props, null, a11.mode, h11), h11.ref = Lg2(a11, d11, f11), h11.return = a11, a11 = h11);
            }
            return g10(a11);
          case wa2:
            a: {
              for (l11 = f11.key; null !== d11; ) {
                if (d11.key === l11) if (4 === d11.tag && d11.stateNode.containerInfo === f11.containerInfo && d11.stateNode.implementation === f11.implementation) {
                  c10(a11, d11.sibling);
                  d11 = e10(d11, f11.children || []);
                  d11.return = a11;
                  a11 = d11;
                  break a;
                } else {
                  c10(a11, d11);
                  break;
                }
                else b10(a11, d11);
                d11 = d11.sibling;
              }
              d11 = Sg2(f11, a11.mode, h11);
              d11.return = a11;
              a11 = d11;
            }
            return g10(a11);
          case Ha2:
            return l11 = f11._init, J10(a11, d11, l11(f11._payload), h11);
        }
        if (eb2(f11)) return n10(a11, d11, f11, h11);
        if (Ka2(f11)) return t10(a11, d11, f11, h11);
        Mg2(a11, f11);
      }
      return "string" === typeof f11 && "" !== f11 || "number" === typeof f11 ? (f11 = "" + f11, null !== d11 && 6 === d11.tag ? (c10(a11, d11.sibling), d11 = e10(d11, f11), d11.return = a11, a11 = d11) : (c10(a11, d11), d11 = Qg2(f11, a11.mode, h11), d11.return = a11, a11 = d11), g10(a11)) : c10(a11, d11);
    }
    return J10;
  }
  var Ug2 = Og2(true), Vg2 = Og2(false), Wg2 = Uf2(null), Xg2 = null, Yg2 = null, Zg2 = null;
  function $g2() {
    Zg2 = Yg2 = Xg2 = null;
  }
  function ah2(a10) {
    var b10 = Wg2.current;
    E10(Wg2);
    a10._currentValue = b10;
  }
  function bh2(a10, b10, c10) {
    for (; null !== a10; ) {
      var d10 = a10.alternate;
      (a10.childLanes & b10) !== b10 ? (a10.childLanes |= b10, null !== d10 && (d10.childLanes |= b10)) : null !== d10 && (d10.childLanes & b10) !== b10 && (d10.childLanes |= b10);
      if (a10 === c10) break;
      a10 = a10.return;
    }
  }
  function ch2(a10, b10) {
    Xg2 = a10;
    Zg2 = Yg2 = null;
    a10 = a10.dependencies;
    null !== a10 && null !== a10.firstContext && (0 !== (a10.lanes & b10) && (dh2 = true), a10.firstContext = null);
  }
  function eh2(a10) {
    var b10 = a10._currentValue;
    if (Zg2 !== a10) if (a10 = { context: a10, memoizedValue: b10, next: null }, null === Yg2) {
      if (null === Xg2) throw Error(p10(308));
      Yg2 = a10;
      Xg2.dependencies = { lanes: 0, firstContext: a10 };
    } else Yg2 = Yg2.next = a10;
    return b10;
  }
  var fh2 = null;
  function gh2(a10) {
    null === fh2 ? fh2 = [a10] : fh2.push(a10);
  }
  function hh2(a10, b10, c10, d10) {
    var e10 = b10.interleaved;
    null === e10 ? (c10.next = c10, gh2(b10)) : (c10.next = e10.next, e10.next = c10);
    b10.interleaved = c10;
    return ih2(a10, d10);
  }
  function ih2(a10, b10) {
    a10.lanes |= b10;
    var c10 = a10.alternate;
    null !== c10 && (c10.lanes |= b10);
    c10 = a10;
    for (a10 = a10.return; null !== a10; ) a10.childLanes |= b10, c10 = a10.alternate, null !== c10 && (c10.childLanes |= b10), c10 = a10, a10 = a10.return;
    return 3 === c10.tag ? c10.stateNode : null;
  }
  var jh2 = false;
  function kh2(a10) {
    a10.updateQueue = { baseState: a10.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh2(a10, b10) {
    a10 = a10.updateQueue;
    b10.updateQueue === a10 && (b10.updateQueue = { baseState: a10.baseState, firstBaseUpdate: a10.firstBaseUpdate, lastBaseUpdate: a10.lastBaseUpdate, shared: a10.shared, effects: a10.effects });
  }
  function mh2(a10, b10) {
    return { eventTime: a10, lane: b10, tag: 0, payload: null, callback: null, next: null };
  }
  function nh2(a10, b10, c10) {
    var d10 = a10.updateQueue;
    if (null === d10) return null;
    d10 = d10.shared;
    if (0 !== (K10 & 2)) {
      var e10 = d10.pending;
      null === e10 ? b10.next = b10 : (b10.next = e10.next, e10.next = b10);
      d10.pending = b10;
      return ih2(a10, c10);
    }
    e10 = d10.interleaved;
    null === e10 ? (b10.next = b10, gh2(d10)) : (b10.next = e10.next, e10.next = b10);
    d10.interleaved = b10;
    return ih2(a10, c10);
  }
  function oh2(a10, b10, c10) {
    b10 = b10.updateQueue;
    if (null !== b10 && (b10 = b10.shared, 0 !== (c10 & 4194240))) {
      var d10 = b10.lanes;
      d10 &= a10.pendingLanes;
      c10 |= d10;
      b10.lanes = c10;
      Cc2(a10, c10);
    }
  }
  function ph2(a10, b10) {
    var c10 = a10.updateQueue, d10 = a10.alternate;
    if (null !== d10 && (d10 = d10.updateQueue, c10 === d10)) {
      var e10 = null, f10 = null;
      c10 = c10.firstBaseUpdate;
      if (null !== c10) {
        do {
          var g10 = { eventTime: c10.eventTime, lane: c10.lane, tag: c10.tag, payload: c10.payload, callback: c10.callback, next: null };
          null === f10 ? e10 = f10 = g10 : f10 = f10.next = g10;
          c10 = c10.next;
        } while (null !== c10);
        null === f10 ? e10 = f10 = b10 : f10 = f10.next = b10;
      } else e10 = f10 = b10;
      c10 = { baseState: d10.baseState, firstBaseUpdate: e10, lastBaseUpdate: f10, shared: d10.shared, effects: d10.effects };
      a10.updateQueue = c10;
      return;
    }
    a10 = c10.lastBaseUpdate;
    null === a10 ? c10.firstBaseUpdate = b10 : a10.next = b10;
    c10.lastBaseUpdate = b10;
  }
  function qh2(a10, b10, c10, d10) {
    var e10 = a10.updateQueue;
    jh2 = false;
    var f10 = e10.firstBaseUpdate, g10 = e10.lastBaseUpdate, h10 = e10.shared.pending;
    if (null !== h10) {
      e10.shared.pending = null;
      var k10 = h10, l10 = k10.next;
      k10.next = null;
      null === g10 ? f10 = l10 : g10.next = l10;
      g10 = k10;
      var m10 = a10.alternate;
      null !== m10 && (m10 = m10.updateQueue, h10 = m10.lastBaseUpdate, h10 !== g10 && (null === h10 ? m10.firstBaseUpdate = l10 : h10.next = l10, m10.lastBaseUpdate = k10));
    }
    if (null !== f10) {
      var q10 = e10.baseState;
      g10 = 0;
      m10 = l10 = k10 = null;
      h10 = f10;
      do {
        var r10 = h10.lane, y10 = h10.eventTime;
        if ((d10 & r10) === r10) {
          null !== m10 && (m10 = m10.next = {
            eventTime: y10,
            lane: 0,
            tag: h10.tag,
            payload: h10.payload,
            callback: h10.callback,
            next: null
          });
          a: {
            var n10 = a10, t10 = h10;
            r10 = b10;
            y10 = c10;
            switch (t10.tag) {
              case 1:
                n10 = t10.payload;
                if ("function" === typeof n10) {
                  q10 = n10.call(y10, q10, r10);
                  break a;
                }
                q10 = n10;
                break a;
              case 3:
                n10.flags = n10.flags & -65537 | 128;
              case 0:
                n10 = t10.payload;
                r10 = "function" === typeof n10 ? n10.call(y10, q10, r10) : n10;
                if (null === r10 || void 0 === r10) break a;
                q10 = A10({}, q10, r10);
                break a;
              case 2:
                jh2 = true;
            }
          }
          null !== h10.callback && 0 !== h10.lane && (a10.flags |= 64, r10 = e10.effects, null === r10 ? e10.effects = [h10] : r10.push(h10));
        } else y10 = { eventTime: y10, lane: r10, tag: h10.tag, payload: h10.payload, callback: h10.callback, next: null }, null === m10 ? (l10 = m10 = y10, k10 = q10) : m10 = m10.next = y10, g10 |= r10;
        h10 = h10.next;
        if (null === h10) if (h10 = e10.shared.pending, null === h10) break;
        else r10 = h10, h10 = r10.next, r10.next = null, e10.lastBaseUpdate = r10, e10.shared.pending = null;
      } while (1);
      null === m10 && (k10 = q10);
      e10.baseState = k10;
      e10.firstBaseUpdate = l10;
      e10.lastBaseUpdate = m10;
      b10 = e10.shared.interleaved;
      if (null !== b10) {
        e10 = b10;
        do
          g10 |= e10.lane, e10 = e10.next;
        while (e10 !== b10);
      } else null === f10 && (e10.shared.lanes = 0);
      rh2 |= g10;
      a10.lanes = g10;
      a10.memoizedState = q10;
    }
  }
  function sh2(a10, b10, c10) {
    a10 = b10.effects;
    b10.effects = null;
    if (null !== a10) for (b10 = 0; b10 < a10.length; b10++) {
      var d10 = a10[b10], e10 = d10.callback;
      if (null !== e10) {
        d10.callback = null;
        d10 = c10;
        if ("function" !== typeof e10) throw Error(p10(191, e10));
        e10.call(d10);
      }
    }
  }
  var th2 = {}, uh2 = Uf2(th2), vh2 = Uf2(th2), wh2 = Uf2(th2);
  function xh2(a10) {
    if (a10 === th2) throw Error(p10(174));
    return a10;
  }
  function yh2(a10, b10) {
    G10(wh2, b10);
    G10(vh2, a10);
    G10(uh2, th2);
    a10 = b10.nodeType;
    switch (a10) {
      case 9:
      case 11:
        b10 = (b10 = b10.documentElement) ? b10.namespaceURI : lb2(null, "");
        break;
      default:
        a10 = 8 === a10 ? b10.parentNode : b10, b10 = a10.namespaceURI || null, a10 = a10.tagName, b10 = lb2(b10, a10);
    }
    E10(uh2);
    G10(uh2, b10);
  }
  function zh2() {
    E10(uh2);
    E10(vh2);
    E10(wh2);
  }
  function Ah2(a10) {
    xh2(wh2.current);
    var b10 = xh2(uh2.current);
    var c10 = lb2(b10, a10.type);
    b10 !== c10 && (G10(vh2, a10), G10(uh2, c10));
  }
  function Bh2(a10) {
    vh2.current === a10 && (E10(uh2), E10(vh2));
  }
  var L10 = Uf2(0);
  function Ch2(a10) {
    for (var b10 = a10; null !== b10; ) {
      if (13 === b10.tag) {
        var c10 = b10.memoizedState;
        if (null !== c10 && (c10 = c10.dehydrated, null === c10 || "$?" === c10.data || "$!" === c10.data)) return b10;
      } else if (19 === b10.tag && void 0 !== b10.memoizedProps.revealOrder) {
        if (0 !== (b10.flags & 128)) return b10;
      } else if (null !== b10.child) {
        b10.child.return = b10;
        b10 = b10.child;
        continue;
      }
      if (b10 === a10) break;
      for (; null === b10.sibling; ) {
        if (null === b10.return || b10.return === a10) return null;
        b10 = b10.return;
      }
      b10.sibling.return = b10.return;
      b10 = b10.sibling;
    }
    return null;
  }
  var Dh2 = [];
  function Eh2() {
    for (var a10 = 0; a10 < Dh2.length; a10++) Dh2[a10]._workInProgressVersionPrimary = null;
    Dh2.length = 0;
  }
  var Fh2 = ua2.ReactCurrentDispatcher, Gh2 = ua2.ReactCurrentBatchConfig, Hh2 = 0, M10 = null, N10 = null, O10 = null, Ih2 = false, Jh2 = false, Kh2 = 0, Lh2 = 0;
  function P10() {
    throw Error(p10(321));
  }
  function Mh2(a10, b10) {
    if (null === b10) return false;
    for (var c10 = 0; c10 < b10.length && c10 < a10.length; c10++) if (!He2(a10[c10], b10[c10])) return false;
    return true;
  }
  function Nh2(a10, b10, c10, d10, e10, f10) {
    Hh2 = f10;
    M10 = b10;
    b10.memoizedState = null;
    b10.updateQueue = null;
    b10.lanes = 0;
    Fh2.current = null === a10 || null === a10.memoizedState ? Oh2 : Ph2;
    a10 = c10(d10, e10);
    if (Jh2) {
      f10 = 0;
      do {
        Jh2 = false;
        Kh2 = 0;
        if (25 <= f10) throw Error(p10(301));
        f10 += 1;
        O10 = N10 = null;
        b10.updateQueue = null;
        Fh2.current = Qh2;
        a10 = c10(d10, e10);
      } while (Jh2);
    }
    Fh2.current = Rh2;
    b10 = null !== N10 && null !== N10.next;
    Hh2 = 0;
    O10 = N10 = M10 = null;
    Ih2 = false;
    if (b10) throw Error(p10(300));
    return a10;
  }
  function Sh2() {
    var a10 = 0 !== Kh2;
    Kh2 = 0;
    return a10;
  }
  function Th2() {
    var a10 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O10 ? M10.memoizedState = O10 = a10 : O10 = O10.next = a10;
    return O10;
  }
  function Uh2() {
    if (null === N10) {
      var a10 = M10.alternate;
      a10 = null !== a10 ? a10.memoizedState : null;
    } else a10 = N10.next;
    var b10 = null === O10 ? M10.memoizedState : O10.next;
    if (null !== b10) O10 = b10, N10 = a10;
    else {
      if (null === a10) throw Error(p10(310));
      N10 = a10;
      a10 = { memoizedState: N10.memoizedState, baseState: N10.baseState, baseQueue: N10.baseQueue, queue: N10.queue, next: null };
      null === O10 ? M10.memoizedState = O10 = a10 : O10 = O10.next = a10;
    }
    return O10;
  }
  function Vh2(a10, b10) {
    return "function" === typeof b10 ? b10(a10) : b10;
  }
  function Wh2(a10) {
    var b10 = Uh2(), c10 = b10.queue;
    if (null === c10) throw Error(p10(311));
    c10.lastRenderedReducer = a10;
    var d10 = N10, e10 = d10.baseQueue, f10 = c10.pending;
    if (null !== f10) {
      if (null !== e10) {
        var g10 = e10.next;
        e10.next = f10.next;
        f10.next = g10;
      }
      d10.baseQueue = e10 = f10;
      c10.pending = null;
    }
    if (null !== e10) {
      f10 = e10.next;
      d10 = d10.baseState;
      var h10 = g10 = null, k10 = null, l10 = f10;
      do {
        var m10 = l10.lane;
        if ((Hh2 & m10) === m10) null !== k10 && (k10 = k10.next = { lane: 0, action: l10.action, hasEagerState: l10.hasEagerState, eagerState: l10.eagerState, next: null }), d10 = l10.hasEagerState ? l10.eagerState : a10(d10, l10.action);
        else {
          var q10 = {
            lane: m10,
            action: l10.action,
            hasEagerState: l10.hasEagerState,
            eagerState: l10.eagerState,
            next: null
          };
          null === k10 ? (h10 = k10 = q10, g10 = d10) : k10 = k10.next = q10;
          M10.lanes |= m10;
          rh2 |= m10;
        }
        l10 = l10.next;
      } while (null !== l10 && l10 !== f10);
      null === k10 ? g10 = d10 : k10.next = h10;
      He2(d10, b10.memoizedState) || (dh2 = true);
      b10.memoizedState = d10;
      b10.baseState = g10;
      b10.baseQueue = k10;
      c10.lastRenderedState = d10;
    }
    a10 = c10.interleaved;
    if (null !== a10) {
      e10 = a10;
      do
        f10 = e10.lane, M10.lanes |= f10, rh2 |= f10, e10 = e10.next;
      while (e10 !== a10);
    } else null === e10 && (c10.lanes = 0);
    return [b10.memoizedState, c10.dispatch];
  }
  function Xh2(a10) {
    var b10 = Uh2(), c10 = b10.queue;
    if (null === c10) throw Error(p10(311));
    c10.lastRenderedReducer = a10;
    var d10 = c10.dispatch, e10 = c10.pending, f10 = b10.memoizedState;
    if (null !== e10) {
      c10.pending = null;
      var g10 = e10 = e10.next;
      do
        f10 = a10(f10, g10.action), g10 = g10.next;
      while (g10 !== e10);
      He2(f10, b10.memoizedState) || (dh2 = true);
      b10.memoizedState = f10;
      null === b10.baseQueue && (b10.baseState = f10);
      c10.lastRenderedState = f10;
    }
    return [f10, d10];
  }
  function Yh2() {
  }
  function Zh2(a10, b10) {
    var c10 = M10, d10 = Uh2(), e10 = b10(), f10 = !He2(d10.memoizedState, e10);
    f10 && (d10.memoizedState = e10, dh2 = true);
    d10 = d10.queue;
    $h2(ai2.bind(null, c10, d10, a10), [a10]);
    if (d10.getSnapshot !== b10 || f10 || null !== O10 && O10.memoizedState.tag & 1) {
      c10.flags |= 2048;
      bi(9, ci2.bind(null, c10, d10, e10, b10), void 0, null);
      if (null === Q10) throw Error(p10(349));
      0 !== (Hh2 & 30) || di2(c10, b10, e10);
    }
    return e10;
  }
  function di2(a10, b10, c10) {
    a10.flags |= 16384;
    a10 = { getSnapshot: b10, value: c10 };
    b10 = M10.updateQueue;
    null === b10 ? (b10 = { lastEffect: null, stores: null }, M10.updateQueue = b10, b10.stores = [a10]) : (c10 = b10.stores, null === c10 ? b10.stores = [a10] : c10.push(a10));
  }
  function ci2(a10, b10, c10, d10) {
    b10.value = c10;
    b10.getSnapshot = d10;
    ei2(b10) && fi2(a10);
  }
  function ai2(a10, b10, c10) {
    return c10(function() {
      ei2(b10) && fi2(a10);
    });
  }
  function ei2(a10) {
    var b10 = a10.getSnapshot;
    a10 = a10.value;
    try {
      var c10 = b10();
      return !He2(a10, c10);
    } catch (d10) {
      return true;
    }
  }
  function fi2(a10) {
    var b10 = ih2(a10, 1);
    null !== b10 && gi2(b10, a10, 1, -1);
  }
  function hi2(a10) {
    var b10 = Th2();
    "function" === typeof a10 && (a10 = a10());
    b10.memoizedState = b10.baseState = a10;
    a10 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh2, lastRenderedState: a10 };
    b10.queue = a10;
    a10 = a10.dispatch = ii2.bind(null, M10, a10);
    return [b10.memoizedState, a10];
  }
  function bi(a10, b10, c10, d10) {
    a10 = { tag: a10, create: b10, destroy: c10, deps: d10, next: null };
    b10 = M10.updateQueue;
    null === b10 ? (b10 = { lastEffect: null, stores: null }, M10.updateQueue = b10, b10.lastEffect = a10.next = a10) : (c10 = b10.lastEffect, null === c10 ? b10.lastEffect = a10.next = a10 : (d10 = c10.next, c10.next = a10, a10.next = d10, b10.lastEffect = a10));
    return a10;
  }
  function ji2() {
    return Uh2().memoizedState;
  }
  function ki(a10, b10, c10, d10) {
    var e10 = Th2();
    M10.flags |= a10;
    e10.memoizedState = bi(1 | b10, c10, void 0, void 0 === d10 ? null : d10);
  }
  function li(a10, b10, c10, d10) {
    var e10 = Uh2();
    d10 = void 0 === d10 ? null : d10;
    var f10 = void 0;
    if (null !== N10) {
      var g10 = N10.memoizedState;
      f10 = g10.destroy;
      if (null !== d10 && Mh2(d10, g10.deps)) {
        e10.memoizedState = bi(b10, c10, f10, d10);
        return;
      }
    }
    M10.flags |= a10;
    e10.memoizedState = bi(1 | b10, c10, f10, d10);
  }
  function mi2(a10, b10) {
    return ki(8390656, 8, a10, b10);
  }
  function $h2(a10, b10) {
    return li(2048, 8, a10, b10);
  }
  function ni2(a10, b10) {
    return li(4, 2, a10, b10);
  }
  function oi2(a10, b10) {
    return li(4, 4, a10, b10);
  }
  function pi2(a10, b10) {
    if ("function" === typeof b10) return a10 = a10(), b10(a10), function() {
      b10(null);
    };
    if (null !== b10 && void 0 !== b10) return a10 = a10(), b10.current = a10, function() {
      b10.current = null;
    };
  }
  function qi2(a10, b10, c10) {
    c10 = null !== c10 && void 0 !== c10 ? c10.concat([a10]) : null;
    return li(4, 4, pi2.bind(null, b10, a10), c10);
  }
  function ri2() {
  }
  function si2(a10, b10) {
    var c10 = Uh2();
    b10 = void 0 === b10 ? null : b10;
    var d10 = c10.memoizedState;
    if (null !== d10 && null !== b10 && Mh2(b10, d10[1])) return d10[0];
    c10.memoizedState = [a10, b10];
    return a10;
  }
  function ti(a10, b10) {
    var c10 = Uh2();
    b10 = void 0 === b10 ? null : b10;
    var d10 = c10.memoizedState;
    if (null !== d10 && null !== b10 && Mh2(b10, d10[1])) return d10[0];
    a10 = a10();
    c10.memoizedState = [a10, b10];
    return a10;
  }
  function ui2(a10, b10, c10) {
    if (0 === (Hh2 & 21)) return a10.baseState && (a10.baseState = false, dh2 = true), a10.memoizedState = c10;
    He2(c10, b10) || (c10 = yc2(), M10.lanes |= c10, rh2 |= c10, a10.baseState = true);
    return b10;
  }
  function vi2(a10, b10) {
    var c10 = C10;
    C10 = 0 !== c10 && 4 > c10 ? c10 : 4;
    a10(true);
    var d10 = Gh2.transition;
    Gh2.transition = {};
    try {
      a10(false), b10();
    } finally {
      C10 = c10, Gh2.transition = d10;
    }
  }
  function wi2() {
    return Uh2().memoizedState;
  }
  function xi2(a10, b10, c10) {
    var d10 = yi2(a10);
    c10 = { lane: d10, action: c10, hasEagerState: false, eagerState: null, next: null };
    if (zi2(a10)) Ai2(b10, c10);
    else if (c10 = hh2(a10, b10, c10, d10), null !== c10) {
      var e10 = R10();
      gi2(c10, a10, d10, e10);
      Bi2(c10, b10, d10);
    }
  }
  function ii2(a10, b10, c10) {
    var d10 = yi2(a10), e10 = { lane: d10, action: c10, hasEagerState: false, eagerState: null, next: null };
    if (zi2(a10)) Ai2(b10, e10);
    else {
      var f10 = a10.alternate;
      if (0 === a10.lanes && (null === f10 || 0 === f10.lanes) && (f10 = b10.lastRenderedReducer, null !== f10)) try {
        var g10 = b10.lastRenderedState, h10 = f10(g10, c10);
        e10.hasEagerState = true;
        e10.eagerState = h10;
        if (He2(h10, g10)) {
          var k10 = b10.interleaved;
          null === k10 ? (e10.next = e10, gh2(b10)) : (e10.next = k10.next, k10.next = e10);
          b10.interleaved = e10;
          return;
        }
      } catch (l10) {
      } finally {
      }
      c10 = hh2(a10, b10, e10, d10);
      null !== c10 && (e10 = R10(), gi2(c10, a10, d10, e10), Bi2(c10, b10, d10));
    }
  }
  function zi2(a10) {
    var b10 = a10.alternate;
    return a10 === M10 || null !== b10 && b10 === M10;
  }
  function Ai2(a10, b10) {
    Jh2 = Ih2 = true;
    var c10 = a10.pending;
    null === c10 ? b10.next = b10 : (b10.next = c10.next, c10.next = b10);
    a10.pending = b10;
  }
  function Bi2(a10, b10, c10) {
    if (0 !== (c10 & 4194240)) {
      var d10 = b10.lanes;
      d10 &= a10.pendingLanes;
      c10 |= d10;
      b10.lanes = c10;
      Cc2(a10, c10);
    }
  }
  var Rh2 = { readContext: eh2, useCallback: P10, useContext: P10, useEffect: P10, useImperativeHandle: P10, useInsertionEffect: P10, useLayoutEffect: P10, useMemo: P10, useReducer: P10, useRef: P10, useState: P10, useDebugValue: P10, useDeferredValue: P10, useTransition: P10, useMutableSource: P10, useSyncExternalStore: P10, useId: P10, unstable_isNewReconciler: false }, Oh2 = { readContext: eh2, useCallback: function(a10, b10) {
    Th2().memoizedState = [a10, void 0 === b10 ? null : b10];
    return a10;
  }, useContext: eh2, useEffect: mi2, useImperativeHandle: function(a10, b10, c10) {
    c10 = null !== c10 && void 0 !== c10 ? c10.concat([a10]) : null;
    return ki(
      4194308,
      4,
      pi2.bind(null, b10, a10),
      c10
    );
  }, useLayoutEffect: function(a10, b10) {
    return ki(4194308, 4, a10, b10);
  }, useInsertionEffect: function(a10, b10) {
    return ki(4, 2, a10, b10);
  }, useMemo: function(a10, b10) {
    var c10 = Th2();
    b10 = void 0 === b10 ? null : b10;
    a10 = a10();
    c10.memoizedState = [a10, b10];
    return a10;
  }, useReducer: function(a10, b10, c10) {
    var d10 = Th2();
    b10 = void 0 !== c10 ? c10(b10) : b10;
    d10.memoizedState = d10.baseState = b10;
    a10 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a10, lastRenderedState: b10 };
    d10.queue = a10;
    a10 = a10.dispatch = xi2.bind(null, M10, a10);
    return [d10.memoizedState, a10];
  }, useRef: function(a10) {
    var b10 = Th2();
    a10 = { current: a10 };
    return b10.memoizedState = a10;
  }, useState: hi2, useDebugValue: ri2, useDeferredValue: function(a10) {
    return Th2().memoizedState = a10;
  }, useTransition: function() {
    var a10 = hi2(false), b10 = a10[0];
    a10 = vi2.bind(null, a10[1]);
    Th2().memoizedState = a10;
    return [b10, a10];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a10, b10, c10) {
    var d10 = M10, e10 = Th2();
    if (I10) {
      if (void 0 === c10) throw Error(p10(407));
      c10 = c10();
    } else {
      c10 = b10();
      if (null === Q10) throw Error(p10(349));
      0 !== (Hh2 & 30) || di2(d10, b10, c10);
    }
    e10.memoizedState = c10;
    var f10 = { value: c10, getSnapshot: b10 };
    e10.queue = f10;
    mi2(ai2.bind(
      null,
      d10,
      f10,
      a10
    ), [a10]);
    d10.flags |= 2048;
    bi(9, ci2.bind(null, d10, f10, c10, b10), void 0, null);
    return c10;
  }, useId: function() {
    var a10 = Th2(), b10 = Q10.identifierPrefix;
    if (I10) {
      var c10 = sg2;
      var d10 = rg2;
      c10 = (d10 & ~(1 << 32 - oc2(d10) - 1)).toString(32) + c10;
      b10 = ":" + b10 + "R" + c10;
      c10 = Kh2++;
      0 < c10 && (b10 += "H" + c10.toString(32));
      b10 += ":";
    } else c10 = Lh2++, b10 = ":" + b10 + "r" + c10.toString(32) + ":";
    return a10.memoizedState = b10;
  }, unstable_isNewReconciler: false }, Ph2 = {
    readContext: eh2,
    useCallback: si2,
    useContext: eh2,
    useEffect: $h2,
    useImperativeHandle: qi2,
    useInsertionEffect: ni2,
    useLayoutEffect: oi2,
    useMemo: ti,
    useReducer: Wh2,
    useRef: ji2,
    useState: function() {
      return Wh2(Vh2);
    },
    useDebugValue: ri2,
    useDeferredValue: function(a10) {
      var b10 = Uh2();
      return ui2(b10, N10.memoizedState, a10);
    },
    useTransition: function() {
      var a10 = Wh2(Vh2)[0], b10 = Uh2().memoizedState;
      return [a10, b10];
    },
    useMutableSource: Yh2,
    useSyncExternalStore: Zh2,
    useId: wi2,
    unstable_isNewReconciler: false
  }, Qh2 = { readContext: eh2, useCallback: si2, useContext: eh2, useEffect: $h2, useImperativeHandle: qi2, useInsertionEffect: ni2, useLayoutEffect: oi2, useMemo: ti, useReducer: Xh2, useRef: ji2, useState: function() {
    return Xh2(Vh2);
  }, useDebugValue: ri2, useDeferredValue: function(a10) {
    var b10 = Uh2();
    return null === N10 ? b10.memoizedState = a10 : ui2(b10, N10.memoizedState, a10);
  }, useTransition: function() {
    var a10 = Xh2(Vh2)[0], b10 = Uh2().memoizedState;
    return [a10, b10];
  }, useMutableSource: Yh2, useSyncExternalStore: Zh2, useId: wi2, unstable_isNewReconciler: false };
  function Ci(a10, b10) {
    if (a10 && a10.defaultProps) {
      b10 = A10({}, b10);
      a10 = a10.defaultProps;
      for (var c10 in a10) void 0 === b10[c10] && (b10[c10] = a10[c10]);
      return b10;
    }
    return b10;
  }
  function Di2(a10, b10, c10, d10) {
    b10 = a10.memoizedState;
    c10 = c10(d10, b10);
    c10 = null === c10 || void 0 === c10 ? b10 : A10({}, b10, c10);
    a10.memoizedState = c10;
    0 === a10.lanes && (a10.updateQueue.baseState = c10);
  }
  var Ei2 = { isMounted: function(a10) {
    return (a10 = a10._reactInternals) ? Vb2(a10) === a10 : false;
  }, enqueueSetState: function(a10, b10, c10) {
    a10 = a10._reactInternals;
    var d10 = R10(), e10 = yi2(a10), f10 = mh2(d10, e10);
    f10.payload = b10;
    void 0 !== c10 && null !== c10 && (f10.callback = c10);
    b10 = nh2(a10, f10, e10);
    null !== b10 && (gi2(b10, a10, e10, d10), oh2(b10, a10, e10));
  }, enqueueReplaceState: function(a10, b10, c10) {
    a10 = a10._reactInternals;
    var d10 = R10(), e10 = yi2(a10), f10 = mh2(d10, e10);
    f10.tag = 1;
    f10.payload = b10;
    void 0 !== c10 && null !== c10 && (f10.callback = c10);
    b10 = nh2(a10, f10, e10);
    null !== b10 && (gi2(b10, a10, e10, d10), oh2(b10, a10, e10));
  }, enqueueForceUpdate: function(a10, b10) {
    a10 = a10._reactInternals;
    var c10 = R10(), d10 = yi2(a10), e10 = mh2(c10, d10);
    e10.tag = 2;
    void 0 !== b10 && null !== b10 && (e10.callback = b10);
    b10 = nh2(a10, e10, d10);
    null !== b10 && (gi2(b10, a10, d10, c10), oh2(b10, a10, d10));
  } };
  function Fi2(a10, b10, c10, d10, e10, f10, g10) {
    a10 = a10.stateNode;
    return "function" === typeof a10.shouldComponentUpdate ? a10.shouldComponentUpdate(d10, f10, g10) : b10.prototype && b10.prototype.isPureReactComponent ? !Ie2(c10, d10) || !Ie2(e10, f10) : true;
  }
  function Gi2(a10, b10, c10) {
    var d10 = false, e10 = Vf2;
    var f10 = b10.contextType;
    "object" === typeof f10 && null !== f10 ? f10 = eh2(f10) : (e10 = Zf2(b10) ? Xf2 : H10.current, d10 = b10.contextTypes, f10 = (d10 = null !== d10 && void 0 !== d10) ? Yf2(a10, e10) : Vf2);
    b10 = new b10(c10, f10);
    a10.memoizedState = null !== b10.state && void 0 !== b10.state ? b10.state : null;
    b10.updater = Ei2;
    a10.stateNode = b10;
    b10._reactInternals = a10;
    d10 && (a10 = a10.stateNode, a10.__reactInternalMemoizedUnmaskedChildContext = e10, a10.__reactInternalMemoizedMaskedChildContext = f10);
    return b10;
  }
  function Hi2(a10, b10, c10, d10) {
    a10 = b10.state;
    "function" === typeof b10.componentWillReceiveProps && b10.componentWillReceiveProps(c10, d10);
    "function" === typeof b10.UNSAFE_componentWillReceiveProps && b10.UNSAFE_componentWillReceiveProps(c10, d10);
    b10.state !== a10 && Ei2.enqueueReplaceState(b10, b10.state, null);
  }
  function Ii2(a10, b10, c10, d10) {
    var e10 = a10.stateNode;
    e10.props = c10;
    e10.state = a10.memoizedState;
    e10.refs = {};
    kh2(a10);
    var f10 = b10.contextType;
    "object" === typeof f10 && null !== f10 ? e10.context = eh2(f10) : (f10 = Zf2(b10) ? Xf2 : H10.current, e10.context = Yf2(a10, f10));
    e10.state = a10.memoizedState;
    f10 = b10.getDerivedStateFromProps;
    "function" === typeof f10 && (Di2(a10, b10, f10, c10), e10.state = a10.memoizedState);
    "function" === typeof b10.getDerivedStateFromProps || "function" === typeof e10.getSnapshotBeforeUpdate || "function" !== typeof e10.UNSAFE_componentWillMount && "function" !== typeof e10.componentWillMount || (b10 = e10.state, "function" === typeof e10.componentWillMount && e10.componentWillMount(), "function" === typeof e10.UNSAFE_componentWillMount && e10.UNSAFE_componentWillMount(), b10 !== e10.state && Ei2.enqueueReplaceState(e10, e10.state, null), qh2(a10, c10, e10, d10), e10.state = a10.memoizedState);
    "function" === typeof e10.componentDidMount && (a10.flags |= 4194308);
  }
  function Ji2(a10, b10) {
    try {
      var c10 = "", d10 = b10;
      do
        c10 += Pa2(d10), d10 = d10.return;
      while (d10);
      var e10 = c10;
    } catch (f10) {
      e10 = "\nError generating stack: " + f10.message + "\n" + f10.stack;
    }
    return { value: a10, source: b10, stack: e10, digest: null };
  }
  function Ki2(a10, b10, c10) {
    return { value: a10, source: null, stack: null != c10 ? c10 : null, digest: null != b10 ? b10 : null };
  }
  function Li2(a10, b10) {
    try {
      console.error(b10.value);
    } catch (c10) {
      setTimeout(function() {
        throw c10;
      });
    }
  }
  var Mi2 = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni2(a10, b10, c10) {
    c10 = mh2(-1, c10);
    c10.tag = 3;
    c10.payload = { element: null };
    var d10 = b10.value;
    c10.callback = function() {
      Oi2 || (Oi2 = true, Pi2 = d10);
      Li2(a10, b10);
    };
    return c10;
  }
  function Qi2(a10, b10, c10) {
    c10 = mh2(-1, c10);
    c10.tag = 3;
    var d10 = a10.type.getDerivedStateFromError;
    if ("function" === typeof d10) {
      var e10 = b10.value;
      c10.payload = function() {
        return d10(e10);
      };
      c10.callback = function() {
        Li2(a10, b10);
      };
    }
    var f10 = a10.stateNode;
    null !== f10 && "function" === typeof f10.componentDidCatch && (c10.callback = function() {
      Li2(a10, b10);
      "function" !== typeof d10 && (null === Ri2 ? Ri2 = /* @__PURE__ */ new Set([this]) : Ri2.add(this));
      var c11 = b10.stack;
      this.componentDidCatch(b10.value, { componentStack: null !== c11 ? c11 : "" });
    });
    return c10;
  }
  function Si(a10, b10, c10) {
    var d10 = a10.pingCache;
    if (null === d10) {
      d10 = a10.pingCache = new Mi2();
      var e10 = /* @__PURE__ */ new Set();
      d10.set(b10, e10);
    } else e10 = d10.get(b10), void 0 === e10 && (e10 = /* @__PURE__ */ new Set(), d10.set(b10, e10));
    e10.has(c10) || (e10.add(c10), a10 = Ti.bind(null, a10, b10, c10), b10.then(a10, a10));
  }
  function Ui2(a10) {
    do {
      var b10;
      if (b10 = 13 === a10.tag) b10 = a10.memoizedState, b10 = null !== b10 ? null !== b10.dehydrated ? true : false : true;
      if (b10) return a10;
      a10 = a10.return;
    } while (null !== a10);
    return null;
  }
  function Vi2(a10, b10, c10, d10, e10) {
    if (0 === (a10.mode & 1)) return a10 === b10 ? a10.flags |= 65536 : (a10.flags |= 128, c10.flags |= 131072, c10.flags &= -52805, 1 === c10.tag && (null === c10.alternate ? c10.tag = 17 : (b10 = mh2(-1, 1), b10.tag = 2, nh2(c10, b10, 1))), c10.lanes |= 1), a10;
    a10.flags |= 65536;
    a10.lanes = e10;
    return a10;
  }
  var Wi2 = ua2.ReactCurrentOwner, dh2 = false;
  function Xi2(a10, b10, c10, d10) {
    b10.child = null === a10 ? Vg2(b10, null, c10, d10) : Ug2(b10, a10.child, c10, d10);
  }
  function Yi2(a10, b10, c10, d10, e10) {
    c10 = c10.render;
    var f10 = b10.ref;
    ch2(b10, e10);
    d10 = Nh2(a10, b10, c10, d10, f10, e10);
    c10 = Sh2();
    if (null !== a10 && !dh2) return b10.updateQueue = a10.updateQueue, b10.flags &= -2053, a10.lanes &= ~e10, Zi(a10, b10, e10);
    I10 && c10 && vg2(b10);
    b10.flags |= 1;
    Xi2(a10, b10, d10, e10);
    return b10.child;
  }
  function $i(a10, b10, c10, d10, e10) {
    if (null === a10) {
      var f10 = c10.type;
      if ("function" === typeof f10 && !aj2(f10) && void 0 === f10.defaultProps && null === c10.compare && void 0 === c10.defaultProps) return b10.tag = 15, b10.type = f10, bj2(a10, b10, f10, d10, e10);
      a10 = Rg2(c10.type, null, d10, b10, b10.mode, e10);
      a10.ref = b10.ref;
      a10.return = b10;
      return b10.child = a10;
    }
    f10 = a10.child;
    if (0 === (a10.lanes & e10)) {
      var g10 = f10.memoizedProps;
      c10 = c10.compare;
      c10 = null !== c10 ? c10 : Ie2;
      if (c10(g10, d10) && a10.ref === b10.ref) return Zi(a10, b10, e10);
    }
    b10.flags |= 1;
    a10 = Pg2(f10, d10);
    a10.ref = b10.ref;
    a10.return = b10;
    return b10.child = a10;
  }
  function bj2(a10, b10, c10, d10, e10) {
    if (null !== a10) {
      var f10 = a10.memoizedProps;
      if (Ie2(f10, d10) && a10.ref === b10.ref) if (dh2 = false, b10.pendingProps = d10 = f10, 0 !== (a10.lanes & e10)) 0 !== (a10.flags & 131072) && (dh2 = true);
      else return b10.lanes = a10.lanes, Zi(a10, b10, e10);
    }
    return cj2(a10, b10, c10, d10, e10);
  }
  function dj2(a10, b10, c10) {
    var d10 = b10.pendingProps, e10 = d10.children, f10 = null !== a10 ? a10.memoizedState : null;
    if ("hidden" === d10.mode) if (0 === (b10.mode & 1)) b10.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G10(ej2, fj2), fj2 |= c10;
    else {
      if (0 === (c10 & 1073741824)) return a10 = null !== f10 ? f10.baseLanes | c10 : c10, b10.lanes = b10.childLanes = 1073741824, b10.memoizedState = { baseLanes: a10, cachePool: null, transitions: null }, b10.updateQueue = null, G10(ej2, fj2), fj2 |= a10, null;
      b10.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d10 = null !== f10 ? f10.baseLanes : c10;
      G10(ej2, fj2);
      fj2 |= d10;
    }
    else null !== f10 ? (d10 = f10.baseLanes | c10, b10.memoizedState = null) : d10 = c10, G10(ej2, fj2), fj2 |= d10;
    Xi2(a10, b10, e10, c10);
    return b10.child;
  }
  function gj2(a10, b10) {
    var c10 = b10.ref;
    if (null === a10 && null !== c10 || null !== a10 && a10.ref !== c10) b10.flags |= 512, b10.flags |= 2097152;
  }
  function cj2(a10, b10, c10, d10, e10) {
    var f10 = Zf2(c10) ? Xf2 : H10.current;
    f10 = Yf2(b10, f10);
    ch2(b10, e10);
    c10 = Nh2(a10, b10, c10, d10, f10, e10);
    d10 = Sh2();
    if (null !== a10 && !dh2) return b10.updateQueue = a10.updateQueue, b10.flags &= -2053, a10.lanes &= ~e10, Zi(a10, b10, e10);
    I10 && d10 && vg2(b10);
    b10.flags |= 1;
    Xi2(a10, b10, c10, e10);
    return b10.child;
  }
  function hj2(a10, b10, c10, d10, e10) {
    if (Zf2(c10)) {
      var f10 = true;
      cg2(b10);
    } else f10 = false;
    ch2(b10, e10);
    if (null === b10.stateNode) ij2(a10, b10), Gi2(b10, c10, d10), Ii2(b10, c10, d10, e10), d10 = true;
    else if (null === a10) {
      var g10 = b10.stateNode, h10 = b10.memoizedProps;
      g10.props = h10;
      var k10 = g10.context, l10 = c10.contextType;
      "object" === typeof l10 && null !== l10 ? l10 = eh2(l10) : (l10 = Zf2(c10) ? Xf2 : H10.current, l10 = Yf2(b10, l10));
      var m10 = c10.getDerivedStateFromProps, q10 = "function" === typeof m10 || "function" === typeof g10.getSnapshotBeforeUpdate;
      q10 || "function" !== typeof g10.UNSAFE_componentWillReceiveProps && "function" !== typeof g10.componentWillReceiveProps || (h10 !== d10 || k10 !== l10) && Hi2(b10, g10, d10, l10);
      jh2 = false;
      var r10 = b10.memoizedState;
      g10.state = r10;
      qh2(b10, d10, g10, e10);
      k10 = b10.memoizedState;
      h10 !== d10 || r10 !== k10 || Wf2.current || jh2 ? ("function" === typeof m10 && (Di2(b10, c10, m10, d10), k10 = b10.memoizedState), (h10 = jh2 || Fi2(b10, c10, h10, d10, r10, k10, l10)) ? (q10 || "function" !== typeof g10.UNSAFE_componentWillMount && "function" !== typeof g10.componentWillMount || ("function" === typeof g10.componentWillMount && g10.componentWillMount(), "function" === typeof g10.UNSAFE_componentWillMount && g10.UNSAFE_componentWillMount()), "function" === typeof g10.componentDidMount && (b10.flags |= 4194308)) : ("function" === typeof g10.componentDidMount && (b10.flags |= 4194308), b10.memoizedProps = d10, b10.memoizedState = k10), g10.props = d10, g10.state = k10, g10.context = l10, d10 = h10) : ("function" === typeof g10.componentDidMount && (b10.flags |= 4194308), d10 = false);
    } else {
      g10 = b10.stateNode;
      lh2(a10, b10);
      h10 = b10.memoizedProps;
      l10 = b10.type === b10.elementType ? h10 : Ci(b10.type, h10);
      g10.props = l10;
      q10 = b10.pendingProps;
      r10 = g10.context;
      k10 = c10.contextType;
      "object" === typeof k10 && null !== k10 ? k10 = eh2(k10) : (k10 = Zf2(c10) ? Xf2 : H10.current, k10 = Yf2(b10, k10));
      var y10 = c10.getDerivedStateFromProps;
      (m10 = "function" === typeof y10 || "function" === typeof g10.getSnapshotBeforeUpdate) || "function" !== typeof g10.UNSAFE_componentWillReceiveProps && "function" !== typeof g10.componentWillReceiveProps || (h10 !== q10 || r10 !== k10) && Hi2(b10, g10, d10, k10);
      jh2 = false;
      r10 = b10.memoizedState;
      g10.state = r10;
      qh2(b10, d10, g10, e10);
      var n10 = b10.memoizedState;
      h10 !== q10 || r10 !== n10 || Wf2.current || jh2 ? ("function" === typeof y10 && (Di2(b10, c10, y10, d10), n10 = b10.memoizedState), (l10 = jh2 || Fi2(b10, c10, l10, d10, r10, n10, k10) || false) ? (m10 || "function" !== typeof g10.UNSAFE_componentWillUpdate && "function" !== typeof g10.componentWillUpdate || ("function" === typeof g10.componentWillUpdate && g10.componentWillUpdate(d10, n10, k10), "function" === typeof g10.UNSAFE_componentWillUpdate && g10.UNSAFE_componentWillUpdate(d10, n10, k10)), "function" === typeof g10.componentDidUpdate && (b10.flags |= 4), "function" === typeof g10.getSnapshotBeforeUpdate && (b10.flags |= 1024)) : ("function" !== typeof g10.componentDidUpdate || h10 === a10.memoizedProps && r10 === a10.memoizedState || (b10.flags |= 4), "function" !== typeof g10.getSnapshotBeforeUpdate || h10 === a10.memoizedProps && r10 === a10.memoizedState || (b10.flags |= 1024), b10.memoizedProps = d10, b10.memoizedState = n10), g10.props = d10, g10.state = n10, g10.context = k10, d10 = l10) : ("function" !== typeof g10.componentDidUpdate || h10 === a10.memoizedProps && r10 === a10.memoizedState || (b10.flags |= 4), "function" !== typeof g10.getSnapshotBeforeUpdate || h10 === a10.memoizedProps && r10 === a10.memoizedState || (b10.flags |= 1024), d10 = false);
    }
    return jj2(a10, b10, c10, d10, f10, e10);
  }
  function jj2(a10, b10, c10, d10, e10, f10) {
    gj2(a10, b10);
    var g10 = 0 !== (b10.flags & 128);
    if (!d10 && !g10) return e10 && dg2(b10, c10, false), Zi(a10, b10, f10);
    d10 = b10.stateNode;
    Wi2.current = b10;
    var h10 = g10 && "function" !== typeof c10.getDerivedStateFromError ? null : d10.render();
    b10.flags |= 1;
    null !== a10 && g10 ? (b10.child = Ug2(b10, a10.child, null, f10), b10.child = Ug2(b10, null, h10, f10)) : Xi2(a10, b10, h10, f10);
    b10.memoizedState = d10.state;
    e10 && dg2(b10, c10, true);
    return b10.child;
  }
  function kj2(a10) {
    var b10 = a10.stateNode;
    b10.pendingContext ? ag2(a10, b10.pendingContext, b10.pendingContext !== b10.context) : b10.context && ag2(a10, b10.context, false);
    yh2(a10, b10.containerInfo);
  }
  function lj2(a10, b10, c10, d10, e10) {
    Ig2();
    Jg2(e10);
    b10.flags |= 256;
    Xi2(a10, b10, c10, d10);
    return b10.child;
  }
  var mj2 = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj2(a10) {
    return { baseLanes: a10, cachePool: null, transitions: null };
  }
  function oj2(a10, b10, c10) {
    var d10 = b10.pendingProps, e10 = L10.current, f10 = false, g10 = 0 !== (b10.flags & 128), h10;
    (h10 = g10) || (h10 = null !== a10 && null === a10.memoizedState ? false : 0 !== (e10 & 2));
    if (h10) f10 = true, b10.flags &= -129;
    else if (null === a10 || null !== a10.memoizedState) e10 |= 1;
    G10(L10, e10 & 1);
    if (null === a10) {
      Eg2(b10);
      a10 = b10.memoizedState;
      if (null !== a10 && (a10 = a10.dehydrated, null !== a10)) return 0 === (b10.mode & 1) ? b10.lanes = 1 : "$!" === a10.data ? b10.lanes = 8 : b10.lanes = 1073741824, null;
      g10 = d10.children;
      a10 = d10.fallback;
      return f10 ? (d10 = b10.mode, f10 = b10.child, g10 = { mode: "hidden", children: g10 }, 0 === (d10 & 1) && null !== f10 ? (f10.childLanes = 0, f10.pendingProps = g10) : f10 = pj2(g10, d10, 0, null), a10 = Tg2(a10, d10, c10, null), f10.return = b10, a10.return = b10, f10.sibling = a10, b10.child = f10, b10.child.memoizedState = nj2(c10), b10.memoizedState = mj2, a10) : qj2(b10, g10);
    }
    e10 = a10.memoizedState;
    if (null !== e10 && (h10 = e10.dehydrated, null !== h10)) return rj2(a10, b10, g10, d10, h10, e10, c10);
    if (f10) {
      f10 = d10.fallback;
      g10 = b10.mode;
      e10 = a10.child;
      h10 = e10.sibling;
      var k10 = { mode: "hidden", children: d10.children };
      0 === (g10 & 1) && b10.child !== e10 ? (d10 = b10.child, d10.childLanes = 0, d10.pendingProps = k10, b10.deletions = null) : (d10 = Pg2(e10, k10), d10.subtreeFlags = e10.subtreeFlags & 14680064);
      null !== h10 ? f10 = Pg2(h10, f10) : (f10 = Tg2(f10, g10, c10, null), f10.flags |= 2);
      f10.return = b10;
      d10.return = b10;
      d10.sibling = f10;
      b10.child = d10;
      d10 = f10;
      f10 = b10.child;
      g10 = a10.child.memoizedState;
      g10 = null === g10 ? nj2(c10) : { baseLanes: g10.baseLanes | c10, cachePool: null, transitions: g10.transitions };
      f10.memoizedState = g10;
      f10.childLanes = a10.childLanes & ~c10;
      b10.memoizedState = mj2;
      return d10;
    }
    f10 = a10.child;
    a10 = f10.sibling;
    d10 = Pg2(f10, { mode: "visible", children: d10.children });
    0 === (b10.mode & 1) && (d10.lanes = c10);
    d10.return = b10;
    d10.sibling = null;
    null !== a10 && (c10 = b10.deletions, null === c10 ? (b10.deletions = [a10], b10.flags |= 16) : c10.push(a10));
    b10.child = d10;
    b10.memoizedState = null;
    return d10;
  }
  function qj2(a10, b10) {
    b10 = pj2({ mode: "visible", children: b10 }, a10.mode, 0, null);
    b10.return = a10;
    return a10.child = b10;
  }
  function sj2(a10, b10, c10, d10) {
    null !== d10 && Jg2(d10);
    Ug2(b10, a10.child, null, c10);
    a10 = qj2(b10, b10.pendingProps.children);
    a10.flags |= 2;
    b10.memoizedState = null;
    return a10;
  }
  function rj2(a10, b10, c10, d10, e10, f10, g10) {
    if (c10) {
      if (b10.flags & 256) return b10.flags &= -257, d10 = Ki2(Error(p10(422))), sj2(a10, b10, g10, d10);
      if (null !== b10.memoizedState) return b10.child = a10.child, b10.flags |= 128, null;
      f10 = d10.fallback;
      e10 = b10.mode;
      d10 = pj2({ mode: "visible", children: d10.children }, e10, 0, null);
      f10 = Tg2(f10, e10, g10, null);
      f10.flags |= 2;
      d10.return = b10;
      f10.return = b10;
      d10.sibling = f10;
      b10.child = d10;
      0 !== (b10.mode & 1) && Ug2(b10, a10.child, null, g10);
      b10.child.memoizedState = nj2(g10);
      b10.memoizedState = mj2;
      return f10;
    }
    if (0 === (b10.mode & 1)) return sj2(a10, b10, g10, null);
    if ("$!" === e10.data) {
      d10 = e10.nextSibling && e10.nextSibling.dataset;
      if (d10) var h10 = d10.dgst;
      d10 = h10;
      f10 = Error(p10(419));
      d10 = Ki2(f10, d10, void 0);
      return sj2(a10, b10, g10, d10);
    }
    h10 = 0 !== (g10 & a10.childLanes);
    if (dh2 || h10) {
      d10 = Q10;
      if (null !== d10) {
        switch (g10 & -g10) {
          case 4:
            e10 = 2;
            break;
          case 16:
            e10 = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e10 = 32;
            break;
          case 536870912:
            e10 = 268435456;
            break;
          default:
            e10 = 0;
        }
        e10 = 0 !== (e10 & (d10.suspendedLanes | g10)) ? 0 : e10;
        0 !== e10 && e10 !== f10.retryLane && (f10.retryLane = e10, ih2(a10, e10), gi2(d10, a10, e10, -1));
      }
      tj2();
      d10 = Ki2(Error(p10(421)));
      return sj2(a10, b10, g10, d10);
    }
    if ("$?" === e10.data) return b10.flags |= 128, b10.child = a10.child, b10 = uj2.bind(null, a10), e10._reactRetry = b10, null;
    a10 = f10.treeContext;
    yg2 = Lf2(e10.nextSibling);
    xg2 = b10;
    I10 = true;
    zg2 = null;
    null !== a10 && (og2[pg2++] = rg2, og2[pg2++] = sg2, og2[pg2++] = qg2, rg2 = a10.id, sg2 = a10.overflow, qg2 = b10);
    b10 = qj2(b10, d10.children);
    b10.flags |= 4096;
    return b10;
  }
  function vj2(a10, b10, c10) {
    a10.lanes |= b10;
    var d10 = a10.alternate;
    null !== d10 && (d10.lanes |= b10);
    bh2(a10.return, b10, c10);
  }
  function wj2(a10, b10, c10, d10, e10) {
    var f10 = a10.memoizedState;
    null === f10 ? a10.memoizedState = { isBackwards: b10, rendering: null, renderingStartTime: 0, last: d10, tail: c10, tailMode: e10 } : (f10.isBackwards = b10, f10.rendering = null, f10.renderingStartTime = 0, f10.last = d10, f10.tail = c10, f10.tailMode = e10);
  }
  function xj2(a10, b10, c10) {
    var d10 = b10.pendingProps, e10 = d10.revealOrder, f10 = d10.tail;
    Xi2(a10, b10, d10.children, c10);
    d10 = L10.current;
    if (0 !== (d10 & 2)) d10 = d10 & 1 | 2, b10.flags |= 128;
    else {
      if (null !== a10 && 0 !== (a10.flags & 128)) a: for (a10 = b10.child; null !== a10; ) {
        if (13 === a10.tag) null !== a10.memoizedState && vj2(a10, c10, b10);
        else if (19 === a10.tag) vj2(a10, c10, b10);
        else if (null !== a10.child) {
          a10.child.return = a10;
          a10 = a10.child;
          continue;
        }
        if (a10 === b10) break a;
        for (; null === a10.sibling; ) {
          if (null === a10.return || a10.return === b10) break a;
          a10 = a10.return;
        }
        a10.sibling.return = a10.return;
        a10 = a10.sibling;
      }
      d10 &= 1;
    }
    G10(L10, d10);
    if (0 === (b10.mode & 1)) b10.memoizedState = null;
    else switch (e10) {
      case "forwards":
        c10 = b10.child;
        for (e10 = null; null !== c10; ) a10 = c10.alternate, null !== a10 && null === Ch2(a10) && (e10 = c10), c10 = c10.sibling;
        c10 = e10;
        null === c10 ? (e10 = b10.child, b10.child = null) : (e10 = c10.sibling, c10.sibling = null);
        wj2(b10, false, e10, c10, f10);
        break;
      case "backwards":
        c10 = null;
        e10 = b10.child;
        for (b10.child = null; null !== e10; ) {
          a10 = e10.alternate;
          if (null !== a10 && null === Ch2(a10)) {
            b10.child = e10;
            break;
          }
          a10 = e10.sibling;
          e10.sibling = c10;
          c10 = e10;
          e10 = a10;
        }
        wj2(b10, true, c10, null, f10);
        break;
      case "together":
        wj2(b10, false, null, null, void 0);
        break;
      default:
        b10.memoizedState = null;
    }
    return b10.child;
  }
  function ij2(a10, b10) {
    0 === (b10.mode & 1) && null !== a10 && (a10.alternate = null, b10.alternate = null, b10.flags |= 2);
  }
  function Zi(a10, b10, c10) {
    null !== a10 && (b10.dependencies = a10.dependencies);
    rh2 |= b10.lanes;
    if (0 === (c10 & b10.childLanes)) return null;
    if (null !== a10 && b10.child !== a10.child) throw Error(p10(153));
    if (null !== b10.child) {
      a10 = b10.child;
      c10 = Pg2(a10, a10.pendingProps);
      b10.child = c10;
      for (c10.return = b10; null !== a10.sibling; ) a10 = a10.sibling, c10 = c10.sibling = Pg2(a10, a10.pendingProps), c10.return = b10;
      c10.sibling = null;
    }
    return b10.child;
  }
  function yj2(a10, b10, c10) {
    switch (b10.tag) {
      case 3:
        kj2(b10);
        Ig2();
        break;
      case 5:
        Ah2(b10);
        break;
      case 1:
        Zf2(b10.type) && cg2(b10);
        break;
      case 4:
        yh2(b10, b10.stateNode.containerInfo);
        break;
      case 10:
        var d10 = b10.type._context, e10 = b10.memoizedProps.value;
        G10(Wg2, d10._currentValue);
        d10._currentValue = e10;
        break;
      case 13:
        d10 = b10.memoizedState;
        if (null !== d10) {
          if (null !== d10.dehydrated) return G10(L10, L10.current & 1), b10.flags |= 128, null;
          if (0 !== (c10 & b10.child.childLanes)) return oj2(a10, b10, c10);
          G10(L10, L10.current & 1);
          a10 = Zi(a10, b10, c10);
          return null !== a10 ? a10.sibling : null;
        }
        G10(L10, L10.current & 1);
        break;
      case 19:
        d10 = 0 !== (c10 & b10.childLanes);
        if (0 !== (a10.flags & 128)) {
          if (d10) return xj2(a10, b10, c10);
          b10.flags |= 128;
        }
        e10 = b10.memoizedState;
        null !== e10 && (e10.rendering = null, e10.tail = null, e10.lastEffect = null);
        G10(L10, L10.current);
        if (d10) break;
        else return null;
      case 22:
      case 23:
        return b10.lanes = 0, dj2(a10, b10, c10);
    }
    return Zi(a10, b10, c10);
  }
  var zj2, Aj2, Bj2, Cj2;
  zj2 = function(a10, b10) {
    for (var c10 = b10.child; null !== c10; ) {
      if (5 === c10.tag || 6 === c10.tag) a10.appendChild(c10.stateNode);
      else if (4 !== c10.tag && null !== c10.child) {
        c10.child.return = c10;
        c10 = c10.child;
        continue;
      }
      if (c10 === b10) break;
      for (; null === c10.sibling; ) {
        if (null === c10.return || c10.return === b10) return;
        c10 = c10.return;
      }
      c10.sibling.return = c10.return;
      c10 = c10.sibling;
    }
  };
  Aj2 = function() {
  };
  Bj2 = function(a10, b10, c10, d10) {
    var e10 = a10.memoizedProps;
    if (e10 !== d10) {
      a10 = b10.stateNode;
      xh2(uh2.current);
      var f10 = null;
      switch (c10) {
        case "input":
          e10 = Ya2(a10, e10);
          d10 = Ya2(a10, d10);
          f10 = [];
          break;
        case "select":
          e10 = A10({}, e10, { value: void 0 });
          d10 = A10({}, d10, { value: void 0 });
          f10 = [];
          break;
        case "textarea":
          e10 = gb2(a10, e10);
          d10 = gb2(a10, d10);
          f10 = [];
          break;
        default:
          "function" !== typeof e10.onClick && "function" === typeof d10.onClick && (a10.onclick = Bf2);
      }
      ub2(c10, d10);
      var g10;
      c10 = null;
      for (l10 in e10) if (!d10.hasOwnProperty(l10) && e10.hasOwnProperty(l10) && null != e10[l10]) if ("style" === l10) {
        var h10 = e10[l10];
        for (g10 in h10) h10.hasOwnProperty(g10) && (c10 || (c10 = {}), c10[g10] = "");
      } else "dangerouslySetInnerHTML" !== l10 && "children" !== l10 && "suppressContentEditableWarning" !== l10 && "suppressHydrationWarning" !== l10 && "autoFocus" !== l10 && (ea2.hasOwnProperty(l10) ? f10 || (f10 = []) : (f10 = f10 || []).push(l10, null));
      for (l10 in d10) {
        var k10 = d10[l10];
        h10 = null != e10 ? e10[l10] : void 0;
        if (d10.hasOwnProperty(l10) && k10 !== h10 && (null != k10 || null != h10)) if ("style" === l10) if (h10) {
          for (g10 in h10) !h10.hasOwnProperty(g10) || k10 && k10.hasOwnProperty(g10) || (c10 || (c10 = {}), c10[g10] = "");
          for (g10 in k10) k10.hasOwnProperty(g10) && h10[g10] !== k10[g10] && (c10 || (c10 = {}), c10[g10] = k10[g10]);
        } else c10 || (f10 || (f10 = []), f10.push(
          l10,
          c10
        )), c10 = k10;
        else "dangerouslySetInnerHTML" === l10 ? (k10 = k10 ? k10.__html : void 0, h10 = h10 ? h10.__html : void 0, null != k10 && h10 !== k10 && (f10 = f10 || []).push(l10, k10)) : "children" === l10 ? "string" !== typeof k10 && "number" !== typeof k10 || (f10 = f10 || []).push(l10, "" + k10) : "suppressContentEditableWarning" !== l10 && "suppressHydrationWarning" !== l10 && (ea2.hasOwnProperty(l10) ? (null != k10 && "onScroll" === l10 && D10("scroll", a10), f10 || h10 === k10 || (f10 = [])) : (f10 = f10 || []).push(l10, k10));
      }
      c10 && (f10 = f10 || []).push("style", c10);
      var l10 = f10;
      if (b10.updateQueue = l10) b10.flags |= 4;
    }
  };
  Cj2 = function(a10, b10, c10, d10) {
    c10 !== d10 && (b10.flags |= 4);
  };
  function Dj2(a10, b10) {
    if (!I10) switch (a10.tailMode) {
      case "hidden":
        b10 = a10.tail;
        for (var c10 = null; null !== b10; ) null !== b10.alternate && (c10 = b10), b10 = b10.sibling;
        null === c10 ? a10.tail = null : c10.sibling = null;
        break;
      case "collapsed":
        c10 = a10.tail;
        for (var d10 = null; null !== c10; ) null !== c10.alternate && (d10 = c10), c10 = c10.sibling;
        null === d10 ? b10 || null === a10.tail ? a10.tail = null : a10.tail.sibling = null : d10.sibling = null;
    }
  }
  function S10(a10) {
    var b10 = null !== a10.alternate && a10.alternate.child === a10.child, c10 = 0, d10 = 0;
    if (b10) for (var e10 = a10.child; null !== e10; ) c10 |= e10.lanes | e10.childLanes, d10 |= e10.subtreeFlags & 14680064, d10 |= e10.flags & 14680064, e10.return = a10, e10 = e10.sibling;
    else for (e10 = a10.child; null !== e10; ) c10 |= e10.lanes | e10.childLanes, d10 |= e10.subtreeFlags, d10 |= e10.flags, e10.return = a10, e10 = e10.sibling;
    a10.subtreeFlags |= d10;
    a10.childLanes = c10;
    return b10;
  }
  function Ej2(a10, b10, c10) {
    var d10 = b10.pendingProps;
    wg2(b10);
    switch (b10.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S10(b10), null;
      case 1:
        return Zf2(b10.type) && $f2(), S10(b10), null;
      case 3:
        d10 = b10.stateNode;
        zh2();
        E10(Wf2);
        E10(H10);
        Eh2();
        d10.pendingContext && (d10.context = d10.pendingContext, d10.pendingContext = null);
        if (null === a10 || null === a10.child) Gg2(b10) ? b10.flags |= 4 : null === a10 || a10.memoizedState.isDehydrated && 0 === (b10.flags & 256) || (b10.flags |= 1024, null !== zg2 && (Fj2(zg2), zg2 = null));
        Aj2(a10, b10);
        S10(b10);
        return null;
      case 5:
        Bh2(b10);
        var e10 = xh2(wh2.current);
        c10 = b10.type;
        if (null !== a10 && null != b10.stateNode) Bj2(a10, b10, c10, d10, e10), a10.ref !== b10.ref && (b10.flags |= 512, b10.flags |= 2097152);
        else {
          if (!d10) {
            if (null === b10.stateNode) throw Error(p10(166));
            S10(b10);
            return null;
          }
          a10 = xh2(uh2.current);
          if (Gg2(b10)) {
            d10 = b10.stateNode;
            c10 = b10.type;
            var f10 = b10.memoizedProps;
            d10[Of2] = b10;
            d10[Pf2] = f10;
            a10 = 0 !== (b10.mode & 1);
            switch (c10) {
              case "dialog":
                D10("cancel", d10);
                D10("close", d10);
                break;
              case "iframe":
              case "object":
              case "embed":
                D10("load", d10);
                break;
              case "video":
              case "audio":
                for (e10 = 0; e10 < lf2.length; e10++) D10(lf2[e10], d10);
                break;
              case "source":
                D10("error", d10);
                break;
              case "img":
              case "image":
              case "link":
                D10(
                  "error",
                  d10
                );
                D10("load", d10);
                break;
              case "details":
                D10("toggle", d10);
                break;
              case "input":
                Za2(d10, f10);
                D10("invalid", d10);
                break;
              case "select":
                d10._wrapperState = { wasMultiple: !!f10.multiple };
                D10("invalid", d10);
                break;
              case "textarea":
                hb2(d10, f10), D10("invalid", d10);
            }
            ub2(c10, f10);
            e10 = null;
            for (var g10 in f10) if (f10.hasOwnProperty(g10)) {
              var h10 = f10[g10];
              "children" === g10 ? "string" === typeof h10 ? d10.textContent !== h10 && (true !== f10.suppressHydrationWarning && Af2(d10.textContent, h10, a10), e10 = ["children", h10]) : "number" === typeof h10 && d10.textContent !== "" + h10 && (true !== f10.suppressHydrationWarning && Af2(
                d10.textContent,
                h10,
                a10
              ), e10 = ["children", "" + h10]) : ea2.hasOwnProperty(g10) && null != h10 && "onScroll" === g10 && D10("scroll", d10);
            }
            switch (c10) {
              case "input":
                Va2(d10);
                db2(d10, f10, true);
                break;
              case "textarea":
                Va2(d10);
                jb2(d10);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f10.onClick && (d10.onclick = Bf2);
            }
            d10 = e10;
            b10.updateQueue = d10;
            null !== d10 && (b10.flags |= 4);
          } else {
            g10 = 9 === e10.nodeType ? e10 : e10.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a10 && (a10 = kb2(c10));
            "http://www.w3.org/1999/xhtml" === a10 ? "script" === c10 ? (a10 = g10.createElement("div"), a10.innerHTML = "<script><\/script>", a10 = a10.removeChild(a10.firstChild)) : "string" === typeof d10.is ? a10 = g10.createElement(c10, { is: d10.is }) : (a10 = g10.createElement(c10), "select" === c10 && (g10 = a10, d10.multiple ? g10.multiple = true : d10.size && (g10.size = d10.size))) : a10 = g10.createElementNS(a10, c10);
            a10[Of2] = b10;
            a10[Pf2] = d10;
            zj2(a10, b10, false, false);
            b10.stateNode = a10;
            a: {
              g10 = vb2(c10, d10);
              switch (c10) {
                case "dialog":
                  D10("cancel", a10);
                  D10("close", a10);
                  e10 = d10;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D10("load", a10);
                  e10 = d10;
                  break;
                case "video":
                case "audio":
                  for (e10 = 0; e10 < lf2.length; e10++) D10(lf2[e10], a10);
                  e10 = d10;
                  break;
                case "source":
                  D10("error", a10);
                  e10 = d10;
                  break;
                case "img":
                case "image":
                case "link":
                  D10(
                    "error",
                    a10
                  );
                  D10("load", a10);
                  e10 = d10;
                  break;
                case "details":
                  D10("toggle", a10);
                  e10 = d10;
                  break;
                case "input":
                  Za2(a10, d10);
                  e10 = Ya2(a10, d10);
                  D10("invalid", a10);
                  break;
                case "option":
                  e10 = d10;
                  break;
                case "select":
                  a10._wrapperState = { wasMultiple: !!d10.multiple };
                  e10 = A10({}, d10, { value: void 0 });
                  D10("invalid", a10);
                  break;
                case "textarea":
                  hb2(a10, d10);
                  e10 = gb2(a10, d10);
                  D10("invalid", a10);
                  break;
                default:
                  e10 = d10;
              }
              ub2(c10, e10);
              h10 = e10;
              for (f10 in h10) if (h10.hasOwnProperty(f10)) {
                var k10 = h10[f10];
                "style" === f10 ? sb2(a10, k10) : "dangerouslySetInnerHTML" === f10 ? (k10 = k10 ? k10.__html : void 0, null != k10 && nb2(a10, k10)) : "children" === f10 ? "string" === typeof k10 ? ("textarea" !== c10 || "" !== k10) && ob2(a10, k10) : "number" === typeof k10 && ob2(a10, "" + k10) : "suppressContentEditableWarning" !== f10 && "suppressHydrationWarning" !== f10 && "autoFocus" !== f10 && (ea2.hasOwnProperty(f10) ? null != k10 && "onScroll" === f10 && D10("scroll", a10) : null != k10 && ta2(a10, f10, k10, g10));
              }
              switch (c10) {
                case "input":
                  Va2(a10);
                  db2(a10, d10, false);
                  break;
                case "textarea":
                  Va2(a10);
                  jb2(a10);
                  break;
                case "option":
                  null != d10.value && a10.setAttribute("value", "" + Sa2(d10.value));
                  break;
                case "select":
                  a10.multiple = !!d10.multiple;
                  f10 = d10.value;
                  null != f10 ? fb2(a10, !!d10.multiple, f10, false) : null != d10.defaultValue && fb2(
                    a10,
                    !!d10.multiple,
                    d10.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e10.onClick && (a10.onclick = Bf2);
              }
              switch (c10) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d10 = !!d10.autoFocus;
                  break a;
                case "img":
                  d10 = true;
                  break a;
                default:
                  d10 = false;
              }
            }
            d10 && (b10.flags |= 4);
          }
          null !== b10.ref && (b10.flags |= 512, b10.flags |= 2097152);
        }
        S10(b10);
        return null;
      case 6:
        if (a10 && null != b10.stateNode) Cj2(a10, b10, a10.memoizedProps, d10);
        else {
          if ("string" !== typeof d10 && null === b10.stateNode) throw Error(p10(166));
          c10 = xh2(wh2.current);
          xh2(uh2.current);
          if (Gg2(b10)) {
            d10 = b10.stateNode;
            c10 = b10.memoizedProps;
            d10[Of2] = b10;
            if (f10 = d10.nodeValue !== c10) {
              if (a10 = xg2, null !== a10) switch (a10.tag) {
                case 3:
                  Af2(d10.nodeValue, c10, 0 !== (a10.mode & 1));
                  break;
                case 5:
                  true !== a10.memoizedProps.suppressHydrationWarning && Af2(d10.nodeValue, c10, 0 !== (a10.mode & 1));
              }
            }
            f10 && (b10.flags |= 4);
          } else d10 = (9 === c10.nodeType ? c10 : c10.ownerDocument).createTextNode(d10), d10[Of2] = b10, b10.stateNode = d10;
        }
        S10(b10);
        return null;
      case 13:
        E10(L10);
        d10 = b10.memoizedState;
        if (null === a10 || null !== a10.memoizedState && null !== a10.memoizedState.dehydrated) {
          if (I10 && null !== yg2 && 0 !== (b10.mode & 1) && 0 === (b10.flags & 128)) Hg2(), Ig2(), b10.flags |= 98560, f10 = false;
          else if (f10 = Gg2(b10), null !== d10 && null !== d10.dehydrated) {
            if (null === a10) {
              if (!f10) throw Error(p10(318));
              f10 = b10.memoizedState;
              f10 = null !== f10 ? f10.dehydrated : null;
              if (!f10) throw Error(p10(317));
              f10[Of2] = b10;
            } else Ig2(), 0 === (b10.flags & 128) && (b10.memoizedState = null), b10.flags |= 4;
            S10(b10);
            f10 = false;
          } else null !== zg2 && (Fj2(zg2), zg2 = null), f10 = true;
          if (!f10) return b10.flags & 65536 ? b10 : null;
        }
        if (0 !== (b10.flags & 128)) return b10.lanes = c10, b10;
        d10 = null !== d10;
        d10 !== (null !== a10 && null !== a10.memoizedState) && d10 && (b10.child.flags |= 8192, 0 !== (b10.mode & 1) && (null === a10 || 0 !== (L10.current & 1) ? 0 === T10 && (T10 = 3) : tj2()));
        null !== b10.updateQueue && (b10.flags |= 4);
        S10(b10);
        return null;
      case 4:
        return zh2(), Aj2(a10, b10), null === a10 && sf2(b10.stateNode.containerInfo), S10(b10), null;
      case 10:
        return ah2(b10.type._context), S10(b10), null;
      case 17:
        return Zf2(b10.type) && $f2(), S10(b10), null;
      case 19:
        E10(L10);
        f10 = b10.memoizedState;
        if (null === f10) return S10(b10), null;
        d10 = 0 !== (b10.flags & 128);
        g10 = f10.rendering;
        if (null === g10) if (d10) Dj2(f10, false);
        else {
          if (0 !== T10 || null !== a10 && 0 !== (a10.flags & 128)) for (a10 = b10.child; null !== a10; ) {
            g10 = Ch2(a10);
            if (null !== g10) {
              b10.flags |= 128;
              Dj2(f10, false);
              d10 = g10.updateQueue;
              null !== d10 && (b10.updateQueue = d10, b10.flags |= 4);
              b10.subtreeFlags = 0;
              d10 = c10;
              for (c10 = b10.child; null !== c10; ) f10 = c10, a10 = d10, f10.flags &= 14680066, g10 = f10.alternate, null === g10 ? (f10.childLanes = 0, f10.lanes = a10, f10.child = null, f10.subtreeFlags = 0, f10.memoizedProps = null, f10.memoizedState = null, f10.updateQueue = null, f10.dependencies = null, f10.stateNode = null) : (f10.childLanes = g10.childLanes, f10.lanes = g10.lanes, f10.child = g10.child, f10.subtreeFlags = 0, f10.deletions = null, f10.memoizedProps = g10.memoizedProps, f10.memoizedState = g10.memoizedState, f10.updateQueue = g10.updateQueue, f10.type = g10.type, a10 = g10.dependencies, f10.dependencies = null === a10 ? null : { lanes: a10.lanes, firstContext: a10.firstContext }), c10 = c10.sibling;
              G10(L10, L10.current & 1 | 2);
              return b10.child;
            }
            a10 = a10.sibling;
          }
          null !== f10.tail && B10() > Gj2 && (b10.flags |= 128, d10 = true, Dj2(f10, false), b10.lanes = 4194304);
        }
        else {
          if (!d10) if (a10 = Ch2(g10), null !== a10) {
            if (b10.flags |= 128, d10 = true, c10 = a10.updateQueue, null !== c10 && (b10.updateQueue = c10, b10.flags |= 4), Dj2(f10, true), null === f10.tail && "hidden" === f10.tailMode && !g10.alternate && !I10) return S10(b10), null;
          } else 2 * B10() - f10.renderingStartTime > Gj2 && 1073741824 !== c10 && (b10.flags |= 128, d10 = true, Dj2(f10, false), b10.lanes = 4194304);
          f10.isBackwards ? (g10.sibling = b10.child, b10.child = g10) : (c10 = f10.last, null !== c10 ? c10.sibling = g10 : b10.child = g10, f10.last = g10);
        }
        if (null !== f10.tail) return b10 = f10.tail, f10.rendering = b10, f10.tail = b10.sibling, f10.renderingStartTime = B10(), b10.sibling = null, c10 = L10.current, G10(L10, d10 ? c10 & 1 | 2 : c10 & 1), b10;
        S10(b10);
        return null;
      case 22:
      case 23:
        return Hj2(), d10 = null !== b10.memoizedState, null !== a10 && null !== a10.memoizedState !== d10 && (b10.flags |= 8192), d10 && 0 !== (b10.mode & 1) ? 0 !== (fj2 & 1073741824) && (S10(b10), b10.subtreeFlags & 6 && (b10.flags |= 8192)) : S10(b10), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p10(156, b10.tag));
  }
  function Ij2(a10, b10) {
    wg2(b10);
    switch (b10.tag) {
      case 1:
        return Zf2(b10.type) && $f2(), a10 = b10.flags, a10 & 65536 ? (b10.flags = a10 & -65537 | 128, b10) : null;
      case 3:
        return zh2(), E10(Wf2), E10(H10), Eh2(), a10 = b10.flags, 0 !== (a10 & 65536) && 0 === (a10 & 128) ? (b10.flags = a10 & -65537 | 128, b10) : null;
      case 5:
        return Bh2(b10), null;
      case 13:
        E10(L10);
        a10 = b10.memoizedState;
        if (null !== a10 && null !== a10.dehydrated) {
          if (null === b10.alternate) throw Error(p10(340));
          Ig2();
        }
        a10 = b10.flags;
        return a10 & 65536 ? (b10.flags = a10 & -65537 | 128, b10) : null;
      case 19:
        return E10(L10), null;
      case 4:
        return zh2(), null;
      case 10:
        return ah2(b10.type._context), null;
      case 22:
      case 23:
        return Hj2(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj2 = false, U10 = false, Kj2 = "function" === typeof WeakSet ? WeakSet : Set, V10 = null;
  function Lj2(a10, b10) {
    var c10 = a10.ref;
    if (null !== c10) if ("function" === typeof c10) try {
      c10(null);
    } catch (d10) {
      W10(a10, b10, d10);
    }
    else c10.current = null;
  }
  function Mj2(a10, b10, c10) {
    try {
      c10();
    } catch (d10) {
      W10(a10, b10, d10);
    }
  }
  var Nj2 = false;
  function Oj2(a10, b10) {
    Cf2 = dd;
    a10 = Me();
    if (Ne(a10)) {
      if ("selectionStart" in a10) var c10 = { start: a10.selectionStart, end: a10.selectionEnd };
      else a: {
        c10 = (c10 = a10.ownerDocument) && c10.defaultView || window;
        var d10 = c10.getSelection && c10.getSelection();
        if (d10 && 0 !== d10.rangeCount) {
          c10 = d10.anchorNode;
          var e10 = d10.anchorOffset, f10 = d10.focusNode;
          d10 = d10.focusOffset;
          try {
            c10.nodeType, f10.nodeType;
          } catch (F10) {
            c10 = null;
            break a;
          }
          var g10 = 0, h10 = -1, k10 = -1, l10 = 0, m10 = 0, q10 = a10, r10 = null;
          b: for (; ; ) {
            for (var y10; ; ) {
              q10 !== c10 || 0 !== e10 && 3 !== q10.nodeType || (h10 = g10 + e10);
              q10 !== f10 || 0 !== d10 && 3 !== q10.nodeType || (k10 = g10 + d10);
              3 === q10.nodeType && (g10 += q10.nodeValue.length);
              if (null === (y10 = q10.firstChild)) break;
              r10 = q10;
              q10 = y10;
            }
            for (; ; ) {
              if (q10 === a10) break b;
              r10 === c10 && ++l10 === e10 && (h10 = g10);
              r10 === f10 && ++m10 === d10 && (k10 = g10);
              if (null !== (y10 = q10.nextSibling)) break;
              q10 = r10;
              r10 = q10.parentNode;
            }
            q10 = y10;
          }
          c10 = -1 === h10 || -1 === k10 ? null : { start: h10, end: k10 };
        } else c10 = null;
      }
      c10 = c10 || { start: 0, end: 0 };
    } else c10 = null;
    Df2 = { focusedElem: a10, selectionRange: c10 };
    dd = false;
    for (V10 = b10; null !== V10; ) if (b10 = V10, a10 = b10.child, 0 !== (b10.subtreeFlags & 1028) && null !== a10) a10.return = b10, V10 = a10;
    else for (; null !== V10; ) {
      b10 = V10;
      try {
        var n10 = b10.alternate;
        if (0 !== (b10.flags & 1024)) switch (b10.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n10) {
              var t10 = n10.memoizedProps, J10 = n10.memoizedState, x10 = b10.stateNode, w10 = x10.getSnapshotBeforeUpdate(b10.elementType === b10.type ? t10 : Ci(b10.type, t10), J10);
              x10.__reactInternalSnapshotBeforeUpdate = w10;
            }
            break;
          case 3:
            var u10 = b10.stateNode.containerInfo;
            1 === u10.nodeType ? u10.textContent = "" : 9 === u10.nodeType && u10.documentElement && u10.removeChild(u10.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p10(163));
        }
      } catch (F10) {
        W10(b10, b10.return, F10);
      }
      a10 = b10.sibling;
      if (null !== a10) {
        a10.return = b10.return;
        V10 = a10;
        break;
      }
      V10 = b10.return;
    }
    n10 = Nj2;
    Nj2 = false;
    return n10;
  }
  function Pj2(a10, b10, c10) {
    var d10 = b10.updateQueue;
    d10 = null !== d10 ? d10.lastEffect : null;
    if (null !== d10) {
      var e10 = d10 = d10.next;
      do {
        if ((e10.tag & a10) === a10) {
          var f10 = e10.destroy;
          e10.destroy = void 0;
          void 0 !== f10 && Mj2(b10, c10, f10);
        }
        e10 = e10.next;
      } while (e10 !== d10);
    }
  }
  function Qj2(a10, b10) {
    b10 = b10.updateQueue;
    b10 = null !== b10 ? b10.lastEffect : null;
    if (null !== b10) {
      var c10 = b10 = b10.next;
      do {
        if ((c10.tag & a10) === a10) {
          var d10 = c10.create;
          c10.destroy = d10();
        }
        c10 = c10.next;
      } while (c10 !== b10);
    }
  }
  function Rj2(a10) {
    var b10 = a10.ref;
    if (null !== b10) {
      var c10 = a10.stateNode;
      switch (a10.tag) {
        case 5:
          a10 = c10;
          break;
        default:
          a10 = c10;
      }
      "function" === typeof b10 ? b10(a10) : b10.current = a10;
    }
  }
  function Sj2(a10) {
    var b10 = a10.alternate;
    null !== b10 && (a10.alternate = null, Sj2(b10));
    a10.child = null;
    a10.deletions = null;
    a10.sibling = null;
    5 === a10.tag && (b10 = a10.stateNode, null !== b10 && (delete b10[Of2], delete b10[Pf2], delete b10[of2], delete b10[Qf2], delete b10[Rf2]));
    a10.stateNode = null;
    a10.return = null;
    a10.dependencies = null;
    a10.memoizedProps = null;
    a10.memoizedState = null;
    a10.pendingProps = null;
    a10.stateNode = null;
    a10.updateQueue = null;
  }
  function Tj2(a10) {
    return 5 === a10.tag || 3 === a10.tag || 4 === a10.tag;
  }
  function Uj2(a10) {
    a: for (; ; ) {
      for (; null === a10.sibling; ) {
        if (null === a10.return || Tj2(a10.return)) return null;
        a10 = a10.return;
      }
      a10.sibling.return = a10.return;
      for (a10 = a10.sibling; 5 !== a10.tag && 6 !== a10.tag && 18 !== a10.tag; ) {
        if (a10.flags & 2) continue a;
        if (null === a10.child || 4 === a10.tag) continue a;
        else a10.child.return = a10, a10 = a10.child;
      }
      if (!(a10.flags & 2)) return a10.stateNode;
    }
  }
  function Vj2(a10, b10, c10) {
    var d10 = a10.tag;
    if (5 === d10 || 6 === d10) a10 = a10.stateNode, b10 ? 8 === c10.nodeType ? c10.parentNode.insertBefore(a10, b10) : c10.insertBefore(a10, b10) : (8 === c10.nodeType ? (b10 = c10.parentNode, b10.insertBefore(a10, c10)) : (b10 = c10, b10.appendChild(a10)), c10 = c10._reactRootContainer, null !== c10 && void 0 !== c10 || null !== b10.onclick || (b10.onclick = Bf2));
    else if (4 !== d10 && (a10 = a10.child, null !== a10)) for (Vj2(a10, b10, c10), a10 = a10.sibling; null !== a10; ) Vj2(a10, b10, c10), a10 = a10.sibling;
  }
  function Wj2(a10, b10, c10) {
    var d10 = a10.tag;
    if (5 === d10 || 6 === d10) a10 = a10.stateNode, b10 ? c10.insertBefore(a10, b10) : c10.appendChild(a10);
    else if (4 !== d10 && (a10 = a10.child, null !== a10)) for (Wj2(a10, b10, c10), a10 = a10.sibling; null !== a10; ) Wj2(a10, b10, c10), a10 = a10.sibling;
  }
  var X10 = null, Xj2 = false;
  function Yj2(a10, b10, c10) {
    for (c10 = c10.child; null !== c10; ) Zj2(a10, b10, c10), c10 = c10.sibling;
  }
  function Zj2(a10, b10, c10) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc2, c10);
    } catch (h10) {
    }
    switch (c10.tag) {
      case 5:
        U10 || Lj2(c10, b10);
      case 6:
        var d10 = X10, e10 = Xj2;
        X10 = null;
        Yj2(a10, b10, c10);
        X10 = d10;
        Xj2 = e10;
        null !== X10 && (Xj2 ? (a10 = X10, c10 = c10.stateNode, 8 === a10.nodeType ? a10.parentNode.removeChild(c10) : a10.removeChild(c10)) : X10.removeChild(c10.stateNode));
        break;
      case 18:
        null !== X10 && (Xj2 ? (a10 = X10, c10 = c10.stateNode, 8 === a10.nodeType ? Kf2(a10.parentNode, c10) : 1 === a10.nodeType && Kf2(a10, c10), bd2(a10)) : Kf2(X10, c10.stateNode));
        break;
      case 4:
        d10 = X10;
        e10 = Xj2;
        X10 = c10.stateNode.containerInfo;
        Xj2 = true;
        Yj2(a10, b10, c10);
        X10 = d10;
        Xj2 = e10;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U10 && (d10 = c10.updateQueue, null !== d10 && (d10 = d10.lastEffect, null !== d10))) {
          e10 = d10 = d10.next;
          do {
            var f10 = e10, g10 = f10.destroy;
            f10 = f10.tag;
            void 0 !== g10 && (0 !== (f10 & 2) ? Mj2(c10, b10, g10) : 0 !== (f10 & 4) && Mj2(c10, b10, g10));
            e10 = e10.next;
          } while (e10 !== d10);
        }
        Yj2(a10, b10, c10);
        break;
      case 1:
        if (!U10 && (Lj2(c10, b10), d10 = c10.stateNode, "function" === typeof d10.componentWillUnmount)) try {
          d10.props = c10.memoizedProps, d10.state = c10.memoizedState, d10.componentWillUnmount();
        } catch (h10) {
          W10(c10, b10, h10);
        }
        Yj2(a10, b10, c10);
        break;
      case 21:
        Yj2(a10, b10, c10);
        break;
      case 22:
        c10.mode & 1 ? (U10 = (d10 = U10) || null !== c10.memoizedState, Yj2(a10, b10, c10), U10 = d10) : Yj2(a10, b10, c10);
        break;
      default:
        Yj2(a10, b10, c10);
    }
  }
  function ak2(a10) {
    var b10 = a10.updateQueue;
    if (null !== b10) {
      a10.updateQueue = null;
      var c10 = a10.stateNode;
      null === c10 && (c10 = a10.stateNode = new Kj2());
      b10.forEach(function(b11) {
        var d10 = bk2.bind(null, a10, b11);
        c10.has(b11) || (c10.add(b11), b11.then(d10, d10));
      });
    }
  }
  function ck2(a10, b10) {
    var c10 = b10.deletions;
    if (null !== c10) for (var d10 = 0; d10 < c10.length; d10++) {
      var e10 = c10[d10];
      try {
        var f10 = a10, g10 = b10, h10 = g10;
        a: for (; null !== h10; ) {
          switch (h10.tag) {
            case 5:
              X10 = h10.stateNode;
              Xj2 = false;
              break a;
            case 3:
              X10 = h10.stateNode.containerInfo;
              Xj2 = true;
              break a;
            case 4:
              X10 = h10.stateNode.containerInfo;
              Xj2 = true;
              break a;
          }
          h10 = h10.return;
        }
        if (null === X10) throw Error(p10(160));
        Zj2(f10, g10, e10);
        X10 = null;
        Xj2 = false;
        var k10 = e10.alternate;
        null !== k10 && (k10.return = null);
        e10.return = null;
      } catch (l10) {
        W10(e10, b10, l10);
      }
    }
    if (b10.subtreeFlags & 12854) for (b10 = b10.child; null !== b10; ) dk2(b10, a10), b10 = b10.sibling;
  }
  function dk2(a10, b10) {
    var c10 = a10.alternate, d10 = a10.flags;
    switch (a10.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck2(b10, a10);
        ek2(a10);
        if (d10 & 4) {
          try {
            Pj2(3, a10, a10.return), Qj2(3, a10);
          } catch (t10) {
            W10(a10, a10.return, t10);
          }
          try {
            Pj2(5, a10, a10.return);
          } catch (t10) {
            W10(a10, a10.return, t10);
          }
        }
        break;
      case 1:
        ck2(b10, a10);
        ek2(a10);
        d10 & 512 && null !== c10 && Lj2(c10, c10.return);
        break;
      case 5:
        ck2(b10, a10);
        ek2(a10);
        d10 & 512 && null !== c10 && Lj2(c10, c10.return);
        if (a10.flags & 32) {
          var e10 = a10.stateNode;
          try {
            ob2(e10, "");
          } catch (t10) {
            W10(a10, a10.return, t10);
          }
        }
        if (d10 & 4 && (e10 = a10.stateNode, null != e10)) {
          var f10 = a10.memoizedProps, g10 = null !== c10 ? c10.memoizedProps : f10, h10 = a10.type, k10 = a10.updateQueue;
          a10.updateQueue = null;
          if (null !== k10) try {
            "input" === h10 && "radio" === f10.type && null != f10.name && ab2(e10, f10);
            vb2(h10, g10);
            var l10 = vb2(h10, f10);
            for (g10 = 0; g10 < k10.length; g10 += 2) {
              var m10 = k10[g10], q10 = k10[g10 + 1];
              "style" === m10 ? sb2(e10, q10) : "dangerouslySetInnerHTML" === m10 ? nb2(e10, q10) : "children" === m10 ? ob2(e10, q10) : ta2(e10, m10, q10, l10);
            }
            switch (h10) {
              case "input":
                bb2(e10, f10);
                break;
              case "textarea":
                ib2(e10, f10);
                break;
              case "select":
                var r10 = e10._wrapperState.wasMultiple;
                e10._wrapperState.wasMultiple = !!f10.multiple;
                var y10 = f10.value;
                null != y10 ? fb2(e10, !!f10.multiple, y10, false) : r10 !== !!f10.multiple && (null != f10.defaultValue ? fb2(
                  e10,
                  !!f10.multiple,
                  f10.defaultValue,
                  true
                ) : fb2(e10, !!f10.multiple, f10.multiple ? [] : "", false));
            }
            e10[Pf2] = f10;
          } catch (t10) {
            W10(a10, a10.return, t10);
          }
        }
        break;
      case 6:
        ck2(b10, a10);
        ek2(a10);
        if (d10 & 4) {
          if (null === a10.stateNode) throw Error(p10(162));
          e10 = a10.stateNode;
          f10 = a10.memoizedProps;
          try {
            e10.nodeValue = f10;
          } catch (t10) {
            W10(a10, a10.return, t10);
          }
        }
        break;
      case 3:
        ck2(b10, a10);
        ek2(a10);
        if (d10 & 4 && null !== c10 && c10.memoizedState.isDehydrated) try {
          bd2(b10.containerInfo);
        } catch (t10) {
          W10(a10, a10.return, t10);
        }
        break;
      case 4:
        ck2(b10, a10);
        ek2(a10);
        break;
      case 13:
        ck2(b10, a10);
        ek2(a10);
        e10 = a10.child;
        e10.flags & 8192 && (f10 = null !== e10.memoizedState, e10.stateNode.isHidden = f10, !f10 || null !== e10.alternate && null !== e10.alternate.memoizedState || (fk2 = B10()));
        d10 & 4 && ak2(a10);
        break;
      case 22:
        m10 = null !== c10 && null !== c10.memoizedState;
        a10.mode & 1 ? (U10 = (l10 = U10) || m10, ck2(b10, a10), U10 = l10) : ck2(b10, a10);
        ek2(a10);
        if (d10 & 8192) {
          l10 = null !== a10.memoizedState;
          if ((a10.stateNode.isHidden = l10) && !m10 && 0 !== (a10.mode & 1)) for (V10 = a10, m10 = a10.child; null !== m10; ) {
            for (q10 = V10 = m10; null !== V10; ) {
              r10 = V10;
              y10 = r10.child;
              switch (r10.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj2(4, r10, r10.return);
                  break;
                case 1:
                  Lj2(r10, r10.return);
                  var n10 = r10.stateNode;
                  if ("function" === typeof n10.componentWillUnmount) {
                    d10 = r10;
                    c10 = r10.return;
                    try {
                      b10 = d10, n10.props = b10.memoizedProps, n10.state = b10.memoizedState, n10.componentWillUnmount();
                    } catch (t10) {
                      W10(d10, c10, t10);
                    }
                  }
                  break;
                case 5:
                  Lj2(r10, r10.return);
                  break;
                case 22:
                  if (null !== r10.memoizedState) {
                    gk2(q10);
                    continue;
                  }
              }
              null !== y10 ? (y10.return = r10, V10 = y10) : gk2(q10);
            }
            m10 = m10.sibling;
          }
          a: for (m10 = null, q10 = a10; ; ) {
            if (5 === q10.tag) {
              if (null === m10) {
                m10 = q10;
                try {
                  e10 = q10.stateNode, l10 ? (f10 = e10.style, "function" === typeof f10.setProperty ? f10.setProperty("display", "none", "important") : f10.display = "none") : (h10 = q10.stateNode, k10 = q10.memoizedProps.style, g10 = void 0 !== k10 && null !== k10 && k10.hasOwnProperty("display") ? k10.display : null, h10.style.display = rb2("display", g10));
                } catch (t10) {
                  W10(a10, a10.return, t10);
                }
              }
            } else if (6 === q10.tag) {
              if (null === m10) try {
                q10.stateNode.nodeValue = l10 ? "" : q10.memoizedProps;
              } catch (t10) {
                W10(a10, a10.return, t10);
              }
            } else if ((22 !== q10.tag && 23 !== q10.tag || null === q10.memoizedState || q10 === a10) && null !== q10.child) {
              q10.child.return = q10;
              q10 = q10.child;
              continue;
            }
            if (q10 === a10) break a;
            for (; null === q10.sibling; ) {
              if (null === q10.return || q10.return === a10) break a;
              m10 === q10 && (m10 = null);
              q10 = q10.return;
            }
            m10 === q10 && (m10 = null);
            q10.sibling.return = q10.return;
            q10 = q10.sibling;
          }
        }
        break;
      case 19:
        ck2(b10, a10);
        ek2(a10);
        d10 & 4 && ak2(a10);
        break;
      case 21:
        break;
      default:
        ck2(
          b10,
          a10
        ), ek2(a10);
    }
  }
  function ek2(a10) {
    var b10 = a10.flags;
    if (b10 & 2) {
      try {
        a: {
          for (var c10 = a10.return; null !== c10; ) {
            if (Tj2(c10)) {
              var d10 = c10;
              break a;
            }
            c10 = c10.return;
          }
          throw Error(p10(160));
        }
        switch (d10.tag) {
          case 5:
            var e10 = d10.stateNode;
            d10.flags & 32 && (ob2(e10, ""), d10.flags &= -33);
            var f10 = Uj2(a10);
            Wj2(a10, f10, e10);
            break;
          case 3:
          case 4:
            var g10 = d10.stateNode.containerInfo, h10 = Uj2(a10);
            Vj2(a10, h10, g10);
            break;
          default:
            throw Error(p10(161));
        }
      } catch (k10) {
        W10(a10, a10.return, k10);
      }
      a10.flags &= -3;
    }
    b10 & 4096 && (a10.flags &= -4097);
  }
  function hk2(a10, b10, c10) {
    V10 = a10;
    ik2(a10);
  }
  function ik2(a10, b10, c10) {
    for (var d10 = 0 !== (a10.mode & 1); null !== V10; ) {
      var e10 = V10, f10 = e10.child;
      if (22 === e10.tag && d10) {
        var g10 = null !== e10.memoizedState || Jj2;
        if (!g10) {
          var h10 = e10.alternate, k10 = null !== h10 && null !== h10.memoizedState || U10;
          h10 = Jj2;
          var l10 = U10;
          Jj2 = g10;
          if ((U10 = k10) && !l10) for (V10 = e10; null !== V10; ) g10 = V10, k10 = g10.child, 22 === g10.tag && null !== g10.memoizedState ? jk2(e10) : null !== k10 ? (k10.return = g10, V10 = k10) : jk2(e10);
          for (; null !== f10; ) V10 = f10, ik2(f10), f10 = f10.sibling;
          V10 = e10;
          Jj2 = h10;
          U10 = l10;
        }
        kk2(a10);
      } else 0 !== (e10.subtreeFlags & 8772) && null !== f10 ? (f10.return = e10, V10 = f10) : kk2(a10);
    }
  }
  function kk2(a10) {
    for (; null !== V10; ) {
      var b10 = V10;
      if (0 !== (b10.flags & 8772)) {
        var c10 = b10.alternate;
        try {
          if (0 !== (b10.flags & 8772)) switch (b10.tag) {
            case 0:
            case 11:
            case 15:
              U10 || Qj2(5, b10);
              break;
            case 1:
              var d10 = b10.stateNode;
              if (b10.flags & 4 && !U10) if (null === c10) d10.componentDidMount();
              else {
                var e10 = b10.elementType === b10.type ? c10.memoizedProps : Ci(b10.type, c10.memoizedProps);
                d10.componentDidUpdate(e10, c10.memoizedState, d10.__reactInternalSnapshotBeforeUpdate);
              }
              var f10 = b10.updateQueue;
              null !== f10 && sh2(b10, f10, d10);
              break;
            case 3:
              var g10 = b10.updateQueue;
              if (null !== g10) {
                c10 = null;
                if (null !== b10.child) switch (b10.child.tag) {
                  case 5:
                    c10 = b10.child.stateNode;
                    break;
                  case 1:
                    c10 = b10.child.stateNode;
                }
                sh2(b10, g10, c10);
              }
              break;
            case 5:
              var h10 = b10.stateNode;
              if (null === c10 && b10.flags & 4) {
                c10 = h10;
                var k10 = b10.memoizedProps;
                switch (b10.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k10.autoFocus && c10.focus();
                    break;
                  case "img":
                    k10.src && (c10.src = k10.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b10.memoizedState) {
                var l10 = b10.alternate;
                if (null !== l10) {
                  var m10 = l10.memoizedState;
                  if (null !== m10) {
                    var q10 = m10.dehydrated;
                    null !== q10 && bd2(q10);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p10(163));
          }
          U10 || b10.flags & 512 && Rj2(b10);
        } catch (r10) {
          W10(b10, b10.return, r10);
        }
      }
      if (b10 === a10) {
        V10 = null;
        break;
      }
      c10 = b10.sibling;
      if (null !== c10) {
        c10.return = b10.return;
        V10 = c10;
        break;
      }
      V10 = b10.return;
    }
  }
  function gk2(a10) {
    for (; null !== V10; ) {
      var b10 = V10;
      if (b10 === a10) {
        V10 = null;
        break;
      }
      var c10 = b10.sibling;
      if (null !== c10) {
        c10.return = b10.return;
        V10 = c10;
        break;
      }
      V10 = b10.return;
    }
  }
  function jk2(a10) {
    for (; null !== V10; ) {
      var b10 = V10;
      try {
        switch (b10.tag) {
          case 0:
          case 11:
          case 15:
            var c10 = b10.return;
            try {
              Qj2(4, b10);
            } catch (k10) {
              W10(b10, c10, k10);
            }
            break;
          case 1:
            var d10 = b10.stateNode;
            if ("function" === typeof d10.componentDidMount) {
              var e10 = b10.return;
              try {
                d10.componentDidMount();
              } catch (k10) {
                W10(b10, e10, k10);
              }
            }
            var f10 = b10.return;
            try {
              Rj2(b10);
            } catch (k10) {
              W10(b10, f10, k10);
            }
            break;
          case 5:
            var g10 = b10.return;
            try {
              Rj2(b10);
            } catch (k10) {
              W10(b10, g10, k10);
            }
        }
      } catch (k10) {
        W10(b10, b10.return, k10);
      }
      if (b10 === a10) {
        V10 = null;
        break;
      }
      var h10 = b10.sibling;
      if (null !== h10) {
        h10.return = b10.return;
        V10 = h10;
        break;
      }
      V10 = b10.return;
    }
  }
  var lk2 = Math.ceil, mk2 = ua2.ReactCurrentDispatcher, nk2 = ua2.ReactCurrentOwner, ok2 = ua2.ReactCurrentBatchConfig, K10 = 0, Q10 = null, Y10 = null, Z10 = 0, fj2 = 0, ej2 = Uf2(0), T10 = 0, pk2 = null, rh2 = 0, qk2 = 0, rk2 = 0, sk2 = null, tk2 = null, fk2 = 0, Gj2 = Infinity, uk2 = null, Oi2 = false, Pi2 = null, Ri2 = null, vk2 = false, wk2 = null, xk2 = 0, yk2 = 0, zk2 = null, Ak2 = -1, Bk2 = 0;
  function R10() {
    return 0 !== (K10 & 6) ? B10() : -1 !== Ak2 ? Ak2 : Ak2 = B10();
  }
  function yi2(a10) {
    if (0 === (a10.mode & 1)) return 1;
    if (0 !== (K10 & 2) && 0 !== Z10) return Z10 & -Z10;
    if (null !== Kg2.transition) return 0 === Bk2 && (Bk2 = yc2()), Bk2;
    a10 = C10;
    if (0 !== a10) return a10;
    a10 = window.event;
    a10 = void 0 === a10 ? 16 : jd2(a10.type);
    return a10;
  }
  function gi2(a10, b10, c10, d10) {
    if (50 < yk2) throw yk2 = 0, zk2 = null, Error(p10(185));
    Ac(a10, c10, d10);
    if (0 === (K10 & 2) || a10 !== Q10) a10 === Q10 && (0 === (K10 & 2) && (qk2 |= c10), 4 === T10 && Ck2(a10, Z10)), Dk2(a10, d10), 1 === c10 && 0 === K10 && 0 === (b10.mode & 1) && (Gj2 = B10() + 500, fg2 && jg2());
  }
  function Dk2(a10, b10) {
    var c10 = a10.callbackNode;
    wc(a10, b10);
    var d10 = uc(a10, a10 === Q10 ? Z10 : 0);
    if (0 === d10) null !== c10 && bc2(c10), a10.callbackNode = null, a10.callbackPriority = 0;
    else if (b10 = d10 & -d10, a10.callbackPriority !== b10) {
      null != c10 && bc2(c10);
      if (1 === b10) 0 === a10.tag ? ig2(Ek2.bind(null, a10)) : hg2(Ek2.bind(null, a10)), Jf2(function() {
        0 === (K10 & 6) && jg2();
      }), c10 = null;
      else {
        switch (Dc(d10)) {
          case 1:
            c10 = fc2;
            break;
          case 4:
            c10 = gc;
            break;
          case 16:
            c10 = hc;
            break;
          case 536870912:
            c10 = jc2;
            break;
          default:
            c10 = hc;
        }
        c10 = Fk2(c10, Gk2.bind(null, a10));
      }
      a10.callbackPriority = b10;
      a10.callbackNode = c10;
    }
  }
  function Gk2(a10, b10) {
    Ak2 = -1;
    Bk2 = 0;
    if (0 !== (K10 & 6)) throw Error(p10(327));
    var c10 = a10.callbackNode;
    if (Hk2() && a10.callbackNode !== c10) return null;
    var d10 = uc(a10, a10 === Q10 ? Z10 : 0);
    if (0 === d10) return null;
    if (0 !== (d10 & 30) || 0 !== (d10 & a10.expiredLanes) || b10) b10 = Ik2(a10, d10);
    else {
      b10 = d10;
      var e10 = K10;
      K10 |= 2;
      var f10 = Jk2();
      if (Q10 !== a10 || Z10 !== b10) uk2 = null, Gj2 = B10() + 500, Kk2(a10, b10);
      do
        try {
          Lk2();
          break;
        } catch (h10) {
          Mk2(a10, h10);
        }
      while (1);
      $g2();
      mk2.current = f10;
      K10 = e10;
      null !== Y10 ? b10 = 0 : (Q10 = null, Z10 = 0, b10 = T10);
    }
    if (0 !== b10) {
      2 === b10 && (e10 = xc(a10), 0 !== e10 && (d10 = e10, b10 = Nk2(a10, e10)));
      if (1 === b10) throw c10 = pk2, Kk2(a10, 0), Ck2(a10, d10), Dk2(a10, B10()), c10;
      if (6 === b10) Ck2(a10, d10);
      else {
        e10 = a10.current.alternate;
        if (0 === (d10 & 30) && !Ok2(e10) && (b10 = Ik2(a10, d10), 2 === b10 && (f10 = xc(a10), 0 !== f10 && (d10 = f10, b10 = Nk2(a10, f10))), 1 === b10)) throw c10 = pk2, Kk2(a10, 0), Ck2(a10, d10), Dk2(a10, B10()), c10;
        a10.finishedWork = e10;
        a10.finishedLanes = d10;
        switch (b10) {
          case 0:
          case 1:
            throw Error(p10(345));
          case 2:
            Pk2(a10, tk2, uk2);
            break;
          case 3:
            Ck2(a10, d10);
            if ((d10 & 130023424) === d10 && (b10 = fk2 + 500 - B10(), 10 < b10)) {
              if (0 !== uc(a10, 0)) break;
              e10 = a10.suspendedLanes;
              if ((e10 & d10) !== d10) {
                R10();
                a10.pingedLanes |= a10.suspendedLanes & e10;
                break;
              }
              a10.timeoutHandle = Ff2(Pk2.bind(null, a10, tk2, uk2), b10);
              break;
            }
            Pk2(a10, tk2, uk2);
            break;
          case 4:
            Ck2(a10, d10);
            if ((d10 & 4194240) === d10) break;
            b10 = a10.eventTimes;
            for (e10 = -1; 0 < d10; ) {
              var g10 = 31 - oc2(d10);
              f10 = 1 << g10;
              g10 = b10[g10];
              g10 > e10 && (e10 = g10);
              d10 &= ~f10;
            }
            d10 = e10;
            d10 = B10() - d10;
            d10 = (120 > d10 ? 120 : 480 > d10 ? 480 : 1080 > d10 ? 1080 : 1920 > d10 ? 1920 : 3e3 > d10 ? 3e3 : 4320 > d10 ? 4320 : 1960 * lk2(d10 / 1960)) - d10;
            if (10 < d10) {
              a10.timeoutHandle = Ff2(Pk2.bind(null, a10, tk2, uk2), d10);
              break;
            }
            Pk2(a10, tk2, uk2);
            break;
          case 5:
            Pk2(a10, tk2, uk2);
            break;
          default:
            throw Error(p10(329));
        }
      }
    }
    Dk2(a10, B10());
    return a10.callbackNode === c10 ? Gk2.bind(null, a10) : null;
  }
  function Nk2(a10, b10) {
    var c10 = sk2;
    a10.current.memoizedState.isDehydrated && (Kk2(a10, b10).flags |= 256);
    a10 = Ik2(a10, b10);
    2 !== a10 && (b10 = tk2, tk2 = c10, null !== b10 && Fj2(b10));
    return a10;
  }
  function Fj2(a10) {
    null === tk2 ? tk2 = a10 : tk2.push.apply(tk2, a10);
  }
  function Ok2(a10) {
    for (var b10 = a10; ; ) {
      if (b10.flags & 16384) {
        var c10 = b10.updateQueue;
        if (null !== c10 && (c10 = c10.stores, null !== c10)) for (var d10 = 0; d10 < c10.length; d10++) {
          var e10 = c10[d10], f10 = e10.getSnapshot;
          e10 = e10.value;
          try {
            if (!He2(f10(), e10)) return false;
          } catch (g10) {
            return false;
          }
        }
      }
      c10 = b10.child;
      if (b10.subtreeFlags & 16384 && null !== c10) c10.return = b10, b10 = c10;
      else {
        if (b10 === a10) break;
        for (; null === b10.sibling; ) {
          if (null === b10.return || b10.return === a10) return true;
          b10 = b10.return;
        }
        b10.sibling.return = b10.return;
        b10 = b10.sibling;
      }
    }
    return true;
  }
  function Ck2(a10, b10) {
    b10 &= ~rk2;
    b10 &= ~qk2;
    a10.suspendedLanes |= b10;
    a10.pingedLanes &= ~b10;
    for (a10 = a10.expirationTimes; 0 < b10; ) {
      var c10 = 31 - oc2(b10), d10 = 1 << c10;
      a10[c10] = -1;
      b10 &= ~d10;
    }
  }
  function Ek2(a10) {
    if (0 !== (K10 & 6)) throw Error(p10(327));
    Hk2();
    var b10 = uc(a10, 0);
    if (0 === (b10 & 1)) return Dk2(a10, B10()), null;
    var c10 = Ik2(a10, b10);
    if (0 !== a10.tag && 2 === c10) {
      var d10 = xc(a10);
      0 !== d10 && (b10 = d10, c10 = Nk2(a10, d10));
    }
    if (1 === c10) throw c10 = pk2, Kk2(a10, 0), Ck2(a10, b10), Dk2(a10, B10()), c10;
    if (6 === c10) throw Error(p10(345));
    a10.finishedWork = a10.current.alternate;
    a10.finishedLanes = b10;
    Pk2(a10, tk2, uk2);
    Dk2(a10, B10());
    return null;
  }
  function Qk2(a10, b10) {
    var c10 = K10;
    K10 |= 1;
    try {
      return a10(b10);
    } finally {
      K10 = c10, 0 === K10 && (Gj2 = B10() + 500, fg2 && jg2());
    }
  }
  function Rk2(a10) {
    null !== wk2 && 0 === wk2.tag && 0 === (K10 & 6) && Hk2();
    var b10 = K10;
    K10 |= 1;
    var c10 = ok2.transition, d10 = C10;
    try {
      if (ok2.transition = null, C10 = 1, a10) return a10();
    } finally {
      C10 = d10, ok2.transition = c10, K10 = b10, 0 === (K10 & 6) && jg2();
    }
  }
  function Hj2() {
    fj2 = ej2.current;
    E10(ej2);
  }
  function Kk2(a10, b10) {
    a10.finishedWork = null;
    a10.finishedLanes = 0;
    var c10 = a10.timeoutHandle;
    -1 !== c10 && (a10.timeoutHandle = -1, Gf2(c10));
    if (null !== Y10) for (c10 = Y10.return; null !== c10; ) {
      var d10 = c10;
      wg2(d10);
      switch (d10.tag) {
        case 1:
          d10 = d10.type.childContextTypes;
          null !== d10 && void 0 !== d10 && $f2();
          break;
        case 3:
          zh2();
          E10(Wf2);
          E10(H10);
          Eh2();
          break;
        case 5:
          Bh2(d10);
          break;
        case 4:
          zh2();
          break;
        case 13:
          E10(L10);
          break;
        case 19:
          E10(L10);
          break;
        case 10:
          ah2(d10.type._context);
          break;
        case 22:
        case 23:
          Hj2();
      }
      c10 = c10.return;
    }
    Q10 = a10;
    Y10 = a10 = Pg2(a10.current, null);
    Z10 = fj2 = b10;
    T10 = 0;
    pk2 = null;
    rk2 = qk2 = rh2 = 0;
    tk2 = sk2 = null;
    if (null !== fh2) {
      for (b10 = 0; b10 < fh2.length; b10++) if (c10 = fh2[b10], d10 = c10.interleaved, null !== d10) {
        c10.interleaved = null;
        var e10 = d10.next, f10 = c10.pending;
        if (null !== f10) {
          var g10 = f10.next;
          f10.next = e10;
          d10.next = g10;
        }
        c10.pending = d10;
      }
      fh2 = null;
    }
    return a10;
  }
  function Mk2(a10, b10) {
    do {
      var c10 = Y10;
      try {
        $g2();
        Fh2.current = Rh2;
        if (Ih2) {
          for (var d10 = M10.memoizedState; null !== d10; ) {
            var e10 = d10.queue;
            null !== e10 && (e10.pending = null);
            d10 = d10.next;
          }
          Ih2 = false;
        }
        Hh2 = 0;
        O10 = N10 = M10 = null;
        Jh2 = false;
        Kh2 = 0;
        nk2.current = null;
        if (null === c10 || null === c10.return) {
          T10 = 1;
          pk2 = b10;
          Y10 = null;
          break;
        }
        a: {
          var f10 = a10, g10 = c10.return, h10 = c10, k10 = b10;
          b10 = Z10;
          h10.flags |= 32768;
          if (null !== k10 && "object" === typeof k10 && "function" === typeof k10.then) {
            var l10 = k10, m10 = h10, q10 = m10.tag;
            if (0 === (m10.mode & 1) && (0 === q10 || 11 === q10 || 15 === q10)) {
              var r10 = m10.alternate;
              r10 ? (m10.updateQueue = r10.updateQueue, m10.memoizedState = r10.memoizedState, m10.lanes = r10.lanes) : (m10.updateQueue = null, m10.memoizedState = null);
            }
            var y10 = Ui2(g10);
            if (null !== y10) {
              y10.flags &= -257;
              Vi2(y10, g10, h10, f10, b10);
              y10.mode & 1 && Si(f10, l10, b10);
              b10 = y10;
              k10 = l10;
              var n10 = b10.updateQueue;
              if (null === n10) {
                var t10 = /* @__PURE__ */ new Set();
                t10.add(k10);
                b10.updateQueue = t10;
              } else n10.add(k10);
              break a;
            } else {
              if (0 === (b10 & 1)) {
                Si(f10, l10, b10);
                tj2();
                break a;
              }
              k10 = Error(p10(426));
            }
          } else if (I10 && h10.mode & 1) {
            var J10 = Ui2(g10);
            if (null !== J10) {
              0 === (J10.flags & 65536) && (J10.flags |= 256);
              Vi2(J10, g10, h10, f10, b10);
              Jg2(Ji2(k10, h10));
              break a;
            }
          }
          f10 = k10 = Ji2(k10, h10);
          4 !== T10 && (T10 = 2);
          null === sk2 ? sk2 = [f10] : sk2.push(f10);
          f10 = g10;
          do {
            switch (f10.tag) {
              case 3:
                f10.flags |= 65536;
                b10 &= -b10;
                f10.lanes |= b10;
                var x10 = Ni2(f10, k10, b10);
                ph2(f10, x10);
                break a;
              case 1:
                h10 = k10;
                var w10 = f10.type, u10 = f10.stateNode;
                if (0 === (f10.flags & 128) && ("function" === typeof w10.getDerivedStateFromError || null !== u10 && "function" === typeof u10.componentDidCatch && (null === Ri2 || !Ri2.has(u10)))) {
                  f10.flags |= 65536;
                  b10 &= -b10;
                  f10.lanes |= b10;
                  var F10 = Qi2(f10, h10, b10);
                  ph2(f10, F10);
                  break a;
                }
            }
            f10 = f10.return;
          } while (null !== f10);
        }
        Sk2(c10);
      } catch (na2) {
        b10 = na2;
        Y10 === c10 && null !== c10 && (Y10 = c10 = c10.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk2() {
    var a10 = mk2.current;
    mk2.current = Rh2;
    return null === a10 ? Rh2 : a10;
  }
  function tj2() {
    if (0 === T10 || 3 === T10 || 2 === T10) T10 = 4;
    null === Q10 || 0 === (rh2 & 268435455) && 0 === (qk2 & 268435455) || Ck2(Q10, Z10);
  }
  function Ik2(a10, b10) {
    var c10 = K10;
    K10 |= 2;
    var d10 = Jk2();
    if (Q10 !== a10 || Z10 !== b10) uk2 = null, Kk2(a10, b10);
    do
      try {
        Tk2();
        break;
      } catch (e10) {
        Mk2(a10, e10);
      }
    while (1);
    $g2();
    K10 = c10;
    mk2.current = d10;
    if (null !== Y10) throw Error(p10(261));
    Q10 = null;
    Z10 = 0;
    return T10;
  }
  function Tk2() {
    for (; null !== Y10; ) Uk2(Y10);
  }
  function Lk2() {
    for (; null !== Y10 && !cc(); ) Uk2(Y10);
  }
  function Uk2(a10) {
    var b10 = Vk2(a10.alternate, a10, fj2);
    a10.memoizedProps = a10.pendingProps;
    null === b10 ? Sk2(a10) : Y10 = b10;
    nk2.current = null;
  }
  function Sk2(a10) {
    var b10 = a10;
    do {
      var c10 = b10.alternate;
      a10 = b10.return;
      if (0 === (b10.flags & 32768)) {
        if (c10 = Ej2(c10, b10, fj2), null !== c10) {
          Y10 = c10;
          return;
        }
      } else {
        c10 = Ij2(c10, b10);
        if (null !== c10) {
          c10.flags &= 32767;
          Y10 = c10;
          return;
        }
        if (null !== a10) a10.flags |= 32768, a10.subtreeFlags = 0, a10.deletions = null;
        else {
          T10 = 6;
          Y10 = null;
          return;
        }
      }
      b10 = b10.sibling;
      if (null !== b10) {
        Y10 = b10;
        return;
      }
      Y10 = b10 = a10;
    } while (null !== b10);
    0 === T10 && (T10 = 5);
  }
  function Pk2(a10, b10, c10) {
    var d10 = C10, e10 = ok2.transition;
    try {
      ok2.transition = null, C10 = 1, Wk2(a10, b10, c10, d10);
    } finally {
      ok2.transition = e10, C10 = d10;
    }
    return null;
  }
  function Wk2(a10, b10, c10, d10) {
    do
      Hk2();
    while (null !== wk2);
    if (0 !== (K10 & 6)) throw Error(p10(327));
    c10 = a10.finishedWork;
    var e10 = a10.finishedLanes;
    if (null === c10) return null;
    a10.finishedWork = null;
    a10.finishedLanes = 0;
    if (c10 === a10.current) throw Error(p10(177));
    a10.callbackNode = null;
    a10.callbackPriority = 0;
    var f10 = c10.lanes | c10.childLanes;
    Bc2(a10, f10);
    a10 === Q10 && (Y10 = Q10 = null, Z10 = 0);
    0 === (c10.subtreeFlags & 2064) && 0 === (c10.flags & 2064) || vk2 || (vk2 = true, Fk2(hc, function() {
      Hk2();
      return null;
    }));
    f10 = 0 !== (c10.flags & 15990);
    if (0 !== (c10.subtreeFlags & 15990) || f10) {
      f10 = ok2.transition;
      ok2.transition = null;
      var g10 = C10;
      C10 = 1;
      var h10 = K10;
      K10 |= 4;
      nk2.current = null;
      Oj2(a10, c10);
      dk2(c10, a10);
      Oe2(Df2);
      dd = !!Cf2;
      Df2 = Cf2 = null;
      a10.current = c10;
      hk2(c10);
      dc2();
      K10 = h10;
      C10 = g10;
      ok2.transition = f10;
    } else a10.current = c10;
    vk2 && (vk2 = false, wk2 = a10, xk2 = e10);
    f10 = a10.pendingLanes;
    0 === f10 && (Ri2 = null);
    mc(c10.stateNode);
    Dk2(a10, B10());
    if (null !== b10) for (d10 = a10.onRecoverableError, c10 = 0; c10 < b10.length; c10++) e10 = b10[c10], d10(e10.value, { componentStack: e10.stack, digest: e10.digest });
    if (Oi2) throw Oi2 = false, a10 = Pi2, Pi2 = null, a10;
    0 !== (xk2 & 1) && 0 !== a10.tag && Hk2();
    f10 = a10.pendingLanes;
    0 !== (f10 & 1) ? a10 === zk2 ? yk2++ : (yk2 = 0, zk2 = a10) : yk2 = 0;
    jg2();
    return null;
  }
  function Hk2() {
    if (null !== wk2) {
      var a10 = Dc(xk2), b10 = ok2.transition, c10 = C10;
      try {
        ok2.transition = null;
        C10 = 16 > a10 ? 16 : a10;
        if (null === wk2) var d10 = false;
        else {
          a10 = wk2;
          wk2 = null;
          xk2 = 0;
          if (0 !== (K10 & 6)) throw Error(p10(331));
          var e10 = K10;
          K10 |= 4;
          for (V10 = a10.current; null !== V10; ) {
            var f10 = V10, g10 = f10.child;
            if (0 !== (V10.flags & 16)) {
              var h10 = f10.deletions;
              if (null !== h10) {
                for (var k10 = 0; k10 < h10.length; k10++) {
                  var l10 = h10[k10];
                  for (V10 = l10; null !== V10; ) {
                    var m10 = V10;
                    switch (m10.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj2(8, m10, f10);
                    }
                    var q10 = m10.child;
                    if (null !== q10) q10.return = m10, V10 = q10;
                    else for (; null !== V10; ) {
                      m10 = V10;
                      var r10 = m10.sibling, y10 = m10.return;
                      Sj2(m10);
                      if (m10 === l10) {
                        V10 = null;
                        break;
                      }
                      if (null !== r10) {
                        r10.return = y10;
                        V10 = r10;
                        break;
                      }
                      V10 = y10;
                    }
                  }
                }
                var n10 = f10.alternate;
                if (null !== n10) {
                  var t10 = n10.child;
                  if (null !== t10) {
                    n10.child = null;
                    do {
                      var J10 = t10.sibling;
                      t10.sibling = null;
                      t10 = J10;
                    } while (null !== t10);
                  }
                }
                V10 = f10;
              }
            }
            if (0 !== (f10.subtreeFlags & 2064) && null !== g10) g10.return = f10, V10 = g10;
            else b: for (; null !== V10; ) {
              f10 = V10;
              if (0 !== (f10.flags & 2048)) switch (f10.tag) {
                case 0:
                case 11:
                case 15:
                  Pj2(9, f10, f10.return);
              }
              var x10 = f10.sibling;
              if (null !== x10) {
                x10.return = f10.return;
                V10 = x10;
                break b;
              }
              V10 = f10.return;
            }
          }
          var w10 = a10.current;
          for (V10 = w10; null !== V10; ) {
            g10 = V10;
            var u10 = g10.child;
            if (0 !== (g10.subtreeFlags & 2064) && null !== u10) u10.return = g10, V10 = u10;
            else b: for (g10 = w10; null !== V10; ) {
              h10 = V10;
              if (0 !== (h10.flags & 2048)) try {
                switch (h10.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj2(9, h10);
                }
              } catch (na2) {
                W10(h10, h10.return, na2);
              }
              if (h10 === g10) {
                V10 = null;
                break b;
              }
              var F10 = h10.sibling;
              if (null !== F10) {
                F10.return = h10.return;
                V10 = F10;
                break b;
              }
              V10 = h10.return;
            }
          }
          K10 = e10;
          jg2();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc2, a10);
          } catch (na2) {
          }
          d10 = true;
        }
        return d10;
      } finally {
        C10 = c10, ok2.transition = b10;
      }
    }
    return false;
  }
  function Xk2(a10, b10, c10) {
    b10 = Ji2(c10, b10);
    b10 = Ni2(a10, b10, 1);
    a10 = nh2(a10, b10, 1);
    b10 = R10();
    null !== a10 && (Ac(a10, 1, b10), Dk2(a10, b10));
  }
  function W10(a10, b10, c10) {
    if (3 === a10.tag) Xk2(a10, a10, c10);
    else for (; null !== b10; ) {
      if (3 === b10.tag) {
        Xk2(b10, a10, c10);
        break;
      } else if (1 === b10.tag) {
        var d10 = b10.stateNode;
        if ("function" === typeof b10.type.getDerivedStateFromError || "function" === typeof d10.componentDidCatch && (null === Ri2 || !Ri2.has(d10))) {
          a10 = Ji2(c10, a10);
          a10 = Qi2(b10, a10, 1);
          b10 = nh2(b10, a10, 1);
          a10 = R10();
          null !== b10 && (Ac(b10, 1, a10), Dk2(b10, a10));
          break;
        }
      }
      b10 = b10.return;
    }
  }
  function Ti(a10, b10, c10) {
    var d10 = a10.pingCache;
    null !== d10 && d10.delete(b10);
    b10 = R10();
    a10.pingedLanes |= a10.suspendedLanes & c10;
    Q10 === a10 && (Z10 & c10) === c10 && (4 === T10 || 3 === T10 && (Z10 & 130023424) === Z10 && 500 > B10() - fk2 ? Kk2(a10, 0) : rk2 |= c10);
    Dk2(a10, b10);
  }
  function Yk2(a10, b10) {
    0 === b10 && (0 === (a10.mode & 1) ? b10 = 1 : (b10 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c10 = R10();
    a10 = ih2(a10, b10);
    null !== a10 && (Ac(a10, b10, c10), Dk2(a10, c10));
  }
  function uj2(a10) {
    var b10 = a10.memoizedState, c10 = 0;
    null !== b10 && (c10 = b10.retryLane);
    Yk2(a10, c10);
  }
  function bk2(a10, b10) {
    var c10 = 0;
    switch (a10.tag) {
      case 13:
        var d10 = a10.stateNode;
        var e10 = a10.memoizedState;
        null !== e10 && (c10 = e10.retryLane);
        break;
      case 19:
        d10 = a10.stateNode;
        break;
      default:
        throw Error(p10(314));
    }
    null !== d10 && d10.delete(b10);
    Yk2(a10, c10);
  }
  var Vk2;
  Vk2 = function(a10, b10, c10) {
    if (null !== a10) if (a10.memoizedProps !== b10.pendingProps || Wf2.current) dh2 = true;
    else {
      if (0 === (a10.lanes & c10) && 0 === (b10.flags & 128)) return dh2 = false, yj2(a10, b10, c10);
      dh2 = 0 !== (a10.flags & 131072) ? true : false;
    }
    else dh2 = false, I10 && 0 !== (b10.flags & 1048576) && ug2(b10, ng2, b10.index);
    b10.lanes = 0;
    switch (b10.tag) {
      case 2:
        var d10 = b10.type;
        ij2(a10, b10);
        a10 = b10.pendingProps;
        var e10 = Yf2(b10, H10.current);
        ch2(b10, c10);
        e10 = Nh2(null, b10, d10, a10, e10, c10);
        var f10 = Sh2();
        b10.flags |= 1;
        "object" === typeof e10 && null !== e10 && "function" === typeof e10.render && void 0 === e10.$$typeof ? (b10.tag = 1, b10.memoizedState = null, b10.updateQueue = null, Zf2(d10) ? (f10 = true, cg2(b10)) : f10 = false, b10.memoizedState = null !== e10.state && void 0 !== e10.state ? e10.state : null, kh2(b10), e10.updater = Ei2, b10.stateNode = e10, e10._reactInternals = b10, Ii2(b10, d10, a10, c10), b10 = jj2(null, b10, d10, true, f10, c10)) : (b10.tag = 0, I10 && f10 && vg2(b10), Xi2(null, b10, e10, c10), b10 = b10.child);
        return b10;
      case 16:
        d10 = b10.elementType;
        a: {
          ij2(a10, b10);
          a10 = b10.pendingProps;
          e10 = d10._init;
          d10 = e10(d10._payload);
          b10.type = d10;
          e10 = b10.tag = Zk2(d10);
          a10 = Ci(d10, a10);
          switch (e10) {
            case 0:
              b10 = cj2(null, b10, d10, a10, c10);
              break a;
            case 1:
              b10 = hj2(null, b10, d10, a10, c10);
              break a;
            case 11:
              b10 = Yi2(null, b10, d10, a10, c10);
              break a;
            case 14:
              b10 = $i(null, b10, d10, Ci(d10.type, a10), c10);
              break a;
          }
          throw Error(p10(
            306,
            d10,
            ""
          ));
        }
        return b10;
      case 0:
        return d10 = b10.type, e10 = b10.pendingProps, e10 = b10.elementType === d10 ? e10 : Ci(d10, e10), cj2(a10, b10, d10, e10, c10);
      case 1:
        return d10 = b10.type, e10 = b10.pendingProps, e10 = b10.elementType === d10 ? e10 : Ci(d10, e10), hj2(a10, b10, d10, e10, c10);
      case 3:
        a: {
          kj2(b10);
          if (null === a10) throw Error(p10(387));
          d10 = b10.pendingProps;
          f10 = b10.memoizedState;
          e10 = f10.element;
          lh2(a10, b10);
          qh2(b10, d10, null, c10);
          var g10 = b10.memoizedState;
          d10 = g10.element;
          if (f10.isDehydrated) if (f10 = { element: d10, isDehydrated: false, cache: g10.cache, pendingSuspenseBoundaries: g10.pendingSuspenseBoundaries, transitions: g10.transitions }, b10.updateQueue.baseState = f10, b10.memoizedState = f10, b10.flags & 256) {
            e10 = Ji2(Error(p10(423)), b10);
            b10 = lj2(a10, b10, d10, c10, e10);
            break a;
          } else if (d10 !== e10) {
            e10 = Ji2(Error(p10(424)), b10);
            b10 = lj2(a10, b10, d10, c10, e10);
            break a;
          } else for (yg2 = Lf2(b10.stateNode.containerInfo.firstChild), xg2 = b10, I10 = true, zg2 = null, c10 = Vg2(b10, null, d10, c10), b10.child = c10; c10; ) c10.flags = c10.flags & -3 | 4096, c10 = c10.sibling;
          else {
            Ig2();
            if (d10 === e10) {
              b10 = Zi(a10, b10, c10);
              break a;
            }
            Xi2(a10, b10, d10, c10);
          }
          b10 = b10.child;
        }
        return b10;
      case 5:
        return Ah2(b10), null === a10 && Eg2(b10), d10 = b10.type, e10 = b10.pendingProps, f10 = null !== a10 ? a10.memoizedProps : null, g10 = e10.children, Ef2(d10, e10) ? g10 = null : null !== f10 && Ef2(d10, f10) && (b10.flags |= 32), gj2(a10, b10), Xi2(a10, b10, g10, c10), b10.child;
      case 6:
        return null === a10 && Eg2(b10), null;
      case 13:
        return oj2(a10, b10, c10);
      case 4:
        return yh2(b10, b10.stateNode.containerInfo), d10 = b10.pendingProps, null === a10 ? b10.child = Ug2(b10, null, d10, c10) : Xi2(a10, b10, d10, c10), b10.child;
      case 11:
        return d10 = b10.type, e10 = b10.pendingProps, e10 = b10.elementType === d10 ? e10 : Ci(d10, e10), Yi2(a10, b10, d10, e10, c10);
      case 7:
        return Xi2(a10, b10, b10.pendingProps, c10), b10.child;
      case 8:
        return Xi2(a10, b10, b10.pendingProps.children, c10), b10.child;
      case 12:
        return Xi2(a10, b10, b10.pendingProps.children, c10), b10.child;
      case 10:
        a: {
          d10 = b10.type._context;
          e10 = b10.pendingProps;
          f10 = b10.memoizedProps;
          g10 = e10.value;
          G10(Wg2, d10._currentValue);
          d10._currentValue = g10;
          if (null !== f10) if (He2(f10.value, g10)) {
            if (f10.children === e10.children && !Wf2.current) {
              b10 = Zi(a10, b10, c10);
              break a;
            }
          } else for (f10 = b10.child, null !== f10 && (f10.return = b10); null !== f10; ) {
            var h10 = f10.dependencies;
            if (null !== h10) {
              g10 = f10.child;
              for (var k10 = h10.firstContext; null !== k10; ) {
                if (k10.context === d10) {
                  if (1 === f10.tag) {
                    k10 = mh2(-1, c10 & -c10);
                    k10.tag = 2;
                    var l10 = f10.updateQueue;
                    if (null !== l10) {
                      l10 = l10.shared;
                      var m10 = l10.pending;
                      null === m10 ? k10.next = k10 : (k10.next = m10.next, m10.next = k10);
                      l10.pending = k10;
                    }
                  }
                  f10.lanes |= c10;
                  k10 = f10.alternate;
                  null !== k10 && (k10.lanes |= c10);
                  bh2(
                    f10.return,
                    c10,
                    b10
                  );
                  h10.lanes |= c10;
                  break;
                }
                k10 = k10.next;
              }
            } else if (10 === f10.tag) g10 = f10.type === b10.type ? null : f10.child;
            else if (18 === f10.tag) {
              g10 = f10.return;
              if (null === g10) throw Error(p10(341));
              g10.lanes |= c10;
              h10 = g10.alternate;
              null !== h10 && (h10.lanes |= c10);
              bh2(g10, c10, b10);
              g10 = f10.sibling;
            } else g10 = f10.child;
            if (null !== g10) g10.return = f10;
            else for (g10 = f10; null !== g10; ) {
              if (g10 === b10) {
                g10 = null;
                break;
              }
              f10 = g10.sibling;
              if (null !== f10) {
                f10.return = g10.return;
                g10 = f10;
                break;
              }
              g10 = g10.return;
            }
            f10 = g10;
          }
          Xi2(a10, b10, e10.children, c10);
          b10 = b10.child;
        }
        return b10;
      case 9:
        return e10 = b10.type, d10 = b10.pendingProps.children, ch2(b10, c10), e10 = eh2(e10), d10 = d10(e10), b10.flags |= 1, Xi2(a10, b10, d10, c10), b10.child;
      case 14:
        return d10 = b10.type, e10 = Ci(d10, b10.pendingProps), e10 = Ci(d10.type, e10), $i(a10, b10, d10, e10, c10);
      case 15:
        return bj2(a10, b10, b10.type, b10.pendingProps, c10);
      case 17:
        return d10 = b10.type, e10 = b10.pendingProps, e10 = b10.elementType === d10 ? e10 : Ci(d10, e10), ij2(a10, b10), b10.tag = 1, Zf2(d10) ? (a10 = true, cg2(b10)) : a10 = false, ch2(b10, c10), Gi2(b10, d10, e10), Ii2(b10, d10, e10, c10), jj2(null, b10, d10, true, a10, c10);
      case 19:
        return xj2(a10, b10, c10);
      case 22:
        return dj2(a10, b10, c10);
    }
    throw Error(p10(156, b10.tag));
  };
  function Fk2(a10, b10) {
    return ac(a10, b10);
  }
  function $k2(a10, b10, c10, d10) {
    this.tag = a10;
    this.key = c10;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b10;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d10;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg2(a10, b10, c10, d10) {
    return new $k2(a10, b10, c10, d10);
  }
  function aj2(a10) {
    a10 = a10.prototype;
    return !(!a10 || !a10.isReactComponent);
  }
  function Zk2(a10) {
    if ("function" === typeof a10) return aj2(a10) ? 1 : 0;
    if (void 0 !== a10 && null !== a10) {
      a10 = a10.$$typeof;
      if (a10 === Da2) return 11;
      if (a10 === Ga2) return 14;
    }
    return 2;
  }
  function Pg2(a10, b10) {
    var c10 = a10.alternate;
    null === c10 ? (c10 = Bg2(a10.tag, b10, a10.key, a10.mode), c10.elementType = a10.elementType, c10.type = a10.type, c10.stateNode = a10.stateNode, c10.alternate = a10, a10.alternate = c10) : (c10.pendingProps = b10, c10.type = a10.type, c10.flags = 0, c10.subtreeFlags = 0, c10.deletions = null);
    c10.flags = a10.flags & 14680064;
    c10.childLanes = a10.childLanes;
    c10.lanes = a10.lanes;
    c10.child = a10.child;
    c10.memoizedProps = a10.memoizedProps;
    c10.memoizedState = a10.memoizedState;
    c10.updateQueue = a10.updateQueue;
    b10 = a10.dependencies;
    c10.dependencies = null === b10 ? null : { lanes: b10.lanes, firstContext: b10.firstContext };
    c10.sibling = a10.sibling;
    c10.index = a10.index;
    c10.ref = a10.ref;
    return c10;
  }
  function Rg2(a10, b10, c10, d10, e10, f10) {
    var g10 = 2;
    d10 = a10;
    if ("function" === typeof a10) aj2(a10) && (g10 = 1);
    else if ("string" === typeof a10) g10 = 5;
    else a: switch (a10) {
      case ya2:
        return Tg2(c10.children, e10, f10, b10);
      case za:
        g10 = 8;
        e10 |= 8;
        break;
      case Aa2:
        return a10 = Bg2(12, c10, b10, e10 | 2), a10.elementType = Aa2, a10.lanes = f10, a10;
      case Ea2:
        return a10 = Bg2(13, c10, b10, e10), a10.elementType = Ea2, a10.lanes = f10, a10;
      case Fa2:
        return a10 = Bg2(19, c10, b10, e10), a10.elementType = Fa2, a10.lanes = f10, a10;
      case Ia2:
        return pj2(c10, e10, f10, b10);
      default:
        if ("object" === typeof a10 && null !== a10) switch (a10.$$typeof) {
          case Ba2:
            g10 = 10;
            break a;
          case Ca2:
            g10 = 9;
            break a;
          case Da2:
            g10 = 11;
            break a;
          case Ga2:
            g10 = 14;
            break a;
          case Ha2:
            g10 = 16;
            d10 = null;
            break a;
        }
        throw Error(p10(130, null == a10 ? a10 : typeof a10, ""));
    }
    b10 = Bg2(g10, c10, b10, e10);
    b10.elementType = a10;
    b10.type = d10;
    b10.lanes = f10;
    return b10;
  }
  function Tg2(a10, b10, c10, d10) {
    a10 = Bg2(7, a10, d10, b10);
    a10.lanes = c10;
    return a10;
  }
  function pj2(a10, b10, c10, d10) {
    a10 = Bg2(22, a10, d10, b10);
    a10.elementType = Ia2;
    a10.lanes = c10;
    a10.stateNode = { isHidden: false };
    return a10;
  }
  function Qg2(a10, b10, c10) {
    a10 = Bg2(6, a10, null, b10);
    a10.lanes = c10;
    return a10;
  }
  function Sg2(a10, b10, c10) {
    b10 = Bg2(4, null !== a10.children ? a10.children : [], a10.key, b10);
    b10.lanes = c10;
    b10.stateNode = { containerInfo: a10.containerInfo, pendingChildren: null, implementation: a10.implementation };
    return b10;
  }
  function al2(a10, b10, c10, d10, e10) {
    this.tag = b10;
    this.containerInfo = a10;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc2(0);
    this.expirationTimes = zc2(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc2(0);
    this.identifierPrefix = d10;
    this.onRecoverableError = e10;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl2(a10, b10, c10, d10, e10, f10, g10, h10, k10) {
    a10 = new al2(a10, b10, c10, h10, k10);
    1 === b10 ? (b10 = 1, true === f10 && (b10 |= 8)) : b10 = 0;
    f10 = Bg2(3, null, null, b10);
    a10.current = f10;
    f10.stateNode = a10;
    f10.memoizedState = { element: d10, isDehydrated: c10, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh2(f10);
    return a10;
  }
  function cl2(a10, b10, c10) {
    var d10 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa2, key: null == d10 ? null : "" + d10, children: a10, containerInfo: b10, implementation: c10 };
  }
  function dl(a10) {
    if (!a10) return Vf2;
    a10 = a10._reactInternals;
    a: {
      if (Vb2(a10) !== a10 || 1 !== a10.tag) throw Error(p10(170));
      var b10 = a10;
      do {
        switch (b10.tag) {
          case 3:
            b10 = b10.stateNode.context;
            break a;
          case 1:
            if (Zf2(b10.type)) {
              b10 = b10.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b10 = b10.return;
      } while (null !== b10);
      throw Error(p10(171));
    }
    if (1 === a10.tag) {
      var c10 = a10.type;
      if (Zf2(c10)) return bg2(a10, c10, b10);
    }
    return b10;
  }
  function el(a10, b10, c10, d10, e10, f10, g10, h10, k10) {
    a10 = bl2(c10, d10, true, a10, e10, f10, g10, h10, k10);
    a10.context = dl(null);
    c10 = a10.current;
    d10 = R10();
    e10 = yi2(c10);
    f10 = mh2(d10, e10);
    f10.callback = void 0 !== b10 && null !== b10 ? b10 : null;
    nh2(c10, f10, e10);
    a10.current.lanes = e10;
    Ac(a10, e10, d10);
    Dk2(a10, d10);
    return a10;
  }
  function fl2(a10, b10, c10, d10) {
    var e10 = b10.current, f10 = R10(), g10 = yi2(e10);
    c10 = dl(c10);
    null === b10.context ? b10.context = c10 : b10.pendingContext = c10;
    b10 = mh2(f10, g10);
    b10.payload = { element: a10 };
    d10 = void 0 === d10 ? null : d10;
    null !== d10 && (b10.callback = d10);
    a10 = nh2(e10, b10, g10);
    null !== a10 && (gi2(a10, e10, g10, f10), oh2(a10, e10, g10));
    return g10;
  }
  function gl2(a10) {
    a10 = a10.current;
    if (!a10.child) return null;
    switch (a10.child.tag) {
      case 5:
        return a10.child.stateNode;
      default:
        return a10.child.stateNode;
    }
  }
  function hl(a10, b10) {
    a10 = a10.memoizedState;
    if (null !== a10 && null !== a10.dehydrated) {
      var c10 = a10.retryLane;
      a10.retryLane = 0 !== c10 && c10 < b10 ? c10 : b10;
    }
  }
  function il2(a10, b10) {
    hl(a10, b10);
    (a10 = a10.alternate) && hl(a10, b10);
  }
  function jl2() {
    return null;
  }
  var kl2 = "function" === typeof reportError ? reportError : function(a10) {
    console.error(a10);
  };
  function ll2(a10) {
    this._internalRoot = a10;
  }
  ml2.prototype.render = ll2.prototype.render = function(a10) {
    var b10 = this._internalRoot;
    if (null === b10) throw Error(p10(409));
    fl2(a10, b10, null, null);
  };
  ml2.prototype.unmount = ll2.prototype.unmount = function() {
    var a10 = this._internalRoot;
    if (null !== a10) {
      this._internalRoot = null;
      var b10 = a10.containerInfo;
      Rk2(function() {
        fl2(null, a10, null, null);
      });
      b10[uf2] = null;
    }
  };
  function ml2(a10) {
    this._internalRoot = a10;
  }
  ml2.prototype.unstable_scheduleHydration = function(a10) {
    if (a10) {
      var b10 = Hc2();
      a10 = { blockedOn: null, target: a10, priority: b10 };
      for (var c10 = 0; c10 < Qc2.length && 0 !== b10 && b10 < Qc2[c10].priority; c10++) ;
      Qc2.splice(c10, 0, a10);
      0 === c10 && Vc2(a10);
    }
  };
  function nl2(a10) {
    return !(!a10 || 1 !== a10.nodeType && 9 !== a10.nodeType && 11 !== a10.nodeType);
  }
  function ol2(a10) {
    return !(!a10 || 1 !== a10.nodeType && 9 !== a10.nodeType && 11 !== a10.nodeType && (8 !== a10.nodeType || " react-mount-point-unstable " !== a10.nodeValue));
  }
  function pl2() {
  }
  function ql2(a10, b10, c10, d10, e10) {
    if (e10) {
      if ("function" === typeof d10) {
        var f10 = d10;
        d10 = function() {
          var a11 = gl2(g10);
          f10.call(a11);
        };
      }
      var g10 = el(b10, d10, a10, 0, null, false, false, "", pl2);
      a10._reactRootContainer = g10;
      a10[uf2] = g10.current;
      sf2(8 === a10.nodeType ? a10.parentNode : a10);
      Rk2();
      return g10;
    }
    for (; e10 = a10.lastChild; ) a10.removeChild(e10);
    if ("function" === typeof d10) {
      var h10 = d10;
      d10 = function() {
        var a11 = gl2(k10);
        h10.call(a11);
      };
    }
    var k10 = bl2(a10, 0, false, null, null, false, false, "", pl2);
    a10._reactRootContainer = k10;
    a10[uf2] = k10.current;
    sf2(8 === a10.nodeType ? a10.parentNode : a10);
    Rk2(function() {
      fl2(b10, k10, c10, d10);
    });
    return k10;
  }
  function rl2(a10, b10, c10, d10, e10) {
    var f10 = c10._reactRootContainer;
    if (f10) {
      var g10 = f10;
      if ("function" === typeof e10) {
        var h10 = e10;
        e10 = function() {
          var a11 = gl2(g10);
          h10.call(a11);
        };
      }
      fl2(b10, g10, a10, e10);
    } else g10 = ql2(c10, b10, a10, e10, d10);
    return gl2(g10);
  }
  Ec2 = function(a10) {
    switch (a10.tag) {
      case 3:
        var b10 = a10.stateNode;
        if (b10.current.memoizedState.isDehydrated) {
          var c10 = tc2(b10.pendingLanes);
          0 !== c10 && (Cc2(b10, c10 | 1), Dk2(b10, B10()), 0 === (K10 & 6) && (Gj2 = B10() + 500, jg2()));
        }
        break;
      case 13:
        Rk2(function() {
          var b11 = ih2(a10, 1);
          if (null !== b11) {
            var c11 = R10();
            gi2(b11, a10, 1, c11);
          }
        }), il2(a10, 1);
    }
  };
  Fc2 = function(a10) {
    if (13 === a10.tag) {
      var b10 = ih2(a10, 134217728);
      if (null !== b10) {
        var c10 = R10();
        gi2(b10, a10, 134217728, c10);
      }
      il2(a10, 134217728);
    }
  };
  Gc2 = function(a10) {
    if (13 === a10.tag) {
      var b10 = yi2(a10), c10 = ih2(a10, b10);
      if (null !== c10) {
        var d10 = R10();
        gi2(c10, a10, b10, d10);
      }
      il2(a10, b10);
    }
  };
  Hc2 = function() {
    return C10;
  };
  Ic2 = function(a10, b10) {
    var c10 = C10;
    try {
      return C10 = a10, b10();
    } finally {
      C10 = c10;
    }
  };
  yb2 = function(a10, b10, c10) {
    switch (b10) {
      case "input":
        bb2(a10, c10);
        b10 = c10.name;
        if ("radio" === c10.type && null != b10) {
          for (c10 = a10; c10.parentNode; ) c10 = c10.parentNode;
          c10 = c10.querySelectorAll("input[name=" + JSON.stringify("" + b10) + '][type="radio"]');
          for (b10 = 0; b10 < c10.length; b10++) {
            var d10 = c10[b10];
            if (d10 !== a10 && d10.form === a10.form) {
              var e10 = Db2(d10);
              if (!e10) throw Error(p10(90));
              Wa2(d10);
              bb2(d10, e10);
            }
          }
        }
        break;
      case "textarea":
        ib2(a10, c10);
        break;
      case "select":
        b10 = c10.value, null != b10 && fb2(a10, !!c10.multiple, b10, false);
    }
  };
  Gb2 = Qk2;
  Hb2 = Rk2;
  var sl2 = { usingClientEntryPoint: false, Events: [Cb2, ue2, Db2, Eb2, Fb2, Qk2] }, tl2 = { findFiberByHostInstance: Wc2, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul2 = { bundleType: tl2.bundleType, version: tl2.version, rendererPackageName: tl2.rendererPackageName, rendererConfig: tl2.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua2.ReactCurrentDispatcher, findHostInstanceByFiber: function(a10) {
    a10 = Zb2(a10);
    return null === a10 ? null : a10.stateNode;
  }, findFiberByHostInstance: tl2.findFiberByHostInstance || jl2, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc2 = vl.inject(ul2), lc = vl;
    } catch (a10) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl2;
  reactDom_production_min.createPortal = function(a10, b10) {
    var c10 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl2(b10)) throw Error(p10(200));
    return cl2(a10, b10, null, c10);
  };
  reactDom_production_min.createRoot = function(a10, b10) {
    if (!nl2(a10)) throw Error(p10(299));
    var c10 = false, d10 = "", e10 = kl2;
    null !== b10 && void 0 !== b10 && (true === b10.unstable_strictMode && (c10 = true), void 0 !== b10.identifierPrefix && (d10 = b10.identifierPrefix), void 0 !== b10.onRecoverableError && (e10 = b10.onRecoverableError));
    b10 = bl2(a10, 1, false, null, null, c10, false, d10, e10);
    a10[uf2] = b10.current;
    sf2(8 === a10.nodeType ? a10.parentNode : a10);
    return new ll2(b10);
  };
  reactDom_production_min.findDOMNode = function(a10) {
    if (null == a10) return null;
    if (1 === a10.nodeType) return a10;
    var b10 = a10._reactInternals;
    if (void 0 === b10) {
      if ("function" === typeof a10.render) throw Error(p10(188));
      a10 = Object.keys(a10).join(",");
      throw Error(p10(268, a10));
    }
    a10 = Zb2(b10);
    a10 = null === a10 ? null : a10.stateNode;
    return a10;
  };
  reactDom_production_min.flushSync = function(a10) {
    return Rk2(a10);
  };
  reactDom_production_min.hydrate = function(a10, b10, c10) {
    if (!ol2(b10)) throw Error(p10(200));
    return rl2(null, a10, b10, true, c10);
  };
  reactDom_production_min.hydrateRoot = function(a10, b10, c10) {
    if (!nl2(a10)) throw Error(p10(405));
    var d10 = null != c10 && c10.hydratedSources || null, e10 = false, f10 = "", g10 = kl2;
    null !== c10 && void 0 !== c10 && (true === c10.unstable_strictMode && (e10 = true), void 0 !== c10.identifierPrefix && (f10 = c10.identifierPrefix), void 0 !== c10.onRecoverableError && (g10 = c10.onRecoverableError));
    b10 = el(b10, null, a10, 1, null != c10 ? c10 : null, e10, false, f10, g10);
    a10[uf2] = b10.current;
    sf2(a10);
    if (d10) for (a10 = 0; a10 < d10.length; a10++) c10 = d10[a10], e10 = c10._getVersion, e10 = e10(c10._source), null == b10.mutableSourceEagerHydrationData ? b10.mutableSourceEagerHydrationData = [c10, e10] : b10.mutableSourceEagerHydrationData.push(
      c10,
      e10
    );
    return new ml2(b10);
  };
  reactDom_production_min.render = function(a10, b10, c10) {
    if (!ol2(b10)) throw Error(p10(200));
    return rl2(null, a10, b10, false, c10);
  };
  reactDom_production_min.unmountComponentAtNode = function(a10) {
    if (!ol2(a10)) throw Error(p10(40));
    return a10._reactRootContainer ? (Rk2(function() {
      rl2(null, null, a10, false, function() {
        a10._reactRootContainer = null;
        a10[uf2] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk2;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a10, b10, c10, d10) {
    if (!ol2(c10)) throw Error(p10(200));
    if (null == a10 || void 0 === a10._reactInternals) throw Error(p10(38));
    return rl2(a10, b10, c10, false, d10);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  return reactDom_production_min;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production_min();
  }
  return reactDom.exports;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  var m10 = requireReactDom();
  {
    client.createRoot = m10.createRoot;
    client.hydrateRoot = m10.hydrateRoot;
  }
  return client;
}
var clientExports = requireClient();
var reactExports = requireReact();
const spe = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: spe
}, [reactExports]);
var h$4 = Object.defineProperty;
var d$4 = (s10, n10, r10) => n10 in s10 ? h$4(s10, n10, { enumerable: true, configurable: true, writable: true, value: r10 }) : s10[n10] = r10;
var m$4 = (s10, n10, r10) => (d$4(s10, typeof n10 != "symbol" ? n10 + "" : n10, r10), r10);
var t$3 = class t {
  static clamp(n10, r10, u10) {
    return Math.max(r10, typeof u10 != "undefined" ? Math.min(n10, u10) : n10);
  }
  static clampV(n10, r10, u10) {
    return n10.map((b10) => u10 ? t$3.clamp(b10, r10, u10) : t$3.clamp(b10, r10));
  }
  static cross(n10, r10, u10) {
    return (r10[0] - n10[0]) * (u10[1] - n10[1]) - (u10[0] - n10[0]) * (r10[1] - n10[1]);
  }
  static snap(n10, r10 = 1) {
    return [Math.round(n10[0] / r10) * r10, Math.round(n10[1] / r10) * r10];
  }
}, e$3 = t$3;
m$4(e$3, "neg", (n10) => [-n10[0], -n10[1]]), m$4(e$3, "add", (n10, r10) => [n10[0] + r10[0], n10[1] + r10[1]]), m$4(e$3, "addScalar", (n10, r10) => [n10[0] + r10, n10[1] + r10]), m$4(e$3, "sub", (n10, r10) => [n10[0] - r10[0], n10[1] - r10[1]]), m$4(e$3, "subScalar", (n10, r10) => [n10[0] - r10, n10[1] - r10]), m$4(e$3, "vec", (n10, r10) => [r10[0] - n10[0], r10[1] - n10[1]]), m$4(e$3, "mul", (n10, r10) => [n10[0] * r10, n10[1] * r10]), m$4(e$3, "mulV", (n10, r10) => [n10[0] * r10[0], n10[1] * r10[1]]), m$4(e$3, "div", (n10, r10) => [n10[0] / r10, n10[1] / r10]), m$4(e$3, "divV", (n10, r10) => [n10[0] / r10[0], n10[1] / r10[1]]), m$4(e$3, "per", (n10) => [n10[1], -n10[0]]), m$4(e$3, "dpr", (n10, r10) => n10[0] * r10[0] + n10[1] * r10[1]), m$4(e$3, "cpr", (n10, r10) => n10[0] * r10[1] - r10[0] * n10[1]), m$4(e$3, "len2", (n10) => n10[0] * n10[0] + n10[1] * n10[1]), m$4(e$3, "len", (n10) => Math.hypot(n10[0], n10[1])), m$4(e$3, "pry", (n10, r10) => t$3.dpr(n10, r10) / t$3.len(r10)), m$4(e$3, "uni", (n10) => t$3.div(n10, t$3.len(n10))), m$4(e$3, "normalize", (n10) => t$3.uni(n10)), m$4(e$3, "tangent", (n10, r10) => t$3.uni(t$3.sub(n10, r10))), m$4(e$3, "dist2", (n10, r10) => t$3.len2(t$3.sub(n10, r10))), m$4(e$3, "dist", (n10, r10) => Math.hypot(n10[1] - r10[1], n10[0] - r10[0])), m$4(e$3, "fastDist", (n10, r10) => {
  let u10 = [r10[0] - n10[0], r10[1] - n10[1]], b10 = [Math.abs(u10[0]), Math.abs(u10[1])], a10 = 1 / Math.max(b10[0], b10[1]);
  return a10 = a10 * (1.29289 - (b10[0] + b10[1]) * a10 * 0.29289), [u10[0] * a10, u10[1] * a10];
}), m$4(e$3, "ang", (n10, r10) => Math.atan2(t$3.cpr(n10, r10), t$3.dpr(n10, r10))), m$4(e$3, "angle", (n10, r10) => Math.atan2(r10[1] - n10[1], r10[0] - n10[0])), m$4(e$3, "med", (n10, r10) => t$3.mul(t$3.add(n10, r10), 0.5)), m$4(e$3, "rot", (n10, r10 = 0) => [n10[0] * Math.cos(r10) - n10[1] * Math.sin(r10), n10[0] * Math.sin(r10) + n10[1] * Math.cos(r10)]), m$4(e$3, "rotWith", (n10, r10, u10 = 0) => {
  if (u10 === 0) return n10;
  let b10 = Math.sin(u10), a10 = Math.cos(u10), i10 = n10[0] - r10[0], o10 = n10[1] - r10[1], c10 = i10 * a10 - o10 * b10, l10 = i10 * b10 + o10 * a10;
  return [c10 + r10[0], l10 + r10[1]];
}), m$4(e$3, "isEqual", (n10, r10) => n10[0] === r10[0] && n10[1] === r10[1]), m$4(e$3, "lrp", (n10, r10, u10) => t$3.add(n10, t$3.mul(t$3.sub(r10, n10), u10))), m$4(e$3, "int", (n10, r10, u10, b10, a10 = 1) => {
  let i10 = (t$3.clamp(u10, b10) - u10) / (b10 - u10);
  return t$3.add(t$3.mul(n10, 1 - i10), t$3.mul(r10, a10));
}), m$4(e$3, "ang3", (n10, r10, u10) => {
  let b10 = t$3.vec(r10, n10), a10 = t$3.vec(r10, u10);
  return t$3.ang(b10, a10);
}), m$4(e$3, "abs", (n10) => [Math.abs(n10[0]), Math.abs(n10[1])]), m$4(e$3, "rescale", (n10, r10) => {
  let u10 = t$3.len(n10);
  return [r10 * n10[0] / u10, r10 * n10[1] / u10];
}), m$4(e$3, "isLeft", (n10, r10, u10) => (r10[0] - n10[0]) * (u10[1] - n10[1]) - (u10[0] - n10[0]) * (r10[1] - n10[1])), m$4(e$3, "clockwise", (n10, r10, u10) => t$3.isLeft(n10, r10, u10) > 0), m$4(e$3, "toFixed", (n10) => n10.map((r10) => Math.round(r10 * 100) / 100)), m$4(e$3, "nearestPointOnLineThroughPoint", (n10, r10, u10) => t$3.add(n10, t$3.mul(r10, t$3.pry(t$3.sub(u10, n10), r10)))), m$4(e$3, "distanceToLineThroughPoint", (n10, r10, u10) => t$3.dist(u10, t$3.nearestPointOnLineThroughPoint(n10, r10, u10))), m$4(e$3, "nearestPointOnLineSegment", (n10, r10, u10, b10 = true) => {
  let a10 = t$3.uni(t$3.sub(r10, n10)), i10 = t$3.add(n10, t$3.mul(a10, t$3.pry(t$3.sub(u10, n10), a10)));
  if (b10) {
    if (i10[0] < Math.min(n10[0], r10[0])) return n10[0] < r10[0] ? n10 : r10;
    if (i10[0] > Math.max(n10[0], r10[0])) return n10[0] > r10[0] ? n10 : r10;
    if (i10[1] < Math.min(n10[1], r10[1])) return n10[1] < r10[1] ? n10 : r10;
    if (i10[1] > Math.max(n10[1], r10[1])) return n10[1] > r10[1] ? n10 : r10;
  }
  return i10;
}), m$4(e$3, "distanceToLineSegment", (n10, r10, u10, b10 = true) => t$3.dist(u10, t$3.nearestPointOnLineSegment(n10, r10, u10, b10))), m$4(e$3, "nearestPointOnBounds", (n10, r10) => [t$3.clamp(r10[0], n10.minX, n10.maxX), t$3.clamp(r10[1], n10.minY, n10.maxY)]), m$4(e$3, "distanceToBounds", (n10, r10) => t$3.dist(r10, t$3.nearestPointOnBounds(n10, r10))), m$4(e$3, "nudge", (n10, r10, u10) => t$3.isEqual(n10, r10) ? n10 : t$3.add(n10, t$3.mul(t$3.uni(t$3.sub(r10, n10)), u10))), m$4(e$3, "nudgeAtAngle", (n10, r10, u10) => [Math.cos(r10) * u10 + n10[0], Math.sin(r10) * u10 + n10[1]]), m$4(e$3, "toPrecision", (n10, r10 = 4) => [+n10[0].toPrecision(r10), +n10[1].toPrecision(r10)]), m$4(e$3, "pointsBetween", (n10, r10, u10 = 6) => Array.from(Array(u10)).map((b10, a10) => {
  let i10 = a10 / (u10 - 1), o10 = Math.min(1, 0.5 + Math.abs(0.5 - i10));
  return [...t$3.lrp(n10, r10, i10), o10];
})), m$4(e$3, "slope", (n10, r10) => n10[0] === r10[0] ? NaN : (n10[1] - r10[1]) / (n10[0] - r10[0])), m$4(e$3, "max", (...n10) => [Math.max(...n10.map((r10) => r10[0])), Math.max(...n10.map((r10) => r10[1]))]), m$4(e$3, "min", (...n10) => [Math.min(...n10.map((r10) => r10[0])), Math.min(...n10.map((r10) => r10[1]))]);
var p$4 = e$3;
function clamp$1(v10, min2, max2) {
  return Math.max(min2, Math.min(v10, max2));
}
const V$3 = {
  toVector(v10, fallback) {
    if (v10 === void 0) v10 = fallback;
    return Array.isArray(v10) ? v10 : [v10, v10];
  },
  add(v12, v22) {
    return [v12[0] + v22[0], v12[1] + v22[1]];
  },
  sub(v12, v22) {
    return [v12[0] - v22[0], v12[1] - v22[1]];
  },
  addTo(v12, v22) {
    v12[0] += v22[0];
    v12[1] += v22[1];
  },
  subTo(v12, v22) {
    v12[0] -= v22[0];
    v12[1] -= v22[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min2, max2, constant = 0.15) {
  if (constant === 0) return clamp$1(position, min2, max2);
  if (position < min2) return -rubberband(min2 - position, max2 - min2, constant) + min2;
  if (position > max2) return +rubberband(position - max2, max2 - min2, constant) + max2;
  return position;
}
function computeRubberband(bounds, [Vx2, Vy2], [Rx2, Ry2]) {
  const [[X02, X12], [Y02, Y12]] = bounds;
  return [rubberbandIfOutOfBounds(Vx2, X02, X12, Rx2), rubberbandIfOutOfBounds(Vy2, Y02, Y12, Ry2)];
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint);
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(e10, r10) {
  var t10 = Object.keys(e10);
  if (Object.getOwnPropertySymbols) {
    var o10 = Object.getOwnPropertySymbols(e10);
    r10 && (o10 = o10.filter(function(r22) {
      return Object.getOwnPropertyDescriptor(e10, r22).enumerable;
    })), t10.push.apply(t10, o10);
  }
  return t10;
}
function _objectSpread2(e10) {
  for (var r10 = 1; r10 < arguments.length; r10++) {
    var t10 = null != arguments[r10] ? arguments[r10] : {};
    r10 % 2 ? ownKeys(Object(t10), true).forEach(function(r22) {
      _defineProperty(e10, r22, t10[r22]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e10, Object.getOwnPropertyDescriptors(t10)) : ownKeys(Object(t10)).forEach(function(r22) {
      Object.defineProperty(e10, r22, Object.getOwnPropertyDescriptor(t10, r22));
    });
  }
  return e10;
}
const EVENT_TYPE_MAP = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function capitalize(string) {
  if (!string) return "";
  return string[0].toUpperCase() + string.slice(1);
}
const actionsWithoutCaptureSupported = ["enter", "leave"];
function hasCapture(capture = false, actionKey) {
  return capture && !actionsWithoutCaptureSupported.includes(actionKey);
}
function toHandlerProp(device, action = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
}
const pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(prop) {
  let eventKey = prop.substring(2).toLowerCase();
  const passive = !!~eventKey.indexOf("passive");
  if (passive) eventKey = eventKey.replace("passive", "");
  const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
  const capture = !!~eventKey.indexOf(captureKey);
  if (capture) eventKey = eventKey.replace("capture", "");
  return {
    device: eventKey,
    capture,
    passive
  };
}
function toDomEventType(device, action = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getPointerType(event) {
  if (isTouch(event)) return "touch";
  if ("pointerType" in event) return event.pointerType;
  return "mouse";
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter((e10) => {
    var _event$currentTarget, _event$currentTarget$;
    return e10.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e10.target));
  });
}
function getTouchList(event) {
  return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
}
function getValueEvent(event) {
  return isTouch(event) ? getTouchList(event)[0] : event;
}
function distanceAngle(P12, P22) {
  try {
    const dx2 = P22.clientX - P12.clientX;
    const dy2 = P22.clientY - P12.clientY;
    const cx2 = (P22.clientX + P12.clientX) / 2;
    const cy2 = (P22.clientY + P12.clientY) / 2;
    const distance = Math.hypot(dx2, dy2);
    const angle = -(Math.atan2(dx2, dy2) * 180) / Math.PI;
    const origin = [cx2, cy2];
    return {
      angle,
      distance,
      origin
    };
  } catch (_unused) {
  }
  return null;
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P12, P22] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P12, P22);
}
function pointerId(event) {
  const valueEvent = getValueEvent(event);
  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
}
function pointerValues(event) {
  const valueEvent = getValueEvent(event);
  return [valueEvent.clientX, valueEvent.clientY];
}
const LINE_HEIGHT = 40;
const PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function scrollValues(event) {
  var _ref, _ref2;
  const {
    scrollX,
    scrollY,
    scrollLeft,
    scrollTop
  } = event.currentTarget;
  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event) payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    });
  }
  return payload;
}
function call(v10, ...args) {
  if (typeof v10 === "function") {
    return v10(...args);
  } else {
    return v10;
  }
}
function noop() {
}
function chain(...fns) {
  if (fns.length === 0) return noop;
  if (fns.length === 1) return fns[0];
  return function() {
    let result;
    for (const fn2 of fns) {
      result = fn2.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
const BEFORE_LAST_KINEMATICS_DELAY = 32;
class Engine {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init) this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared,
      ingKey,
      args
    } = this;
    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._direction = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = state.timeDelta = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.overflow = [0, 0];
    state._movementBound = [false, false];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config.from ? call(config.from, state) : state.offset;
      state.offset = state.lastOffset;
      state.startTime = state.timeStamp = event.timeStamp;
    }
  }
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config,
      shared
    } = this;
    state.args = this.args;
    let dt2 = 0;
    if (event) {
      state.event = event;
      if (config.preventDefault && event.cancelable) state.event.preventDefault();
      state.type = event.type;
      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared.locked = !!document.pointerLockElement;
      Object.assign(shared, getEventDetails(event));
      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
      dt2 = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V$3.addTo(state._distance, _absoluteDelta);
    }
    if (this.axisIntent) this.axisIntent(event);
    const [_m0, _m1] = state._movement;
    const [t02, t12] = config.threshold;
    const {
      _step,
      values
    } = state;
    if (config.hasCustomTransform) {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t02 && values[0];
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t12 && values[1];
    } else {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t02 && Math.sign(_m0) * t02;
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t12 && Math.sign(_m1) * t12;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional) return;
    const movement = [0, 0];
    if (config.hasCustomTransform) {
      const [v02, v12] = values;
      movement[0] = _step[0] !== false ? v02 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v12 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);
    const previousOffset = state.offset;
    const gestureIsActive = state._active && !state._blocked || state.active;
    if (gestureIsActive) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config) state._bounds = call(config.bounds, state);
          if (this.setup) this.setup();
        }
        state.movement = movement;
        this.computeOffset();
      }
    }
    const [ox2, oy2] = state.offset;
    const [[x02, x12], [y02, y12]] = state._bounds;
    state.overflow = [ox2 < x02 ? -1 : ox2 > x12 ? 1 : 0, oy2 < y02 ? -1 : oy2 > y12 ? 1 : 0];
    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
    const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    state.delta = V$3.sub(state.offset, previousOffset);
    this.computeMovement();
    if (gestureIsActive && (!state.last || dt2 > BEFORE_LAST_KINEMATICS_DELAY)) {
      state.delta = V$3.sub(state.offset, previousOffset);
      const absoluteDelta = state.delta.map(Math.abs);
      V$3.addTo(state.distance, absoluteDelta);
      state.direction = state.delta.map(Math.sign);
      state._direction = state._delta.map(Math.sign);
      if (!state.first && dt2 > 0) {
        state.velocity = [absoluteDelta[0] / dt2, absoluteDelta[1] / dt2];
        state.timeDelta = dt2;
      }
    }
  }
  emit() {
    const state = this.state;
    const shared = this.shared;
    const config = this.config;
    if (!state._active) this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;
    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo !== void 0) state.memo = memo;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
}
function selectAxis([dx2, dy2], threshold) {
  const absDx = Math.abs(dx2);
  const absDy = Math.abs(dy2);
  if (absDx > absDy && absDx > threshold) {
    return "x";
  }
  if (absDy > absDx && absDy > threshold) {
    return "y";
  }
  return void 0;
}
class CoordinatesEngine extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "aliasKey", "xy");
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V$3.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V$3.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(event) {
    const state = this.state;
    const config = this.config;
    if (!state.axis && event) {
      const threshold = typeof config.axisThreshold === "object" ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;
      state.axis = selectAxis(state._movement, threshold);
    }
    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;
  }
  restrictToAxis(v10) {
    if (this.config.axis || this.config.lockDirection) {
      switch (this.state.axis) {
        case "x":
          v10[1] = 0;
          break;
        case "y":
          v10[0] = 0;
          break;
      }
    }
  }
}
const identity$1 = (v10) => v10;
const DEFAULT_RUBBERBAND = 0.15;
const commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  eventOptions(value, _k2, config) {
    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V$3.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function") return value;
    if (value != null) return V$3.toVector(value);
  },
  transform(value, _k2, config) {
    const transform = value || config.shared.transform;
    this.hasCustomTransform = !!transform;
    return transform || identity$1;
  },
  threshold(value) {
    return V$3.toVector(value, 0);
  }
};
const DEFAULT_AXIS_THRESHOLD = 0;
const coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis(_v2, _k2, {
    axis
  }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection) return axis;
  },
  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
    return value;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const {
      left = -Infinity,
      right = Infinity,
      top: top2 = -Infinity,
      bottom = Infinity
    } = value;
    return [[left, right], [top2, bottom]];
  }
});
const KEYS_DELTA_MAP = {
  ArrowRight: (displacement, factor = 1) => [displacement * factor, 0],
  ArrowLeft: (displacement, factor = 1) => [-1 * displacement * factor, 0],
  ArrowUp: (displacement, factor = 1) => [0, -1 * displacement * factor],
  ArrowDown: (displacement, factor = 1) => [0, displacement * factor]
};
class DragEngine extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const state = this.state;
    state._pointerId = void 0;
    state._pointerActive = false;
    state._keyboardActive = false;
    state._preventScroll = false;
    state._delayed = false;
    state.swipe = [0, 0];
    state.tap = false;
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
  }
  setup() {
    const state = this.state;
    if (state._bounds instanceof HTMLElement) {
      const boundRect = state._bounds.getBoundingClientRect();
      const targetRect = state.currentTarget.getBoundingClientRect();
      const _bounds = {
        left: boundRect.left - targetRect.left + state.offset[0],
        right: boundRect.right - targetRect.right + state.offset[0],
        top: boundRect.top - targetRect.top + state.offset[1],
        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
      };
      state._bounds = coordinatesConfigResolver.bounds(_bounds);
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    state.canceled = true;
    state._active = false;
    setTimeout(() => {
      this.compute();
      this.emit();
    }, 0);
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean();
    this.state._pointerActive = false;
    this.state._keyboardActive = false;
    super.clean();
  }
  pointerDown(event) {
    const config = this.config;
    const state = this.state;
    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;
    const ctrlIds = this.ctrl.setEventIds(event);
    if (config.pointerCapture) {
      event.target.setPointerCapture(event.pointerId);
    }
    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;
    this.start(event);
    this.setupPointer(event);
    state._pointerId = pointerId(event);
    state._pointerActive = true;
    this.computeValues(pointerValues(event));
    this.computeInitial();
    if (config.preventScrollAxis && getPointerType(event) !== "mouse") {
      state._active = false;
      this.setupScrollPrevention(event);
    } else if (config.delay > 0) {
      this.setupDelayTrigger(event);
      if (config.triggerAllEvents) {
        this.compute(event);
        this.emit();
      }
    } else {
      this.startPointerDrag(event);
    }
  }
  startPointerDrag(event) {
    const state = this.state;
    state._active = true;
    state._preventScroll = true;
    state._delayed = false;
    this.compute(event);
    this.emit();
  }
  pointerMove(event) {
    const state = this.state;
    const config = this.config;
    if (!state._pointerActive) return;
    const id = pointerId(event);
    if (state._pointerId !== void 0 && id !== state._pointerId) return;
    const _values = pointerValues(event);
    if (document.pointerLockElement === event.target) {
      state._delta = [event.movementX, event.movementY];
    } else {
      state._delta = V$3.sub(_values, state._values);
      this.computeValues(_values);
    }
    V$3.addTo(state._movement, state._delta);
    this.compute(event);
    if (state._delayed && state.intentional) {
      this.timeoutStore.remove("dragDelay");
      state.active = false;
      this.startPointerDrag(event);
      return;
    }
    if (config.preventScrollAxis && !state._preventScroll) {
      if (state.axis) {
        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === "xy") {
          state._active = false;
          this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag");
          this.startPointerDrag(event);
          return;
        }
      } else {
        return;
      }
    }
    this.emit();
  }
  pointerUp(event) {
    this.ctrl.setEventIds(event);
    try {
      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
        ;
        event.target.releasePointerCapture(event.pointerId);
      }
    } catch (_unused) {
    }
    const state = this.state;
    const config = this.config;
    if (!state._active || !state._pointerActive) return;
    const id = pointerId(event);
    if (state._pointerId !== void 0 && id !== state._pointerId) return;
    this.state._pointerActive = false;
    this.setActive();
    this.compute(event);
    const [dx2, dy2] = state._distance;
    state.tap = dx2 <= config.tapsThreshold && dy2 <= config.tapsThreshold;
    if (state.tap && config.filterTaps) {
      state._force = true;
    } else {
      const [_dx, _dy] = state._delta;
      const [_mx, _my] = state._movement;
      const [svx, svy] = config.swipe.velocity;
      const [sx2, sy2] = config.swipe.distance;
      const sdt = config.swipe.duration;
      if (state.elapsedTime < sdt) {
        const _vx = Math.abs(_dx / state.timeDelta);
        const _vy = Math.abs(_dy / state.timeDelta);
        if (_vx > svx && Math.abs(_mx) > sx2) state.swipe[0] = Math.sign(_dx);
        if (_vy > svy && Math.abs(_my) > sy2) state.swipe[1] = Math.sign(_dy);
      }
    }
    this.emit();
  }
  pointerClick(event) {
    if (!this.state.tap && event.detail > 0) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setupPointer(event) {
    const config = this.config;
    const device = config.device;
    if (config.pointerLock) {
      event.currentTarget.requestPointerLock();
    }
    if (!config.pointerCapture) {
      this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
    }
  }
  pointerClean() {
    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
      document.exitPointerLock();
    }
  }
  preventScroll(event) {
    if (this.state._preventScroll && event.cancelable) {
      event.preventDefault();
    }
  }
  setupScrollPrevention(event) {
    this.state._preventScroll = false;
    persistEvent(event);
    const remove = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", remove);
    this.eventStore.add(this.sharedConfig.window, "touch", "cancel", remove);
    this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
  }
  setupDelayTrigger(event) {
    this.state._delayed = true;
    this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0];
      this.startPointerDrag(event);
    }, this.config.delay);
  }
  keyDown(event) {
    const deltaFn = KEYS_DELTA_MAP[event.key];
    if (deltaFn) {
      const state = this.state;
      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
      this.start(event);
      state._delta = deltaFn(this.config.keyboardDisplacement, factor);
      state._keyboardActive = true;
      V$3.addTo(state._movement, state._delta);
      this.compute(event);
      this.emit();
    }
  }
  keyUp(event) {
    if (!(event.key in KEYS_DELTA_MAP)) return;
    this.state._keyboardActive = false;
    this.setActive();
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    bindFunction(device, "start", this.pointerDown.bind(this));
    if (this.config.pointerCapture) {
      bindFunction(device, "change", this.pointerMove.bind(this));
      bindFunction(device, "end", this.pointerUp.bind(this));
      bindFunction(device, "cancel", this.pointerUp.bind(this));
      bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
    }
    if (this.config.keys) {
      bindFunction("key", "down", this.keyDown.bind(this));
      bindFunction("key", "up", this.keyUp.bind(this));
    }
    if (this.config.filterTaps) {
      bindFunction("click", "", this.pointerClick.bind(this), {
        capture: true,
        passive: false
      });
    }
  }
}
function persistEvent(event) {
  "persist" in event && typeof event.persist === "function" && event.persist();
}
const isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e10) {
    return false;
  }
}
const SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: supportsTouchEvents(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
const DEFAULT_PREVENT_SCROLL_DELAY = 250;
const DEFAULT_DRAG_DELAY = 180;
const DEFAULT_SWIPE_VELOCITY = 0.5;
const DEFAULT_SWIPE_DISTANCE = 50;
const DEFAULT_SWIPE_DURATION = 250;
const DEFAULT_KEYBOARD_DISPLACEMENT = 10;
const DEFAULT_DRAG_AXIS_THRESHOLD = {
  mouse: 0,
  touch: 0,
  pen: 8
};
const dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  device(_v2, _k2, {
    pointer: {
      touch = false,
      lock = false,
      mouse = false
    } = {}
  }) {
    this.pointerLock = lock && SUPPORT.pointerLock;
    if (SUPPORT.touch && touch) return "touch";
    if (this.pointerLock) return "mouse";
    if (SUPPORT.pointer && !mouse) return "pointer";
    if (SUPPORT.touch) return "touch";
    return "mouse";
  },
  preventScrollAxis(value, _k2, {
    preventScroll
  }) {
    this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
    if (!SUPPORT.touchscreen || preventScroll === false) return void 0;
    return value ? value : preventScroll !== void 0 ? "y" : void 0;
  },
  pointerCapture(_v2, _k2, {
    pointer: {
      capture = true,
      buttons = 1,
      keys = true
    } = {}
  }) {
    this.pointerButtons = buttons;
    this.keys = keys;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k2, {
    filterTaps = false,
    tapsThreshold = 3,
    axis = void 0
  }) {
    const threshold = V$3.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(V$3.toVector(velocity)),
      distance: this.transform(V$3.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  },
  axisThreshold(value) {
    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;
    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
  },
  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {
    return value;
  }
});
function clampStateInternalMovementToBounds(state) {
  const [ox2, oy2] = state.overflow;
  const [dx2, dy2] = state._delta;
  const [dirx, diry] = state._direction;
  if (ox2 < 0 && dx2 > 0 && dirx < 0 || ox2 > 0 && dx2 < 0 && dirx > 0) {
    state._movement[0] = state._movementBound[0];
  }
  if (oy2 < 0 && dy2 > 0 && diry < 0 || oy2 > 0 && dy2 < 0 && diry > 0) {
    state._movement[1] = state._movementBound[1];
  }
}
const SCALE_ANGLE_RATIO_INTENT_DEG = 30;
const PINCH_WHEEL_RATIO = 100;
class PinchEngine extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "pinching");
    _defineProperty(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === "wheel") {
      this.state.offset = V$3.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset: offset2,
      lastOffset
    } = this.state;
    this.state.movement = [offset2[0] / lastOffset[0], offset2[1] - lastOffset[1]];
  }
  axisIntent() {
    const state = this.state;
    const [_m0, _m1] = state._movement;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
      if (axisMovementDifference < 0) state.axis = "angle";
      else if (axisMovementDifference > 0) state.axis = "scale";
    }
  }
  restrictToAxis(v10) {
    if (this.config.lockDirection) {
      if (this.state.axis === "scale") v10[1] = 0;
      else if (this.state.axis === "angle") v10[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id) => ctrlTouchIds.has(id))) return;
    }
    if (ctrlTouchIds.size < 2) return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1) return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id))) return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2) return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active) return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active) return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active) return;
    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active) return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    if (state._active) return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable) event.preventDefault();
    if (!this.state._active) return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V$3.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    const modifierKey = this.config.modifierKey;
    if (modifierKey && (Array.isArray(modifierKey) ? !modifierKey.find((k10) => event[k10]) : !event[modifierKey])) return;
    if (!this.state._active) this.wheelStart(event);
    else this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    V$3.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
      bindFunction("lostPointerCapture", "", this[device + "End"].bind(this));
    }
    if (this.config.pinchOnWheel) {
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
}
const pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  device(_v2, _k2, {
    shared,
    pointer: {
      touch = false
    } = {}
  }) {
    const sharedConfig = shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return "gesture";
    if (SUPPORT.touch && touch) return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer) return "pointer";
      if (SUPPORT.touch) return "touch";
    }
  },
  bounds(_v2, _k2, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = (state) => {
      const D10 = assignDefault(call(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D10.min, D10.max];
    };
    const _angleBounds = (state) => {
      const A10 = assignDefault(call(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A10.min, A10.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function") return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k2, config) {
    this.lockDirection = config.axis === "lock";
    const threshold = V$3.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  },
  modifierKey(value) {
    if (value === void 0) return "ctrlKey";
    return value;
  },
  pinchOnWheel(value = true) {
    return value;
  }
});
class MoveEngine extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "moving");
  }
  move(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    if (!this.state._active) this.moveStart(event);
    else this.moveChange(event);
    this.timeoutStore.add("moveEnd", this.moveEnd.bind(this));
  }
  moveStart(event) {
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.computeInitial();
    this.emit();
  }
  moveChange(event) {
    if (!this.state._active) return;
    const values = pointerValues(event);
    const state = this.state;
    state._delta = V$3.sub(values, state._values);
    V$3.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  moveEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "change", this.move.bind(this));
    bindFunction("pointer", "leave", this.moveEnd.bind(this));
  }
}
const moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
class ScrollEngine extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "scrolling");
  }
  scroll(event) {
    if (!this.state._active) this.start(event);
    this.scrollChange(event);
    this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this));
  }
  scrollChange(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    const values = scrollValues(event);
    state._delta = V$3.sub(values, state._values);
    V$3.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  scrollEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("scroll", "", this.scroll.bind(this));
  }
}
const scrollConfigResolver = coordinatesConfigResolver;
class WheelEngine extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "wheeling");
  }
  wheel(event) {
    if (!this.state._active) this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V$3.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
}
const wheelConfigResolver = coordinatesConfigResolver;
class HoverEngine extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "hovering");
  }
  enter(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.emit();
  }
  leave(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    const state = this.state;
    if (!state._active) return;
    state._active = false;
    const values = pointerValues(event);
    state._movement = state._delta = V$3.sub(values, state._values);
    this.computeValues(values);
    this.compute(event);
    state.delta = state.movement;
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "enter", this.enter.bind(this));
    bindFunction("pointer", "leave", this.leave.bind(this));
  }
}
const hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
const EngineMap = /* @__PURE__ */ new Map();
const ConfigResolverMap = /* @__PURE__ */ new Map();
function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}
const dragAction = {
  key: "drag",
  engine: DragEngine,
  resolver: dragConfigResolver
};
const hoverAction = {
  key: "hover",
  engine: HoverEngine,
  resolver: hoverConfigResolver
};
const moveAction = {
  key: "move",
  engine: MoveEngine,
  resolver: moveConfigResolver
};
const pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
const scrollAction = {
  key: "scroll",
  engine: ScrollEngine,
  resolver: scrollConfigResolver
};
const wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i10;
  for (i10 = 0; i10 < sourceKeys.length; i10++) {
    key = sourceKeys[i10];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i10;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i10 = 0; i10 < sourceSymbolKeys.length; i10++) {
      key = sourceSymbolKeys[i10];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
const sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  transform(value) {
    return value;
  }
};
const _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case "function":
        {
          result[key] = resolver.call(result, config[key], key, config);
        }
        break;
      case "object":
        result[key] = resolveWith(config[key], resolver);
        break;
      case "boolean":
        if (resolver) result[key] = config[key];
        break;
    }
  }
  return result;
}
function parse$2(newConfig, gestureKey, _config = {}) {
  const _ref = newConfig, {
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
  _config.shared = resolveWith({
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  }, sharedConfigResolver);
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith(_objectSpread2({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith(_objectSpread2({
          shared: _config.shared
        }, rest[key]), resolver);
      }
    }
  }
  return _config;
}
class EventStore {
  constructor(ctrl, gestureKey) {
    _defineProperty(this, "_listeners", /* @__PURE__ */ new Set());
    this._ctrl = ctrl;
    this._gestureKey = gestureKey;
  }
  add(element, device, action, handler, options) {
    const listeners = this._listeners;
    const type = toDomEventType(device, action);
    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
    const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);
    element.addEventListener(type, handler, eventOptions);
    const remove = () => {
      element.removeEventListener(type, handler, eventOptions);
      listeners.delete(remove);
    };
    listeners.add(remove);
    return remove;
  }
  clean() {
    this._listeners.forEach((remove) => remove());
    this._listeners.clear();
  }
}
class TimeoutStore {
  constructor() {
    _defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(key, callback, ms2 = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms2, ...args));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout) window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
}
class Controller {
  constructor(handlers) {
    _defineProperty(this, "gestures", /* @__PURE__ */ new Set());
    _defineProperty(this, "_targetEventStore", new EventStore(this));
    _defineProperty(this, "gestureEventStores", {});
    _defineProperty(this, "gestureTimeoutStores", {});
    _defineProperty(this, "handlers", {});
    _defineProperty(this, "config", {});
    _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "touchIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers);
  }
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
      return this.touchIds;
    } else if ("pointerId" in event) {
      if (event.type === "pointerup" || event.type === "pointercancel") this.pointerIds.delete(event.pointerId);
      else if (event.type === "pointerdown") this.pointerIds.add(event.pointerId);
      return this.pointerIds;
    }
  }
  applyHandlers(handlers, nativeHandlers) {
    this.handlers = handlers;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config, gestureKey) {
    this.config = parse$2(config, gestureKey, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target) this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args) {
    const sharedConfig = this.config.shared;
    const props = {};
    let target;
    if (sharedConfig.target) {
      target = sharedConfig.target();
      if (!target) return;
    }
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        const gestureConfig = this.config[gestureKey];
        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
        if (gestureConfig.enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args, gestureKey).bind(bindFunction);
        }
      }
      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
      for (const eventKey in this.nativeHandlers) {
        nativeBindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
          event,
          args
        })), void 0, true);
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target) return props;
    for (const handlerProp in props) {
      const {
        device,
        capture,
        passive
      } = parseProp(handlerProp);
      this._targetEventStore.add(target, device, "", props[handlerProp], {
        capture,
        passive
      });
    }
  }
}
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag) setupGesture(ctrl, "drag");
  if (internalHandlers.wheel) setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll) setupGesture(ctrl, "scroll");
  if (internalHandlers.move) setupGesture(ctrl, "move");
  if (internalHandlers.pinch) setupGesture(ctrl, "pinch");
  if (internalHandlers.hover) setupGesture(ctrl, "hover");
}
const bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
  if (withPassiveOption && passive) handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};
const RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers2) {
  const native = {};
  const handlers = {};
  const actions = /* @__PURE__ */ new Set();
  for (let key in _handlers2) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers[key] = _handlers2[key];
    } else {
      native[key] = _handlers2[key];
    }
  }
  return [handlers, native, actions];
}
function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {
  if (!actions.has(handlerKey)) return;
  if (!EngineMap.has(key)) {
    return;
  }
  const startKey = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn2 = (state) => {
    let memo = void 0;
    if (state.first && startKey in handlers) handlers[startKey](state);
    if (handlerKey in handlers) memo = handlers[handlerKey](state);
    if (state.last && endKey in handlers) handlers[endKey](state);
    return memo;
  };
  internalHandlers[key] = fn2;
  config[key] = config[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}
function useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {
  const ctrl = spe.useMemo(() => new Controller(handlers), []);
  ctrl.applyHandlers(handlers, nativeHandlers);
  ctrl.applyConfig(config, gestureKey);
  spe.useEffect(ctrl.effect.bind(ctrl));
  spe.useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config.target === void 0) {
    return ctrl.bind.bind(ctrl);
  }
  return void 0;
}
function createUseGesture(actions) {
  actions.forEach(registerAction);
  return function useGesture2(_handlers2, _config) {
    const {
      handlers,
      nativeHandlers,
      config
    } = parseMergedHandlers(_handlers2, _config || {});
    return useRecognizers(handlers, config, void 0, nativeHandlers);
  };
}
function useGesture(handlers, config) {
  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);
  return hook(handlers, config || {});
}
function $$2(e10, t10, u10, x10 = (h10) => h10) {
  return e10 * x10(0.5 - t10 * (0.5 - u10));
}
function se$1(e10) {
  return [-e10[0], -e10[1]];
}
function l$6(e10, t10) {
  return [e10[0] + t10[0], e10[1] + t10[1]];
}
function a$6(e10, t10) {
  return [e10[0] - t10[0], e10[1] - t10[1]];
}
function b$4(e10, t10) {
  return [e10[0] * t10, e10[1] * t10];
}
function he$1(e10, t10) {
  return [e10[0] / t10, e10[1] / t10];
}
function R$5(e10) {
  return [e10[1], -e10[0]];
}
function B$2(e10, t10) {
  return e10[0] * t10[0] + e10[1] * t10[1];
}
function ue(e10, t10) {
  return e10[0] === t10[0] && e10[1] === t10[1];
}
function ge(e10) {
  return Math.hypot(e10[0], e10[1]);
}
function de$1(e10) {
  return e10[0] * e10[0] + e10[1] * e10[1];
}
function A$3(e10, t10) {
  return de$1(a$6(e10, t10));
}
function G$2(e10) {
  return he$1(e10, ge(e10));
}
function ie$1(e10, t10) {
  return Math.hypot(e10[1] - t10[1], e10[0] - t10[0]);
}
function L$3(e10, t10, u10) {
  let x10 = Math.sin(u10), h10 = Math.cos(u10), y10 = e10[0] - t10[0], n10 = e10[1] - t10[1], f10 = y10 * h10 - n10 * x10, d10 = y10 * x10 + n10 * h10;
  return [f10 + t10[0], d10 + t10[1]];
}
function K$2(e10, t10, u10) {
  return l$6(e10, b$4(a$6(t10, e10), u10));
}
function ee$2(e10, t10, u10) {
  return l$6(e10, b$4(t10, u10));
}
var { min: C$4, PI: xe$1 } = Math, pe$2 = 0.275, V$2 = xe$1 + 1e-4;
function ce$1(e10, t10 = {}) {
  let { size: u10 = 16, smoothing: x10 = 0.5, thinning: h10 = 0.5, simulatePressure: y10 = true, easing: n10 = (r10) => r10, start: f10 = {}, end: d10 = {}, last: D10 = false } = t10, { cap: S10 = true, easing: j10 = (r10) => r10 * (2 - r10) } = f10, { cap: q10 = true, easing: c10 = (r10) => --r10 * r10 * r10 + 1 } = d10;
  if (e10.length === 0 || u10 <= 0) return [];
  let p10 = e10[e10.length - 1].runningLength, g10 = f10.taper === false ? 0 : f10.taper === true ? Math.max(u10, p10) : f10.taper, T10 = d10.taper === false ? 0 : d10.taper === true ? Math.max(u10, p10) : d10.taper, te2 = Math.pow(u10 * x10, 2), _10 = [], M10 = [], H10 = e10.slice(0, 10).reduce((r10, i10) => {
    let o10 = i10.pressure;
    if (y10) {
      let s10 = C$4(1, i10.distance / u10), W10 = C$4(1, 1 - s10);
      o10 = C$4(1, r10 + (W10 - r10) * (s10 * pe$2));
    }
    return (r10 + o10) / 2;
  }, e10[0].pressure), m10 = $$2(u10, h10, e10[e10.length - 1].pressure, n10), U10, X10 = e10[0].vector, z10 = e10[0].point, F10 = z10, O10 = z10, E10 = F10, J10 = false;
  for (let r10 = 0; r10 < e10.length; r10++) {
    let { pressure: i10 } = e10[r10], { point: o10, vector: s10, distance: W10, runningLength: I10 } = e10[r10];
    if (r10 < e10.length - 1 && p10 - I10 < 3) continue;
    if (h10) {
      if (y10) {
        let v10 = C$4(1, W10 / u10), Z10 = C$4(1, 1 - v10);
        i10 = C$4(1, H10 + (Z10 - H10) * (v10 * pe$2));
      }
      m10 = $$2(u10, h10, i10, n10);
    } else m10 = u10 / 2;
    U10 === void 0 && (U10 = m10);
    let le2 = I10 < g10 ? j10(I10 / g10) : 1, fe = p10 - I10 < T10 ? c10((p10 - I10) / T10) : 1;
    m10 = Math.max(0.01, m10 * Math.min(le2, fe));
    let re2 = (r10 < e10.length - 1 ? e10[r10 + 1] : e10[r10]).vector, Y10 = r10 < e10.length - 1 ? B$2(s10, re2) : 1, be2 = B$2(s10, X10) < 0 && !J10, ne = Y10 !== null && Y10 < 0;
    if (be2 || ne) {
      let v10 = b$4(R$5(X10), m10);
      for (let Z10 = 1 / 13, w10 = 0; w10 <= 1; w10 += Z10) O10 = L$3(a$6(o10, v10), o10, V$2 * w10), _10.push(O10), E10 = L$3(l$6(o10, v10), o10, V$2 * -w10), M10.push(E10);
      z10 = O10, F10 = E10, ne && (J10 = true);
      continue;
    }
    if (J10 = false, r10 === e10.length - 1) {
      let v10 = b$4(R$5(s10), m10);
      _10.push(a$6(o10, v10)), M10.push(l$6(o10, v10));
      continue;
    }
    let oe = b$4(R$5(K$2(re2, s10, Y10)), m10);
    O10 = a$6(o10, oe), (r10 <= 1 || A$3(z10, O10) > te2) && (_10.push(O10), z10 = O10), E10 = l$6(o10, oe), (r10 <= 1 || A$3(F10, E10) > te2) && (M10.push(E10), F10 = E10), H10 = i10, X10 = s10;
  }
  let P10 = e10[0].point.slice(0, 2), k10 = e10.length > 1 ? e10[e10.length - 1].point.slice(0, 2) : l$6(e10[0].point, [1, 1]), Q10 = [], N10 = [];
  if (e10.length === 1) {
    if (!(g10 || T10) || D10) {
      let r10 = ee$2(P10, G$2(R$5(a$6(P10, k10))), -(U10 || m10)), i10 = [];
      for (let o10 = 1 / 13, s10 = o10; s10 <= 1; s10 += o10) i10.push(L$3(r10, P10, V$2 * 2 * s10));
      return i10;
    }
  } else {
    if (!(g10 || T10 && e10.length === 1)) if (S10) for (let i10 = 1 / 13, o10 = i10; o10 <= 1; o10 += i10) {
      let s10 = L$3(M10[0], P10, V$2 * o10);
      Q10.push(s10);
    }
    else {
      let i10 = a$6(_10[0], M10[0]), o10 = b$4(i10, 0.5), s10 = b$4(i10, 0.51);
      Q10.push(a$6(P10, o10), a$6(P10, s10), l$6(P10, s10), l$6(P10, o10));
    }
    let r10 = R$5(se$1(e10[e10.length - 1].vector));
    if (T10 || g10 && e10.length === 1) N10.push(k10);
    else if (q10) {
      let i10 = ee$2(k10, r10, m10);
      for (let o10 = 1 / 29, s10 = o10; s10 < 1; s10 += o10) N10.push(L$3(i10, k10, V$2 * 3 * s10));
    } else N10.push(l$6(k10, b$4(r10, m10)), l$6(k10, b$4(r10, m10 * 0.99)), a$6(k10, b$4(r10, m10 * 0.99)), a$6(k10, b$4(r10, m10)));
  }
  return _10.concat(N10, M10.reverse(), Q10);
}
function me$1(e10, t10 = {}) {
  var q10;
  let { streamline: u10 = 0.5, size: x10 = 16, last: h10 = false } = t10;
  if (e10.length === 0) return [];
  let y10 = 0.15 + (1 - u10) * 0.85, n10 = Array.isArray(e10[0]) ? e10 : e10.map(({ x: c10, y: p10, pressure: g10 = 0.5 }) => [c10, p10, g10]);
  if (n10.length === 2) {
    let c10 = n10[1];
    n10 = n10.slice(0, -1);
    for (let p10 = 1; p10 < 5; p10++) n10.push(K$2(n10[0], c10, p10 / 4));
  }
  n10.length === 1 && (n10 = [...n10, [...l$6(n10[0], [1, 1]), ...n10[0].slice(2)]]);
  let f10 = [{ point: [n10[0][0], n10[0][1]], pressure: n10[0][2] >= 0 ? n10[0][2] : 0.25, vector: [1, 1], distance: 0, runningLength: 0 }], d10 = false, D10 = 0, S10 = f10[0], j10 = n10.length - 1;
  for (let c10 = 1; c10 < n10.length; c10++) {
    let p10 = h10 && c10 === j10 ? n10[c10].slice(0, 2) : K$2(S10.point, n10[c10], y10);
    if (ue(S10.point, p10)) continue;
    let g10 = ie$1(p10, S10.point);
    if (D10 += g10, c10 < j10 && !d10) {
      if (D10 < x10) continue;
      d10 = true;
    }
    S10 = { point: p10, pressure: n10[c10][2] >= 0 ? n10[c10][2] : 0.5, vector: G$2(a$6(S10.point, p10)), distance: g10, runningLength: D10 }, f10.push(S10);
  }
  return f10[0].vector = ((q10 = f10[1]) == null ? void 0 : q10.vector) || [0, 0], f10;
}
function ae(e10, t10 = {}) {
  return ce$1(me$1(e10, t10), t10);
}
var _e$1 = ae;
var A$2 = Object.defineProperty, M$1 = Object.defineProperties;
var q$1 = Object.getOwnPropertyDescriptors;
var X$1 = Object.getOwnPropertySymbols;
var V$1 = Object.prototype.hasOwnProperty, $$1 = Object.prototype.propertyIsEnumerable;
var Y$1 = (e10, n10, t10) => n10 in e10 ? A$2(e10, n10, { enumerable: true, configurable: true, writable: true, value: t10 }) : e10[n10] = t10, g$4 = (e10, n10) => {
  for (var t10 in n10 || (n10 = {})) V$1.call(n10, t10) && Y$1(e10, t10, n10[t10]);
  if (X$1) for (var t10 of X$1(n10)) $$1.call(n10, t10) && Y$1(e10, t10, n10[t10]);
  return e10;
}, T$3 = (e10, n10) => M$1(e10, q$1(n10));
function l$5(e10, ...n10) {
  return { didIntersect: n10.length > 0, message: e10, points: n10 };
}
function I$1(e10, n10, t10 = 0) {
  let r10 = [e10[0] + n10[0] / 2, e10[1] + n10[1] / 2], i10 = e$3.rotWith(e10, r10, t10), u10 = e$3.rotWith(e$3.add(e10, [n10[0], 0]), r10, t10), s10 = e$3.rotWith(e$3.add(e10, n10), r10, t10), o10 = e$3.rotWith(e$3.add(e10, [0, n10[1]]), r10, t10);
  return [["top", [i10, u10]], ["right", [u10, s10]], ["bottom", [s10, o10]], ["left", [o10, i10]]];
}
function v$4(e10, n10, t10) {
  if (t10 === e10 || t10 === n10) return true;
  let r10 = Math.PI * 2, i10 = (n10 - e10 + r10) % r10, u10 = (t10 - e10 + r10) % r10;
  return i10 <= Math.PI != u10 > i10;
}
function ie(e10, n10) {
  let t10 = e$3.slope(e10[0], e10[1]), r10 = e$3.slope(n10[0], n10[1]);
  if (t10 === r10) return;
  if (Number.isNaN(t10) && !Number.isNaN(r10)) return [e10[0][0], (e10[0][0] - n10[0][0]) * r10 + n10[0][1]];
  if (Number.isNaN(r10) && !Number.isNaN(t10)) return [n10[0][0], (n10[0][0] - e10[0][0]) * t10 + e10[0][1]];
  let i10 = (t10 * e10[0][0] - r10 * n10[0][0] + n10[0][1] - e10[0][1]) / (t10 - r10), u10 = r10 * (i10 - n10[0][0]) + n10[0][1];
  return [i10, u10];
}
function x$4(e10, n10, t10, r10) {
  let [i10, u10] = e10, [s10, o10] = n10, [c10, m10] = t10, [b10, f10] = r10;
  if (o10 / s10 !== (f10 - m10) / (b10 - c10)) {
    let p10 = s10 * (f10 - m10) - o10 * (b10 - c10);
    if (p10 !== 0) {
      let L10 = ((u10 - m10) * (b10 - c10) - (i10 - c10) * (f10 - m10)) / p10, h10 = ((u10 - m10) * s10 - (i10 - c10) * o10) / p10;
      if (L10 >= 0 && h10 >= 0 && h10 <= 1) return l$5("intersection", [i10 + L10 * s10, u10 + L10 * o10]);
    }
  }
  return l$5("no intersection");
}
function N$2(e10, n10, t10, r10, i10 = 0) {
  return G$1(t10, r10, i10, e10, n10);
}
function F$1(e10, n10, t10, r10, i10, u10) {
  let s10 = e10, o10 = e$3.mul(n10, 999999999);
  return y$4(s10, o10, t10, r10, i10, u10);
}
function se(e10, n10, t10, r10 = 0) {
  let { minX: i10, minY: u10, width: s10, height: o10 } = t10;
  return N$2(e10, n10, [i10, u10], [s10, o10], r10);
}
function B$1(e10, n10, t10, r10) {
  let i10 = e$3.sub(e10, t10), u10 = e$3.sub(r10, t10), s10 = e$3.sub(n10, e10), o10 = u10[0] * i10[1] - u10[1] * i10[0], c10 = s10[0] * i10[1] - s10[1] * i10[0], m10 = u10[1] * s10[0] - u10[0] * s10[1];
  if (o10 === 0 || c10 === 0) return l$5("coincident");
  if (m10 === 0) return l$5("parallel");
  if (m10 !== 0) {
    let b10 = o10 / m10, f10 = c10 / m10;
    if (0 <= b10 && b10 <= 1 && 0 <= f10 && f10 <= 1) return l$5("intersection", e$3.add(e10, e$3.mul(s10, b10)));
  }
  return l$5("no intersection");
}
function j$1(e10, n10, t10, r10) {
  return E$3(t10, r10, e10, n10);
}
function k$4(e10, n10, t10, r10, i10, u10) {
  let s10 = e$3.angle(t10, i10), o10 = e$3.angle(t10, u10), c10 = U$2(t10, r10, r10, 0, e10, n10);
  if (!c10.didIntersect) return l$5("no intersection");
  let m10 = c10.points.filter((b10) => v$4(s10, o10, e$3.angle(t10, b10)));
  return m10.length === 0 ? l$5("no intersection") : l$5("intersection", ...m10);
}
function R$4(e10, n10, t10, r10) {
  let i10 = (n10[0] - e10[0]) * (n10[0] - e10[0]) + (n10[1] - e10[1]) * (n10[1] - e10[1]), u10 = 2 * ((n10[0] - e10[0]) * (e10[0] - t10[0]) + (n10[1] - e10[1]) * (e10[1] - t10[1])), s10 = t10[0] * t10[0] + t10[1] * t10[1] + e10[0] * e10[0] + e10[1] * e10[1] - 2 * (t10[0] * e10[0] + t10[1] * e10[1]) - r10 * r10, o10 = u10 * u10 - 4 * i10 * s10;
  if (o10 < 0) return l$5("outside");
  if (o10 === 0) return l$5("tangent");
  let c10 = Math.sqrt(o10), m10 = (-u10 + c10) / (2 * i10), b10 = (-u10 - c10) / (2 * i10);
  if ((m10 < 0 || m10 > 1) && (b10 < 0 || b10 > 1)) return m10 < 0 && b10 < 0 || m10 > 1 && b10 > 1 ? l$5("outside") : l$5("inside");
  let f10 = [];
  return 0 <= m10 && m10 <= 1 && f10.push(e$3.lrp(e10, n10, m10)), 0 <= b10 && b10 <= 1 && f10.push(e$3.lrp(e10, n10, b10)), l$5("intersection", ...f10);
}
function y$4(e10, n10, t10, r10, i10, u10 = 0) {
  if (r10 === 0 || i10 === 0 || e$3.isEqual(e10, n10)) return l$5("no intersection");
  r10 = r10 < 0 ? r10 : -r10, i10 = i10 < 0 ? i10 : -i10, e10 = e$3.sub(e$3.rotWith(e10, t10, -u10), t10), n10 = e$3.sub(e$3.rotWith(n10, t10, -u10), t10);
  let s10 = e$3.sub(n10, e10), o10 = s10[0] * s10[0] / r10 / r10 + s10[1] * s10[1] / i10 / i10, c10 = 2 * e10[0] * s10[0] / r10 / r10 + 2 * e10[1] * s10[1] / i10 / i10, m10 = e10[0] * e10[0] / r10 / r10 + e10[1] * e10[1] / i10 / i10 - 1, b10 = [], f10 = c10 * c10 - 4 * o10 * m10;
  if (f10 === 0) b10.push(-c10 / 2 / o10);
  else if (f10 > 0) {
    let L10 = Math.sqrt(f10);
    b10.push((-c10 + L10) / 2 / o10), b10.push((-c10 - L10) / 2 / o10);
  }
  let p10 = b10.filter((L10) => L10 >= 0 && L10 <= 1).map((L10) => e$3.add(t10, e$3.add(e10, e$3.mul(e$3.sub(n10, e10), L10)))).map((L10) => e$3.rotWith(L10, t10, u10));
  return l$5("intersection", ...p10);
}
function ce(e10, n10, t10) {
  return z$2(t10, e10, n10);
}
function S$3(e10, n10, t10) {
  let r10 = [];
  for (let i10 = 1; i10 < t10.length; i10++) {
    let u10 = B$1(e10, n10, t10[i10 - 1], t10[i10]);
    u10 && r10.push(...u10.points);
  }
  return r10.length === 0 ? l$5("no intersection") : l$5("intersection", ...t10);
}
function D$3(e10, n10, t10) {
  let r10 = [];
  for (let i10 = 1; i10 < t10.length + 1; i10++) {
    let u10 = B$1(e10, n10, t10[i10 - 1], t10[i10 % t10.length]);
    u10 && r10.push(...u10.points);
  }
  return r10.length === 0 ? l$5("no intersection") : l$5("intersection", ...t10);
}
function G$1(e10, n10, t10, r10, i10) {
  return I$1(e10, n10, t10).reduce((s10, [o10, [c10, m10]]) => {
    let b10 = x$4(r10, i10, c10, m10);
    return b10 && s10.push(l$5(o10, ...b10.points)), s10;
  }, []).filter((s10) => s10.didIntersect);
}
function E$3(e10, n10, t10, r10) {
  return I$1(e10, n10).reduce((u10, [s10, [o10, c10]]) => {
    let m10 = B$1(t10, r10, o10, c10);
    return m10 && u10.push(l$5(s10, ...m10.points)), u10;
  }, []).filter((u10) => u10.didIntersect);
}
function a$5(e10, n10, t10, r10) {
  return I$1(e10, n10).reduce((u10, [s10, [o10, c10]]) => {
    let m10 = E$3(t10, r10, o10, c10);
    return u10.push(...m10.map((b10) => l$5(`${s10} ${b10.message}`, ...b10.points))), u10;
  }, []).filter((u10) => u10.didIntersect);
}
function H$4(e10, n10, t10, r10, i10, u10) {
  return I$1(e10, n10).reduce((o10, [c10, [m10, b10]]) => {
    let f10 = O$3(t10, r10, i10, u10, m10, b10);
    return f10 && o10.push(T$3(g$4({}, f10), { message: c10 })), o10;
  }, []).filter((o10) => o10.didIntersect);
}
function C$3(e10, n10, t10, r10) {
  return I$1(e10, n10).reduce((u10, [s10, [o10, c10]]) => {
    let m10 = R$4(o10, c10, t10, r10);
    return m10 && u10.push(T$3(g$4({}, m10), { message: s10 })), u10;
  }, []).filter((u10) => u10.didIntersect);
}
function J$1(e10, n10, t10, r10, i10, u10 = 0) {
  return I$1(e10, n10).reduce((o10, [c10, [m10, b10]]) => {
    let f10 = y$4(m10, b10, t10, r10, i10, u10);
    return f10 && o10.push(T$3(g$4({}, f10), { message: c10 })), o10;
  }, []).filter((o10) => o10.didIntersect);
}
function w$4(e10, n10, t10) {
  return I$1(e10, n10).reduce((i10, [u10, [s10, o10]]) => {
    let c10 = S$3(s10, o10, t10);
    return c10.didIntersect && i10.push(l$5(u10, ...c10.points)), i10;
  }, []).filter((i10) => i10.didIntersect);
}
function K$1(e10, n10, t10) {
  return I$1(e10, n10).reduce((i10, [u10, [s10, o10]]) => {
    let c10 = D$3(s10, o10, t10);
    return c10.didIntersect && i10.push(l$5(u10, ...c10.points)), i10;
  }, []).filter((i10) => i10.didIntersect);
}
function O$3(e10, n10, t10, r10, i10, u10) {
  return k$4(i10, u10, e10, n10, t10, r10);
}
function _$1(e10, n10, t10, r10, i10, u10) {
  return H$4(i10, u10, e10, n10, t10, r10);
}
function be$2(e10, n10, t10, r10, i10) {
  let { minX: u10, minY: s10, width: o10, height: c10 } = i10;
  return _$1(e10, n10, t10, r10, [u10, s10], [o10, c10]);
}
function de(e10, n10, t10, r10) {
  return R$4(t10, r10, e10, n10);
}
function le(e10, n10, t10, r10) {
  let i10 = t10[0] - e10[0], u10 = t10[1] - e10[1], s10 = Math.sqrt(i10 * i10 + u10 * u10), o10 = (s10 * s10 - r10 * r10 + n10 * n10) / (2 * s10), c10 = Math.sqrt(n10 * n10 - o10 * o10);
  return i10 /= s10, u10 /= s10, l$5("intersection", [e10[0] + i10 * o10 - u10 * c10, e10[1] + u10 * o10 + i10 * c10], [e10[0] + i10 * o10 + u10 * c10, e10[1] + u10 * o10 - i10 * c10]);
}
function U$2(e10, n10, t10, r10 = 0, i10, u10) {
  return n10 === t10 ? R$4(i10, u10, e10, n10) : y$4(i10, u10, e10, n10, t10, r10);
}
function W$2(e10, n10, t10, r10 = 0, i10, u10) {
  return n10 === t10 ? C$3(i10, u10, e10, n10) : J$1(i10, u10, e10, n10, t10, r10);
}
function pe$1(e10, n10, t10, r10, i10) {
  let { minX: u10, minY: s10, width: o10, height: c10 } = i10;
  return W$2(e10, n10, t10, r10, [u10, s10], [o10, c10]);
}
function z$2(e10, n10, t10) {
  let { minX: r10, minY: i10, width: u10, height: s10 } = e10;
  return j$1(n10, t10, [r10, i10], [u10, s10]);
}
function Te(e10, n10) {
  return a$5([e10.minX, e10.minY], [e10.width, e10.height], [n10.minX, n10.minY], [n10.width, n10.height]);
}
function ye$1(e10, n10) {
  return Q$1(n10, e10);
}
function Se(e10, n10) {
  return ee$1(n10, e10);
}
function Q$1(e10, n10) {
  return w$4([n10.minX, n10.minY], [n10.width, n10.height], e10);
}
function ee$1(e10, n10) {
  return K$1([n10.minX, n10.minY], [n10.width, n10.height], e10);
}
var qt = Object.defineProperty, Qt = Object.defineProperties;
var Jt = Object.getOwnPropertyDescriptors;
var Ce = Object.getOwnPropertySymbols;
var Ze = Object.prototype.hasOwnProperty, qe = Object.prototype.propertyIsEnumerable;
var Oe = (r10, e10, t10) => e10 in r10 ? qt(r10, e10, { enumerable: true, configurable: true, writable: true, value: t10 }) : r10[e10] = t10, g$3 = (r10, e10) => {
  for (var t10 in e10 || (e10 = {})) Ze.call(e10, t10) && Oe(r10, t10, e10[t10]);
  if (Ce) for (var t10 of Ce(e10)) qe.call(e10, t10) && Oe(r10, t10, e10[t10]);
  return r10;
}, U$1 = (r10, e10) => Qt(r10, Jt(e10));
var O$2 = (r10, e10) => {
  var t10 = {};
  for (var n10 in r10) Ze.call(r10, n10) && e10.indexOf(n10) < 0 && (t10[n10] = r10[n10]);
  if (r10 != null && Ce) for (var n10 of Ce(r10)) e10.indexOf(n10) < 0 && qe.call(r10, n10) && (t10[n10] = r10[n10]);
  return t10;
};
var E$2 = (r10, e10, t10) => (Oe(r10, typeof e10 != "symbol" ? e10 + "" : e10, t10), t10);
var Le$1 = reactExports.createContext({});
function R$3() {
  return reactExports.useContext(Le$1);
}
var Qe$1 = ((o10) => (o10.TransformSelected = "transform_selected", o10.TranslateSelected = "translate_selected", o10.TransformAll = "transform_all", o10.TranslateAll = "translate_all", o10))(Qe$1 || {}), we = ((o10) => (o10.Top = "top_edge", o10.Right = "right_edge", o10.Bottom = "bottom_edge", o10.Left = "left_edge", o10))(we || {}), He$1 = ((o10) => (o10.TopLeft = "top_left_corner", o10.TopRight = "top_right_corner", o10.BottomRight = "bottom_right_corner", o10.BottomLeft = "bottom_left_corner", o10))(He$1 || {}), Je$1 = ((s10) => (s10.minX = "minX", s10.midX = "midX", s10.maxX = "maxX", s10.minY = "minY", s10.midY = "midY", s10.maxY = "maxY", s10))(Je$1 || {});
String.prototype.replaceAll || (String.prototype.replaceAll = function(r10, e10) {
  return Object.prototype.toString.call(r10).toLowerCase() === "[object regexp]" ? this.replace(r10, e10) : this.replace(new RegExp(r10, "g"), e10);
});
var Ie$1 = Math.PI * 2, k$3 = class k {
  static lerp(e10, t10, n10) {
    return n10 = k$3.clamp(n10, 0, 1), e10 * (1 - n10) + t10 * n10;
  }
  static lerpColor(e10, t10, n10 = 0.5) {
    function o10(l10) {
      let c10 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(l10);
      return [parseInt(c10[1], 16), parseInt(c10[2], 16), parseInt(c10[3], 16)];
    }
    function i10(l10) {
      return "#" + ((1 << 24) + (l10[0] << 16) + (l10[1] << 8) + l10[2]).toString(16).slice(1);
    }
    let s10 = o10(e10) || [0, 0, 0], a10 = o10(t10) || [0, 0, 0], d10 = s10.slice();
    for (let l10 = 0; l10 < 3; l10++) d10[l10] = Math.round(d10[l10] + n10 * (a10[l10] - s10[l10]));
    return i10(d10);
  }
  static modulate(e10, t10, n10, o10 = false) {
    let [i10, s10] = t10, [a10, d10] = n10, l10 = a10 + (e10 - i10) / (s10 - i10) * (d10 - a10);
    return o10 ? a10 < d10 ? Math.max(Math.min(l10, d10), a10) : Math.max(Math.min(l10, a10), d10) : l10;
  }
  static clamp(e10, t10, n10) {
    return Math.max(t10, typeof n10 != "undefined" ? Math.min(e10, n10) : e10);
  }
  static deepClone(e10) {
    if (e10 === null) return e10;
    if (Array.isArray(e10)) return [...e10];
    if (typeof e10 == "object") {
      let t10 = g$3({}, e10);
      return Object.keys(t10).forEach((n10) => t10[n10] = typeof e10[n10] == "object" ? k$3.deepClone(e10[n10]) : e10[n10]), t10;
    }
    return e10;
  }
  static rng(e10 = "") {
    let t10 = 0, n10 = 0, o10 = 0, i10 = 0;
    function s10() {
      let a10 = t10 ^ t10 << 11;
      return t10 = n10, n10 = o10, o10 = i10, i10 ^= (i10 >>> 19 ^ a10 ^ a10 >>> 8) >>> 0, i10 / 4294967296;
    }
    for (let a10 = 0; a10 < e10.length + 64; a10++) t10 ^= e10.charCodeAt(a10) | 0, s10();
    return s10;
  }
  static pointsToLineSegments(e10, t10 = false) {
    let n10 = [];
    for (let o10 = 1; o10 < e10.length; o10++) n10.push([e10[o10 - 1], e10[o10]]);
    return t10 && n10.push([e10[e10.length - 1], e10[0]]), n10;
  }
  static getRectangleSides(e10, t10, n10 = 0) {
    let o10 = [e10[0] + t10[0] / 2, e10[1] + t10[1] / 2], i10 = e$3.rotWith(e10, o10, n10), s10 = e$3.rotWith(e$3.add(e10, [t10[0], 0]), o10, n10), a10 = e$3.rotWith(e$3.add(e10, t10), o10, n10), d10 = e$3.rotWith(e$3.add(e10, [0, t10[1]]), o10, n10);
    return [["top", [i10, s10]], ["right", [s10, a10]], ["bottom", [a10, d10]], ["left", [d10, i10]]];
  }
  static circleFromThreePoints(e10, t10, n10) {
    let [o10, i10] = e10, [s10, a10] = t10, [d10, l10] = n10, c10 = o10 * (a10 - l10) - i10 * (s10 - d10) + s10 * l10 - d10 * a10, m10 = (o10 * o10 + i10 * i10) * (l10 - a10) + (s10 * s10 + a10 * a10) * (i10 - l10) + (d10 * d10 + l10 * l10) * (a10 - i10), p10 = (o10 * o10 + i10 * i10) * (s10 - d10) + (s10 * s10 + a10 * a10) * (d10 - o10) + (d10 * d10 + l10 * l10) * (o10 - s10), u10 = -m10 / (2 * c10), y10 = -p10 / (2 * c10);
    return [u10, y10, Math.hypot(u10 - o10, y10 - i10)];
  }
  static perimeterOfEllipse(e10, t10) {
    let n10 = Math.pow(e10 - t10, 2) / Math.pow(e10 + t10, 2);
    return Math.PI * (e10 + t10) * (1 + 3 * n10 / (10 + Math.sqrt(4 - 3 * n10)));
  }
  static shortAngleDist(e10, t10) {
    let n10 = Math.PI * 2, o10 = (t10 - e10) % n10;
    return 2 * o10 % n10 - o10;
  }
  static longAngleDist(e10, t10) {
    return Math.PI * 2 - k$3.shortAngleDist(e10, t10);
  }
  static lerpAngles(e10, t10, n10) {
    return e10 + k$3.shortAngleDist(e10, t10) * n10;
  }
  static angleDelta(e10, t10) {
    return k$3.shortAngleDist(e10, t10);
  }
  static getSweep(e10, t10, n10) {
    return k$3.angleDelta(e$3.angle(e10, t10), e$3.angle(e10, n10));
  }
  static clampRadians(e10) {
    return (Math.PI * 2 + e10) % (Math.PI * 2);
  }
  static snapAngleToSegments(e10, t10) {
    let n10 = Math.PI * 2 / t10;
    return Math.floor((k$3.clampRadians(e10) + n10 / 2) / n10) * n10;
  }
  static isAngleBetween(e10, t10, n10) {
    if (n10 === e10 || n10 === t10) return true;
    let o10 = (t10 - e10 + Ie$1) % Ie$1, i10 = (n10 - e10 + Ie$1) % Ie$1;
    return o10 <= Math.PI != i10 > o10;
  }
  static degreesToRadians(e10) {
    return e10 * Math.PI / 180;
  }
  static radiansToDegrees(e10) {
    return e10 * 180 / Math.PI;
  }
  static getArcLength(e10, t10, n10, o10) {
    let i10 = k$3.getSweep(e10, n10, o10);
    return t10 * (2 * Math.PI) * (i10 / (2 * Math.PI));
  }
  static getSweepFlag(e10, t10, n10) {
    let o10 = e$3.angle(e10, n10);
    return (e$3.angle(e10, t10) - o10 + 3 * Math.PI) % (2 * Math.PI) - Math.PI > 0 ? 0 : 1;
  }
  static getLargeArcFlag(e10, t10, n10) {
    let o10 = e$3.angle(n10, e10), s10 = (e$3.angle(n10, t10) - o10 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return Math.abs(s10) > Math.PI / 2 ? 0 : 1;
  }
  static getArcDashOffset(e10, t10, n10, o10, i10) {
    let s10 = k$3.getSweepFlag(e10, n10, o10), a10 = k$3.getArcLength(e10, t10, n10, o10);
    return -(s10 < 0 ? a10 : 2 * Math.PI * e10[2] - a10) / 2 + i10;
  }
  static getEllipseDashOffset(e10, t10) {
    return -(2 * Math.PI * e10[2]) / 2 + -t10;
  }
  static pointInCircle(e10, t10, n10) {
    return e$3.dist(e10, t10) <= n10;
  }
  static pointInEllipse(e10, t10, n10, o10, i10 = 0) {
    i10 = i10 || 0;
    let s10 = Math.cos(i10), a10 = Math.sin(i10), d10 = e$3.sub(e10, t10), l10 = s10 * d10[0] + a10 * d10[1], c10 = a10 * d10[0] - s10 * d10[1];
    return l10 * l10 / (n10 * n10) + c10 * c10 / (o10 * o10) <= 1;
  }
  static pointInRect(e10, t10) {
    return !(e10[0] < t10[0] || e10[0] > e10[0] + t10[0] || e10[1] < t10[1] || e10[1] > e10[1] + t10[1]);
  }
  static pointInPolygon(e10, t10) {
    let n10 = 0;
    return t10.forEach((o10, i10) => {
      let s10 = t10[(i10 + 1) % t10.length];
      o10[1] <= e10[1] ? s10[1] > e10[1] && e$3.cross(o10, s10, e10) > 0 && (n10 += 1) : s10[1] <= e10[1] && e$3.cross(o10, s10, e10) < 0 && (n10 -= 1);
    }), n10 !== 0;
  }
  static pointInBounds(e10, t10) {
    return !(e10[0] < t10.minX || e10[0] > t10.maxX || e10[1] < t10.minY || e10[1] > t10.maxY);
  }
  static pointInPolyline(e10, t10, n10 = 3) {
    for (let o10 = 1; o10 < t10.length; o10++) if (e$3.distanceToLineSegment(t10[o10 - 1], t10[o10], e10) < n10) return true;
    return false;
  }
  static getBoundsSides(e10) {
    return this.getRectangleSides([e10.minX, e10.minY], [e10.width, e10.height]);
  }
  static expandBounds(e10, t10) {
    return { minX: e10.minX - t10, minY: e10.minY - t10, maxX: e10.maxX + t10, maxY: e10.maxY + t10, width: e10.width + t10 * 2, height: e10.height + t10 * 2 };
  }
  static boundsCollide(e10, t10) {
    return !(e10.maxX < t10.minX || e10.minX > t10.maxX || e10.maxY < t10.minY || e10.minY > t10.maxY);
  }
  static boundsContain(e10, t10) {
    return e10.minX < t10.minX && e10.minY < t10.minY && e10.maxY > t10.maxY && e10.maxX > t10.maxX;
  }
  static boundsContained(e10, t10) {
    return k$3.boundsContain(t10, e10);
  }
  static boundsAreEqual(e10, t10) {
    return !(t10.maxX !== e10.maxX || t10.minX !== e10.minX || t10.maxY !== e10.maxY || t10.minY !== e10.minY);
  }
  static getBoundsFromPoints(e10, t10 = 0) {
    let n10 = 1 / 0, o10 = 1 / 0, i10 = -1 / 0, s10 = -1 / 0;
    if (e10.length < 2) n10 = 0, o10 = 0, i10 = 1, s10 = 1;
    else for (let [a10, d10] of e10) n10 = Math.min(a10, n10), o10 = Math.min(d10, o10), i10 = Math.max(a10, i10), s10 = Math.max(d10, s10);
    return t10 !== 0 ? k$3.getBoundsFromPoints(e10.map((a10) => e$3.rotWith(a10, [(n10 + i10) / 2, (o10 + s10) / 2], t10))) : { minX: n10, minY: o10, maxX: i10, maxY: s10, width: Math.max(1, i10 - n10), height: Math.max(1, s10 - o10) };
  }
  static centerBounds(e10, t10) {
    let n10 = this.getBoundsCenter(e10), o10 = t10[0] - n10[0], i10 = t10[1] - n10[1];
    return this.translateBounds(e10, [o10, i10]);
  }
  static snapBoundsToGrid(e10, t10) {
    let n10 = Math.round(e10.minX / t10) * t10, o10 = Math.round(e10.minY / t10) * t10, i10 = Math.round(e10.maxX / t10) * t10, s10 = Math.round(e10.maxY / t10) * t10;
    return { minX: n10, minY: o10, maxX: i10, maxY: s10, width: Math.max(1, i10 - n10), height: Math.max(1, s10 - o10) };
  }
  static translateBounds(e10, t10) {
    return { minX: e10.minX + t10[0], minY: e10.minY + t10[1], maxX: e10.maxX + t10[0], maxY: e10.maxY + t10[1], width: e10.width, height: e10.height };
  }
  static rotateBounds(e10, t10, n10) {
    let [o10, i10] = e$3.rotWith([e10.minX, e10.minY], t10, n10), [s10, a10] = e$3.rotWith([e10.maxX, e10.maxY], t10, n10);
    return { minX: o10, minY: i10, maxX: s10, maxY: a10, width: e10.width, height: e10.height };
  }
  static getRotatedEllipseBounds(e10, t10, n10, o10, i10 = 0) {
    let s10 = Math.cos(i10), a10 = Math.sin(i10), d10 = Math.hypot(n10 * s10, o10 * a10), l10 = Math.hypot(n10 * a10, o10 * s10);
    return { minX: e10 + n10 - d10, minY: t10 + o10 - l10, maxX: e10 + n10 + d10, maxY: t10 + o10 + l10, width: d10 * 2, height: l10 * 2 };
  }
  static getExpandedBounds(e10, t10) {
    let n10 = Math.min(e10.minX, t10.minX), o10 = Math.min(e10.minY, t10.minY), i10 = Math.max(e10.maxX, t10.maxX), s10 = Math.max(e10.maxY, t10.maxY), a10 = Math.abs(i10 - n10), d10 = Math.abs(s10 - o10);
    return { minX: n10, minY: o10, maxX: i10, maxY: s10, width: a10, height: d10 };
  }
  static getCommonBounds(e10) {
    if (e10.length < 2) return e10[0];
    let t10 = e10[0];
    for (let n10 = 1; n10 < e10.length; n10++) t10 = k$3.getExpandedBounds(t10, e10[n10]);
    return t10;
  }
  static getRotatedCorners(e10, t10 = 0) {
    let n10 = [e10.minX + e10.width / 2, e10.minY + e10.height / 2];
    return [[e10.minX, e10.minY], [e10.maxX, e10.minY], [e10.maxX, e10.maxY], [e10.minX, e10.maxY]].map((o10) => e$3.rotWith(o10, n10, t10));
  }
  static getTransformedBoundingBox(e10, t10, n10, o10 = 0, i10 = false) {
    let [s10, a10] = [e10.minX, e10.minY], [d10, l10] = [e10.maxX, e10.maxY], [c10, m10] = [e10.minX, e10.minY], [p10, u10] = [e10.maxX, e10.maxY];
    if (t10 === "center") return { minX: c10 + n10[0], minY: m10 + n10[1], maxX: p10 + n10[0], maxY: u10 + n10[1], width: p10 - c10, height: u10 - m10, scaleX: 1, scaleY: 1 };
    let [y10, T10] = e$3.rot(n10, -o10);
    switch (t10) {
      case "top_edge":
      case "top_left_corner":
      case "top_right_corner": {
        m10 += T10;
        break;
      }
      case "bottom_edge":
      case "bottom_left_corner":
      case "bottom_right_corner": {
        u10 += T10;
        break;
      }
    }
    switch (t10) {
      case "left_edge":
      case "top_left_corner":
      case "bottom_left_corner": {
        c10 += y10;
        break;
      }
      case "right_edge":
      case "top_right_corner":
      case "bottom_right_corner": {
        p10 += y10;
        break;
      }
    }
    let v10 = d10 - s10, x10 = l10 - a10, f10 = (p10 - c10) / v10, L10 = (u10 - m10) / x10, Y10 = f10 < 0, X10 = L10 < 0, S10 = Math.abs(p10 - c10), b10 = Math.abs(u10 - m10);
    if (i10) {
      let P10 = v10 / x10, B10 = P10 < S10 / b10, M10 = S10 * (L10 < 0 ? 1 : -1) * (1 / P10), I10 = b10 * (f10 < 0 ? 1 : -1) * P10;
      switch (t10) {
        case "top_left_corner": {
          B10 ? m10 = u10 + M10 : c10 = p10 + I10;
          break;
        }
        case "top_right_corner": {
          B10 ? m10 = u10 + M10 : p10 = c10 - I10;
          break;
        }
        case "bottom_right_corner": {
          B10 ? u10 = m10 - M10 : p10 = c10 - I10;
          break;
        }
        case "bottom_left_corner": {
          B10 ? u10 = m10 - M10 : c10 = p10 + I10;
          break;
        }
        case "bottom_edge":
        case "top_edge": {
          let A10 = (c10 + p10) / 2, J10 = b10 * P10;
          c10 = A10 - J10 / 2, p10 = A10 + J10 / 2;
          break;
        }
        case "left_edge":
        case "right_edge": {
          let A10 = (m10 + u10) / 2, J10 = S10 / P10;
          m10 = A10 - J10 / 2, u10 = A10 + J10 / 2;
          break;
        }
      }
    }
    if (o10 % (Math.PI * 2) !== 0) {
      let P10 = [0, 0], B10 = e$3.med([s10, a10], [d10, l10]), M10 = e$3.med([c10, m10], [p10, u10]);
      switch (t10) {
        case "top_left_corner": {
          P10 = e$3.sub(e$3.rotWith([p10, u10], M10, o10), e$3.rotWith([d10, l10], B10, o10));
          break;
        }
        case "top_right_corner": {
          P10 = e$3.sub(e$3.rotWith([c10, u10], M10, o10), e$3.rotWith([s10, l10], B10, o10));
          break;
        }
        case "bottom_right_corner": {
          P10 = e$3.sub(e$3.rotWith([c10, m10], M10, o10), e$3.rotWith([s10, a10], B10, o10));
          break;
        }
        case "bottom_left_corner": {
          P10 = e$3.sub(e$3.rotWith([p10, m10], M10, o10), e$3.rotWith([d10, a10], B10, o10));
          break;
        }
        case "top_edge": {
          P10 = e$3.sub(e$3.rotWith(e$3.med([c10, u10], [p10, u10]), M10, o10), e$3.rotWith(e$3.med([s10, l10], [d10, l10]), B10, o10));
          break;
        }
        case "left_edge": {
          P10 = e$3.sub(e$3.rotWith(e$3.med([p10, m10], [p10, u10]), M10, o10), e$3.rotWith(e$3.med([d10, a10], [d10, l10]), B10, o10));
          break;
        }
        case "bottom_edge": {
          P10 = e$3.sub(e$3.rotWith(e$3.med([c10, m10], [p10, m10]), M10, o10), e$3.rotWith(e$3.med([s10, a10], [d10, a10]), B10, o10));
          break;
        }
        case "right_edge": {
          P10 = e$3.sub(e$3.rotWith(e$3.med([c10, m10], [c10, u10]), M10, o10), e$3.rotWith(e$3.med([s10, a10], [s10, l10]), B10, o10));
          break;
        }
      }
      [c10, m10] = e$3.sub([c10, m10], P10), [p10, u10] = e$3.sub([p10, u10], P10);
    }
    return p10 < c10 && ([p10, c10] = [c10, p10]), u10 < m10 && ([u10, m10] = [m10, u10]), { minX: c10, minY: m10, maxX: p10, maxY: u10, width: p10 - c10, height: u10 - m10, scaleX: (p10 - c10) / (d10 - s10 || 1) * (Y10 ? -1 : 1), scaleY: (u10 - m10) / (l10 - a10 || 1) * (X10 ? -1 : 1) };
  }
  static getTransformAnchor(e10, t10, n10) {
    let o10 = e10;
    switch (e10) {
      case "top_left_corner": {
        t10 && n10 ? o10 = "bottom_right_corner" : t10 ? o10 = "top_right_corner" : n10 ? o10 = "bottom_left_corner" : o10 = "bottom_right_corner";
        break;
      }
      case "top_right_corner": {
        t10 && n10 ? o10 = "bottom_left_corner" : t10 ? o10 = "top_left_corner" : n10 ? o10 = "bottom_right_corner" : o10 = "bottom_left_corner";
        break;
      }
      case "bottom_right_corner": {
        t10 && n10 ? o10 = "top_left_corner" : t10 ? o10 = "bottom_left_corner" : n10 ? o10 = "top_right_corner" : o10 = "top_left_corner";
        break;
      }
      case "bottom_left_corner": {
        t10 && n10 ? o10 = "top_right_corner" : t10 ? o10 = "bottom_right_corner" : n10 ? o10 = "top_left_corner" : o10 = "top_right_corner";
        break;
      }
    }
    return o10;
  }
  static getRelativeTransformedBoundingBox(e10, t10, n10, o10, i10) {
    let s10 = (o10 ? t10.maxX - n10.maxX : n10.minX - t10.minX) / t10.width, a10 = (i10 ? t10.maxY - n10.maxY : n10.minY - t10.minY) / t10.height, d10 = n10.width / t10.width, l10 = n10.height / t10.height, c10 = e10.minX + e10.width * s10, m10 = e10.minY + e10.height * a10, p10 = e10.width * d10, u10 = e10.height * l10;
    return { minX: c10, minY: m10, maxX: c10 + p10, maxY: m10 + u10, width: p10, height: u10 };
  }
  static getRotatedSize(e10, t10) {
    let n10 = e$3.div(e10, 2), o10 = [[0, 0], [e10[0], 0], e10, [0, e10[1]]].map((s10) => e$3.rotWith(s10, n10, t10)), i10 = k$3.getBoundsFromPoints(o10);
    return [i10.width, i10.height];
  }
  static getBoundsCenter(e10) {
    return [e10.minX + e10.width / 2, e10.minY + e10.height / 2];
  }
  static getBoundsWithCenter(e10) {
    let t10 = k$3.getBoundsCenter(e10);
    return U$1(g$3({}, e10), { midX: t10[0], midY: t10[1] });
  }
  static getCommonTopLeft(e10) {
    let t10 = [1 / 0, 1 / 0];
    return e10.forEach((n10) => {
      t10[0] = Math.min(t10[0], n10[0]), t10[1] = Math.min(t10[1], n10[1]);
    }), t10;
  }
  static getFromCache(e10, t10, n10) {
    let o10 = e10.get(t10);
    if (o10 === void 0 && (e10.set(t10, n10()), o10 = e10.get(t10), o10 === void 0)) throw Error("Cache did not include item!");
    return o10;
  }
  static uniqueId(e10 = "") {
    return e10 ? ((Number(e10) ^ Math.random() * 16) >> Number(e10) / 4).toString(16) : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, k$3.uniqueId);
  }
  static rotateArray(e10, t10) {
    return e10.map((n10, o10) => e10[(o10 + t10) % e10.length]);
  }
  static debounce(e10, t10 = 0) {
    let n10;
    return function(...o10) {
      clearTimeout(n10), n10 = setTimeout(() => e10.apply(o10), t10);
    };
  }
  static getSvgPathFromStroke(e10, t10 = true) {
    let n10 = e10.length;
    if (n10 < 4) return "";
    let o10 = e10[0], i10 = e10[1], s10 = e10[2], a10 = `M${o10[0].toFixed(2)},${o10[1].toFixed(2)} Q${i10[0].toFixed(2)},${i10[1].toFixed(2)} ${ee(i10[0], s10[0]).toFixed(2)},${ee(i10[1], s10[1]).toFixed(2)} T`;
    for (let d10 = 2, l10 = n10 - 1; d10 < l10; d10++) o10 = e10[d10], i10 = e10[d10 + 1], a10 += `${ee(o10[0], i10[0]).toFixed(2)},${ee(o10[1], i10[1]).toFixed(2)} `;
    return t10 && (a10 += "Z"), a10;
  }
  static getSvgPathFromStrokePoints(e10, t10 = false) {
    let n10 = e10.length;
    if (n10 < 4) return "";
    let o10 = e10[0].point, i10 = e10[1].point, s10 = e10[2].point, a10 = `M${o10[0].toFixed(2)},${o10[1].toFixed(2)} Q${i10[0].toFixed(2)},${i10[1].toFixed(2)} ${ee(i10[0], s10[0]).toFixed(2)},${ee(i10[1], s10[1]).toFixed(2)} T`;
    for (let d10 = 2, l10 = n10 - 1; d10 < l10; d10++) o10 = e10[d10].point, i10 = e10[d10 + 1].point, a10 += `${ee(o10[0], i10[0]).toFixed(2)},${ee(o10[1], i10[1]).toFixed(2)} `;
    return t10 && (a10 += "Z"), a10;
  }
  static getPerfectDashProps(e10, t10, n10, o10 = 1, i10 = true, s10 = 2) {
    let a10, d10, l10;
    if (n10.toLowerCase() === "dashed") a10 = t10 * s10, l10 = 1, d10 = i10 ? (a10 / 2).toString() : "0";
    else if (n10.toLowerCase() === "dotted") a10 = t10 / 100, l10 = 100, d10 = "0";
    else return { strokeDasharray: "none", strokeDashoffset: "none" };
    let c10 = Math.floor(e10 / a10 / (2 * l10));
    c10 -= c10 % o10, c10 = Math.max(c10, 4);
    let m10 = Math.max(a10, (e10 - c10 * a10) / (i10 ? c10 : c10 - 1));
    return { strokeDasharray: [a10, m10].join(" "), strokeDashoffset: d10 };
  }
  static isMobileSafari() {
    if (typeof window == "undefined") return false;
    let e10 = window.navigator.userAgent, t10 = !!e10.match(/iPad/i) || !!e10.match(/iPhone/i), n10 = !!e10.match(/WebKit/i);
    return t10 && n10 && !e10.match(/CriOS/i);
  }
  static throttle(e10, t10) {
    let n10, o10;
    return function(...i10) {
      return n10 || (n10 = true, setTimeout(() => n10 = false, t10), o10 = e10(...i10)), o10;
    };
  }
  static isDarwin() {
    return /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  }
  static metaKey(e10) {
    return k$3.isDarwin() ? e10.metaKey : e10.ctrlKey;
  }
  static lns(e10) {
    let t10 = e10.split("");
    return t10.push(...t10.splice(0, Math.round(t10.length / 5))), t10.push(...t10.splice(0, Math.round(t10.length / 4))), t10.push(...t10.splice(0, Math.round(t10.length / 3))), t10.push(...t10.splice(0, Math.round(t10.length / 2))), t10.reverse().map((n10) => +n10 ? +n10 < 5 ? 5 + +n10 : +n10 > 5 ? +n10 - 5 : n10 : n10).join("");
  }
}, C$2 = k$3;
E$2(C$2, "getSnapPoints", (e10, t10, n10) => {
  let o10 = g$3({}, e10), i10 = [0, 0], s10 = [], a10 = { ["minX"]: { id: "minX", isSnapped: false }, ["midX"]: { id: "midX", isSnapped: false }, ["maxX"]: { id: "maxX", isSnapped: false }, ["minY"]: { id: "minY", isSnapped: false }, ["midY"]: { id: "midY", isSnapped: false }, ["maxY"]: { id: "maxY", isSnapped: false } }, d10 = ["midX", "minX", "maxX"], l10 = ["midY", "minY", "maxY"], c10 = t10.map((T10) => {
    let v10 = d10.flatMap((f10, L10) => d10.map((Y10, X10) => {
      let S10 = o10[f10] - T10[Y10], b10 = Math.abs(S10);
      return { f: f10, t: Y10, gap: S10, distance: b10, isCareful: L10 === 0 || L10 + X10 === 3 };
    })), x10 = l10.flatMap((f10, L10) => l10.map((Y10, X10) => {
      let S10 = o10[f10] - T10[Y10], b10 = Math.abs(S10);
      return { f: f10, t: Y10, gap: S10, distance: b10, isCareful: L10 === 0 || L10 + X10 === 3 };
    }));
    return [T10, v10, x10];
  }), m10 = 1 / 0, p10 = 1 / 0, u10 = 1 / 0, y10 = 1 / 0;
  return c10.forEach(([T10, v10, x10]) => {
    v10.forEach((f10) => {
      f10.distance < n10 && f10.distance < u10 && (u10 = f10.distance, m10 = f10.gap);
    }), x10.forEach((f10) => {
      f10.distance < n10 && f10.distance < y10 && (y10 = f10.distance, p10 = f10.gap);
    });
  }), c10.forEach(([T10, v10, x10]) => {
    m10 !== 1 / 0 && v10.forEach((f10) => {
      Math.abs(f10.gap - m10) < 2 && (a10[f10.f] = U$1(g$3({}, a10[f10.f]), { isSnapped: true, to: T10[f10.t], B: T10, distance: f10.distance }));
    }), p10 !== 1 / 0 && x10.forEach((f10) => {
      Math.abs(f10.gap - p10) < 2 && (a10[f10.f] = U$1(g$3({}, a10[f10.f]), { isSnapped: true, to: T10[f10.t], B: T10, distance: f10.distance }));
    });
  }), i10[0] = m10 === 1 / 0 ? 0 : m10, i10[1] = p10 === 1 / 0 ? 0 : p10, o10.minX -= i10[0], o10.midX -= i10[0], o10.maxX -= i10[0], o10.minY -= i10[1], o10.midY -= i10[1], o10.maxY -= i10[1], d10.forEach((T10) => {
    let v10 = a10[T10];
    if (!v10.isSnapped) return;
    let { id: x10, B: f10 } = v10, L10 = o10[x10];
    s10.push(x10 === "minX" ? [[L10, o10.midY], [L10, f10.minY], [L10, f10.maxY]] : [[L10, o10.minY], [L10, o10.maxY], [L10, f10.minY], [L10, f10.maxY]]);
  }), l10.forEach((T10) => {
    let v10 = a10[T10];
    if (!v10.isSnapped) return;
    let { id: x10, B: f10 } = v10, L10 = o10[x10];
    s10.push(x10 === "midY" ? [[o10.midX, L10], [f10.minX, L10], [f10.maxX, L10]] : [[o10.minX, L10], [o10.maxX, L10], [f10.minX, L10], [f10.maxX, L10]]);
  }), { offset: i10, snapLines: s10 };
}), E$2(C$2, "deepMerge", (e10, t10) => {
  let n10 = g$3({}, e10), o10 = Object.entries(t10);
  for (let [i10, s10] of o10) n10[i10] = s10 === Object(s10) && !Array.isArray(s10) ? k$3.deepMerge(n10[i10], s10) : s10;
  return n10;
});
function ee(r10, e10) {
  return (r10 + e10) / 2;
}
var w$3 = C$2;
function tt(r10, e10) {
  let t10 = reactExports.useRef(void 0), n10 = reactExports.useRef(void 0), o10 = reactExports.useRef([0, 0]), i10 = reactExports.useRef(0), { inputs: s10, bounds: a10, callbacks: d10 } = R$3();
  reactExports.useEffect(() => {
    let u10 = (y10) => y10.preventDefault();
    return document.addEventListener("gesturestart", u10), document.addEventListener("gesturechange", u10), () => {
      document.removeEventListener("gesturestart", u10), document.removeEventListener("gesturechange", u10);
    };
  }, []);
  let l10 = reactExports.useCallback(({ event: u10 }) => {
    var L10, Y10, X10, S10;
    if (u10.preventDefault(), s10.isPinching || u10.timeStamp <= i10.current) return;
    i10.current = u10.timeStamp;
    let [y10, T10, v10] = tn$1(u10);
    if ((u10.altKey || u10.ctrlKey || u10.metaKey) && u10.buttons === 0) {
      let P10 = [...(Y10 = (L10 = s10.pointer) == null ? void 0 : L10.point) != null ? Y10 : [a10.width / 2, a10.height / 2], v10 * 0.618], B10 = s10.pan(P10, u10);
      (X10 = d10.onZoom) == null || X10.call(d10, U$1(g$3({}, B10), { delta: P10 }), u10);
      return;
    }
    let x10 = e$3.mul(u10.shiftKey && !w$3.isDarwin() ? [T10, 0] : [y10, T10], 0.5);
    if (e$3.isEqual(x10, [0, 0])) return;
    let f10 = s10.pan(x10, u10);
    (S10 = d10.onPan) == null || S10.call(d10, f10, u10);
  }, [d10, s10, a10]), c10 = reactExports.useCallback(({ origin: u10, event: y10 }) => {
    var x10;
    if (y10 instanceof WheelEvent) return;
    let T10 = e10.current;
    if (!T10 || !(y10.target === T10 || T10.contains(y10.target))) return;
    let v10 = s10.pinch(u10, u10);
    s10.isPinching = true, (x10 = d10.onPinchStart) == null || x10.call(d10, v10, y10), n10.current = v10.point, t10.current = v10.origin, o10.current = [0, 0];
  }, [d10, s10, a10]), m10 = reactExports.useCallback(({ origin: u10, offset: y10, event: T10 }) => {
    var L10;
    if (T10 instanceof WheelEvent) return;
    let v10 = e10.current;
    if (!(T10.target === v10 || (v10 == null ? void 0 : v10.contains(T10.target))) || !t10.current) return;
    let x10 = s10.pinch(u10, t10.current), f10 = e$3.sub(x10.delta, o10.current);
    o10.current = x10.delta, (L10 = d10.onPinch) == null || L10.call(d10, U$1(g$3({}, x10), { point: x10.point, origin: t10.current, delta: [...f10, y10[0]] }), T10), n10.current = u10;
  }, [d10, s10, a10]), p10 = reactExports.useCallback(({ origin: u10, event: y10 }) => {
    var x10;
    let T10 = e10.current;
    if (!(y10.target === T10 || (T10 == null ? void 0 : T10.contains(y10.target)))) return;
    let v10 = s10.pinch(u10, u10);
    s10.isPinching = false, (x10 = d10.onPinchEnd) == null || x10.call(d10, v10, y10), n10.current = void 0, t10.current = void 0, o10.current = [0, 0];
  }, []);
  useGesture({ onWheel: l10, onPinchStart: c10, onPinch: m10, onPinchEnd: p10 }, { target: e10, eventOptions: { passive: false }, pinch: { from: [r10.current, 0], scaleBounds: () => ({ from: r10.current, max: 5, min: 0.1 }) } });
}
var et = 10;
function tn$1(r10) {
  let { deltaY: e10, deltaX: t10 } = r10, n10 = 0;
  if (r10.ctrlKey || r10.metaKey) {
    let o10 = Math.sign(r10.deltaY), i10 = Math.abs(r10.deltaY), s10 = e10;
    i10 > et && (s10 = et * o10), n10 = s10;
  }
  return [t10, e10, n10];
}
function nt$1() {
  let { callbacks: r10 } = R$3();
  reactExports.useEffect(() => {
    function e10() {
      var t10;
      (t10 = r10.onShapeBlur) == null || t10.call(r10);
    }
    return w$3.isMobileSafari() ? (document.addEventListener("focusout", e10), () => document.removeEventListener("focusout", e10)) : () => null;
  }, [r10]);
}
function rt() {
  let { callbacks: r10, inputs: e10 } = R$3();
  return reactExports.useMemo(() => ({ onPointerDown: (t10) => {
    var o10, i10, s10;
    if (t10.dead || (t10.dead = true, !e10.pointerIsValid(t10))) return;
    if (t10.currentTarget.setPointerCapture(t10.pointerId), t10.button === 2) {
      (o10 = r10.onRightPointCanvas) == null || o10.call(r10, e10.pointerDown(t10, "canvas"), t10);
      return;
    }
    let n10 = e10.pointerDown(t10, "canvas");
    t10.button === 0 && ((i10 = r10.onPointCanvas) == null || i10.call(r10, n10, t10)), (s10 = r10.onPointerDown) == null || s10.call(r10, n10, t10);
  }, onPointerMove: (t10) => {
    var o10, i10;
    if (t10.dead || (t10.dead = true, !e10.pointerIsValid(t10))) return;
    let n10 = e10.pointerMove(t10, "canvas");
    t10.buttons === 1 && t10.currentTarget.hasPointerCapture(t10.pointerId) && ((o10 = r10.onDragCanvas) == null || o10.call(r10, n10, t10)), (i10 = r10.onPointerMove) == null || i10.call(r10, n10, t10);
  }, onPointerUp: (t10) => {
    var i10, s10, a10, d10, l10;
    if (t10.dead || (t10.dead = true, e10.activePointer = void 0, !e10.pointerIsValid(t10))) return;
    let n10 = e10.isDoubleClick(), o10 = e10.pointerUp(t10, "canvas");
    if (t10.button === 2) {
      (i10 = r10.onPointerUp) == null || i10.call(r10, o10, t10);
      return;
    }
    t10.currentTarget.hasPointerCapture(t10.pointerId) && ((s10 = t10.currentTarget) == null || s10.releasePointerCapture(t10.pointerId)), t10.button === 0 && (n10 && !(o10.altKey || o10.metaKey) && ((a10 = r10.onDoubleClickCanvas) == null || a10.call(r10, o10, t10)), (d10 = r10.onReleaseCanvas) == null || d10.call(r10, o10, t10)), (l10 = r10.onPointerUp) == null || l10.call(r10, o10, t10);
  }, onDrop: r10.onDrop, onDragOver: r10.onDragOver }), [r10, e10]);
}
function it(r10) {
  let { rPageState: e10, rSelectionBounds: t10, callbacks: n10, inputs: o10 } = reactExports.useContext(Le$1);
  return reactExports.useMemo(() => ({ onPointerDown: (i10) => {
    var a10, d10, l10, c10, m10, p10, u10;
    if (i10.dead || (i10.dead = true, !o10.pointerIsValid(i10))) return;
    if (i10.button === 2) {
      (a10 = n10.onRightPointShape) == null || a10.call(n10, o10.pointerDown(i10, r10), i10);
      return;
    }
    let s10 = o10.pointerDown(i10, r10);
    if ((d10 = i10.currentTarget) == null || d10.setPointerCapture(i10.pointerId), t10.current && C$2.pointInBounds(s10.point, t10.current) && !e10.current.selectedIds.includes(r10)) {
      i10.button === 0 && ((l10 = n10.onPointBounds) == null || l10.call(n10, o10.pointerDown(i10, "bounds"), i10), (c10 = n10.onPointShape) == null || c10.call(n10, s10, i10)), (m10 = n10.onPointerDown) == null || m10.call(n10, s10, i10);
      return;
    }
    i10.button === 0 && ((p10 = n10.onPointShape) == null || p10.call(n10, s10, i10)), (u10 = n10.onPointerDown) == null || u10.call(n10, s10, i10);
  }, onPointerUp: (i10) => {
    var d10, l10, c10, m10;
    if (i10.dead || (i10.dead = true, !o10.pointerIsValid(i10)) || i10.button === 2) return;
    o10.activePointer = void 0;
    let s10 = o10.isDoubleClick(), a10 = o10.pointerUp(i10, r10);
    i10.pointerId && i10.currentTarget.hasPointerCapture(i10.pointerId) && ((d10 = i10.currentTarget) == null || d10.releasePointerCapture(i10.pointerId)), i10.button === 0 && (s10 && !(a10.altKey || a10.metaKey) && ((l10 = n10.onDoubleClickShape) == null || l10.call(n10, a10, i10)), (c10 = n10.onReleaseShape) == null || c10.call(n10, a10, i10)), (m10 = n10.onPointerUp) == null || m10.call(n10, a10, i10);
  }, onPointerMove: (i10) => {
    var a10, d10;
    if (i10.dead || (i10.dead = true, i10.buttons === 2 || !o10.pointerIsValid(i10) || o10.pointer && i10.pointerId !== o10.pointer.pointerId)) return;
    let s10 = o10.pointerMove(i10, r10);
    i10.buttons === 1 && i10.currentTarget.hasPointerCapture(i10.pointerId) && ((a10 = n10.onDragShape) == null || a10.call(n10, s10, i10)), (d10 = n10.onPointerMove) == null || d10.call(n10, s10, i10);
  }, onPointerEnter: (i10) => {
    var a10;
    if (!o10.pointerIsValid(i10)) return;
    let s10 = o10.pointerEnter(i10, r10);
    (a10 = n10.onHoverShape) == null || a10.call(n10, s10, i10);
  }, onPointerLeave: (i10) => {
    var a10;
    if (!o10.pointerIsValid(i10)) return;
    let s10 = o10.pointerEnter(i10, r10);
    (a10 = n10.onUnhoverShape) == null || a10.call(n10, s10, i10);
  } }), [o10, n10, r10]);
}
function st$1(r10, e10, t10, n10, o10, i10 = false, s10 = false, a10, d10) {
  let l10 = { shape: r10, asset: r10.assetId ? o10[r10.assetId] : void 0, meta: a10, isChildOfSelected: s10, isGhost: r10.isGhost || i10, isEditing: n10.editingId === r10.id, isBinding: d10 === r10.id, isSelected: n10.selectedIds.includes(r10.id), isHovered: n10.hoveredId === r10.id || r10.children !== void 0 && (n10.hoveredId && r10.children.includes(n10.hoveredId) || r10.children.some((c10) => n10.selectedIds.includes(c10))) };
  e10.push(l10), r10.children && (l10.children = [], r10.children.map((c10) => t10[c10]).filter((c10) => t10[c10.id]).sort((c10, m10) => c10.childIndex - m10.childIndex).forEach((c10) => st$1(c10, l10.children, t10, n10, o10, l10.isGhost, l10.isSelected || l10.isChildOfSelected, a10)));
}
function on(r10, e10) {
  return C$2.boundsContain(e10, r10) || C$2.boundsCollide(e10, r10);
}
function at(r10, e10, t10, n10) {
  let { callbacks: o10, shapeUtils: i10, bounds: s10 } = R$3(), a10 = reactExports.useRef(), d10 = reactExports.useRef(-1), l10 = reactExports.useRef(/* @__PURE__ */ new Set()), c10 = reactExports.useRef(/* @__PURE__ */ new Set()), { selectedIds: m10, camera: p10 } = e10, [u10, y10] = e$3.sub(e$3.div([0, 0], p10.zoom), p10.point), [T10, v10] = e$3.sub(e$3.div([s10.width, s10.height], p10.zoom), p10.point), x10 = { minX: u10, minY: y10, maxX: T10, maxY: v10, height: T10 - u10, width: v10 - y10 }, f10 = c10.current, L10 = l10.current;
  f10.clear(), L10.clear(), Object.values(r10.shapes).filter((b10) => i10[b10.type].isStateful || m10.includes(b10.id) || on(i10[b10.type].getBounds(b10), x10)).forEach((b10) => {
    if (b10.parentId === r10.id) {
      L10.add(b10.id), f10.add(b10);
      return;
    }
    let P10 = r10.shapes[b10.parentId];
    if (P10 === void 0) throw Error(`A shape (${b10.id}) has a parent (${b10.parentId}) that does not exist!`);
    L10.add(P10.id), f10.add(P10);
  }), f10.size !== d10.current && (a10.current && clearTimeout(a10.current), a10.current = requestAnimationFrame(() => {
    var b10;
    (b10 = o10.onRenderCountChange) == null || b10.call(o10, Array.from(L10.values()));
  }), d10.current = f10.size);
  let X10 = e10.bindingId ? r10.bindings[e10.bindingId].toId : void 0, S10 = [];
  return f10.forEach((b10) => {
    if (b10 === void 0) throw Error("Rendered shapes included a missing shape");
    st$1(b10, S10, r10.shapes, e10, t10, b10.isGhost, false, n10, X10);
  }), S10.sort((b10, P10) => b10.shape.childIndex - P10.shape.childIndex), S10;
}
var ze = /* @__PURE__ */ new Map();
function rn(r10, e10) {
  return Object.keys(e10).reduce((t10, n10) => {
    let o10 = e10[n10];
    return o10 ? t10 + `${`--${r10}-${n10}`}: ${o10};
` : t10;
  }, "");
}
function sn(r10, e10, t10 = ":root") {
  reactExports.useLayoutEffect(() => {
    let n10 = document.createElement("style"), o10 = rn(r10, e10);
    return n10.setAttribute("id", `${r10}-theme`), n10.setAttribute("data-selector", t10), n10.innerHTML = `
        ${t10} {
          ${o10}
        }
      `, document.head.appendChild(n10), () => {
      n10 && document.head.contains(n10) && document.head.removeChild(n10);
    };
  }, [r10, e10, t10]);
}
function an$1(r10, e10) {
  reactExports.useLayoutEffect(() => {
    if (ze.get(r10)) return () => {
    };
    let t10 = document.createElement("style");
    return t10.innerHTML = e10, t10.setAttribute("id", r10), document.head.appendChild(t10), ze.set(r10, t10), () => {
      t10 && document.head.contains(t10) && (document.head.removeChild(t10), ze.delete(r10));
    };
  }, [r10, e10]);
}
var dn$1 = (r10, ...e10) => r10.reduce((t10, n10, o10) => t10 + n10 + (o10 < e10.length ? e10[o10] : ""), ""), ln$1 = { accent: "rgb(255, 0, 0)", brushFill: "rgba(0,0,0,.05)", brushStroke: "rgba(0,0,0,.25)", brushDashStroke: "rgba(0,0,0,.6)", selectStroke: "rgb(66, 133, 244)", selectFill: "rgba(65, 132, 244, 0.05)", binding: "rgba(65, 132, 244, 0.12)", background: "rgb(248, 249, 250)", foreground: "rgb(51, 51, 51)", grid: "rgba(144, 144, 144, 1)" }, cn = dn$1`
  .tl-container {
    --tl-zoom: 1;
    --tl-scale: calc(1 / var(--tl-zoom));
    --tl-padding: calc(64px * max(1, var(--tl-scale)));
    --tl-performance-all: auto;
    --tl-performance-selected: auto;
    position: relative;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
    max-width: 100%;
    max-height: 100%;
    box-sizing: border-box;
    padding: 0px;
    margin: 0px;
    z-index: 100;
    overflow: hidden;
    touch-action: none;
    overscroll-behavior: none;
    background-color: var(--tl-background);
  }
  .tl-container * {
    box-sizing: border-box;
  }
  .tl-overlay {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: none;
  }
  .tl-grid {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: none;
    user-select: none;
  }
  .tl-snap-line {
    stroke: var(--tl-accent);
    stroke-width: calc(1px * var(--tl-scale));
  }
  .tl-snap-point {
    stroke: var(--tl-accent);
    stroke-width: calc(1px * var(--tl-scale));
  }
  .tl-canvas {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: all;
    overflow: clip;
  }
  .tl-layer {
    position: absolute;
    top: 0px;
    left: 0px;
    height: 0px;
    width: 0px;
    contain: layout style size;
  }
  .tl-absolute {
    position: absolute;
    top: 0px;
    left: 0px;
    transform-origin: center center;
    contain: layout style size;
  }
  .tl-positioned {
    position: absolute;
    top: 0px;
    left: 0px;
    transform-origin: center center;
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
    contain: layout style size;
    will-change: var(--tl-performance-all);
  }
  .tl-positioned-svg {
    width: 100%;
    height: 100%;
    overflow: hidden;
    contain: layout style size;
  }
  .tl-positioned-div {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    padding: var(--tl-padding);
    overflow: hidden;
    contain: layout style size;
  }
  .tl-positioned-selected {
    will-change: var(--tl-performance-selected);
  }
  .tl-inner-div {
    position: relative;
    width: 100%;
    height: 100%;
  }
  .tl-stroke-hitarea {
    fill: none;
    stroke: transparent;
    stroke-width: calc(24px * var(--tl-scale));
    pointer-events: stroke;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .tl-fill-hitarea {
    fill: transparent;
    stroke: transparent;
    stroke-width: calc(24px * var(--tl-scale));
    pointer-events: all;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .tl-counter-scaled {
    transform: scale(var(--tl-scale));
  }
  .tl-dashed {
    stroke-dasharray: calc(2px * var(--tl-scale)), calc(2px * var(--tl-scale));
  }
  .tl-transparent {
    fill: transparent;
    stroke: transparent;
  }
  .tl-cursor-ns {
    cursor: ns-resize;
  }
  .tl-cursor-ew {
    cursor: ew-resize;
  }
  .tl-cursor-nesw {
    cursor: nesw-resize;
  }
  .tl-cursor-nwse {
    cursor: nwse-resize;
  }
  .tl-corner-handle {
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
    stroke-width: calc(1.5px * var(--tl-scale));
  }
  .tl-rotate-handle {
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
    stroke-width: calc(1.5px * var(--tl-scale));
    cursor: grab;
  }
  .tl-binding {
    fill: var(--tl-selectFill);
    stroke: var(--tl-selectStroke);
    stroke-width: calc(1px * var(--tl-scale));
    pointer-events: none;
  }
  .tl-user {
    left: calc(-15px * var(--tl-scale));
    top: calc(-15px * var(--tl-scale));
    height: calc(35px * var(--tl-scale));
    width: calc(35px * var(--tl-scale));
    transform: scale(var(--tl-scale));
    pointer-events: none;
    will-change: transform;
  }
  .tl-animated {
    transition: transform 200ms linear;
  }
  .tl-indicator {
    fill: transparent;
    stroke-width: calc(1.5px * var(--tl-scale));
    pointer-events: none;
  }
  .tl-user-indicator-bounds {
    border-style: solid;
    border-width: calc(1px * var(--tl-scale));
  }
  .tl-hovered {
    stroke: var(--tl-selectStroke);
  }
  .tl-selected {
    stroke: var(--tl-selectStroke);
  }
  .tl-locked {
    stroke-dasharray: calc(3px * var(--tl-scale)) calc(3px * var(--tl-scale));
  }
  .tl-editing {
    stroke-width: calc(2.5px * min(5, var(--tl-scale)));
  }
  .tl-performance {
    will-change: transform, contents;
  }
  .tl-clone-target {
    pointer-events: all;
  }
  .tl-clone-target:hover .tl-clone-button {
    opacity: 1;
  }
  .tl-clone-button-target {
    cursor: pointer;
    pointer-events: all;
  }
  .tl-clone-button-target:hover .tl-clone-button {
    fill: var(--tl-selectStroke);
  }
  .tl-clone-button {
    opacity: 0;
    r: calc(8px * var(--tl-scale));
    stroke-width: calc(1.5px * var(--tl-scale));
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
  }
  .tl-bounds {
    pointer-events: none;
    contain: layout style size;
  }
  .tl-bounds-bg {
    stroke: none;
    fill: var(--tl-selectFill);
    pointer-events: all;
    contain: layout style size;
  }
  .tl-bounds-center {
    fill: transparent;
    stroke: var(--tl-selectStroke);
    stroke-width: calc(1.5px * var(--tl-scale));
  }
  .tl-brush {
    fill: var(--tl-brushFill);
    stroke: var(--tl-brushStroke);
    stroke-width: calc(1px * var(--tl-scale));
    pointer-events: none;
    contain: layout style size;
  }
  .tl-dashed-brush-line {
    fill: none;
    stroke: var(--tl-brushDashStroke);
    stroke-width: calc(1px * var(--tl-scale));
    pointer-events: none;
  }
  .tl-brush.dashed {
    stroke: none;
  }
  .tl-handle {
    pointer-events: all;
    cursor: grab;
  }
  .tl-handle:hover .tl-handle-bg {
    fill: var(--tl-selectFill);
  }
  .tl-handle:hover .tl-handle-bg > * {
    stroke: var(--tl-selectFill);
  }
  .tl-handle:active .tl-handle-bg {
    cursor: grabbing;
    fill: var(--tl-selectFill);
  }
  .tl-handle:active .tl-handle-bg > * {
    stroke: var(--tl-selectFill);
  }
  .tl-handle {
    fill: var(--tl-background);
    stroke: var(--tl-selectStroke);
    stroke-width: 1.5px;
  }
  .tl-handle-bg {
    fill: transparent;
    stroke: none;
    pointer-events: all;
    r: calc(16px / max(1, var(--tl-zoom)));
  }
  .tl-binding-indicator {
    fill: transparent;
    stroke: var(--tl-binding);
  }
  .tl-centered-g {
    transform: translate(var(--tl-padding), var(--tl-padding));
  }
  .tl-current-parent > *[data-shy='true'] {
    opacity: 1;
  }
  .tl-binding {
    fill: none;
    stroke: var(--tl-selectStroke);
    stroke-width: calc(2px * var(--tl-scale));
  }
  .tl-grid-dot {
    fill: var(--tl-grid);
  }
  .tl-erase-line {
    stroke-linejoin: round;
    stroke-linecap: round;
    pointer-events: none;
    fill: var(--tl-grid);
    opacity: 0.32;
  }
`;
function dt(r10, e10) {
  let t10 = reactExports.useMemo(() => g$3(g$3({}, ln$1), r10), [r10]);
  sn("tl", t10, e10), an$1("tl-canvas", cn);
}
function _(r10) {
  let { callbacks: e10, inputs: t10 } = R$3(), n10 = reactExports.useCallback((d10) => {
    var c10, m10, p10, u10;
    if (d10.dead || (d10.dead = true, !t10.pointerIsValid(d10))) return;
    (c10 = d10.currentTarget) == null || c10.setPointerCapture(d10.pointerId);
    let l10 = t10.pointerDown(d10, r10);
    if (d10.button === 2) {
      (m10 = e10.onRightPointBoundsHandle) == null || m10.call(e10, l10, d10);
      return;
    }
    d10.button === 0 && ((p10 = e10.onPointBoundsHandle) == null || p10.call(e10, l10, d10)), (u10 = e10.onPointerDown) == null || u10.call(e10, l10, d10);
  }, [t10, e10, r10]), o10 = reactExports.useCallback((d10) => {
    var m10, p10, u10;
    if (d10.dead || (d10.dead = true, d10.button === 2 || !t10.pointerIsValid(d10))) return;
    let l10 = t10.pointerUp(d10, r10), c10 = t10.isDoubleClick();
    d10.button === 0 && (c10 && !(l10.altKey || l10.metaKey) && ((m10 = e10.onDoubleClickBoundsHandle) == null || m10.call(e10, l10, d10)), (p10 = e10.onReleaseBoundsHandle) == null || p10.call(e10, l10, d10)), (u10 = e10.onPointerUp) == null || u10.call(e10, l10, d10);
  }, [t10, e10, r10]), i10 = reactExports.useCallback((d10) => {
    var c10, m10;
    if (d10.dead || (d10.dead = true, !t10.pointerIsValid(d10)) || d10.buttons === 2) return;
    let l10 = t10.pointerMove(d10, r10);
    d10.buttons === 1 && d10.currentTarget.hasPointerCapture(d10.pointerId) && ((c10 = e10.onDragBoundsHandle) == null || c10.call(e10, l10, d10)), (m10 = e10.onPointerMove) == null || m10.call(e10, l10, d10);
  }, [t10, e10, r10]), s10 = reactExports.useCallback((d10) => {
    var l10;
    !t10.pointerIsValid(d10) || (l10 = e10.onHoverBoundsHandle) == null || l10.call(e10, t10.pointerEnter(d10, r10), d10);
  }, [t10, e10, r10]), a10 = reactExports.useCallback((d10) => {
    var l10;
    !t10.pointerIsValid(d10) || (l10 = e10.onUnhoverBoundsHandle) == null || l10.call(e10, t10.pointerEnter(d10, r10), d10);
  }, [t10, e10, r10]);
  return { onPointerDown: n10, onPointerUp: o10, onPointerEnter: s10, onPointerMove: i10, onPointerLeave: a10 };
}
function lt$1(r10, e10, t10) {
  let n10 = reactExports.useRef(), o10 = reactExports.useRef();
  reactExports.useLayoutEffect(() => {
    let { zoom: i10, point: s10 } = t10.camera, a10 = i10 !== n10.current, d10 = s10 !== o10.current;
    if (n10.current = i10, o10.current = s10, a10 || d10) {
      let l10 = r10.current;
      if (e10 && "current" in e10) {
        let c10 = e10.current;
        a10 && c10 && c10.style.setProperty("--tl-zoom", i10.toString()), l10 && l10.style.setProperty("transform", `scale(${i10}) translateX(${s10[0]}px) translateY(${s10[1]}px)`);
      }
    }
  }, [t10.camera.zoom, t10.camera.point]);
}
function ct$1(r10, e10) {
  return [(r10[0] + e10.point[0]) * e10.zoom, (r10[1] + e10.point[1]) * e10.zoom];
}
function Fe(r10, e10) {
  return r10[e10.type];
}
function mt(r10, e10, t10) {
  let { rSelectionBounds: n10 } = R$3(), { selectedIds: o10 } = e10, i10 = reactExports.useRef(), s10, a10 = 0, d10 = false, l10 = false;
  if (o10.length === 1) {
    let m10 = o10[0], p10 = r10.shapes[m10];
    if (!p10) throw Error(`selectedIds is set to the id of a shape that doesn't exist: ${m10}`);
    a10 = p10.rotation || 0, d10 = p10.isLocked || false;
    let u10 = Fe(t10, p10);
    s10 = u10.hideBounds ? void 0 : u10.getBounds(p10);
  } else if (o10.length > 1) {
    let m10 = o10.map((p10) => r10.shapes[p10]);
    a10 = 0, d10 = m10.every((p10) => p10.isLocked), s10 = m10.reduce((p10, u10, y10) => y10 === 0 ? Fe(t10, u10).getRotatedBounds(u10) : w$3.getExpandedBounds(p10, Fe(t10, u10).getRotatedBounds(u10)), {});
  }
  if (s10) {
    let [m10, p10] = ct$1([s10.minX, s10.minY], e10.camera), [u10, y10] = ct$1([s10.maxX, s10.maxY], e10.camera);
    l10 = !!Object.values(r10.bindings).find((T10) => o10.includes(T10.toId) || o10.includes(T10.fromId)), n10.current = { minX: m10, minY: p10, maxX: u10, maxY: y10, width: u10 - m10, height: y10 - p10 };
  } else n10.current = null;
  let c10 = i10.current;
  return !c10 || !s10 ? i10.current = s10 : s10 && c10.minX === s10.minX && c10.minY === s10.minY && c10.maxX === s10.maxX && c10.maxY === s10.maxY && (s10 = i10.current), { bounds: s10, rotation: a10, isLocked: d10, isLinked: l10 };
}
function ht(r10) {
  let { inputs: e10, callbacks: t10 } = R$3();
  return reactExports.useMemo(() => ({ onPointerDown: (n10) => {
    var i10, s10, a10;
    if (n10.dead || (n10.dead = true, !e10.pointerIsValid(n10)) || n10.button === 2) return;
    (i10 = n10.currentTarget) == null || i10.setPointerCapture(n10.pointerId);
    let o10 = e10.pointerDown(n10, r10);
    n10.button === 0 && ((s10 = t10.onPointHandle) == null || s10.call(t10, o10, n10)), (a10 = t10.onPointerDown) == null || a10.call(t10, o10, n10);
  }, onPointerUp: (n10) => {
    var s10, a10, d10, l10;
    if (n10.dead || (n10.dead = true, !e10.pointerIsValid(n10)) || n10.button === 2) return;
    let o10 = e10.isDoubleClick(), i10 = e10.pointerUp(n10, r10);
    n10.currentTarget.hasPointerCapture(n10.pointerId) && ((s10 = n10.currentTarget) == null || s10.releasePointerCapture(n10.pointerId), n10.button === 0 && (o10 && !(i10.altKey || i10.metaKey) && ((a10 = t10.onDoubleClickHandle) == null || a10.call(t10, i10, n10)), (d10 = t10.onReleaseHandle) == null || d10.call(t10, i10, n10))), (l10 = t10.onPointerUp) == null || l10.call(t10, i10, n10);
  }, onPointerMove: (n10) => {
    var i10, s10;
    if (n10.dead || (n10.dead = true, !e10.pointerIsValid(n10)) || n10.buttons === 2) return;
    let o10 = e10.pointerMove(n10, r10);
    n10.buttons === 1 && n10.currentTarget.hasPointerCapture(n10.pointerId) && ((i10 = t10.onDragHandle) == null || i10.call(t10, o10, n10)), (s10 = t10.onPointerMove) == null || s10.call(t10, o10, n10);
  }, onPointerEnter: (n10) => {
    var i10;
    if (!e10.pointerIsValid(n10)) return;
    let o10 = e10.pointerEnter(n10, r10);
    (i10 = t10.onHoverHandle) == null || i10.call(t10, o10, n10);
  }, onPointerLeave: (n10) => {
    var i10;
    if (!e10.pointerIsValid(n10)) return;
    let o10 = e10.pointerEnter(n10, r10);
    (i10 = t10.onUnhoverHandle) == null || i10.call(t10, o10, n10);
  } }), [e10, t10, r10]);
}
function Tt(r10) {
  let { bounds: e10 } = R$3();
  reactExports.useEffect(() => {
    let t10 = (i10) => {
      i10.preventDefault();
    }, n10 = (i10) => {
      let s10 = i10.touches[0].pageX, a10 = i10.touches[0].radiusX || 0;
      (s10 - a10 < 10 || s10 + a10 > e10.width - 10) && i10.preventDefault();
    }, o10 = r10.current;
    return o10 ? (o10.addEventListener("gestureend", t10), o10.addEventListener("gesturechange", t10), o10.addEventListener("gesturestart", t10), o10.addEventListener("touchstart", n10), () => {
      o10 && (o10.removeEventListener("gestureend", t10), o10.removeEventListener("gesturechange", t10), o10.removeEventListener("gesturestart", t10), o10.removeEventListener("touchstart", n10));
    }) : () => {
    };
  }, [r10, e10.width]);
}
function Lt$1() {
  let { callbacks: r10, inputs: e10 } = R$3();
  return reactExports.useMemo(() => ({ onPointerDown: (t10) => {
    var o10, i10, s10, a10;
    if (t10.dead || (t10.dead = true, !e10.pointerIsValid(t10))) return;
    if (t10.button === 2) {
      (o10 = r10.onRightPointBounds) == null || o10.call(r10, e10.pointerDown(t10, "bounds"), t10);
      return;
    }
    let n10 = e10.pointerDown(t10, "bounds");
    (i10 = t10.currentTarget) == null || i10.setPointerCapture(t10.pointerId), t10.button === 0 && ((s10 = r10.onPointBounds) == null || s10.call(r10, n10, t10)), (a10 = r10.onPointerDown) == null || a10.call(r10, n10, t10);
  }, onPointerUp: (t10) => {
    var i10, s10, a10, d10;
    if (t10.dead || (t10.dead = true, t10.button === 2) || (e10.activePointer = void 0, !e10.pointerIsValid(t10))) return;
    let n10 = e10.isDoubleClick(), o10 = e10.pointerUp(t10, "bounds");
    t10.currentTarget.hasPointerCapture(t10.pointerId) && ((i10 = t10.currentTarget) == null || i10.releasePointerCapture(t10.pointerId)), t10.button === 0 && (n10 && !(o10.altKey || o10.metaKey) && ((s10 = r10.onDoubleClickBounds) == null || s10.call(r10, o10, t10)), (a10 = r10.onReleaseBounds) == null || a10.call(r10, o10, t10)), (d10 = r10.onPointerUp) == null || d10.call(r10, o10, t10);
  }, onPointerMove: (t10) => {
    var o10, i10;
    if (t10.dead || (t10.dead = true, !e10.pointerIsValid(t10))) return;
    t10.buttons === 1 && t10.currentTarget.hasPointerCapture(t10.pointerId) && ((o10 = r10.onDragBounds) == null || o10.call(r10, e10.pointerMove(t10, "bounds"), t10));
    let n10 = e10.pointerMove(t10, "bounds");
    (i10 = r10.onPointerMove) == null || i10.call(r10, n10, t10);
  }, onPointerEnter: (t10) => {
    var n10;
    !e10.pointerIsValid(t10) || (n10 = r10.onHoverBounds) == null || n10.call(r10, e10.pointerEnter(t10, "bounds"), t10);
  }, onPointerLeave: (t10) => {
    var n10;
    !e10.pointerIsValid(t10) || (n10 = r10.onUnhoverBounds) == null || n10.call(r10, e10.pointerEnter(t10, "bounds"), t10);
  } }), [e10, r10]);
}
function De(r10, e10 = 0) {
  let t10 = reactExports.useRef(null);
  return reactExports.useLayoutEffect(() => {
    let n10 = t10.current, o10 = `
    translate(
      calc(${r10.minX}px - var(--tl-padding)),
      calc(${r10.minY}px - var(--tl-padding))
    )
    rotate(${e10 + (r10.rotation || 0)}rad)`;
    n10.style.setProperty("transform", o10), n10.style.setProperty("width", `calc(${Math.floor(r10.width)}px + (var(--tl-padding) * 2))`), n10.style.setProperty("height", `calc(${Math.floor(r10.height)}px + (var(--tl-padding) * 2))`);
  }, [r10, e10]), t10;
}
function vt() {
  let { inputs: r10, callbacks: e10 } = R$3();
  reactExports.useEffect(() => {
    let t10 = (o10) => {
      var i10;
      (i10 = e10.onKeyDown) == null || i10.call(e10, o10.key, r10.keydown(o10), o10);
    }, n10 = (o10) => {
      var i10;
      r10.keyup(o10), (i10 = e10.onKeyUp) == null || i10.call(e10, o10.key, r10.keyup(o10), o10);
    };
    return window.addEventListener("keydown", t10), window.addEventListener("keyup", n10), () => {
      window.removeEventListener("keydown", t10), window.removeEventListener("keyup", n10);
    };
  }, [r10, e10]);
}
function bt(r10, e10) {
  reactExports.useLayoutEffect(() => {
    if (e10 && "current" in e10) {
      let t10 = e10 == null ? void 0 : e10.current;
      if (!t10) return;
      switch (r10) {
        case "transform_selected": {
          t10.style.setProperty("--tl-performance-all", "auto"), t10.style.setProperty("--tl-performance-selected", "transform, contents");
          break;
        }
        case "transform_all": {
          t10.style.setProperty("--tl-performance-all", "transform, contents"), t10.style.setProperty("--tl-performance-selected", "transform, contents");
          break;
        }
        case "translate_selected": {
          t10.style.setProperty("--tl-performance-all", "auto"), t10.style.setProperty("--tl-performance-selected", "transform");
          break;
        }
        case "translate_all": {
          t10.style.setProperty("--tl-performance-all", "transform"), t10.style.setProperty("--tl-performance-selected", "transform");
          break;
        }
        default:
          t10.style.setProperty("--tl-performance-all", "auto"), t10.style.setProperty("--tl-performance-selected", "auto");
      }
    }
  }, [r10]);
}
function un(a10) {
  var d10 = a10, { id: r10, bounds: e10, rotation: t10 = 0, isGhost: n10 = false, isSelected: o10 = false, children: i10 } = d10, s10 = O$2(d10, ["id", "bounds", "rotation", "isGhost", "isSelected", "children"]);
  let l10 = De(e10, t10);
  return reactExports.createElement("div", g$3({ id: r10, ref: l10, className: `tl-positioned${n10 ? " tl-ghost" : ""}${o10 ? " tl-positioned-selected" : ""}`, "aria-label": "container", "data-testid": "container" }, s10), i10);
}
var Z = reactExports.memo(un);
function mn({ brush: r10, zoom: e10, dashed: t10 }) {
  return reactExports.createElement(Z, { bounds: r10, rotation: 0 }, reactExports.createElement(te, null, reactExports.createElement("rect", { className: "tl-brush" + (t10 ? " dashed" : ""), opacity: 1, x: 0, y: 0, width: r10.width, height: r10.height, "aria-label": "brush" }), t10 && reactExports.createElement("g", { className: "tl-dashed-brush-line" }, reactExports.createElement(Xe, { x1: 0, y1: 0, x2: r10.width, y2: 0, zoom: e10 }), reactExports.createElement(Xe, { x1: r10.width, y1: 0, x2: r10.width, y2: r10.height, zoom: e10 }), reactExports.createElement(Xe, { x1: 0, y1: r10.height, x2: r10.width, y2: r10.height, zoom: e10 }), reactExports.createElement(Xe, { x1: 0, y1: 0, x2: 0, y2: r10.height, zoom: e10 }))));
}
var Pt$1 = reactExports.memo(mn);
function Xe({ x1: r10, y1: e10, x2: t10, y2: n10, zoom: o10 }) {
  let i10 = w$3.getPerfectDashProps(Math.hypot(t10 - r10, n10 - e10), 1 / o10, "dashed", 1, true, 3);
  return reactExports.createElement("line", { x1: r10, y1: e10, x2: t10, y2: n10, strokeWidth: 1 / o10, strokeDasharray: i10.strokeDasharray, strokeDashoffset: i10.strokeDashoffset });
}
var Rt$1 = reactExports.memo(({ color: r10 }) => reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 35 35", fill: "none", fillRule: "evenodd" }, reactExports.createElement("g", { fill: "rgba(0,0,0,.2)", transform: "translate(1,1)" }, reactExports.createElement("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }), reactExports.createElement("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })), reactExports.createElement("g", { fill: "white" }, reactExports.createElement("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }), reactExports.createElement("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })), reactExports.createElement("g", { fill: r10 }, reactExports.createElement("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }), reactExports.createElement("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" }))));
function hn({ points: r10, zoom: e10 }) {
  if (r10.length === 0) return null;
  let t10 = w$3.getSvgPathFromStroke(_e$1(r10, { size: 16 / e10, start: { taper: true } }));
  return reactExports.createElement("path", { d: t10, className: "tl-erase-line" });
}
var Et = reactExports.memo(hn);
var Bt = [[-1, 0.15, 64], [0.05, 0.375, 16], [0.15, 1, 4], [0.7, 2.5, 1]];
function Ct({ grid: r10, camera: e10 }) {
  return reactExports.createElement("svg", { className: "tl-grid", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, reactExports.createElement("defs", null, Bt.map(([t10, n10, o10], i10) => {
    let s10 = o10 * r10 * e10.zoom, a10 = e10.point[0] * e10.zoom, d10 = e10.point[1] * e10.zoom, l10 = a10 > 0 ? a10 % s10 : s10 + a10 % s10, c10 = d10 > 0 ? d10 % s10 : s10 + d10 % s10, m10 = e10.zoom < n10 ? w$3.modulate(e10.zoom, [t10, n10], [0, 1]) : 1;
    return reactExports.createElement("pattern", { key: `grid-pattern-${i10}`, id: `grid-${i10}`, width: s10, height: s10, patternUnits: "userSpaceOnUse" }, reactExports.createElement("circle", { className: "tl-grid-dot", cx: l10, cy: c10, r: 1, opacity: m10 }));
  })), Bt.map((t10, n10) => reactExports.createElement("rect", { key: `grid-rect-${n10}`, width: "100%", height: "100%", fill: `url(#grid-${n10})` })));
}
function fn({ camera: { zoom: r10, point: e10 }, children: t10 }) {
  let n10 = 2.5 / r10;
  return reactExports.createElement("svg", { className: "tl-overlay" }, reactExports.createElement("defs", null, reactExports.createElement("g", { id: "tl-snap-point" }, reactExports.createElement("path", { className: "tl-snap-point", d: `M ${-n10},${-n10} L ${n10},${n10} M ${-n10},${n10} L ${n10},${-n10}` }))), reactExports.createElement("g", { transform: `scale(${r10}) translate(${e10})` }, t10));
}
var St$1 = reactExports.memo(fn);
var te = reactExports.memo(reactExports.forwardRef(function(s10, i10) {
  var a10 = s10, { id: e10, className: t10 = "", children: n10 } = a10, o10 = O$2(a10, ["id", "className", "children"]);
  return reactExports.createElement("svg", g$3({ ref: i10, className: `tl-positioned-svg ${t10}` }, o10), reactExports.createElement("g", { id: e10, className: "tl-centered-g" }, n10));
}));
function Tn({ bounds: r10, isLocked: e10, isHidden: t10 }) {
  return reactExports.createElement("rect", { className: ["tl-bounds-center", e10 ? "tl-dashed" : ""].join(" "), x: -1, y: -1, width: r10.width + 2, height: r10.height + 2, opacity: t10 ? 0 : 1, pointerEvents: "none", "aria-label": "center handle" });
}
var wt = reactExports.memo(Tn);
var gn$1 = { right: 0, bottomRight: 45, bottom: 90, bottomLeft: 135, left: 180, topLeft: 225, top: 270, topRight: 315 };
function Ln({ bounds: r10, side: e10, targetSize: t10, size: n10 }) {
  let o10 = t10 * 2, i10 = { left: -o10, topLeft: -o10, bottomLeft: -o10, right: r10.width, topRight: r10.width, bottomRight: r10.width, top: r10.width / 2 - o10 / 2, bottom: r10.width / 2 - o10 / 2 }[e10], s10 = { left: r10.height / 2 - o10 / 2, right: r10.height / 2 - o10 / 2, top: -o10 * 2, topLeft: -o10, topRight: -o10, bottom: r10.height, bottomLeft: r10.height, bottomRight: r10.height }[e10], { callbacks: a10, inputs: d10 } = R$3(), l10 = reactExports.useCallback((c10) => {
    var p10;
    c10.stopPropagation();
    let m10 = d10.pointerDown(c10, e10);
    (p10 = a10.onShapeClone) == null || p10.call(a10, m10, c10);
  }, [a10.onShapeClone]);
  return reactExports.createElement("g", { className: "tl-clone-target", transform: `translate(${i10}, ${s10})`, "aria-label": "clone button" }, reactExports.createElement("rect", { className: "tl-transparent", width: t10 * 2, height: t10 * 2 }), reactExports.createElement("g", { className: "tl-clone-button-target", onPointerDown: l10, transform: `translate(${t10}, ${t10}) rotate(${gn$1[e10]})` }, reactExports.createElement("circle", { className: "tl-transparent ", r: t10 }), reactExports.createElement("path", { className: "tl-clone-button", d: `M -${n10 / 2},-${n10 / 2} L ${n10 / 2},0 -${n10 / 2},${n10 / 2} Z`, strokeLinejoin: "round" })));
}
var Q = reactExports.memo(Ln);
function yn$1({ targetSize: r10, size: e10, bounds: t10 }) {
  return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Q, { targetSize: r10, size: e10, bounds: t10, side: "top" }), reactExports.createElement(Q, { targetSize: r10, size: e10, bounds: t10, side: "right" }), reactExports.createElement(Q, { targetSize: r10, size: e10, bounds: t10, side: "bottom" }), reactExports.createElement(Q, { targetSize: r10, size: e10, bounds: t10, side: "left" }), reactExports.createElement(Q, { targetSize: r10, size: e10, bounds: t10, side: "topLeft" }), reactExports.createElement(Q, { targetSize: r10, size: e10, bounds: t10, side: "topRight" }), reactExports.createElement(Q, { targetSize: r10, size: e10, bounds: t10, side: "bottomLeft" }), reactExports.createElement(Q, { targetSize: r10, size: e10, bounds: t10, side: "bottomRight" }));
}
var Ht = reactExports.memo(yn$1);
var vn = { ["top_left_corner"]: "tl-cursor-nwse", ["top_right_corner"]: "tl-cursor-nesw", ["bottom_right_corner"]: "tl-cursor-nwse", ["bottom_left_corner"]: "tl-cursor-nesw" };
function xn({ size: r10, targetSize: e10, isHidden: t10, corner: n10, bounds: o10 }) {
  let i10 = _(n10), s10 = n10 === "top_left_corner" || n10 === "top_right_corner", a10 = n10 === "top_left_corner" || n10 === "bottom_left_corner";
  return reactExports.createElement("g", { opacity: t10 ? 0 : 1 }, reactExports.createElement("rect", g$3({ className: "tl-transparent " + (t10 ? "" : vn[n10]), "aria-label": "corner transparent", x: (a10 ? -1 : o10.width + 1) - e10, y: (s10 ? -1 : o10.height + 1) - e10, width: e10 * 2, height: e10 * 2, pointerEvents: t10 ? "none" : "all" }, i10)), reactExports.createElement("rect", { className: "tl-corner-handle", "aria-label": "corner handle", x: (a10 ? -1 : o10.width + 1) - r10 / 2, y: (s10 ? -1 : o10.height + 1) - r10 / 2, width: r10, height: r10, pointerEvents: "none" }));
}
var be$1 = reactExports.memo(xn);
var bn = { ["top_edge"]: "tl-cursor-ns", ["right_edge"]: "tl-cursor-ew", ["bottom_edge"]: "tl-cursor-ns", ["left_edge"]: "tl-cursor-ew" };
function Pn({ size: r10, isHidden: e10, bounds: t10, edge: n10 }) {
  let o10 = _(n10), i10 = n10 === "top_edge" || n10 === "bottom_edge", s10 = n10 === "right_edge" || n10 === "bottom_edge", { height: a10, width: d10 } = t10;
  return reactExports.createElement("rect", g$3({ pointerEvents: e10 ? "none" : "all", className: "tl-transparent tl-edge-handle " + (e10 ? "" : bn[n10]), "aria-label": `${n10} handle`, opacity: e10 ? 0 : 1, x: i10 ? r10 / 2 : (s10 ? d10 + 1 : -1) - r10 / 2, y: i10 ? (s10 ? a10 + 1 : -1) - r10 / 2 : r10 / 2, width: i10 ? Math.max(0, d10 + 1 - r10) : r10, height: i10 ? r10 : Math.max(0, a10 + 1 - r10) }, o10));
}
var Pe$1 = reactExports.memo(Pn);
function Rn({ size: r10, bounds: e10, isHidden: t10 }) {
  let n10 = _("left"), o10 = _("center"), i10 = _("right");
  return reactExports.createElement("g", { cursor: "grab", transform: `translate(${e10.width / 2 - r10 * 4}, ${e10.height + r10 * 2})`, "aria-label": "link handle" }, reactExports.createElement("g", { className: "tl-transparent", pointerEvents: t10 ? "none" : "all" }, reactExports.createElement("rect", g$3({ x: 0, y: 0, width: r10 * 2, height: r10 * 2 }, n10)), reactExports.createElement("rect", g$3({ x: r10 * 3, y: 0, width: r10 * 2, height: r10 * 2 }, o10)), reactExports.createElement("rect", g$3({ x: r10 * 6, y: 0, width: r10 * 2, height: r10 * 2 }, i10))), reactExports.createElement("g", { className: "tl-rotate-handle", transform: `translate(${r10 / 2}, ${r10 / 2})`, "aria-label": "link rotate handle" }, reactExports.createElement("path", { d: `M 0,${r10 / 2} L ${r10},${r10} ${r10},0 Z`, pointerEvents: "none", opacity: t10 ? 0 : 1 }), reactExports.createElement("path", { transform: `translate(${r10 * 3}, 0)`, d: `M 0,0 L ${r10},0 ${r10 / 2},${r10} Z`, pointerEvents: "none", opacity: t10 ? 0 : 1 }), reactExports.createElement("path", { transform: `translate(${r10 * 6}, 0)`, d: `M ${r10},${r10 / 2} L 0,0 0,${r10} Z`, pointerEvents: "none", opacity: t10 ? 0 : 1 })));
}
var It = reactExports.memo(Rn);
function En$1({ bounds: r10, targetSize: e10, size: t10, isHidden: n10 }) {
  let o10 = _("rotate");
  return reactExports.createElement("g", { cursor: "grab", opacity: n10 ? 0 : 1 }, reactExports.createElement("circle", g$3({ className: "tl-transparent", "aria-label": "rotate handle transparent", cx: r10.width / 2, cy: t10 * -2, r: e10, pointerEvents: n10 ? "none" : "all" }, o10)), reactExports.createElement("circle", { className: "tl-rotate-handle", "aria-label": "rotate handle", cx: r10.width / 2, cy: t10 * -2, r: t10 / 2, pointerEvents: "none" }));
}
var Mt$1 = reactExports.memo(En$1);
var Bn = function({ zoom: e10, bounds: t10, viewportWidth: n10, rotation: o10, isHidden: i10, isLocked: s10, hideCloneHandles: a10, hideResizeHandles: d10, hideRotateHandle: l10, hideBindingHandles: c10 }) {
  let m10 = (n10 < 768 ? 16 : 8) / e10, p10 = 8 / e10, u10 = Math.min(t10.width, t10.height) * e10, y10 = !l10 && !i10 && !s10 && u10 > 32, T10 = !i10 && !s10 && u10 > 24, v10 = !i10 && !s10 && u10 > 20, x10 = !a10 && u10 > 24;
  return reactExports.createElement(Z, { bounds: t10, rotation: o10 }, reactExports.createElement(te, null, reactExports.createElement(wt, { bounds: t10, isLocked: s10, isHidden: i10 }), !d10 && !s10 ? reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Pe$1, { targetSize: m10, size: p10, bounds: t10, edge: "top_edge", isHidden: !T10 }), reactExports.createElement(Pe$1, { targetSize: m10, size: p10, bounds: t10, edge: "right_edge", isHidden: !T10 }), reactExports.createElement(Pe$1, { targetSize: m10, size: p10, bounds: t10, edge: "bottom_edge", isHidden: !T10 }), reactExports.createElement(Pe$1, { targetSize: m10, size: p10, bounds: t10, edge: "left_edge", isHidden: !T10 }), reactExports.createElement(be$1, { targetSize: m10, size: p10, bounds: t10, isHidden: i10 || !v10, corner: "top_left_corner" }), reactExports.createElement(be$1, { targetSize: m10, size: p10, bounds: t10, isHidden: i10 || !v10, corner: "top_right_corner" }), reactExports.createElement(be$1, { targetSize: m10, size: p10, bounds: t10, isHidden: i10 || !v10, corner: "bottom_right_corner" }), reactExports.createElement(be$1, { targetSize: m10, size: p10, bounds: t10, isHidden: i10 || !v10, corner: "bottom_left_corner" })) : null, y10 && reactExports.createElement(Mt$1, { targetSize: m10, size: p10, bounds: t10, isHidden: !T10 }), x10 && reactExports.createElement(Ht, { bounds: t10, targetSize: m10, size: p10 }), !c10 && reactExports.createElement(It, { targetSize: m10, size: p10, bounds: t10, isHidden: !T10 })));
}, kt$1 = reactExports.memo(Bn);
function Cn({ bounds: r10, rotation: e10, isHidden: t10 }) {
  let n10 = Lt$1();
  return reactExports.createElement(Z, { bounds: r10, rotation: e10 }, reactExports.createElement(te, null, reactExports.createElement("rect", g$3({ className: "tl-bounds-bg", "aria-label": "bounds bg", width: r10.width, height: r10.height, opacity: t10 ? 0 : 1 }, n10))));
}
var Kt = reactExports.memo(Cn);
function Sn$1({ id: r10, point: e10 }) {
  let t10 = ht(r10);
  return reactExports.createElement(Z, { bounds: w$3.translateBounds({ minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 }, e10) }, reactExports.createElement(te, null, reactExports.createElement("g", g$3({ className: "tl-handle", "aria-label": "handle" }, t10), reactExports.createElement("circle", { className: "tl-handle-bg", pointerEvents: "all" }), reactExports.createElement("circle", { className: "tl-counter-scaled tl-handle", pointerEvents: "none", r: 4 }))));
}
var Dt = reactExports.memo(Sn$1);
function wn({ shape: r10, zoom: e10 }) {
  if (r10.handles === void 0) return null;
  let t10 = null, n10 = Object.values(r10.handles).reduce((o10, i10) => {
    let s10 = e$3.add(i10.point, r10.point);
    return (!t10 || e$3.dist(s10, t10) * e10 >= 32) && (o10.push(i10), t10 = s10), o10;
  }, []);
  return n10.length === 1 ? null : reactExports.createElement(reactExports.Fragment, null, n10.map((o10) => reactExports.createElement(Dt, { key: r10.id + "_" + o10.id, id: o10.id, point: e$3.add(o10.point, r10.point) })));
}
var Yt$1 = reactExports.memo(wn);
function Hn(r10) {
  let e10 = r10.utils.getRef(r10.shape);
  return reactExports.createElement(r10.utils.Component, g$3({ ref: e10 }, r10));
}
var Xt$1 = reactExports.memo(Hn, (r10, e10) => r10.isHovered !== e10.isHovered || r10.isSelected !== e10.isSelected || r10.isEditing !== e10.isEditing || r10.isBinding !== e10.isBinding || r10.isGhost !== e10.isGhost || r10.meta !== e10.meta ? false : e10.shape !== r10.shape ? !e10.utils.shouldRender(e10.shape, r10.shape) : true);
function In(o10) {
  var i10 = o10, { shape: r10, utils: e10, meta: t10 } = i10, n10 = O$2(i10, ["shape", "utils", "meta"]);
  let { callbacks: s10 } = R$3(), a10 = e10.getBounds(r10), d10 = it(r10.id);
  return reactExports.createElement(Z, { id: r10.id, bounds: a10, rotation: r10.rotation, "data-shape": r10.type, isGhost: n10.isGhost, isSelected: n10.isSelected }, reactExports.createElement(Xt$1, g$3({ shape: r10, utils: e10, meta: t10, events: d10, bounds: a10, onShapeChange: s10.onShapeChange, onShapeBlur: s10.onShapeBlur }, n10)));
}
var Ut = reactExports.memo(In);
function Mn(i10) {
  var s10 = i10, { shape: r10, utils: e10, meta: t10, children: n10 } = s10, o10 = O$2(s10, ["shape", "utils", "meta", "children"]);
  return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Ut, g$3({ shape: r10, utils: e10[r10.type], meta: t10 }, o10)), n10 && n10.map((a10) => reactExports.createElement(je$1, g$3({ key: a10.shape.id, utils: e10 }, a10))));
}
var je$1 = reactExports.memo(Mn);
function kn$1({ isHovered: r10 = false, isSelected: e10 = false, isEditing: t10 = false, shape: n10, user: o10, meta: i10 }) {
  let { shapeUtils: s10 } = R$3(), a10 = s10[n10.type], d10 = a10.getBounds(n10), l10 = De(d10, n10.rotation);
  return reactExports.createElement("div", { ref: l10, draggable: false, className: ["tl-indicator", "tl-absolute", e10 && !o10 ? "tl-selected" : "tl-hovered", t10 ? "tl-editing" : "", n10.isLocked ? "tl-locked" : ""].join(" ") }, reactExports.createElement("svg", { width: "100%", height: "100%" }, reactExports.createElement("g", { className: "tl-centered-g", stroke: o10 == null ? void 0 : o10.color }, reactExports.createElement(a10.Indicator, { shape: n10, meta: i10, user: o10, bounds: d10, isSelected: e10, isHovered: r10 }))));
}
var Ee$1 = reactExports.memo(kn$1);
function Kn({ page: r10, pageState: e10, assets: t10, hideBounds: n10, hideHandles: o10, hideIndicators: i10, hideBindingHandles: s10, hideCloneHandles: a10, hideRotateHandle: d10, hideResizeHandles: l10, meta: c10 }) {
  let { bounds: m10, shapeUtils: p10 } = R$3(), u10 = at(r10, e10, t10, c10), { bounds: y10, isLinked: T10, isLocked: v10, rotation: x10 } = mt(r10, e10, p10), { selectedIds: f10, hoveredId: L10, editingId: Y10, camera: { zoom: X10 } } = e10, S10 = i10, b10 = true, P10 = false, B10, M10 = f10.map((I10) => r10.shapes[I10]);
  if (M10.length === 1) {
    let I10 = M10[0];
    P10 = Y10 === I10.id, P10 && (S10 = true);
    let A10 = p10[I10.type];
    b10 = a10 || !A10.showCloneHandles, I10.handles !== void 0 && !P10 && (B10 = I10);
  }
  return reactExports.createElement(reactExports.Fragment, null, y10 && reactExports.createElement(Kt, { bounds: y10, rotation: x10, isHidden: n10 }), u10.map((I10) => reactExports.createElement(je$1, g$3({ key: I10.shape.id, utils: p10 }, I10))), !S10 && M10.map((I10) => reactExports.createElement(Ee$1, { key: "selected_" + I10.id, shape: I10, meta: c10, isSelected: true, isEditing: P10 })), !S10 && L10 && L10 !== Y10 && reactExports.createElement(Ee$1, { key: "hovered_" + L10, shape: r10.shapes[L10], meta: c10, isHovered: true }), y10 && reactExports.createElement(kt$1, { zoom: X10, bounds: y10, viewportWidth: m10.width, isLocked: v10, rotation: x10, isHidden: n10, hideRotateHandle: d10, hideResizeHandles: l10, hideBindingHandles: s10 || !T10, hideCloneHandles: b10 }), !o10 && B10 && reactExports.createElement(Yt$1, { shape: B10, zoom: X10 }));
}
var $t$1 = reactExports.memo(Kn);
function Dn({ snapLines: r10 }) {
  return reactExports.createElement(reactExports.Fragment, null, r10.map((e10, t10) => reactExports.createElement(Xn, { key: t10, snapLine: e10 })));
}
function Yn$1({ snapLine: r10 }) {
  let e10 = w$3.getBoundsFromPoints(r10);
  return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("line", { className: "tl-snap-line", x1: e10.minX, y1: e10.minY, x2: e10.maxX, y2: e10.maxY }), r10.map(([t10, n10], o10) => reactExports.createElement("use", { key: o10, href: "#tl-snap-point", x: t10, y: n10 })));
}
var Xn = reactExports.memo(Yn$1), Nt = reactExports.memo(Dn);
function Wt({ user: r10, Cursor: e10 }) {
  let t10 = reactExports.useRef(null);
  return reactExports.useLayoutEffect(() => {
    t10.current && (t10.current.style.transform = `translate(${r10.point[0]}px, ${r10.point[1]}px)`);
  }, [r10.point]), reactExports.createElement("div", { ref: t10, className: `tl-absolute tl-user tl-counter-scaled ${r10.session ? "" : "tl-animated"}` }, reactExports.createElement(e10, { id: r10.id, color: r10.color, metadata: r10.metadata }));
}
function At$1({ userId: r10, users: e10, Cursor: t10 }) {
  return reactExports.createElement(reactExports.Fragment, null, Object.values(e10).filter((n10) => n10 && n10.id !== r10).map((n10) => reactExports.createElement(Wt, { key: n10.id, user: n10, Cursor: t10 })));
}
function Ot({ userId: r10, users: e10, meta: t10, page: n10 }) {
  let { shapeUtils: o10 } = R$3();
  return reactExports.createElement(reactExports.Fragment, null, Object.values(e10).filter(Boolean).filter((i10) => i10.id !== r10 && i10.selectedIds.length > 0).map((i10) => {
    let s10 = i10.selectedIds.map((d10) => n10.shapes[d10]).filter(Boolean);
    if (s10.length === 0) return null;
    let a10 = w$3.getCommonBounds(s10.map((d10) => o10[d10.type].getBounds(d10)));
    return reactExports.createElement(reactExports.Fragment, { key: i10.id + "_shapes" }, reactExports.createElement("div", { className: "tl-absolute tl-user-indicator-bounds", style: { backgroundColor: i10.color + "0d", borderColor: i10.color + "78", transform: `translate(${a10.minX}px, ${a10.minY}px)`, width: a10.width, height: a10.height, pointerEvents: "none" } }), s10.map((d10) => reactExports.createElement(Ee$1, { key: `${i10.id}_${d10.id}_indicator`, shape: d10, user: i10, meta: t10, isHovered: true })));
  }));
}
var Un = (r10) => {
  let e10 = r10.parentElement;
  for (; e10; ) {
    if (e10 === document.body) return document;
    let { overflowY: t10 } = window.getComputedStyle(e10);
    if (e10.scrollHeight > e10.clientHeight && (t10 === "auto" || t10 === "scroll" || t10 === "overlay")) return e10;
    e10 = e10.parentElement;
  }
  return document;
};
function Vt$1(r10, e10) {
  let { inputs: t10, callbacks: n10 } = R$3(), o10 = reactExports.useRef(false), i10 = reactExports.useCallback(() => {
    var s10, a10;
    if (o10.current) {
      let d10 = (s10 = r10.current) == null ? void 0 : s10.getBoundingClientRect();
      if (d10) {
        let l10 = { minX: d10.left, maxX: d10.left + d10.width, minY: d10.top, maxY: d10.top + d10.height, width: d10.width, height: d10.height };
        t10.bounds = l10, e10(l10), (a10 = n10.onBoundsChange) == null || a10.call(n10, l10);
      }
    } else o10.current = true;
  }, [r10, t10, n10.onBoundsChange]);
  reactExports.useEffect(() => {
    let s10 = r10.current ? Un(r10.current) : document, a10 = C$2.debounce(i10, 100);
    return s10.addEventListener("scroll", a10), window.addEventListener("resize", a10), () => {
      s10.removeEventListener("scroll", a10), window.removeEventListener("resize", a10);
    };
  }, []), reactExports.useEffect(() => {
    let s10 = new ResizeObserver((a10) => {
      t10.isPinching || a10[0].contentRect && i10();
    });
    return r10.current && s10.observe(r10.current), () => {
      s10.disconnect();
    };
  }, [r10, t10]), reactExports.useEffect(() => {
    i10();
  }, [r10]);
}
function $n$1({ id: r10, page: e10, pageState: t10, assets: n10, snapLines: o10, eraseLine: i10, grid: s10, users: a10, userId: d10, components: l10 = {}, meta: c10, performanceMode: m10, showDashedBrush: p10, hideHandles: u10, hideBounds: y10, hideIndicators: T10, hideBindingHandles: v10, hideCloneHandles: x10, hideResizeHandles: f10, hideRotateHandle: L10, hideGrid: Y10, onBoundsChange: X10, hideCursors: S10 }) {
  var A10;
  let b10 = reactExports.useRef(null), P10 = reactExports.useRef(t10.camera.zoom);
  P10.current = t10.camera.zoom, tt(P10, b10), Vt$1(b10, X10), nt$1(), Tt(b10);
  let B10 = reactExports.useRef(null), M10 = reactExports.useRef(null);
  lt$1(M10, B10, t10), bt(m10, B10), vt();
  let I10 = rt();
  return reactExports.createElement("div", { id: r10, className: "tl-container", ref: B10 }, reactExports.createElement("div", g$3({ id: "canvas", className: "tl-absolute tl-canvas", ref: b10 }, I10), !Y10 && s10 && reactExports.createElement(Ct, { grid: s10, camera: t10.camera }), reactExports.createElement("div", { ref: M10, className: "tl-absolute tl-layer", "data-testid": "layer" }, reactExports.createElement($t$1, { page: e10, pageState: t10, assets: n10, hideBounds: y10, hideIndicators: T10, hideHandles: u10, hideBindingHandles: v10, hideCloneHandles: x10, hideResizeHandles: f10, hideRotateHandle: L10, meta: c10 }), a10 && d10 && reactExports.createElement(Ot, { userId: d10, users: a10, page: e10, meta: c10 }), t10.brush && reactExports.createElement(Pt$1, { brush: t10.brush, dashed: p10, zoom: t10.camera.zoom }), a10 && !S10 && reactExports.createElement(At$1, { userId: d10, users: a10, Cursor: (A10 = l10 == null ? void 0 : l10.Cursor) != null ? A10 : Rt$1 })), reactExports.createElement(St$1, { camera: t10.camera }, i10 && reactExports.createElement(Et, { points: i10, zoom: t10.camera.zoom }), o10 && reactExports.createElement(Nt, { snapLines: o10 }))));
}
var zt$1 = reactExports.memo($n$1);
var Nn$1 = 250, H$3 = class H {
  constructor() {
    E$2(this, "pointer");
    E$2(this, "keyboard");
    E$2(this, "keys", {});
    E$2(this, "isPinching", false);
    E$2(this, "bounds", { minX: 0, maxX: 640, minY: 0, maxY: 480, width: 640, height: 480 });
    E$2(this, "pointerUpTime", 0);
    E$2(this, "activePointer");
    E$2(this, "panStart", (e10) => {
      var a10, d10;
      let { shiftKey: t10, ctrlKey: n10, metaKey: o10, altKey: i10 } = e10, s10 = { target: "wheel", pointerId: ((a10 = this.pointer) == null ? void 0 : a10.pointerId) || 0, origin: ((d10 = this.pointer) == null ? void 0 : d10.origin) || [0, 0], delta: [0, 0], pressure: 0.5, point: H$3.getPoint(e10, this.bounds), shiftKey: t10, ctrlKey: n10, metaKey: o10, altKey: i10, spaceKey: this.keys[" "] };
      return this.pointer = s10, s10;
    });
    E$2(this, "pan", (e10, t10) => {
      if (!this.pointer || this.pointer.target !== "wheel") return this.panStart(t10);
      let { shiftKey: n10, ctrlKey: o10, metaKey: i10, altKey: s10 } = t10, a10 = this.pointer, d10 = H$3.getPoint(t10, this.bounds), l10 = U$1(g$3({}, a10), { target: "wheel", delta: e10, point: d10, shiftKey: n10, ctrlKey: o10, metaKey: i10, altKey: s10, spaceKey: this.keys[" "] });
      return this.pointer = l10, l10;
    });
    E$2(this, "keydown", (e10) => {
      var s10, a10;
      let { shiftKey: t10, ctrlKey: n10, metaKey: o10, altKey: i10 } = e10;
      return this.keys[e10.key] = true, { point: ((s10 = this.pointer) == null ? void 0 : s10.point) || [0, 0], origin: ((a10 = this.pointer) == null ? void 0 : a10.origin) || [0, 0], key: e10.key, keys: Object.keys(this.keys), shiftKey: t10, ctrlKey: n10, metaKey: C$2.isDarwin() ? o10 : n10, altKey: i10 };
    });
    E$2(this, "keyup", (e10) => {
      var s10, a10;
      let { shiftKey: t10, ctrlKey: n10, metaKey: o10, altKey: i10 } = e10;
      return delete this.keys[e10.key], { point: ((s10 = this.pointer) == null ? void 0 : s10.point) || [0, 0], origin: ((a10 = this.pointer) == null ? void 0 : a10.origin) || [0, 0], key: e10.key, keys: Object.keys(this.keys), shiftKey: t10, ctrlKey: n10, metaKey: C$2.isDarwin() ? o10 : n10, altKey: i10 };
    });
  }
  pointerIsValid(e10) {
    if ("pointerId" in e10 && this.activePointer && this.activePointer !== e10.pointerId) return false;
    if ("touches" in e10) {
      let t10 = e10.changedTouches[0];
      if (this.activePointer && this.activePointer !== t10.identifier) return false;
    }
    return true;
  }
  touchStart(e10, t10) {
    let { shiftKey: n10, ctrlKey: o10, metaKey: i10, altKey: s10 } = e10, a10 = e10.changedTouches[0];
    this.activePointer = a10.identifier;
    let d10 = { target: t10, pointerId: a10.identifier, origin: H$3.getPoint(a10, this.bounds), delta: [0, 0], point: H$3.getPoint(a10, this.bounds), pressure: H$3.getPressure(a10), shiftKey: n10, ctrlKey: o10, metaKey: C$2.isDarwin() ? i10 : o10, altKey: s10, spaceKey: this.keys[" "] };
    return this.pointer = d10, d10;
  }
  touchEnd(e10, t10) {
    let { shiftKey: n10, ctrlKey: o10, metaKey: i10, altKey: s10 } = e10, a10 = e10.changedTouches[0], d10 = { target: t10, pointerId: a10.identifier, origin: H$3.getPoint(a10, this.bounds), delta: [0, 0], point: H$3.getPoint(a10, this.bounds), pressure: H$3.getPressure(a10), shiftKey: n10, ctrlKey: o10, metaKey: C$2.isDarwin() ? i10 : o10, altKey: s10, spaceKey: this.keys[" "] };
    return this.pointer = d10, this.activePointer = void 0, d10;
  }
  touchMove(e10, t10) {
    let { shiftKey: n10, ctrlKey: o10, metaKey: i10, altKey: s10 } = e10, a10 = e10.changedTouches[0], d10 = this.pointer, l10 = H$3.getPoint(a10, this.bounds), c10 = (d10 == null ? void 0 : d10.point) ? e$3.sub(l10, d10.point) : [0, 0], m10 = U$1(g$3({ origin: l10 }, d10), { target: t10, pointerId: a10.identifier, point: l10, delta: c10, pressure: H$3.getPressure(a10), shiftKey: n10, ctrlKey: o10, metaKey: C$2.isDarwin() ? i10 : o10, altKey: s10, spaceKey: this.keys[" "] });
    return this.pointer = m10, m10;
  }
  pointerDown(e10, t10) {
    let { shiftKey: n10, ctrlKey: o10, metaKey: i10, altKey: s10 } = e10, a10 = H$3.getPoint(e10, this.bounds);
    this.activePointer = e10.pointerId;
    let d10 = { target: t10, pointerId: e10.pointerId, origin: a10, point: a10, delta: [0, 0], pressure: H$3.getPressure(e10), shiftKey: n10, ctrlKey: o10, metaKey: C$2.isDarwin() ? i10 : o10, altKey: s10, spaceKey: this.keys[" "] };
    return this.pointer = d10, d10;
  }
  pointerEnter(e10, t10) {
    let { shiftKey: n10, ctrlKey: o10, metaKey: i10, altKey: s10 } = e10, a10 = H$3.getPoint(e10, this.bounds), d10 = { target: t10, pointerId: e10.pointerId, origin: a10, delta: [0, 0], point: a10, pressure: H$3.getPressure(e10), shiftKey: n10, ctrlKey: o10, metaKey: C$2.isDarwin() ? i10 : o10, altKey: s10, spaceKey: this.keys[" "] };
    return this.pointer = d10, d10;
  }
  pointerMove(e10, t10) {
    let { shiftKey: n10, ctrlKey: o10, metaKey: i10, altKey: s10 } = e10, a10 = this.pointer, d10 = H$3.getPoint(e10, this.bounds), l10 = (a10 == null ? void 0 : a10.point) ? e$3.sub(d10, a10.point) : [0, 0], c10 = U$1(g$3({ origin: d10 }, a10), { target: t10, pointerId: e10.pointerId, point: d10, delta: l10, pressure: H$3.getPressure(e10), shiftKey: n10, ctrlKey: o10, metaKey: C$2.isDarwin() ? i10 : o10, altKey: s10, spaceKey: this.keys[" "] });
    return this.pointer = c10, c10;
  }
  pointerUp(e10, t10) {
    let { shiftKey: n10, ctrlKey: o10, metaKey: i10, altKey: s10 } = e10, a10 = this.pointer, d10 = H$3.getPoint(e10, this.bounds), l10 = (a10 == null ? void 0 : a10.point) ? e$3.sub(d10, a10.point) : [0, 0];
    this.activePointer = void 0;
    let c10 = U$1(g$3({ origin: d10 }, a10), { target: t10, pointerId: e10.pointerId, point: d10, delta: l10, pressure: H$3.getPressure(e10), shiftKey: n10, ctrlKey: o10, metaKey: C$2.isDarwin() ? i10 : o10, altKey: s10, spaceKey: this.keys[" "] });
    return this.pointer = c10, this.pointerUpTime = performance.now(), c10;
  }
  isDoubleClick() {
    if (!this.pointer) return false;
    let { origin: e10, point: t10 } = this.pointer, n10 = performance.now() - this.pointerUpTime < Nn$1 && e$3.dist(e10, t10) < 4;
    return n10 && (this.activePointer = void 0), n10;
  }
  clear() {
    this.pointer = void 0;
  }
  resetDoubleClick() {
    this.pointerUpTime = 0;
  }
  pinch(e10, t10) {
    let { shiftKey: n10, ctrlKey: o10, metaKey: i10, altKey: s10 } = this.keys, a10 = e$3.sub(t10, e10), d10 = { pointerId: 0, target: "pinch", origin: t10, delta: a10, point: e$3.sub(e$3.toFixed(e10), [this.bounds.minX, this.bounds.minY]), pressure: 0.5, shiftKey: n10, ctrlKey: o10, metaKey: C$2.isDarwin() ? i10 : o10, altKey: s10, spaceKey: this.keys[" "] };
    return this.pointer = d10, d10;
  }
  reset() {
    this.pointerUpTime = 0, this.pointer = void 0, this.keyboard = void 0, this.activePointer = void 0, this.keys = {};
  }
  static getPoint(e10, t10) {
    return [+e10.clientX.toFixed(2) - t10.minX, +e10.clientY.toFixed(2) - t10.minY];
  }
  static getPressure(e10) {
    return "pressure" in e10 && +e10.pressure.toFixed(2) || 0.5;
  }
  static commandKey() {
    return C$2.isDarwin() ? "" : "Ctrl";
  }
};
new H$3();
var Wn$1 = Object.freeze({});
function An$1(M10) {
  var I10 = M10, { id: r10 = "tl", shapeUtils: e10, page: t10, pageState: n10, assets: o10 = Wn$1, users: i10, userId: s10, theme: a10, meta: d10, snapLines: l10, eraseLine: c10, grid: m10, containerRef: p10, performanceMode: u10, components: y10, hideHandles: T10 = false, hideIndicators: v10 = false, hideCloneHandles: x10 = false, hideBindingHandles: f10 = false, hideResizeHandles: L10 = false, hideRotateHandles: Y10 = false, hideBounds: X10 = false, hideGrid: S10 = true, showDashedBrush: b10 = false, hideCursors: P10 } = I10, B10 = O$2(I10, ["id", "shapeUtils", "page", "pageState", "assets", "users", "userId", "theme", "meta", "snapLines", "eraseLine", "grid", "containerRef", "performanceMode", "components", "hideHandles", "hideIndicators", "hideCloneHandles", "hideBindingHandles", "hideResizeHandles", "hideRotateHandles", "hideBounds", "hideGrid", "showDashedBrush", "hideCursors"]);
  dt(a10, "#" + r10);
  let A10 = reactExports.useRef(null), J10 = reactExports.useRef(n10);
  reactExports.useEffect(() => {
    J10.current = n10;
  }, [n10]);
  let [Ft, Gt2] = reactExports.useState(() => ({ callbacks: B10, shapeUtils: e10, rSelectionBounds: A10, rPageState: J10, bounds: { minX: 0, minY: 0, maxX: 1 / 0, maxY: 1 / 0, width: 1 / 0, height: 1 / 0 }, inputs: new H$3() })), jt = reactExports.useCallback((_t) => {
    Gt2((Zt) => U$1(g$3({}, Zt), { bounds: _t }));
  }, []);
  return reactExports.createElement(Le$1.Provider, { value: Ft }, reactExports.createElement(zt$1, { id: r10, page: t10, pageState: n10, assets: o10, snapLines: l10, eraseLine: c10, grid: m10, users: i10, userId: s10, externalContainerRef: p10, hideBounds: X10, hideIndicators: v10, hideHandles: T10, hideCloneHandles: x10, hideBindingHandles: f10, hideRotateHandle: Y10, hideResizeHandles: L10, hideGrid: S10, showDashedBrush: b10, onBoundsChange: jt, performanceMode: u10, components: y10, meta: d10, hideCursors: P10 }));
}
var ks = reactExports.memo(An$1);
var Xs = reactExports.memo(reactExports.forwardRef(function(i10, o10) {
  var s10 = i10, { children: e10, className: t10 = "" } = s10, n10 = O$2(s10, ["children", "className"]);
  return reactExports.createElement("div", g$3({ ref: o10, className: `tl-positioned-div ${t10}`, draggable: false }, n10), reactExports.createElement("div", { className: "tl-inner-div" }, e10));
}));
var _e = class {
  constructor() {
    E$2(this, "refMap", /* @__PURE__ */ new Map());
    E$2(this, "boundsCache", /* @__PURE__ */ new WeakMap());
    E$2(this, "showCloneHandles", false);
    E$2(this, "hideBounds", false);
    E$2(this, "isStateful", false);
    E$2(this, "shouldRender", (e10, t10) => true);
    E$2(this, "getRef", (e10) => (this.refMap.has(e10.id) || this.refMap.set(e10.id, reactExports.createRef()), this.refMap.get(e10.id)));
    E$2(this, "hitTestBounds", (e10, t10) => {
      let n10 = this.getBounds(e10), o10 = w$3.getRotatedCorners(n10, e10.rotation);
      return o10.every((i10) => w$3.pointInBounds(i10, t10)) || ee$1(o10, t10).length > 0;
    });
    E$2(this, "getRotatedBounds", (e10) => w$3.getBoundsFromPoints(w$3.getRotatedCorners(this.getBounds(e10), e10.rotation)));
  }
};
E$2(_e, "Component", (e10) => reactExports.forwardRef(e10)), E$2(_e, "Indicator", (e10) => e10);
/**
* String.prototype.replaceAll() polyfill
* https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/
* @author Chris Ferdinandi
* @license MIT
*/
function _setPrototypeOf(t10, e10) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t11, e11) {
    return t11.__proto__ = e11, t11;
  }, _setPrototypeOf(t10, e10);
}
function _inheritsLoose(t10, o10) {
  t10.prototype = Object.create(o10.prototype), t10.prototype.constructor = t10, _setPrototypeOf(t10, o10);
}
var changedArray = function changedArray2(a10, b10) {
  if (a10 === void 0) {
    a10 = [];
  }
  if (b10 === void 0) {
    b10 = [];
  }
  return a10.length !== b10.length || a10.some(function(item, index2) {
    return !Object.is(item, b10[index2]);
  });
};
var initialState = {
  error: null
};
var ErrorBoundary = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(ErrorBoundary2, _React$Component);
  function ErrorBoundary2() {
    var _this;
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
    _this.state = initialState;
    _this.resetErrorBoundary = function() {
      var _this$props;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);
      _this.reset();
    };
    return _this;
  }
  ErrorBoundary2.getDerivedStateFromError = function getDerivedStateFromError(error) {
    return {
      error
    };
  };
  var _proto = ErrorBoundary2.prototype;
  _proto.reset = function reset() {
    this.setState(initialState);
  };
  _proto.componentDidCatch = function componentDidCatch(error, info) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    var error = this.state.error;
    var resetKeys = this.props.resetKeys;
    if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {
      var _this$props$onResetKe, _this$props3;
      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);
      this.reset();
    }
  };
  _proto.render = function render() {
    var error = this.state.error;
    var _this$props4 = this.props, fallbackRender = _this$props4.fallbackRender, FallbackComponent = _this$props4.FallbackComponent, fallback = _this$props4.fallback;
    if (error !== null) {
      var _props = {
        error,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (/* @__PURE__ */ reactExports.isValidElement(fallback)) {
        return fallback;
      } else if (typeof fallbackRender === "function") {
        return fallbackRender(_props);
      } else if (FallbackComponent) {
        return /* @__PURE__ */ reactExports.createElement(FallbackComponent, _props);
      } else {
        throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
    }
    return this.props.children;
  };
  return ErrorBoundary2;
}(reactExports.Component);
var extendStatics = function(d10, b10) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d11, b11) {
    d11.__proto__ = b11;
  } || function(d11, b11) {
    for (var p10 in b11) if (Object.prototype.hasOwnProperty.call(b11, p10)) d11[p10] = b11[p10];
  };
  return extendStatics(d10, b10);
};
function __extends(d10, b10) {
  if (typeof b10 !== "function" && b10 !== null)
    throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
  extendStatics(d10, b10);
  function __2() {
    this.constructor = d10;
  }
  d10.prototype = b10 === null ? Object.create(b10) : (__2.prototype = b10.prototype, new __2());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t10) {
    for (var s10, i10 = 1, n10 = arguments.length; i10 < n10; i10++) {
      s10 = arguments[i10];
      for (var p10 in s10) if (Object.prototype.hasOwnProperty.call(s10, p10)) t10[p10] = s10[p10];
    }
    return t10;
  };
  return __assign.apply(this, arguments);
};
function __rest(s10, e10) {
  var t10 = {};
  for (var p10 in s10) if (Object.prototype.hasOwnProperty.call(s10, p10) && e10.indexOf(p10) < 0)
    t10[p10] = s10[p10];
  if (s10 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i10 = 0, p10 = Object.getOwnPropertySymbols(s10); i10 < p10.length; i10++) {
      if (e10.indexOf(p10[i10]) < 0 && Object.prototype.propertyIsEnumerable.call(s10, p10[i10]))
        t10[p10[i10]] = s10[p10[i10]];
    }
  return t10;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i10 = 0, l10 = from.length, ar2; i10 < l10; i10++) {
    if (ar2 || !(i10 in from)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i10);
      ar2[i10] = from[i10];
    }
  }
  return to.concat(ar2 || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e10 = new Error(message);
  return e10.name = "SuppressedError", e10.error = error, e10.suppressed = suppressed, e10;
};
function memoize(fn2, options) {
  var cache = options && options.cache ? options.cache : cacheDefault;
  var serializer = options && options.serializer ? options.serializer : serializerDefault;
  var strategy = options && options.strategy ? options.strategy : strategyDefault;
  return strategy(fn2, {
    cache,
    serializer
  });
}
function isPrimitive(value) {
  return value == null || typeof value === "number" || typeof value === "boolean";
}
function monadic(fn2, cache, serializer, arg) {
  var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
  var computedValue = cache.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn2.call(this, arg);
    cache.set(cacheKey, computedValue);
  }
  return computedValue;
}
function variadic(fn2, cache, serializer) {
  var args = Array.prototype.slice.call(arguments, 3);
  var cacheKey = serializer(args);
  var computedValue = cache.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn2.apply(this, args);
    cache.set(cacheKey, computedValue);
  }
  return computedValue;
}
function assemble(fn2, context, strategy, cache, serialize) {
  return strategy.bind(context, fn2, cache, serialize);
}
function strategyDefault(fn2, options) {
  var strategy = fn2.length === 1 ? monadic : variadic;
  return assemble(fn2, this, strategy, options.cache.create(), options.serializer);
}
function strategyVariadic(fn2, options) {
  return assemble(fn2, this, variadic, options.cache.create(), options.serializer);
}
var serializerDefault = function() {
  return JSON.stringify(arguments);
};
function ObjectWithoutPrototypeCache() {
  this.cache = /* @__PURE__ */ Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function(key) {
  return this.cache[key];
};
ObjectWithoutPrototypeCache.prototype.set = function(key, value) {
  this.cache[key] = value;
};
var cacheDefault = {
  create: function create() {
    return new ObjectWithoutPrototypeCache();
  }
};
var strategies = {
  variadic: strategyVariadic
};
function invariant(condition, message, Err) {
  if (Err === void 0) {
    Err = Error;
  }
  if (!condition) {
    throw new Err(message);
  }
}
memoize(function() {
  var _a2;
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  return new ((_a2 = Intl.NumberFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
}, {
  strategy: strategies.variadic
});
memoize(function() {
  var _a2;
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  return new ((_a2 = Intl.DateTimeFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
}, {
  strategy: strategies.variadic
});
memoize(function() {
  var _a2;
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  return new ((_a2 = Intl.PluralRules).bind.apply(_a2, __spreadArray([void 0], args, false)))();
}, {
  strategy: strategies.variadic
});
memoize(function() {
  var _a2;
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  return new ((_a2 = Intl.Locale).bind.apply(_a2, __spreadArray([void 0], args, false)))();
}, {
  strategy: strategies.variadic
});
memoize(function() {
  var _a2;
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  return new ((_a2 = Intl.ListFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
}, {
  strategy: strategies.variadic
});
var ErrorKind;
(function(ErrorKind2) {
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
  ErrorKind2[ErrorKind2["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
  ErrorKind2[ErrorKind2["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
  ErrorKind2[ErrorKind2["INVALID_TAG"] = 23] = "INVALID_TAG";
  ErrorKind2[ErrorKind2["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
  ErrorKind2[ErrorKind2["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
  ErrorKind2[ErrorKind2["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));
var TYPE;
(function(TYPE2) {
  TYPE2[TYPE2["literal"] = 0] = "literal";
  TYPE2[TYPE2["argument"] = 1] = "argument";
  TYPE2[TYPE2["number"] = 2] = "number";
  TYPE2[TYPE2["date"] = 3] = "date";
  TYPE2[TYPE2["time"] = 4] = "time";
  TYPE2[TYPE2["select"] = 5] = "select";
  TYPE2[TYPE2["plural"] = 6] = "plural";
  TYPE2[TYPE2["pound"] = 7] = "pound";
  TYPE2[TYPE2["tag"] = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function(SKELETON_TYPE2) {
  SKELETON_TYPE2[SKELETON_TYPE2["number"] = 0] = "number";
  SKELETON_TYPE2[SKELETON_TYPE2["dateTime"] = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
function isLiteralElement(el) {
  return el.type === TYPE.literal;
}
function isArgumentElement(el) {
  return el.type === TYPE.argument;
}
function isNumberElement(el) {
  return el.type === TYPE.number;
}
function isDateElement(el) {
  return el.type === TYPE.date;
}
function isTimeElement(el) {
  return el.type === TYPE.time;
}
function isSelectElement(el) {
  return el.type === TYPE.select;
}
function isPluralElement(el) {
  return el.type === TYPE.plural;
}
function isPoundElement(el) {
  return el.type === TYPE.pound;
}
function isTagElement(el) {
  return el.type === TYPE.tag;
}
function isNumberSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.dateTime);
}
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(skeleton) {
  var result = {};
  skeleton.replace(DATE_TIME_REGEX, function(match) {
    var len = match.length;
    switch (match[0]) {
      // Era
      case "G":
        result.era = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      // Year
      case "y":
        result.year = len === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      // Quarter
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      // Month
      case "M":
      case "L":
        result.month = ["numeric", "2-digit", "short", "long", "narrow"][len - 1];
        break;
      // Week
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        result.day = ["numeric", "2-digit"][len - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      // Weekday
      case "E":
        result.weekday = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "e":
        if (len < 4) {
          throw new RangeError("`e..eee` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "c":
        if (len < 4) {
          throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      // Period
      case "a":
        result.hour12 = true;
        break;
      case "b":
      // am, pm, noon, midnight
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      // Hour
      case "h":
        result.hourCycle = "h12";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "H":
        result.hourCycle = "h23";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "K":
        result.hourCycle = "h11";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "k":
        result.hourCycle = "h24";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      // Minute
      case "m":
        result.minute = ["numeric", "2-digit"][len - 1];
        break;
      // Second
      case "s":
        result.second = ["numeric", "2-digit"][len - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
      // Zone
      case "z":
        result.timeZoneName = len < 4 ? "short" : "long";
        break;
      case "Z":
      // 1..3, 4, 5: The ISO8601 varios formats
      case "O":
      // 1, 4: milliseconds in day short, long
      case "v":
      // 1, 4: generic non-location format
      case "V":
      // 1, 2, 3, 4: time zone ID or city
      case "X":
      // 1, 2, 3, 4: The ISO8601 varios formats
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
    }
    return "";
  });
  return result;
}
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;
function parseNumberSkeletonFromString(skeleton) {
  if (skeleton.length === 0) {
    throw new Error("Number skeleton cannot be empty");
  }
  var stringTokens = skeleton.split(WHITE_SPACE_REGEX).filter(function(x10) {
    return x10.length > 0;
  });
  var tokens = [];
  for (var _i2 = 0, stringTokens_1 = stringTokens; _i2 < stringTokens_1.length; _i2++) {
    var stringToken = stringTokens_1[_i2];
    var stemAndOptions = stringToken.split("/");
    if (stemAndOptions.length === 0) {
      throw new Error("Invalid number skeleton");
    }
    var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
    for (var _a2 = 0, options_1 = options; _a2 < options_1.length; _a2++) {
      var option = options_1[_a2];
      if (option.length === 0) {
        throw new Error("Invalid number skeleton");
      }
    }
    tokens.push({ stem, options });
  }
  return tokens;
}
function icuUnitToEcma(unit) {
  return unit.replace(/^(.*?)-/, "");
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(str) {
  var result = {};
  if (str[str.length - 1] === "r") {
    result.roundingPriority = "morePrecision";
  } else if (str[str.length - 1] === "s") {
    result.roundingPriority = "lessPrecision";
  }
  str.replace(SIGNIFICANT_PRECISION_REGEX, function(_10, g12, g22) {
    if (typeof g22 !== "string") {
      result.minimumSignificantDigits = g12.length;
      result.maximumSignificantDigits = g12.length;
    } else if (g22 === "+") {
      result.minimumSignificantDigits = g12.length;
    } else if (g12[0] === "#") {
      result.maximumSignificantDigits = g12.length;
    } else {
      result.minimumSignificantDigits = g12.length;
      result.maximumSignificantDigits = g12.length + (typeof g22 === "string" ? g22.length : 0);
    }
    return "";
  });
  return result;
}
function parseSign(str) {
  switch (str) {
    case "sign-auto":
      return {
        signDisplay: "auto"
      };
    case "sign-accounting":
    case "()":
      return {
        currencySign: "accounting"
      };
    case "sign-always":
    case "+!":
      return {
        signDisplay: "always"
      };
    case "sign-accounting-always":
    case "()!":
      return {
        signDisplay: "always",
        currencySign: "accounting"
      };
    case "sign-except-zero":
    case "+?":
      return {
        signDisplay: "exceptZero"
      };
    case "sign-accounting-except-zero":
    case "()?":
      return {
        signDisplay: "exceptZero",
        currencySign: "accounting"
      };
    case "sign-never":
    case "+_":
      return {
        signDisplay: "never"
      };
  }
}
function parseConciseScientificAndEngineeringStem(stem) {
  var result;
  if (stem[0] === "E" && stem[1] === "E") {
    result = {
      notation: "engineering"
    };
    stem = stem.slice(2);
  } else if (stem[0] === "E") {
    result = {
      notation: "scientific"
    };
    stem = stem.slice(1);
  }
  if (result) {
    var signDisplay = stem.slice(0, 2);
    if (signDisplay === "+!") {
      result.signDisplay = "always";
      stem = stem.slice(2);
    } else if (signDisplay === "+?") {
      result.signDisplay = "exceptZero";
      stem = stem.slice(2);
    }
    if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
      throw new Error("Malformed concise eng/scientific notation");
    }
    result.minimumIntegerDigits = stem.length;
  }
  return result;
}
function parseNotationOptions(opt) {
  var result = {};
  var signOpts = parseSign(opt);
  if (signOpts) {
    return signOpts;
  }
  return result;
}
function parseNumberSkeleton(tokens) {
  var result = {};
  for (var _i2 = 0, tokens_1 = tokens; _i2 < tokens_1.length; _i2++) {
    var token = tokens_1[_i2];
    switch (token.stem) {
      case "percent":
      case "%":
        result.style = "percent";
        continue;
      case "%x100":
        result.style = "percent";
        result.scale = 100;
        continue;
      case "currency":
        result.style = "currency";
        result.currency = token.options[0];
        continue;
      case "group-off":
      case ",_":
        result.useGrouping = false;
        continue;
      case "precision-integer":
      case ".":
        result.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        result.style = "unit";
        result.unit = icuUnitToEcma(token.options[0]);
        continue;
      case "compact-short":
      case "K":
        result.notation = "compact";
        result.compactDisplay = "short";
        continue;
      case "compact-long":
      case "KK":
        result.notation = "compact";
        result.compactDisplay = "long";
        continue;
      case "scientific":
        result = __assign(__assign(__assign({}, result), { notation: "scientific" }), token.options.reduce(function(all, opt2) {
          return __assign(__assign({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "engineering":
        result = __assign(__assign(__assign({}, result), { notation: "engineering" }), token.options.reduce(function(all, opt2) {
          return __assign(__assign({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "notation-simple":
        result.notation = "standard";
        continue;
      // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h
      case "unit-width-narrow":
        result.currencyDisplay = "narrowSymbol";
        result.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        result.currencyDisplay = "code";
        result.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        result.currencyDisplay = "name";
        result.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        result.currencyDisplay = "symbol";
        continue;
      case "scale":
        result.scale = parseFloat(token.options[0]);
        continue;
      case "rounding-mode-floor":
        result.roundingMode = "floor";
        continue;
      case "rounding-mode-ceiling":
        result.roundingMode = "ceil";
        continue;
      case "rounding-mode-down":
        result.roundingMode = "trunc";
        continue;
      case "rounding-mode-up":
        result.roundingMode = "expand";
        continue;
      case "rounding-mode-half-even":
        result.roundingMode = "halfEven";
        continue;
      case "rounding-mode-half-down":
        result.roundingMode = "halfTrunc";
        continue;
      case "rounding-mode-half-up":
        result.roundingMode = "halfExpand";
        continue;
      // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
      case "integer-width":
        if (token.options.length > 1) {
          throw new RangeError("integer-width stems only accept a single optional option");
        }
        token.options[0].replace(INTEGER_WIDTH_REGEX, function(_10, g12, g22, g32, g42, g52) {
          if (g12) {
            result.minimumIntegerDigits = g22.length;
          } else if (g32 && g42) {
            throw new Error("We currently do not support maximum integer digits");
          } else if (g52) {
            throw new Error("We currently do not support exact integer digits");
          }
          return "";
        });
        continue;
    }
    if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
      result.minimumIntegerDigits = token.stem.length;
      continue;
    }
    if (FRACTION_PRECISION_REGEX.test(token.stem)) {
      if (token.options.length > 1) {
        throw new RangeError("Fraction-precision stems only accept a single optional option");
      }
      token.stem.replace(FRACTION_PRECISION_REGEX, function(_10, g12, g22, g32, g42, g52) {
        if (g22 === "*") {
          result.minimumFractionDigits = g12.length;
        } else if (g32 && g32[0] === "#") {
          result.maximumFractionDigits = g32.length;
        } else if (g42 && g52) {
          result.minimumFractionDigits = g42.length;
          result.maximumFractionDigits = g42.length + g52.length;
        } else {
          result.minimumFractionDigits = g12.length;
          result.maximumFractionDigits = g12.length;
        }
        return "";
      });
      var opt = token.options[0];
      if (opt === "w") {
        result = __assign(__assign({}, result), { trailingZeroDisplay: "stripIfInteger" });
      } else if (opt) {
        result = __assign(__assign({}, result), parseSignificantPrecision(opt));
      }
      continue;
    }
    if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
      result = __assign(__assign({}, result), parseSignificantPrecision(token.stem));
      continue;
    }
    var signOpts = parseSign(token.stem);
    if (signOpts) {
      result = __assign(__assign({}, result), signOpts);
    }
    var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
    if (conciseScientificAndEngineeringOpts) {
      result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);
    }
  }
  return result;
}
var timeData = {
  "001": [
    "H",
    "h"
  ],
  "419": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "AC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "AD": [
    "H",
    "hB"
  ],
  "AE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "AF": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "AG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "AI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "AL": [
    "h",
    "H",
    "hB"
  ],
  "AM": [
    "H",
    "hB"
  ],
  "AO": [
    "H",
    "hB"
  ],
  "AR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "AS": [
    "h",
    "H"
  ],
  "AT": [
    "H",
    "hB"
  ],
  "AU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "AW": [
    "H",
    "hB"
  ],
  "AX": [
    "H"
  ],
  "AZ": [
    "H",
    "hB",
    "h"
  ],
  "BA": [
    "H",
    "hB",
    "h"
  ],
  "BB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BD": [
    "h",
    "hB",
    "H"
  ],
  "BE": [
    "H",
    "hB"
  ],
  "BF": [
    "H",
    "hB"
  ],
  "BG": [
    "H",
    "hB",
    "h"
  ],
  "BH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "BI": [
    "H",
    "h"
  ],
  "BJ": [
    "H",
    "hB"
  ],
  "BL": [
    "H",
    "hB"
  ],
  "BM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BN": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "BO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "BQ": [
    "H"
  ],
  "BR": [
    "H",
    "hB"
  ],
  "BS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "BT": [
    "h",
    "H"
  ],
  "BW": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "BY": [
    "H",
    "h"
  ],
  "BZ": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CA": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "CC": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CD": [
    "hB",
    "H"
  ],
  "CF": [
    "H",
    "h",
    "hB"
  ],
  "CG": [
    "H",
    "hB"
  ],
  "CH": [
    "H",
    "hB",
    "h"
  ],
  "CI": [
    "H",
    "hB"
  ],
  "CK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CL": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CM": [
    "H",
    "h",
    "hB"
  ],
  "CN": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "CO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CP": [
    "H"
  ],
  "CR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CU": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "CV": [
    "H",
    "hB"
  ],
  "CW": [
    "H",
    "hB"
  ],
  "CX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "CY": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "CZ": [
    "H"
  ],
  "DE": [
    "H",
    "hB"
  ],
  "DG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "DJ": [
    "h",
    "H"
  ],
  "DK": [
    "H"
  ],
  "DM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "DO": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "DZ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "EC": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "EE": [
    "H",
    "hB"
  ],
  "EG": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "EH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "ER": [
    "h",
    "H"
  ],
  "ES": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "ET": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "FI": [
    "H"
  ],
  "FJ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "FM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "FO": [
    "H",
    "h"
  ],
  "FR": [
    "H",
    "hB"
  ],
  "GA": [
    "H",
    "hB"
  ],
  "GB": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GD": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GE": [
    "H",
    "hB",
    "h"
  ],
  "GF": [
    "H",
    "hB"
  ],
  "GG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GH": [
    "h",
    "H"
  ],
  "GI": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "GL": [
    "H",
    "h"
  ],
  "GM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GN": [
    "H",
    "hB"
  ],
  "GP": [
    "H",
    "hB"
  ],
  "GQ": [
    "H",
    "hB",
    "h",
    "hb"
  ],
  "GR": [
    "h",
    "H",
    "hb",
    "hB"
  ],
  "GT": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "GU": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "GW": [
    "H",
    "hB"
  ],
  "GY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "HK": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "HN": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "HR": [
    "H",
    "hB"
  ],
  "HU": [
    "H",
    "h"
  ],
  "IC": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "ID": [
    "H"
  ],
  "IE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IL": [
    "H",
    "hB"
  ],
  "IM": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IN": [
    "h",
    "H"
  ],
  "IO": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "IQ": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "IR": [
    "hB",
    "H"
  ],
  "IS": [
    "H"
  ],
  "IT": [
    "H",
    "hB"
  ],
  "JE": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "JM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "JO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "JP": [
    "H",
    "K",
    "h"
  ],
  "KE": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "KG": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KH": [
    "hB",
    "h",
    "H",
    "hb"
  ],
  "KI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KM": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "KN": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KP": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "KW": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "KY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "KZ": [
    "H",
    "hB"
  ],
  "LA": [
    "H",
    "hb",
    "hB",
    "h"
  ],
  "LB": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "LC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LI": [
    "H",
    "hB",
    "h"
  ],
  "LK": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "LR": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "LS": [
    "h",
    "H"
  ],
  "LT": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "LU": [
    "H",
    "h",
    "hB"
  ],
  "LV": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "LY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "MC": [
    "H",
    "hB"
  ],
  "MD": [
    "H",
    "hB"
  ],
  "ME": [
    "H",
    "hB",
    "h"
  ],
  "MF": [
    "H",
    "hB"
  ],
  "MG": [
    "H",
    "h"
  ],
  "MH": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MK": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "ML": [
    "H"
  ],
  "MM": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "MN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MO": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MP": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MQ": [
    "H",
    "hB"
  ],
  "MR": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "MS": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "MT": [
    "H",
    "h"
  ],
  "MU": [
    "H",
    "h"
  ],
  "MV": [
    "H",
    "h"
  ],
  "MW": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "MX": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "MY": [
    "hb",
    "hB",
    "h",
    "H"
  ],
  "MZ": [
    "H",
    "hB"
  ],
  "NA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "NC": [
    "H",
    "hB"
  ],
  "NE": [
    "H"
  ],
  "NF": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NG": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NI": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "NL": [
    "H",
    "hB"
  ],
  "NO": [
    "H",
    "h"
  ],
  "NP": [
    "H",
    "h",
    "hB"
  ],
  "NR": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NU": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "NZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "OM": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PA": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PE": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PF": [
    "H",
    "h",
    "hB"
  ],
  "PG": [
    "h",
    "H"
  ],
  "PH": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PK": [
    "h",
    "hB",
    "H"
  ],
  "PL": [
    "H",
    "h"
  ],
  "PM": [
    "H",
    "hB"
  ],
  "PN": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "PR": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "PS": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "PT": [
    "H",
    "hB"
  ],
  "PW": [
    "h",
    "H"
  ],
  "PY": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "QA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "RE": [
    "H",
    "hB"
  ],
  "RO": [
    "H",
    "hB"
  ],
  "RS": [
    "H",
    "hB",
    "h"
  ],
  "RU": [
    "H"
  ],
  "RW": [
    "H",
    "h"
  ],
  "SA": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SB": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SC": [
    "H",
    "h",
    "hB"
  ],
  "SD": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SE": [
    "H"
  ],
  "SG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SH": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SI": [
    "H",
    "hB"
  ],
  "SJ": [
    "H"
  ],
  "SK": [
    "H"
  ],
  "SL": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "SM": [
    "H",
    "h",
    "hB"
  ],
  "SN": [
    "H",
    "h",
    "hB"
  ],
  "SO": [
    "h",
    "H"
  ],
  "SR": [
    "H",
    "hB"
  ],
  "SS": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "ST": [
    "H",
    "hB"
  ],
  "SV": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "SX": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "SY": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "SZ": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "TC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TD": [
    "h",
    "H",
    "hB"
  ],
  "TF": [
    "H",
    "h",
    "hB"
  ],
  "TG": [
    "H",
    "hB"
  ],
  "TH": [
    "H",
    "h"
  ],
  "TJ": [
    "H",
    "h"
  ],
  "TL": [
    "H",
    "hB",
    "hb",
    "h"
  ],
  "TM": [
    "H",
    "h"
  ],
  "TN": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "TO": [
    "h",
    "H"
  ],
  "TR": [
    "H",
    "hB"
  ],
  "TT": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "TW": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "TZ": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "UA": [
    "H",
    "hB",
    "h"
  ],
  "UG": [
    "hB",
    "hb",
    "H",
    "h"
  ],
  "UM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "US": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "UY": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "UZ": [
    "H",
    "hB",
    "h"
  ],
  "VA": [
    "H",
    "h",
    "hB"
  ],
  "VC": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VE": [
    "h",
    "H",
    "hB",
    "hb"
  ],
  "VG": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VI": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "VN": [
    "H",
    "h"
  ],
  "VU": [
    "h",
    "H"
  ],
  "WF": [
    "H",
    "hB"
  ],
  "WS": [
    "h",
    "H"
  ],
  "XK": [
    "H",
    "hB",
    "h"
  ],
  "YE": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "YT": [
    "H",
    "hB"
  ],
  "ZA": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "ZM": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "ZW": [
    "H",
    "h"
  ],
  "af-ZA": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "ar-001": [
    "h",
    "hB",
    "hb",
    "H"
  ],
  "ca-ES": [
    "H",
    "h",
    "hB"
  ],
  "en-001": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "en-HK": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "en-IL": [
    "H",
    "h",
    "hb",
    "hB"
  ],
  "en-MY": [
    "h",
    "hb",
    "H",
    "hB"
  ],
  "es-BR": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-ES": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "es-GQ": [
    "H",
    "h",
    "hB",
    "hb"
  ],
  "fr-CA": [
    "H",
    "h",
    "hB"
  ],
  "gl-ES": [
    "H",
    "h",
    "hB"
  ],
  "gu-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "hi-IN": [
    "hB",
    "h",
    "H"
  ],
  "it-CH": [
    "H",
    "h",
    "hB"
  ],
  "it-IT": [
    "H",
    "h",
    "hB"
  ],
  "kn-IN": [
    "hB",
    "h",
    "H"
  ],
  "ml-IN": [
    "hB",
    "h",
    "H"
  ],
  "mr-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "pa-IN": [
    "hB",
    "hb",
    "h",
    "H"
  ],
  "ta-IN": [
    "hB",
    "h",
    "hb",
    "H"
  ],
  "te-IN": [
    "hB",
    "h",
    "H"
  ],
  "zu-ZA": [
    "H",
    "hB",
    "hb",
    "h"
  ]
};
function getBestPattern(skeleton, locale) {
  var skeletonCopy = "";
  for (var patternPos = 0; patternPos < skeleton.length; patternPos++) {
    var patternChar = skeleton.charAt(patternPos);
    if (patternChar === "j") {
      var extraLength = 0;
      while (patternPos + 1 < skeleton.length && skeleton.charAt(patternPos + 1) === patternChar) {
        extraLength++;
        patternPos++;
      }
      var hourLen = 1 + (extraLength & 1);
      var dayPeriodLen = extraLength < 2 ? 1 : 3 + (extraLength >> 1);
      var dayPeriodChar = "a";
      var hourChar = getDefaultHourSymbolFromLocale(locale);
      if (hourChar == "H" || hourChar == "k") {
        dayPeriodLen = 0;
      }
      while (dayPeriodLen-- > 0) {
        skeletonCopy += dayPeriodChar;
      }
      while (hourLen-- > 0) {
        skeletonCopy = hourChar + skeletonCopy;
      }
    } else if (patternChar === "J") {
      skeletonCopy += "H";
    } else {
      skeletonCopy += patternChar;
    }
  }
  return skeletonCopy;
}
function getDefaultHourSymbolFromLocale(locale) {
  var hourCycle = locale.hourCycle;
  if (hourCycle === void 0 && // @ts-ignore hourCycle(s) is not identified yet
  locale.hourCycles && // @ts-ignore
  locale.hourCycles.length) {
    hourCycle = locale.hourCycles[0];
  }
  if (hourCycle) {
    switch (hourCycle) {
      case "h24":
        return "k";
      case "h23":
        return "H";
      case "h12":
        return "h";
      case "h11":
        return "K";
      default:
        throw new Error("Invalid hourCycle");
    }
  }
  var languageTag = locale.language;
  var regionTag;
  if (languageTag !== "root") {
    regionTag = locale.maximize().region;
  }
  var hourCycles = timeData[regionTag || ""] || timeData[languageTag || ""] || timeData["".concat(languageTag, "-001")] || timeData["001"];
  return hourCycles[0];
}
var _a$1;
var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(start, end) {
  return { start, end };
}
var hasNativeStartsWith = !!String.prototype.startsWith && "_a".startsWith("a", 1);
var hasNativeFromCodePoint = !!String.fromCodePoint;
var hasNativeFromEntries = !!Object.fromEntries;
var hasNativeCodePointAt = !!String.prototype.codePointAt;
var hasTrimStart = !!String.prototype.trimStart;
var hasTrimEnd = !!String.prototype.trimEnd;
var hasNativeIsSafeInteger = !!Number.isSafeInteger;
var isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(n10) {
  return typeof n10 === "number" && isFinite(n10) && Math.floor(n10) === n10 && Math.abs(n10) <= 9007199254740991;
};
var REGEX_SUPPORTS_U_AND_Y = true;
try {
  var re$1 = RE$1("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  REGEX_SUPPORTS_U_AND_Y = ((_a$1 = re$1.exec("a")) === null || _a$1 === void 0 ? void 0 : _a$1[0]) === "a";
} catch (_10) {
  REGEX_SUPPORTS_U_AND_Y = false;
}
var startsWith = hasNativeStartsWith ? (
  // Native
  function startsWith2(s10, search, position) {
    return s10.startsWith(search, position);
  }
) : (
  // For IE11
  function startsWith3(s10, search, position) {
    return s10.slice(position, position + search.length) === search;
  }
);
var fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : (
  // IE11
  function fromCodePoint2() {
    var codePoints = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      codePoints[_i2] = arguments[_i2];
    }
    var elements = "";
    var length = codePoints.length;
    var i10 = 0;
    var code3;
    while (length > i10) {
      code3 = codePoints[i10++];
      if (code3 > 1114111)
        throw RangeError(code3 + " is not a valid code point");
      elements += code3 < 65536 ? String.fromCharCode(code3) : String.fromCharCode(((code3 -= 65536) >> 10) + 55296, code3 % 1024 + 56320);
    }
    return elements;
  }
);
var fromEntries = (
  // native
  hasNativeFromEntries ? Object.fromEntries : (
    // Ponyfill
    function fromEntries2(entries) {
      var obj = {};
      for (var _i2 = 0, entries_1 = entries; _i2 < entries_1.length; _i2++) {
        var _a2 = entries_1[_i2], k10 = _a2[0], v10 = _a2[1];
        obj[k10] = v10;
      }
      return obj;
    }
  )
);
var codePointAt = hasNativeCodePointAt ? (
  // Native
  function codePointAt2(s10, index2) {
    return s10.codePointAt(index2);
  }
) : (
  // IE 11
  function codePointAt3(s10, index2) {
    var size2 = s10.length;
    if (index2 < 0 || index2 >= size2) {
      return void 0;
    }
    var first = s10.charCodeAt(index2);
    var second;
    return first < 55296 || first > 56319 || index2 + 1 === size2 || (second = s10.charCodeAt(index2 + 1)) < 56320 || second > 57343 ? first : (first - 55296 << 10) + (second - 56320) + 65536;
  }
);
var trimStart = hasTrimStart ? (
  // Native
  function trimStart2(s10) {
    return s10.trimStart();
  }
) : (
  // Ponyfill
  function trimStart3(s10) {
    return s10.replace(SPACE_SEPARATOR_START_REGEX, "");
  }
);
var trimEnd = hasTrimEnd ? (
  // Native
  function trimEnd2(s10) {
    return s10.trimEnd();
  }
) : (
  // Ponyfill
  function trimEnd3(s10) {
    return s10.replace(SPACE_SEPARATOR_END_REGEX, "");
  }
);
function RE$1(s10, flag) {
  return new RegExp(s10, flag);
}
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
  var IDENTIFIER_PREFIX_RE_1 = RE$1("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s10, index2) {
    var _a2;
    IDENTIFIER_PREFIX_RE_1.lastIndex = index2;
    var match = IDENTIFIER_PREFIX_RE_1.exec(s10);
    return (_a2 = match[1]) !== null && _a2 !== void 0 ? _a2 : "";
  };
} else {
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s10, index2) {
    var match = [];
    while (true) {
      var c10 = codePointAt(s10, index2);
      if (c10 === void 0 || _isWhiteSpace(c10) || _isPatternSyntax(c10)) {
        break;
      }
      match.push(c10);
      index2 += c10 >= 65536 ? 2 : 1;
    }
    return fromCodePoint.apply(void 0, match);
  };
}
var Parser = (
  /** @class */
  function() {
    function Parser2(message, options) {
      if (options === void 0) {
        options = {};
      }
      this.message = message;
      this.position = { offset: 0, line: 1, column: 1 };
      this.ignoreTag = !!options.ignoreTag;
      this.locale = options.locale;
      this.requiresOtherClause = !!options.requiresOtherClause;
      this.shouldParseSkeletons = !!options.shouldParseSkeletons;
    }
    Parser2.prototype.parse = function() {
      if (this.offset() !== 0) {
        throw Error("parser can only be used once");
      }
      return this.parseMessage(0, "", false);
    };
    Parser2.prototype.parseMessage = function(nestingLevel, parentArgType, expectingCloseTag) {
      var elements = [];
      while (!this.isEOF()) {
        var char = this.char();
        if (char === 123) {
          var result = this.parseArgument(nestingLevel, expectingCloseTag);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else if (char === 125 && nestingLevel > 0) {
          break;
        } else if (char === 35 && (parentArgType === "plural" || parentArgType === "selectordinal")) {
          var position = this.clonePosition();
          this.bump();
          elements.push({
            type: TYPE.pound,
            location: createLocation(position, this.clonePosition())
          });
        } else if (char === 60 && !this.ignoreTag && this.peek() === 47) {
          if (expectingCloseTag) {
            break;
          } else {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
          }
        } else if (char === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
          var result = this.parseTag(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        } else {
          var result = this.parseLiteral(nestingLevel, parentArgType);
          if (result.err) {
            return result;
          }
          elements.push(result.val);
        }
      }
      return { val: elements, err: null };
    };
    Parser2.prototype.parseTag = function(nestingLevel, parentArgType) {
      var startPosition = this.clonePosition();
      this.bump();
      var tagName = this.parseTagName();
      this.bumpSpace();
      if (this.bumpIf("/>")) {
        return {
          val: {
            type: TYPE.literal,
            value: "<".concat(tagName, "/>"),
            location: createLocation(startPosition, this.clonePosition())
          },
          err: null
        };
      } else if (this.bumpIf(">")) {
        var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
        if (childrenResult.err) {
          return childrenResult;
        }
        var children = childrenResult.val;
        var endTagStartPosition = this.clonePosition();
        if (this.bumpIf("</")) {
          if (this.isEOF() || !_isAlpha(this.char())) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          var closingTagNameStartPosition = this.clonePosition();
          var closingTagName = this.parseTagName();
          if (tagName !== closingTagName) {
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
          }
          this.bumpSpace();
          if (!this.bumpIf(">")) {
            return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
          }
          return {
            val: {
              type: TYPE.tag,
              value: tagName,
              children,
              location: createLocation(startPosition, this.clonePosition())
            },
            err: null
          };
        } else {
          return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
        }
      } else {
        return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
      }
    };
    Parser2.prototype.parseTagName = function() {
      var startOffset = this.offset();
      this.bump();
      while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
        this.bump();
      }
      return this.message.slice(startOffset, this.offset());
    };
    Parser2.prototype.parseLiteral = function(nestingLevel, parentArgType) {
      var start = this.clonePosition();
      var value = "";
      while (true) {
        var parseQuoteResult = this.tryParseQuote(parentArgType);
        if (parseQuoteResult) {
          value += parseQuoteResult;
          continue;
        }
        var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
        if (parseUnquotedResult) {
          value += parseUnquotedResult;
          continue;
        }
        var parseLeftAngleResult = this.tryParseLeftAngleBracket();
        if (parseLeftAngleResult) {
          value += parseLeftAngleResult;
          continue;
        }
        break;
      }
      var location2 = createLocation(start, this.clonePosition());
      return {
        val: { type: TYPE.literal, value, location: location2 },
        err: null
      };
    };
    Parser2.prototype.tryParseLeftAngleBracket = function() {
      if (!this.isEOF() && this.char() === 60 && (this.ignoreTag || // If at the opening tag or closing tag position, bail.
      !_isAlphaOrSlash(this.peek() || 0))) {
        this.bump();
        return "<";
      }
      return null;
    };
    Parser2.prototype.tryParseQuote = function(parentArgType) {
      if (this.isEOF() || this.char() !== 39) {
        return null;
      }
      switch (this.peek()) {
        case 39:
          this.bump();
          this.bump();
          return "'";
        // '{', '<', '>', '}'
        case 123:
        case 60:
        case 62:
        case 125:
          break;
        case 35:
          if (parentArgType === "plural" || parentArgType === "selectordinal") {
            break;
          }
          return null;
        default:
          return null;
      }
      this.bump();
      var codePoints = [this.char()];
      this.bump();
      while (!this.isEOF()) {
        var ch2 = this.char();
        if (ch2 === 39) {
          if (this.peek() === 39) {
            codePoints.push(39);
            this.bump();
          } else {
            this.bump();
            break;
          }
        } else {
          codePoints.push(ch2);
        }
        this.bump();
      }
      return fromCodePoint.apply(void 0, codePoints);
    };
    Parser2.prototype.tryParseUnquoted = function(nestingLevel, parentArgType) {
      if (this.isEOF()) {
        return null;
      }
      var ch2 = this.char();
      if (ch2 === 60 || ch2 === 123 || ch2 === 35 && (parentArgType === "plural" || parentArgType === "selectordinal") || ch2 === 125 && nestingLevel > 0) {
        return null;
      } else {
        this.bump();
        return fromCodePoint(ch2);
      }
    };
    Parser2.prototype.parseArgument = function(nestingLevel, expectingCloseTag) {
      var openingBracePosition = this.clonePosition();
      this.bump();
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      if (this.char() === 125) {
        this.bump();
        return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      var value = this.parseIdentifierIfPossible().value;
      if (!value) {
        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bumpSpace();
      if (this.isEOF()) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      switch (this.char()) {
        // Simple argument: `{name}`
        case 125: {
          this.bump();
          return {
            val: {
              type: TYPE.argument,
              // value does not include the opening and closing braces.
              value,
              location: createLocation(openingBracePosition, this.clonePosition())
            },
            err: null
          };
        }
        // Argument with options: `{name, format, ...}`
        case 44: {
          this.bump();
          this.bumpSpace();
          if (this.isEOF()) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
          }
          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
        }
        default:
          return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
      }
    };
    Parser2.prototype.parseIdentifierIfPossible = function() {
      var startingPosition = this.clonePosition();
      var startOffset = this.offset();
      var value = matchIdentifierAtIndex(this.message, startOffset);
      var endOffset = startOffset + value.length;
      this.bumpTo(endOffset);
      var endPosition = this.clonePosition();
      var location2 = createLocation(startingPosition, endPosition);
      return { value, location: location2 };
    };
    Parser2.prototype.parseArgumentOptions = function(nestingLevel, expectingCloseTag, value, openingBracePosition) {
      var _a2;
      var typeStartPosition = this.clonePosition();
      var argType = this.parseIdentifierIfPossible().value;
      var typeEndPosition = this.clonePosition();
      switch (argType) {
        case "":
          return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
        case "number":
        case "date":
        case "time": {
          this.bumpSpace();
          var styleAndLocation = null;
          if (this.bumpIf(",")) {
            this.bumpSpace();
            var styleStartPosition = this.clonePosition();
            var result = this.parseSimpleArgStyleIfPossible();
            if (result.err) {
              return result;
            }
            var style = trimEnd(result.val);
            if (style.length === 0) {
              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            var styleLocation = createLocation(styleStartPosition, this.clonePosition());
            styleAndLocation = { style, styleLocation };
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_1 = createLocation(openingBracePosition, this.clonePosition());
          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, "::", 0)) {
            var skeleton = trimStart(styleAndLocation.style.slice(2));
            if (argType === "number") {
              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
              if (result.err) {
                return result;
              }
              return {
                val: { type: TYPE.number, value, location: location_1, style: result.val },
                err: null
              };
            } else {
              if (skeleton.length === 0) {
                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
              }
              var dateTimePattern = skeleton;
              if (this.locale) {
                dateTimePattern = getBestPattern(skeleton, this.locale);
              }
              var style = {
                type: SKELETON_TYPE.dateTime,
                pattern: dateTimePattern,
                location: styleAndLocation.styleLocation,
                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(dateTimePattern) : {}
              };
              var type = argType === "date" ? TYPE.date : TYPE.time;
              return {
                val: { type, value, location: location_1, style },
                err: null
              };
            }
          }
          return {
            val: {
              type: argType === "number" ? TYPE.number : argType === "date" ? TYPE.date : TYPE.time,
              value,
              location: location_1,
              style: (_a2 = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a2 !== void 0 ? _a2 : null
            },
            err: null
          };
        }
        case "plural":
        case "selectordinal":
        case "select": {
          var typeEndPosition_1 = this.clonePosition();
          this.bumpSpace();
          if (!this.bumpIf(",")) {
            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));
          }
          this.bumpSpace();
          var identifierAndLocation = this.parseIdentifierIfPossible();
          var pluralOffset = 0;
          if (argType !== "select" && identifierAndLocation.value === "offset") {
            if (!this.bumpIf(":")) {
              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            this.bumpSpace();
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
            if (result.err) {
              return result;
            }
            this.bumpSpace();
            identifierAndLocation = this.parseIdentifierIfPossible();
            pluralOffset = result.val;
          }
          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
          if (optionsResult.err) {
            return optionsResult;
          }
          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
          if (argCloseResult.err) {
            return argCloseResult;
          }
          var location_2 = createLocation(openingBracePosition, this.clonePosition());
          if (argType === "select") {
            return {
              val: {
                type: TYPE.select,
                value,
                options: fromEntries(optionsResult.val),
                location: location_2
              },
              err: null
            };
          } else {
            return {
              val: {
                type: TYPE.plural,
                value,
                options: fromEntries(optionsResult.val),
                offset: pluralOffset,
                pluralType: argType === "plural" ? "cardinal" : "ordinal",
                location: location_2
              },
              err: null
            };
          }
        }
        default:
          return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
      }
    };
    Parser2.prototype.tryParseArgumentClose = function(openingBracePosition) {
      if (this.isEOF() || this.char() !== 125) {
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
      }
      this.bump();
      return { val: true, err: null };
    };
    Parser2.prototype.parseSimpleArgStyleIfPossible = function() {
      var nestedBraces = 0;
      var startPosition = this.clonePosition();
      while (!this.isEOF()) {
        var ch2 = this.char();
        switch (ch2) {
          case 39: {
            this.bump();
            var apostrophePosition = this.clonePosition();
            if (!this.bumpUntil("'")) {
              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
            }
            this.bump();
            break;
          }
          case 123: {
            nestedBraces += 1;
            this.bump();
            break;
          }
          case 125: {
            if (nestedBraces > 0) {
              nestedBraces -= 1;
            } else {
              return {
                val: this.message.slice(startPosition.offset, this.offset()),
                err: null
              };
            }
            break;
          }
          default:
            this.bump();
            break;
        }
      }
      return {
        val: this.message.slice(startPosition.offset, this.offset()),
        err: null
      };
    };
    Parser2.prototype.parseNumberSkeletonFromString = function(skeleton, location2) {
      var tokens = [];
      try {
        tokens = parseNumberSkeletonFromString(skeleton);
      } catch (e10) {
        return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location2);
      }
      return {
        val: {
          type: SKELETON_TYPE.number,
          tokens,
          location: location2,
          parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}
        },
        err: null
      };
    };
    Parser2.prototype.tryParsePluralOrSelectOptions = function(nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
      var _a2;
      var hasOtherClause = false;
      var options = [];
      var parsedSelectors = /* @__PURE__ */ new Set();
      var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
      while (true) {
        if (selector.length === 0) {
          var startPosition = this.clonePosition();
          if (parentArgType !== "select" && this.bumpIf("=")) {
            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
            if (result.err) {
              return result;
            }
            selectorLocation = createLocation(startPosition, this.clonePosition());
            selector = this.message.slice(startPosition.offset, this.offset());
          } else {
            break;
          }
        }
        if (parsedSelectors.has(selector)) {
          return this.error(parentArgType === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
        }
        if (selector === "other") {
          hasOtherClause = true;
        }
        this.bumpSpace();
        var openingBracePosition = this.clonePosition();
        if (!this.bumpIf("{")) {
          return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
        }
        var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
        if (fragmentResult.err) {
          return fragmentResult;
        }
        var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        options.push([
          selector,
          {
            value: fragmentResult.val,
            location: createLocation(openingBracePosition, this.clonePosition())
          }
        ]);
        parsedSelectors.add(selector);
        this.bumpSpace();
        _a2 = this.parseIdentifierIfPossible(), selector = _a2.value, selectorLocation = _a2.location;
      }
      if (options.length === 0) {
        return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
      }
      if (this.requiresOtherClause && !hasOtherClause) {
        return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
      }
      return { val: options, err: null };
    };
    Parser2.prototype.tryParseDecimalInteger = function(expectNumberError, invalidNumberError) {
      var sign = 1;
      var startingPosition = this.clonePosition();
      if (this.bumpIf("+")) ;
      else if (this.bumpIf("-")) {
        sign = -1;
      }
      var hasDigits = false;
      var decimal = 0;
      while (!this.isEOF()) {
        var ch2 = this.char();
        if (ch2 >= 48 && ch2 <= 57) {
          hasDigits = true;
          decimal = decimal * 10 + (ch2 - 48);
          this.bump();
        } else {
          break;
        }
      }
      var location2 = createLocation(startingPosition, this.clonePosition());
      if (!hasDigits) {
        return this.error(expectNumberError, location2);
      }
      decimal *= sign;
      if (!isSafeInteger(decimal)) {
        return this.error(invalidNumberError, location2);
      }
      return { val: decimal, err: null };
    };
    Parser2.prototype.offset = function() {
      return this.position.offset;
    };
    Parser2.prototype.isEOF = function() {
      return this.offset() === this.message.length;
    };
    Parser2.prototype.clonePosition = function() {
      return {
        offset: this.position.offset,
        line: this.position.line,
        column: this.position.column
      };
    };
    Parser2.prototype.char = function() {
      var offset2 = this.position.offset;
      if (offset2 >= this.message.length) {
        throw Error("out of bound");
      }
      var code3 = codePointAt(this.message, offset2);
      if (code3 === void 0) {
        throw Error("Offset ".concat(offset2, " is at invalid UTF-16 code unit boundary"));
      }
      return code3;
    };
    Parser2.prototype.error = function(kind, location2) {
      return {
        val: null,
        err: {
          kind,
          message: this.message,
          location: location2
        }
      };
    };
    Parser2.prototype.bump = function() {
      if (this.isEOF()) {
        return;
      }
      var code3 = this.char();
      if (code3 === 10) {
        this.position.line += 1;
        this.position.column = 1;
        this.position.offset += 1;
      } else {
        this.position.column += 1;
        this.position.offset += code3 < 65536 ? 1 : 2;
      }
    };
    Parser2.prototype.bumpIf = function(prefix) {
      if (startsWith(this.message, prefix, this.offset())) {
        for (var i10 = 0; i10 < prefix.length; i10++) {
          this.bump();
        }
        return true;
      }
      return false;
    };
    Parser2.prototype.bumpUntil = function(pattern) {
      var currentOffset = this.offset();
      var index2 = this.message.indexOf(pattern, currentOffset);
      if (index2 >= 0) {
        this.bumpTo(index2);
        return true;
      } else {
        this.bumpTo(this.message.length);
        return false;
      }
    };
    Parser2.prototype.bumpTo = function(targetOffset) {
      if (this.offset() > targetOffset) {
        throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
      }
      targetOffset = Math.min(targetOffset, this.message.length);
      while (true) {
        var offset2 = this.offset();
        if (offset2 === targetOffset) {
          break;
        }
        if (offset2 > targetOffset) {
          throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
        }
        this.bump();
        if (this.isEOF()) {
          break;
        }
      }
    };
    Parser2.prototype.bumpSpace = function() {
      while (!this.isEOF() && _isWhiteSpace(this.char())) {
        this.bump();
      }
    };
    Parser2.prototype.peek = function() {
      if (this.isEOF()) {
        return null;
      }
      var code3 = this.char();
      var offset2 = this.offset();
      var nextCode = this.message.charCodeAt(offset2 + (code3 >= 65536 ? 2 : 1));
      return nextCode !== null && nextCode !== void 0 ? nextCode : null;
    };
    return Parser2;
  }()
);
function _isAlpha(codepoint) {
  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;
}
function _isAlphaOrSlash(codepoint) {
  return _isAlpha(codepoint) || codepoint === 47;
}
function _isPotentialElementNameChar(c10) {
  return c10 === 45 || c10 === 46 || c10 >= 48 && c10 <= 57 || c10 === 95 || c10 >= 97 && c10 <= 122 || c10 >= 65 && c10 <= 90 || c10 == 183 || c10 >= 192 && c10 <= 214 || c10 >= 216 && c10 <= 246 || c10 >= 248 && c10 <= 893 || c10 >= 895 && c10 <= 8191 || c10 >= 8204 && c10 <= 8205 || c10 >= 8255 && c10 <= 8256 || c10 >= 8304 && c10 <= 8591 || c10 >= 11264 && c10 <= 12271 || c10 >= 12289 && c10 <= 55295 || c10 >= 63744 && c10 <= 64975 || c10 >= 65008 && c10 <= 65533 || c10 >= 65536 && c10 <= 983039;
}
function _isWhiteSpace(c10) {
  return c10 >= 9 && c10 <= 13 || c10 === 32 || c10 === 133 || c10 >= 8206 && c10 <= 8207 || c10 === 8232 || c10 === 8233;
}
function _isPatternSyntax(c10) {
  return c10 >= 33 && c10 <= 35 || c10 === 36 || c10 >= 37 && c10 <= 39 || c10 === 40 || c10 === 41 || c10 === 42 || c10 === 43 || c10 === 44 || c10 === 45 || c10 >= 46 && c10 <= 47 || c10 >= 58 && c10 <= 59 || c10 >= 60 && c10 <= 62 || c10 >= 63 && c10 <= 64 || c10 === 91 || c10 === 92 || c10 === 93 || c10 === 94 || c10 === 96 || c10 === 123 || c10 === 124 || c10 === 125 || c10 === 126 || c10 === 161 || c10 >= 162 && c10 <= 165 || c10 === 166 || c10 === 167 || c10 === 169 || c10 === 171 || c10 === 172 || c10 === 174 || c10 === 176 || c10 === 177 || c10 === 182 || c10 === 187 || c10 === 191 || c10 === 215 || c10 === 247 || c10 >= 8208 && c10 <= 8213 || c10 >= 8214 && c10 <= 8215 || c10 === 8216 || c10 === 8217 || c10 === 8218 || c10 >= 8219 && c10 <= 8220 || c10 === 8221 || c10 === 8222 || c10 === 8223 || c10 >= 8224 && c10 <= 8231 || c10 >= 8240 && c10 <= 8248 || c10 === 8249 || c10 === 8250 || c10 >= 8251 && c10 <= 8254 || c10 >= 8257 && c10 <= 8259 || c10 === 8260 || c10 === 8261 || c10 === 8262 || c10 >= 8263 && c10 <= 8273 || c10 === 8274 || c10 === 8275 || c10 >= 8277 && c10 <= 8286 || c10 >= 8592 && c10 <= 8596 || c10 >= 8597 && c10 <= 8601 || c10 >= 8602 && c10 <= 8603 || c10 >= 8604 && c10 <= 8607 || c10 === 8608 || c10 >= 8609 && c10 <= 8610 || c10 === 8611 || c10 >= 8612 && c10 <= 8613 || c10 === 8614 || c10 >= 8615 && c10 <= 8621 || c10 === 8622 || c10 >= 8623 && c10 <= 8653 || c10 >= 8654 && c10 <= 8655 || c10 >= 8656 && c10 <= 8657 || c10 === 8658 || c10 === 8659 || c10 === 8660 || c10 >= 8661 && c10 <= 8691 || c10 >= 8692 && c10 <= 8959 || c10 >= 8960 && c10 <= 8967 || c10 === 8968 || c10 === 8969 || c10 === 8970 || c10 === 8971 || c10 >= 8972 && c10 <= 8991 || c10 >= 8992 && c10 <= 8993 || c10 >= 8994 && c10 <= 9e3 || c10 === 9001 || c10 === 9002 || c10 >= 9003 && c10 <= 9083 || c10 === 9084 || c10 >= 9085 && c10 <= 9114 || c10 >= 9115 && c10 <= 9139 || c10 >= 9140 && c10 <= 9179 || c10 >= 9180 && c10 <= 9185 || c10 >= 9186 && c10 <= 9254 || c10 >= 9255 && c10 <= 9279 || c10 >= 9280 && c10 <= 9290 || c10 >= 9291 && c10 <= 9311 || c10 >= 9472 && c10 <= 9654 || c10 === 9655 || c10 >= 9656 && c10 <= 9664 || c10 === 9665 || c10 >= 9666 && c10 <= 9719 || c10 >= 9720 && c10 <= 9727 || c10 >= 9728 && c10 <= 9838 || c10 === 9839 || c10 >= 9840 && c10 <= 10087 || c10 === 10088 || c10 === 10089 || c10 === 10090 || c10 === 10091 || c10 === 10092 || c10 === 10093 || c10 === 10094 || c10 === 10095 || c10 === 10096 || c10 === 10097 || c10 === 10098 || c10 === 10099 || c10 === 10100 || c10 === 10101 || c10 >= 10132 && c10 <= 10175 || c10 >= 10176 && c10 <= 10180 || c10 === 10181 || c10 === 10182 || c10 >= 10183 && c10 <= 10213 || c10 === 10214 || c10 === 10215 || c10 === 10216 || c10 === 10217 || c10 === 10218 || c10 === 10219 || c10 === 10220 || c10 === 10221 || c10 === 10222 || c10 === 10223 || c10 >= 10224 && c10 <= 10239 || c10 >= 10240 && c10 <= 10495 || c10 >= 10496 && c10 <= 10626 || c10 === 10627 || c10 === 10628 || c10 === 10629 || c10 === 10630 || c10 === 10631 || c10 === 10632 || c10 === 10633 || c10 === 10634 || c10 === 10635 || c10 === 10636 || c10 === 10637 || c10 === 10638 || c10 === 10639 || c10 === 10640 || c10 === 10641 || c10 === 10642 || c10 === 10643 || c10 === 10644 || c10 === 10645 || c10 === 10646 || c10 === 10647 || c10 === 10648 || c10 >= 10649 && c10 <= 10711 || c10 === 10712 || c10 === 10713 || c10 === 10714 || c10 === 10715 || c10 >= 10716 && c10 <= 10747 || c10 === 10748 || c10 === 10749 || c10 >= 10750 && c10 <= 11007 || c10 >= 11008 && c10 <= 11055 || c10 >= 11056 && c10 <= 11076 || c10 >= 11077 && c10 <= 11078 || c10 >= 11079 && c10 <= 11084 || c10 >= 11085 && c10 <= 11123 || c10 >= 11124 && c10 <= 11125 || c10 >= 11126 && c10 <= 11157 || c10 === 11158 || c10 >= 11159 && c10 <= 11263 || c10 >= 11776 && c10 <= 11777 || c10 === 11778 || c10 === 11779 || c10 === 11780 || c10 === 11781 || c10 >= 11782 && c10 <= 11784 || c10 === 11785 || c10 === 11786 || c10 === 11787 || c10 === 11788 || c10 === 11789 || c10 >= 11790 && c10 <= 11798 || c10 === 11799 || c10 >= 11800 && c10 <= 11801 || c10 === 11802 || c10 === 11803 || c10 === 11804 || c10 === 11805 || c10 >= 11806 && c10 <= 11807 || c10 === 11808 || c10 === 11809 || c10 === 11810 || c10 === 11811 || c10 === 11812 || c10 === 11813 || c10 === 11814 || c10 === 11815 || c10 === 11816 || c10 === 11817 || c10 >= 11818 && c10 <= 11822 || c10 === 11823 || c10 >= 11824 && c10 <= 11833 || c10 >= 11834 && c10 <= 11835 || c10 >= 11836 && c10 <= 11839 || c10 === 11840 || c10 === 11841 || c10 === 11842 || c10 >= 11843 && c10 <= 11855 || c10 >= 11856 && c10 <= 11857 || c10 === 11858 || c10 >= 11859 && c10 <= 11903 || c10 >= 12289 && c10 <= 12291 || c10 === 12296 || c10 === 12297 || c10 === 12298 || c10 === 12299 || c10 === 12300 || c10 === 12301 || c10 === 12302 || c10 === 12303 || c10 === 12304 || c10 === 12305 || c10 >= 12306 && c10 <= 12307 || c10 === 12308 || c10 === 12309 || c10 === 12310 || c10 === 12311 || c10 === 12312 || c10 === 12313 || c10 === 12314 || c10 === 12315 || c10 === 12316 || c10 === 12317 || c10 >= 12318 && c10 <= 12319 || c10 === 12320 || c10 === 12336 || c10 === 64830 || c10 === 64831 || c10 >= 65093 && c10 <= 65094;
}
function pruneLocation(els) {
  els.forEach(function(el) {
    delete el.location;
    if (isSelectElement(el) || isPluralElement(el)) {
      for (var k10 in el.options) {
        delete el.options[k10].location;
        pruneLocation(el.options[k10].value);
      }
    } else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
      delete el.style.location;
    } else if ((isDateElement(el) || isTimeElement(el)) && isDateTimeSkeleton(el.style)) {
      delete el.style.location;
    } else if (isTagElement(el)) {
      pruneLocation(el.children);
    }
  });
}
function parse$1(message, opts) {
  if (opts === void 0) {
    opts = {};
  }
  opts = __assign({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
  var result = new Parser(message, opts).parse();
  if (result.err) {
    var error = SyntaxError(ErrorKind[result.err.kind]);
    error.location = result.err.location;
    error.originalMessage = result.err.message;
    throw error;
  }
  if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
    pruneLocation(result.val);
  }
  return result.val;
}
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["MISSING_VALUE"] = "MISSING_VALUE";
  ErrorCode2["INVALID_VALUE"] = "INVALID_VALUE";
  ErrorCode2["MISSING_INTL_API"] = "MISSING_INTL_API";
})(ErrorCode || (ErrorCode = {}));
var FormatError = (
  /** @class */
  function(_super) {
    __extends(FormatError2, _super);
    function FormatError2(msg, code3, originalMessage) {
      var _this = _super.call(this, msg) || this;
      _this.code = code3;
      _this.originalMessage = originalMessage;
      return _this;
    }
    FormatError2.prototype.toString = function() {
      return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
    };
    return FormatError2;
  }(Error)
);
var InvalidValueError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueError2, _super);
    function InvalidValueError2(variableId, value, options, originalMessage) {
      return _super.call(this, 'Invalid values for "'.concat(variableId, '": "').concat(value, '". Options are "').concat(Object.keys(options).join('", "'), '"'), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueError2;
  }(FormatError)
);
var InvalidValueTypeError = (
  /** @class */
  function(_super) {
    __extends(InvalidValueTypeError2, _super);
    function InvalidValueTypeError2(value, type, originalMessage) {
      return _super.call(this, 'Value for "'.concat(value, '" must be of type ').concat(type), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueTypeError2;
  }(FormatError)
);
var MissingValueError = (
  /** @class */
  function(_super) {
    __extends(MissingValueError2, _super);
    function MissingValueError2(variableId, originalMessage) {
      return _super.call(this, 'The intl string context variable "'.concat(variableId, '" was not provided to the string "').concat(originalMessage, '"'), ErrorCode.MISSING_VALUE, originalMessage) || this;
    }
    return MissingValueError2;
  }(FormatError)
);
var PART_TYPE;
(function(PART_TYPE2) {
  PART_TYPE2[PART_TYPE2["literal"] = 0] = "literal";
  PART_TYPE2[PART_TYPE2["object"] = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(parts) {
  if (parts.length < 2) {
    return parts;
  }
  return parts.reduce(function(all, part) {
    var lastPart = all[all.length - 1];
    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {
      all.push(part);
    } else {
      lastPart.value += part.value;
    }
    return all;
  }, []);
}
function isFormatXMLElementFn(el) {
  return typeof el === "function";
}
function formatToParts(els, locales, formatters, formats, values, currentPluralValue, originalMessage) {
  if (els.length === 1 && isLiteralElement(els[0])) {
    return [
      {
        type: PART_TYPE.literal,
        value: els[0].value
      }
    ];
  }
  var result = [];
  for (var _i2 = 0, els_1 = els; _i2 < els_1.length; _i2++) {
    var el = els_1[_i2];
    if (isLiteralElement(el)) {
      result.push({
        type: PART_TYPE.literal,
        value: el.value
      });
      continue;
    }
    if (isPoundElement(el)) {
      if (typeof currentPluralValue === "number") {
        result.push({
          type: PART_TYPE.literal,
          value: formatters.getNumberFormat(locales).format(currentPluralValue)
        });
      }
      continue;
    }
    var varName = el.value;
    if (!(values && varName in values)) {
      throw new MissingValueError(varName, originalMessage);
    }
    var value = values[varName];
    if (isArgumentElement(el)) {
      if (!value || typeof value === "string" || typeof value === "number") {
        value = typeof value === "string" || typeof value === "number" ? String(value) : "";
      }
      result.push({
        type: typeof value === "string" ? PART_TYPE.literal : PART_TYPE.object,
        value
      });
      continue;
    }
    if (isDateElement(el)) {
      var style = typeof el.style === "string" ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : void 0;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTimeElement(el)) {
      var style = typeof el.style === "string" ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : formats.time.medium;
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isNumberElement(el)) {
      var style = typeof el.style === "string" ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : void 0;
      if (style && style.scale) {
        value = value * (style.scale || 1);
      }
      result.push({
        type: PART_TYPE.literal,
        value: formatters.getNumberFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTagElement(el)) {
      var children = el.children, value_1 = el.value;
      var formatFn = values[value_1];
      if (!isFormatXMLElementFn(formatFn)) {
        throw new InvalidValueTypeError(value_1, "function", originalMessage);
      }
      var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);
      var chunks = formatFn(parts.map(function(p10) {
        return p10.value;
      }));
      if (!Array.isArray(chunks)) {
        chunks = [chunks];
      }
      result.push.apply(result, chunks.map(function(c10) {
        return {
          type: typeof c10 === "string" ? PART_TYPE.literal : PART_TYPE.object,
          value: c10
        };
      }));
    }
    if (isSelectElement(el)) {
      var opt = el.options[value] || el.options.other;
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
      continue;
    }
    if (isPluralElement(el)) {
      var opt = el.options["=".concat(value)];
      if (!opt) {
        if (!Intl.PluralRules) {
          throw new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API, originalMessage);
        }
        var rule = formatters.getPluralRules(locales, { type: el.pluralType }).select(value - (el.offset || 0));
        opt = el.options[rule] || el.options.other;
      }
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
      continue;
    }
  }
  return mergeLiteral(result);
}
function mergeConfig(c12, c22) {
  if (!c22) {
    return c12;
  }
  return __assign(__assign(__assign({}, c12 || {}), c22 || {}), Object.keys(c12).reduce(function(all, k10) {
    all[k10] = __assign(__assign({}, c12[k10]), c22[k10] || {});
    return all;
  }, {}));
}
function mergeConfigs(defaultConfig, configs) {
  if (!configs) {
    return defaultConfig;
  }
  return Object.keys(defaultConfig).reduce(function(all, k10) {
    all[k10] = mergeConfig(defaultConfig[k10], configs[k10]);
    return all;
  }, __assign({}, defaultConfig));
}
function createFastMemoizeCache$1(store) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store[key];
        },
        set: function(key, value) {
          store[key] = value;
        }
      };
    }
  };
}
function createDefaultFormatters(cache) {
  if (cache === void 0) {
    cache = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
  }
  return {
    getNumberFormat: memoize(function() {
      var _a2;
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return new ((_a2 = Intl.NumberFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache$1(cache.number),
      strategy: strategies.variadic
    }),
    getDateTimeFormat: memoize(function() {
      var _a2;
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return new ((_a2 = Intl.DateTimeFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache$1(cache.dateTime),
      strategy: strategies.variadic
    }),
    getPluralRules: memoize(function() {
      var _a2;
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return new ((_a2 = Intl.PluralRules).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache$1(cache.pluralRules),
      strategy: strategies.variadic
    })
  };
}
var IntlMessageFormat = (
  /** @class */
  function() {
    function IntlMessageFormat2(message, locales, overrideFormats, opts) {
      if (locales === void 0) {
        locales = IntlMessageFormat2.defaultLocale;
      }
      var _this = this;
      this.formatterCache = {
        number: {},
        dateTime: {},
        pluralRules: {}
      };
      this.format = function(values) {
        var parts = _this.formatToParts(values);
        if (parts.length === 1) {
          return parts[0].value;
        }
        var result = parts.reduce(function(all, part) {
          if (!all.length || part.type !== PART_TYPE.literal || typeof all[all.length - 1] !== "string") {
            all.push(part.value);
          } else {
            all[all.length - 1] += part.value;
          }
          return all;
        }, []);
        if (result.length <= 1) {
          return result[0] || "";
        }
        return result;
      };
      this.formatToParts = function(values) {
        return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, void 0, _this.message);
      };
      this.resolvedOptions = function() {
        var _a3;
        return {
          locale: ((_a3 = _this.resolvedLocale) === null || _a3 === void 0 ? void 0 : _a3.toString()) || Intl.NumberFormat.supportedLocalesOf(_this.locales)[0]
        };
      };
      this.getAst = function() {
        return _this.ast;
      };
      this.locales = locales;
      this.resolvedLocale = IntlMessageFormat2.resolveLocale(locales);
      if (typeof message === "string") {
        this.message = message;
        if (!IntlMessageFormat2.__parse) {
          throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
        }
        var _a2 = opts || {};
        _a2.formatters;
        var parseOpts = __rest(_a2, ["formatters"]);
        this.ast = IntlMessageFormat2.__parse(message, __assign(__assign({}, parseOpts), { locale: this.resolvedLocale }));
      } else {
        this.ast = message;
      }
      if (!Array.isArray(this.ast)) {
        throw new TypeError("A message must be provided as a String or AST.");
      }
      this.formats = mergeConfigs(IntlMessageFormat2.formats, overrideFormats);
      this.formatters = opts && opts.formatters || createDefaultFormatters(this.formatterCache);
    }
    Object.defineProperty(IntlMessageFormat2, "defaultLocale", {
      get: function() {
        if (!IntlMessageFormat2.memoizedDefaultLocale) {
          IntlMessageFormat2.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
        }
        return IntlMessageFormat2.memoizedDefaultLocale;
      },
      enumerable: false,
      configurable: true
    });
    IntlMessageFormat2.memoizedDefaultLocale = null;
    IntlMessageFormat2.resolveLocale = function(locales) {
      if (typeof Intl.Locale === "undefined") {
        return;
      }
      var supportedLocales = Intl.NumberFormat.supportedLocalesOf(locales);
      if (supportedLocales.length > 0) {
        return new Intl.Locale(supportedLocales[0]);
      }
      return new Intl.Locale(typeof locales === "string" ? locales : locales[0]);
    };
    IntlMessageFormat2.__parse = parse$1;
    IntlMessageFormat2.formats = {
      number: {
        integer: {
          maximumFractionDigits: 0
        },
        currency: {
          style: "currency"
        },
        percent: {
          style: "percent"
        }
      },
      date: {
        short: {
          month: "numeric",
          day: "numeric",
          year: "2-digit"
        },
        medium: {
          month: "short",
          day: "numeric",
          year: "numeric"
        },
        long: {
          month: "long",
          day: "numeric",
          year: "numeric"
        },
        full: {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric"
        }
      },
      time: {
        short: {
          hour: "numeric",
          minute: "numeric"
        },
        medium: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric"
        },
        long: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        },
        full: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        }
      }
    };
    return IntlMessageFormat2;
  }()
);
var IntlErrorCode;
(function(IntlErrorCode2) {
  IntlErrorCode2["FORMAT_ERROR"] = "FORMAT_ERROR";
  IntlErrorCode2["UNSUPPORTED_FORMATTER"] = "UNSUPPORTED_FORMATTER";
  IntlErrorCode2["INVALID_CONFIG"] = "INVALID_CONFIG";
  IntlErrorCode2["MISSING_DATA"] = "MISSING_DATA";
  IntlErrorCode2["MISSING_TRANSLATION"] = "MISSING_TRANSLATION";
})(IntlErrorCode || (IntlErrorCode = {}));
var IntlError = (
  /** @class */
  function(_super) {
    __extends(IntlError2, _super);
    function IntlError2(code3, message, exception) {
      var _this = this;
      var err = exception ? exception instanceof Error ? exception : new Error(String(exception)) : void 0;
      _this = _super.call(this, "[@formatjs/intl Error ".concat(code3, "] ").concat(message, "\n").concat(err ? "\n".concat(err.message, "\n").concat(err.stack) : "")) || this;
      _this.code = code3;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(_this, IntlError2);
      }
      return _this;
    }
    return IntlError2;
  }(Error)
);
var UnsupportedFormatterError = (
  /** @class */
  function(_super) {
    __extends(UnsupportedFormatterError2, _super);
    function UnsupportedFormatterError2(message, exception) {
      return _super.call(this, IntlErrorCode.UNSUPPORTED_FORMATTER, message, exception) || this;
    }
    return UnsupportedFormatterError2;
  }(IntlError)
);
var InvalidConfigError = (
  /** @class */
  function(_super) {
    __extends(InvalidConfigError2, _super);
    function InvalidConfigError2(message, exception) {
      return _super.call(this, IntlErrorCode.INVALID_CONFIG, message, exception) || this;
    }
    return InvalidConfigError2;
  }(IntlError)
);
var MissingDataError = (
  /** @class */
  function(_super) {
    __extends(MissingDataError2, _super);
    function MissingDataError2(message, exception) {
      return _super.call(this, IntlErrorCode.MISSING_DATA, message, exception) || this;
    }
    return MissingDataError2;
  }(IntlError)
);
var IntlFormatError = (
  /** @class */
  function(_super) {
    __extends(IntlFormatError2, _super);
    function IntlFormatError2(message, locale, exception) {
      var _this = _super.call(this, IntlErrorCode.FORMAT_ERROR, "".concat(message, "\nLocale: ").concat(locale, "\n"), exception) || this;
      _this.locale = locale;
      return _this;
    }
    return IntlFormatError2;
  }(IntlError)
);
var MessageFormatError = (
  /** @class */
  function(_super) {
    __extends(MessageFormatError2, _super);
    function MessageFormatError2(message, locale, descriptor, exception) {
      var _this = _super.call(this, "".concat(message, "\nMessageID: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.id, "\nDefault Message: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.defaultMessage, "\nDescription: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.description, "\n"), locale, exception) || this;
      _this.descriptor = descriptor;
      _this.locale = locale;
      return _this;
    }
    return MessageFormatError2;
  }(IntlFormatError)
);
var MissingTranslationError = (
  /** @class */
  function(_super) {
    __extends(MissingTranslationError2, _super);
    function MissingTranslationError2(descriptor, locale) {
      var _this = _super.call(this, IntlErrorCode.MISSING_TRANSLATION, 'Missing message: "'.concat(descriptor.id, '" for locale "').concat(locale, '", using ').concat(descriptor.defaultMessage ? "default message (".concat(typeof descriptor.defaultMessage === "string" ? descriptor.defaultMessage : descriptor.defaultMessage.map(function(e10) {
        var _a2;
        return (_a2 = e10.value) !== null && _a2 !== void 0 ? _a2 : JSON.stringify(e10);
      }).join(), ")") : "id", " as fallback.")) || this;
      _this.descriptor = descriptor;
      return _this;
    }
    return MissingTranslationError2;
  }(IntlError)
);
function filterProps(props, allowlist, defaults) {
  if (defaults === void 0) {
    defaults = {};
  }
  return allowlist.reduce(function(filtered, name) {
    if (name in props) {
      filtered[name] = props[name];
    } else if (name in defaults) {
      filtered[name] = defaults[name];
    }
    return filtered;
  }, {});
}
var defaultErrorHandler = function(error) {
};
var defaultWarnHandler = function(warning) {
};
var DEFAULT_INTL_CONFIG$1 = {
  formats: {},
  messages: {},
  timeZone: void 0,
  defaultLocale: "en",
  defaultFormats: {},
  fallbackOnEmptyString: true,
  onError: defaultErrorHandler,
  onWarn: defaultWarnHandler
};
function createIntlCache() {
  return {
    dateTime: {},
    number: {},
    message: {},
    relativeTime: {},
    pluralRules: {},
    list: {},
    displayNames: {}
  };
}
function createFastMemoizeCache(store) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store[key];
        },
        set: function(key, value) {
          store[key] = value;
        }
      };
    }
  };
}
function createFormatters(cache) {
  if (cache === void 0) {
    cache = createIntlCache();
  }
  var RelativeTimeFormat = Intl.RelativeTimeFormat;
  var ListFormat = Intl.ListFormat;
  var DisplayNames = Intl.DisplayNames;
  var getDateTimeFormat = memoize(function() {
    var _a2;
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    return new ((_a2 = Intl.DateTimeFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache.dateTime),
    strategy: strategies.variadic
  });
  var getNumberFormat = memoize(function() {
    var _a2;
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    return new ((_a2 = Intl.NumberFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache.number),
    strategy: strategies.variadic
  });
  var getPluralRules = memoize(function() {
    var _a2;
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    return new ((_a2 = Intl.PluralRules).bind.apply(_a2, __spreadArray([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache.pluralRules),
    strategy: strategies.variadic
  });
  return {
    getDateTimeFormat,
    getNumberFormat,
    getMessageFormat: memoize(function(message, locales, overrideFormats, opts) {
      return new IntlMessageFormat(message, locales, overrideFormats, __assign({ formatters: {
        getNumberFormat,
        getDateTimeFormat,
        getPluralRules
      } }, opts || {}));
    }, {
      cache: createFastMemoizeCache(cache.message),
      strategy: strategies.variadic
    }),
    getRelativeTimeFormat: memoize(function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return new (RelativeTimeFormat.bind.apply(RelativeTimeFormat, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.relativeTime),
      strategy: strategies.variadic
    }),
    getPluralRules,
    getListFormat: memoize(function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return new (ListFormat.bind.apply(ListFormat, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.list),
      strategy: strategies.variadic
    }),
    getDisplayNames: memoize(function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return new (DisplayNames.bind.apply(DisplayNames, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache.displayNames),
      strategy: strategies.variadic
    })
  };
}
function getNamedFormat(formats, type, name, onError) {
  var formatType = formats && formats[type];
  var format;
  if (formatType) {
    format = formatType[name];
  }
  if (format) {
    return format;
  }
  onError(new UnsupportedFormatterError("No ".concat(type, " format named: ").concat(name)));
}
function setTimeZoneInOptions(opts, timeZone) {
  return Object.keys(opts).reduce(function(all, k10) {
    all[k10] = __assign({ timeZone }, opts[k10]);
    return all;
  }, {});
}
function deepMergeOptions(opts1, opts2) {
  var keys = Object.keys(__assign(__assign({}, opts1), opts2));
  return keys.reduce(function(all, k10) {
    all[k10] = __assign(__assign({}, opts1[k10] || {}), opts2[k10] || {});
    return all;
  }, {});
}
function deepMergeFormatsAndSetTimeZone(f12, timeZone) {
  if (!timeZone) {
    return f12;
  }
  var mfFormats = IntlMessageFormat.formats;
  return __assign(__assign(__assign({}, mfFormats), f12), { date: deepMergeOptions(setTimeZoneInOptions(mfFormats.date, timeZone), setTimeZoneInOptions(f12.date || {}, timeZone)), time: deepMergeOptions(setTimeZoneInOptions(mfFormats.time, timeZone), setTimeZoneInOptions(f12.time || {}, timeZone)) });
}
var formatMessage$1 = function(_a2, state, messageDescriptor, values, opts) {
  var locale = _a2.locale, formats = _a2.formats, messages = _a2.messages, defaultLocale = _a2.defaultLocale, defaultFormats = _a2.defaultFormats, fallbackOnEmptyString = _a2.fallbackOnEmptyString, onError = _a2.onError, timeZone = _a2.timeZone, defaultRichTextElements = _a2.defaultRichTextElements;
  if (messageDescriptor === void 0) {
    messageDescriptor = { id: "" };
  }
  var msgId = messageDescriptor.id, defaultMessage = messageDescriptor.defaultMessage;
  invariant(!!msgId, "[@formatjs/intl] An `id` must be provided to format a message. You can either:\n1. Configure your build toolchain with [babel-plugin-formatjs](https://formatjs.io/docs/tooling/babel-plugin)\nor [@formatjs/ts-transformer](https://formatjs.io/docs/tooling/ts-transformer) OR\n2. Configure your `eslint` config to include [eslint-plugin-formatjs](https://formatjs.io/docs/tooling/linter#enforce-id)\nto autofix this issue");
  var id = String(msgId);
  var message = (
    // In case messages is Object.create(null)
    // e.g import('foo.json') from webpack)
    // See https://github.com/formatjs/formatjs/issues/1914
    messages && Object.prototype.hasOwnProperty.call(messages, id) && messages[id]
  );
  if (Array.isArray(message) && message.length === 1 && message[0].type === TYPE.literal) {
    return message[0].value;
  }
  if (!values && message && typeof message === "string" && !defaultRichTextElements) {
    return message.replace(/'\{(.*?)\}'/gi, "{$1}");
  }
  values = __assign(__assign({}, defaultRichTextElements), values || {});
  formats = deepMergeFormatsAndSetTimeZone(formats, timeZone);
  defaultFormats = deepMergeFormatsAndSetTimeZone(defaultFormats, timeZone);
  if (!message) {
    if (fallbackOnEmptyString === false && message === "") {
      return message;
    }
    if (!defaultMessage || locale && locale.toLowerCase() !== defaultLocale.toLowerCase()) {
      onError(new MissingTranslationError(messageDescriptor, locale));
    }
    if (defaultMessage) {
      try {
        var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats, opts);
        return formatter.format(values);
      } catch (e10) {
        onError(new MessageFormatError('Error formatting default message for: "'.concat(id, '", rendering default message verbatim'), locale, messageDescriptor, e10));
        return typeof defaultMessage === "string" ? defaultMessage : id;
      }
    }
    return id;
  }
  try {
    var formatter = state.getMessageFormat(message, locale, formats, __assign({ formatters: state }, opts || {}));
    return formatter.format(values);
  } catch (e10) {
    onError(new MessageFormatError('Error formatting message: "'.concat(id, '", using ').concat(defaultMessage ? "default message" : "id", " as fallback."), locale, messageDescriptor, e10));
  }
  if (defaultMessage) {
    try {
      var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats, opts);
      return formatter.format(values);
    } catch (e10) {
      onError(new MessageFormatError('Error formatting the default message for: "'.concat(id, '", rendering message verbatim'), locale, messageDescriptor, e10));
    }
  }
  if (typeof message === "string") {
    return message;
  }
  if (typeof defaultMessage === "string") {
    return defaultMessage;
  }
  return id;
};
var DATE_TIME_FORMAT_OPTIONS = [
  "formatMatcher",
  "timeZone",
  "hour12",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "hourCycle",
  "dateStyle",
  "timeStyle",
  "calendar",
  // 'dayPeriod',
  "numberingSystem",
  "fractionalSecondDigits"
];
function getFormatter$2(_a2, type, getDateTimeFormat, options) {
  var locale = _a2.locale, formats = _a2.formats, onError = _a2.onError, timeZone = _a2.timeZone;
  if (options === void 0) {
    options = {};
  }
  var format = options.format;
  var defaults = __assign(__assign({}, timeZone && { timeZone }), format && getNamedFormat(formats, type, format, onError));
  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);
  if (type === "time" && !filteredOptions.hour && !filteredOptions.minute && !filteredOptions.second && !filteredOptions.timeStyle && !filteredOptions.dateStyle) {
    filteredOptions = __assign(__assign({}, filteredOptions), { hour: "numeric", minute: "numeric" });
  }
  return getDateTimeFormat(locale, filteredOptions);
}
function formatDate(config, getDateTimeFormat) {
  var _a2 = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    _a2[_i2 - 2] = arguments[_i2];
  }
  var value = _a2[0], _b2 = _a2[1], options = _b2 === void 0 ? {} : _b2;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter$2(config, "date", getDateTimeFormat, options).format(date);
  } catch (e10) {
    config.onError(new IntlFormatError("Error formatting date.", config.locale, e10));
  }
  return String(date);
}
function formatTime(config, getDateTimeFormat) {
  var _a2 = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    _a2[_i2 - 2] = arguments[_i2];
  }
  var value = _a2[0], _b2 = _a2[1], options = _b2 === void 0 ? {} : _b2;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter$2(config, "time", getDateTimeFormat, options).format(date);
  } catch (e10) {
    config.onError(new IntlFormatError("Error formatting time.", config.locale, e10));
  }
  return String(date);
}
function formatDateTimeRange(config, getDateTimeFormat) {
  var _a2 = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    _a2[_i2 - 2] = arguments[_i2];
  }
  var from = _a2[0], to = _a2[1], _b2 = _a2[2], options = _b2 === void 0 ? {} : _b2;
  var timeZone = config.timeZone, locale = config.locale, onError = config.onError;
  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, timeZone ? { timeZone } : {});
  try {
    return getDateTimeFormat(locale, filteredOptions).formatRange(from, to);
  } catch (e10) {
    onError(new IntlFormatError("Error formatting date time range.", config.locale, e10));
  }
  return String(from);
}
function formatDateToParts(config, getDateTimeFormat) {
  var _a2 = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    _a2[_i2 - 2] = arguments[_i2];
  }
  var value = _a2[0], _b2 = _a2[1], options = _b2 === void 0 ? {} : _b2;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter$2(config, "date", getDateTimeFormat, options).formatToParts(date);
  } catch (e10) {
    config.onError(new IntlFormatError("Error formatting date.", config.locale, e10));
  }
  return [];
}
function formatTimeToParts(config, getDateTimeFormat) {
  var _a2 = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    _a2[_i2 - 2] = arguments[_i2];
  }
  var value = _a2[0], _b2 = _a2[1], options = _b2 === void 0 ? {} : _b2;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter$2(config, "time", getDateTimeFormat, options).formatToParts(date);
  } catch (e10) {
    config.onError(new IntlFormatError("Error formatting time.", config.locale, e10));
  }
  return [];
}
var DISPLAY_NAMES_OPTONS = [
  "style",
  "type",
  "fallback",
  "languageDisplay"
];
function formatDisplayName(_a2, getDisplayNames, value, options) {
  var locale = _a2.locale, onError = _a2.onError;
  var DisplayNames = Intl.DisplayNames;
  if (!DisplayNames) {
    onError(new FormatError('Intl.DisplayNames is not available in this environment.\nTry polyfilling it using "@formatjs/intl-displaynames"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, DISPLAY_NAMES_OPTONS);
  try {
    return getDisplayNames(locale, filteredOptions).of(value);
  } catch (e10) {
    onError(new IntlFormatError("Error formatting display name.", locale, e10));
  }
}
var LIST_FORMAT_OPTIONS = [
  "type",
  "style"
];
var now = Date.now();
function generateToken(i10) {
  return "".concat(now, "_").concat(i10, "_").concat(now);
}
function formatList(opts, getListFormat, values, options) {
  if (options === void 0) {
    options = {};
  }
  var results = formatListToParts(opts, getListFormat, values, options).reduce(function(all, el) {
    var val = el.value;
    if (typeof val !== "string") {
      all.push(val);
    } else if (typeof all[all.length - 1] === "string") {
      all[all.length - 1] += val;
    } else {
      all.push(val);
    }
    return all;
  }, []);
  return results.length === 1 ? results[0] : results.length === 0 ? "" : results;
}
function formatListToParts(_a2, getListFormat, values, options) {
  var locale = _a2.locale, onError = _a2.onError;
  if (options === void 0) {
    options = {};
  }
  var ListFormat = Intl.ListFormat;
  if (!ListFormat) {
    onError(new FormatError('Intl.ListFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-listformat"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, LIST_FORMAT_OPTIONS);
  try {
    var richValues_1 = {};
    var serializedValues = values.map(function(v10, i10) {
      if (typeof v10 === "object") {
        var id = generateToken(i10);
        richValues_1[id] = v10;
        return id;
      }
      return String(v10);
    });
    return getListFormat(locale, filteredOptions).formatToParts(serializedValues).map(function(part) {
      return part.type === "literal" ? part : __assign(__assign({}, part), { value: richValues_1[part.value] || part.value });
    });
  } catch (e10) {
    onError(new IntlFormatError("Error formatting list.", locale, e10));
  }
  return values;
}
var PLURAL_FORMAT_OPTIONS = ["type"];
function formatPlural(_a2, getPluralRules, value, options) {
  var locale = _a2.locale, onError = _a2.onError;
  if (options === void 0) {
    options = {};
  }
  if (!Intl.PluralRules) {
    onError(new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, PLURAL_FORMAT_OPTIONS);
  try {
    return getPluralRules(locale, filteredOptions).select(value);
  } catch (e10) {
    onError(new IntlFormatError("Error formatting plural.", locale, e10));
  }
  return "other";
}
var RELATIVE_TIME_FORMAT_OPTIONS = ["numeric", "style"];
function getFormatter$1(_a2, getRelativeTimeFormat, options) {
  var locale = _a2.locale, formats = _a2.formats, onError = _a2.onError;
  if (options === void 0) {
    options = {};
  }
  var format = options.format;
  var defaults = !!format && getNamedFormat(formats, "relative", format, onError) || {};
  var filteredOptions = filterProps(options, RELATIVE_TIME_FORMAT_OPTIONS, defaults);
  return getRelativeTimeFormat(locale, filteredOptions);
}
function formatRelativeTime(config, getRelativeTimeFormat, value, unit, options) {
  if (options === void 0) {
    options = {};
  }
  if (!unit) {
    unit = "second";
  }
  var RelativeTimeFormat = Intl.RelativeTimeFormat;
  if (!RelativeTimeFormat) {
    config.onError(new FormatError('Intl.RelativeTimeFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-relativetimeformat"\n', ErrorCode.MISSING_INTL_API));
  }
  try {
    return getFormatter$1(config, getRelativeTimeFormat, options).format(value, unit);
  } catch (e10) {
    config.onError(new IntlFormatError("Error formatting relative time.", config.locale, e10));
  }
  return String(value);
}
var NUMBER_FORMAT_OPTIONS = [
  "style",
  "currency",
  "unit",
  "unitDisplay",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  // ES2020 NumberFormat
  "compactDisplay",
  "currencyDisplay",
  "currencySign",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "numberingSystem",
  // ES2023 NumberFormat
  "trailingZeroDisplay",
  "roundingPriority",
  "roundingIncrement",
  "roundingMode"
];
function getFormatter(_a2, getNumberFormat, options) {
  var locale = _a2.locale, formats = _a2.formats, onError = _a2.onError;
  if (options === void 0) {
    options = {};
  }
  var format = options.format;
  var defaults = format && getNamedFormat(formats, "number", format, onError) || {};
  var filteredOptions = filterProps(options, NUMBER_FORMAT_OPTIONS, defaults);
  return getNumberFormat(locale, filteredOptions);
}
function formatNumber(config, getNumberFormat, value, options) {
  if (options === void 0) {
    options = {};
  }
  try {
    return getFormatter(config, getNumberFormat, options).format(value);
  } catch (e10) {
    config.onError(new IntlFormatError("Error formatting number.", config.locale, e10));
  }
  return String(value);
}
function formatNumberToParts(config, getNumberFormat, value, options) {
  if (options === void 0) {
    options = {};
  }
  try {
    return getFormatter(config, getNumberFormat, options).formatToParts(value);
  } catch (e10) {
    config.onError(new IntlFormatError("Error formatting number.", config.locale, e10));
  }
  return [];
}
function messagesContainString(messages) {
  var firstMessage = messages ? messages[Object.keys(messages)[0]] : void 0;
  return typeof firstMessage === "string";
}
function verifyConfigMessages(config) {
  if (config.onWarn && config.defaultRichTextElements && messagesContainString(config.messages || {})) {
    config.onWarn('[@formatjs/intl] "defaultRichTextElements" was specified but "message" was not pre-compiled. \nPlease consider using "@formatjs/cli" to pre-compile your messages for performance.\nFor more details see https://formatjs.io/docs/getting-started/message-distribution');
  }
}
function createIntl$1(config, cache) {
  var formatters = createFormatters(cache);
  var resolvedConfig = __assign(__assign({}, DEFAULT_INTL_CONFIG$1), config);
  var locale = resolvedConfig.locale, defaultLocale = resolvedConfig.defaultLocale, onError = resolvedConfig.onError;
  if (!locale) {
    if (onError) {
      onError(new InvalidConfigError('"locale" was not configured, using "'.concat(defaultLocale, '" as fallback. See https://formatjs.io/docs/react-intl/api#intlshape for more details')));
    }
    resolvedConfig.locale = resolvedConfig.defaultLocale || "en";
  } else if (!Intl.NumberFormat.supportedLocalesOf(locale).length && onError) {
    onError(new MissingDataError('Missing locale data for locale: "'.concat(locale, '" in Intl.NumberFormat. Using default locale: "').concat(defaultLocale, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details')));
  } else if (!Intl.DateTimeFormat.supportedLocalesOf(locale).length && onError) {
    onError(new MissingDataError('Missing locale data for locale: "'.concat(locale, '" in Intl.DateTimeFormat. Using default locale: "').concat(defaultLocale, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details')));
  }
  verifyConfigMessages(resolvedConfig);
  return __assign(__assign({}, resolvedConfig), {
    formatters,
    formatNumber: formatNumber.bind(null, resolvedConfig, formatters.getNumberFormat),
    formatNumberToParts: formatNumberToParts.bind(null, resolvedConfig, formatters.getNumberFormat),
    formatRelativeTime: formatRelativeTime.bind(null, resolvedConfig, formatters.getRelativeTimeFormat),
    formatDate: formatDate.bind(null, resolvedConfig, formatters.getDateTimeFormat),
    formatDateToParts: formatDateToParts.bind(null, resolvedConfig, formatters.getDateTimeFormat),
    formatTime: formatTime.bind(null, resolvedConfig, formatters.getDateTimeFormat),
    formatDateTimeRange: formatDateTimeRange.bind(null, resolvedConfig, formatters.getDateTimeFormat),
    formatTimeToParts: formatTimeToParts.bind(null, resolvedConfig, formatters.getDateTimeFormat),
    formatPlural: formatPlural.bind(null, resolvedConfig, formatters.getPluralRules),
    // @ts-expect-error TODO: will get to this later
    formatMessage: formatMessage$1.bind(null, resolvedConfig, formatters),
    // @ts-expect-error TODO: will get to this later
    $t: formatMessage$1.bind(null, resolvedConfig, formatters),
    formatList: formatList.bind(null, resolvedConfig, formatters.getListFormat),
    formatListToParts: formatListToParts.bind(null, resolvedConfig, formatters.getListFormat),
    formatDisplayName: formatDisplayName.bind(null, resolvedConfig, formatters.getDisplayNames)
  });
}
function invariantIntlContext(intl) {
  invariant(intl, "[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry.");
}
var DEFAULT_INTL_CONFIG = __assign(__assign({}, DEFAULT_INTL_CONFIG$1), { textComponent: reactExports.Fragment });
function assignUniqueKeysToParts(formatXMLElementFn) {
  return function(parts) {
    return formatXMLElementFn(reactExports.Children.toArray(parts));
  };
}
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }
  if (!objA || !objB) {
    return false;
  }
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;
  if (bKeys.length !== len) {
    return false;
  }
  for (var i10 = 0; i10 < len; i10++) {
    var key = aKeys[i10];
    if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
      return false;
    }
  }
  return true;
}
var reactIs = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b10 = "function" === typeof Symbol && Symbol.for, c10 = b10 ? Symbol.for("react.element") : 60103, d10 = b10 ? Symbol.for("react.portal") : 60106, e10 = b10 ? Symbol.for("react.fragment") : 60107, f10 = b10 ? Symbol.for("react.strict_mode") : 60108, g10 = b10 ? Symbol.for("react.profiler") : 60114, h10 = b10 ? Symbol.for("react.provider") : 60109, k10 = b10 ? Symbol.for("react.context") : 60110, l10 = b10 ? Symbol.for("react.async_mode") : 60111, m10 = b10 ? Symbol.for("react.concurrent_mode") : 60111, n10 = b10 ? Symbol.for("react.forward_ref") : 60112, p10 = b10 ? Symbol.for("react.suspense") : 60113, q10 = b10 ? Symbol.for("react.suspense_list") : 60120, r10 = b10 ? Symbol.for("react.memo") : 60115, t10 = b10 ? Symbol.for("react.lazy") : 60116, v10 = b10 ? Symbol.for("react.block") : 60121, w10 = b10 ? Symbol.for("react.fundamental") : 60117, x10 = b10 ? Symbol.for("react.responder") : 60118, y10 = b10 ? Symbol.for("react.scope") : 60119;
  function z10(a10) {
    if ("object" === typeof a10 && null !== a10) {
      var u10 = a10.$$typeof;
      switch (u10) {
        case c10:
          switch (a10 = a10.type, a10) {
            case l10:
            case m10:
            case e10:
            case g10:
            case f10:
            case p10:
              return a10;
            default:
              switch (a10 = a10 && a10.$$typeof, a10) {
                case k10:
                case n10:
                case t10:
                case r10:
                case h10:
                  return a10;
                default:
                  return u10;
              }
          }
        case d10:
          return u10;
      }
    }
  }
  function A10(a10) {
    return z10(a10) === m10;
  }
  reactIs_production_min.AsyncMode = l10;
  reactIs_production_min.ConcurrentMode = m10;
  reactIs_production_min.ContextConsumer = k10;
  reactIs_production_min.ContextProvider = h10;
  reactIs_production_min.Element = c10;
  reactIs_production_min.ForwardRef = n10;
  reactIs_production_min.Fragment = e10;
  reactIs_production_min.Lazy = t10;
  reactIs_production_min.Memo = r10;
  reactIs_production_min.Portal = d10;
  reactIs_production_min.Profiler = g10;
  reactIs_production_min.StrictMode = f10;
  reactIs_production_min.Suspense = p10;
  reactIs_production_min.isAsyncMode = function(a10) {
    return A10(a10) || z10(a10) === l10;
  };
  reactIs_production_min.isConcurrentMode = A10;
  reactIs_production_min.isContextConsumer = function(a10) {
    return z10(a10) === k10;
  };
  reactIs_production_min.isContextProvider = function(a10) {
    return z10(a10) === h10;
  };
  reactIs_production_min.isElement = function(a10) {
    return "object" === typeof a10 && null !== a10 && a10.$$typeof === c10;
  };
  reactIs_production_min.isForwardRef = function(a10) {
    return z10(a10) === n10;
  };
  reactIs_production_min.isFragment = function(a10) {
    return z10(a10) === e10;
  };
  reactIs_production_min.isLazy = function(a10) {
    return z10(a10) === t10;
  };
  reactIs_production_min.isMemo = function(a10) {
    return z10(a10) === r10;
  };
  reactIs_production_min.isPortal = function(a10) {
    return z10(a10) === d10;
  };
  reactIs_production_min.isProfiler = function(a10) {
    return z10(a10) === g10;
  };
  reactIs_production_min.isStrictMode = function(a10) {
    return z10(a10) === f10;
  };
  reactIs_production_min.isSuspense = function(a10) {
    return z10(a10) === p10;
  };
  reactIs_production_min.isValidElementType = function(a10) {
    return "string" === typeof a10 || "function" === typeof a10 || a10 === e10 || a10 === m10 || a10 === g10 || a10 === f10 || a10 === p10 || a10 === q10 || "object" === typeof a10 && null !== a10 && (a10.$$typeof === t10 || a10.$$typeof === r10 || a10.$$typeof === h10 || a10.$$typeof === k10 || a10.$$typeof === n10 || a10.$$typeof === w10 || a10.$$typeof === x10 || a10.$$typeof === y10 || a10.$$typeof === v10);
  };
  reactIs_production_min.typeOf = z10;
  return reactIs_production_min;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  {
    reactIs.exports = requireReactIs_production_min();
  }
  return reactIs.exports;
}
var hoistNonReactStatics_cjs;
var hasRequiredHoistNonReactStatics_cjs;
function requireHoistNonReactStatics_cjs() {
  if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
  hasRequiredHoistNonReactStatics_cjs = 1;
  var reactIs2 = requireReactIs();
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    "$$typeof": true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs2.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs2.Memo] = MEMO_STATICS;
  function getStatics(component) {
    if (reactIs2.isMemo(component)) {
      return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
  }
  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);
        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
      }
      var keys = getOwnPropertyNames(sourceComponent);
      if (getOwnPropertySymbols) {
        keys = keys.concat(getOwnPropertySymbols(sourceComponent));
      }
      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);
      for (var i10 = 0; i10 < keys.length; ++i10) {
        var key = keys[i10];
        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
          try {
            defineProperty(targetComponent, key, descriptor);
          } catch (e10) {
          }
        }
      }
    }
    return targetComponent;
  }
  hoistNonReactStatics_cjs = hoistNonReactStatics;
  return hoistNonReactStatics_cjs;
}
requireHoistNonReactStatics_cjs();
var IntlContext = typeof window !== "undefined" && !window.__REACT_INTL_BYPASS_GLOBAL_CONTEXT__ ? window.__REACT_INTL_CONTEXT__ || (window.__REACT_INTL_CONTEXT__ = reactExports.createContext(null)) : reactExports.createContext(null);
IntlContext.Consumer;
var IntlProvider$1 = IntlContext.Provider;
var Provider$1 = IntlProvider$1;
var Context = IntlContext;
function useIntl() {
  var intl = reactExports.useContext(Context);
  invariantIntlContext(intl);
  return intl;
}
var DisplayName;
(function(DisplayName2) {
  DisplayName2["formatDate"] = "FormattedDate";
  DisplayName2["formatTime"] = "FormattedTime";
  DisplayName2["formatNumber"] = "FormattedNumber";
  DisplayName2["formatList"] = "FormattedList";
  DisplayName2["formatDisplayName"] = "FormattedDisplayName";
})(DisplayName || (DisplayName = {}));
var DisplayNameParts;
(function(DisplayNameParts2) {
  DisplayNameParts2["formatDate"] = "FormattedDateParts";
  DisplayNameParts2["formatTime"] = "FormattedTimeParts";
  DisplayNameParts2["formatNumber"] = "FormattedNumberParts";
  DisplayNameParts2["formatList"] = "FormattedListParts";
})(DisplayNameParts || (DisplayNameParts = {}));
function createFormattedDateTimePartsComponent(name) {
  var ComponentParts = function(props) {
    var intl = useIntl();
    var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
    var date = typeof value === "string" ? new Date(value || 0) : value;
    var formattedParts = name === "formatDate" ? intl.formatDateToParts(date, formatProps) : intl.formatTimeToParts(date, formatProps);
    return children(formattedParts);
  };
  ComponentParts.displayName = DisplayNameParts[name];
  return ComponentParts;
}
function createFormattedComponent(name) {
  var Component = function(props) {
    var intl = useIntl();
    var value = props.value, children = props.children, formatProps = __rest(
      props,
      ["value", "children"]
    );
    var formattedValue = intl[name](value, formatProps);
    if (typeof children === "function") {
      return children(formattedValue);
    }
    var Text = intl.textComponent || reactExports.Fragment;
    return reactExports.createElement(Text, null, formattedValue);
  };
  Component.displayName = DisplayName[name];
  return Component;
}
function assignUniqueKeysToFormatXMLElementFnArgument(values) {
  if (!values) {
    return values;
  }
  return Object.keys(values).reduce(function(acc, k10) {
    var v10 = values[k10];
    acc[k10] = isFormatXMLElementFn(v10) ? assignUniqueKeysToParts(v10) : v10;
    return acc;
  }, {});
}
var formatMessage = function(config, formatters, descriptor, rawValues) {
  var rest = [];
  for (var _i2 = 4; _i2 < arguments.length; _i2++) {
    rest[_i2 - 4] = arguments[_i2];
  }
  var values = assignUniqueKeysToFormatXMLElementFnArgument(rawValues);
  var chunks = formatMessage$1.apply(void 0, __spreadArray([
    config,
    formatters,
    descriptor,
    values
  ], rest, false));
  if (Array.isArray(chunks)) {
    return reactExports.Children.toArray(chunks);
  }
  return chunks;
};
var createIntl = function(_a2, cache) {
  var rawDefaultRichTextElements = _a2.defaultRichTextElements, config = __rest(_a2, ["defaultRichTextElements"]);
  var defaultRichTextElements = assignUniqueKeysToFormatXMLElementFnArgument(rawDefaultRichTextElements);
  var coreIntl = createIntl$1(__assign(__assign(__assign({}, DEFAULT_INTL_CONFIG), config), { defaultRichTextElements }), cache);
  var resolvedConfig = {
    locale: coreIntl.locale,
    timeZone: coreIntl.timeZone,
    fallbackOnEmptyString: coreIntl.fallbackOnEmptyString,
    formats: coreIntl.formats,
    defaultLocale: coreIntl.defaultLocale,
    defaultFormats: coreIntl.defaultFormats,
    messages: coreIntl.messages,
    onError: coreIntl.onError,
    defaultRichTextElements
  };
  return __assign(__assign({}, coreIntl), {
    formatMessage: formatMessage.bind(
      null,
      resolvedConfig,
      // @ts-expect-error fix this
      coreIntl.formatters
    ),
    // @ts-expect-error fix this
    $t: formatMessage.bind(null, resolvedConfig, coreIntl.formatters)
  });
};
function processIntlConfig(config) {
  return {
    locale: config.locale,
    timeZone: config.timeZone,
    fallbackOnEmptyString: config.fallbackOnEmptyString,
    formats: config.formats,
    textComponent: config.textComponent,
    messages: config.messages,
    defaultLocale: config.defaultLocale,
    defaultFormats: config.defaultFormats,
    onError: config.onError,
    onWarn: config.onWarn,
    wrapRichTextChunksInFragment: config.wrapRichTextChunksInFragment,
    defaultRichTextElements: config.defaultRichTextElements
  };
}
var IntlProvider = (
  /** @class */
  function(_super) {
    __extends(IntlProvider2, _super);
    function IntlProvider2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.cache = createIntlCache();
      _this.state = {
        cache: _this.cache,
        intl: createIntl(processIntlConfig(_this.props), _this.cache),
        prevConfig: processIntlConfig(_this.props)
      };
      return _this;
    }
    IntlProvider2.getDerivedStateFromProps = function(props, _a2) {
      var prevConfig = _a2.prevConfig, cache = _a2.cache;
      var config = processIntlConfig(props);
      if (!shallowEqual(prevConfig, config)) {
        return {
          intl: createIntl(config, cache),
          prevConfig: config
        };
      }
      return null;
    };
    IntlProvider2.prototype.render = function() {
      invariantIntlContext(this.state.intl);
      return reactExports.createElement(Provider$1, { value: this.state.intl }, this.props.children);
    };
    IntlProvider2.displayName = "IntlProvider";
    IntlProvider2.defaultProps = DEFAULT_INTL_CONFIG;
    return IntlProvider2;
  }(reactExports.PureComponent)
);
function areEqual(prevProps, nextProps) {
  var values = prevProps.values, otherProps = __rest(prevProps, ["values"]);
  var nextValues = nextProps.values, nextOtherProps = __rest(nextProps, ["values"]);
  return shallowEqual(nextValues, values) && shallowEqual(otherProps, nextOtherProps);
}
function FormattedMessage(props) {
  var intl = useIntl();
  var formatMessage2 = intl.formatMessage, _a2 = intl.textComponent, Text = _a2 === void 0 ? reactExports.Fragment : _a2;
  var id = props.id, description = props.description, defaultMessage = props.defaultMessage, values = props.values, children = props.children, _b2 = props.tagName, Component = _b2 === void 0 ? Text : _b2, ignoreTag = props.ignoreTag;
  var descriptor = { id, description, defaultMessage };
  var nodes = formatMessage2(descriptor, values, {
    ignoreTag
  });
  if (typeof children === "function") {
    return children(Array.isArray(nodes) ? nodes : [nodes]);
  }
  if (Component) {
    return reactExports.createElement(Component, null, reactExports.Children.toArray(nodes));
  }
  return reactExports.createElement(reactExports.Fragment, null, nodes);
}
FormattedMessage.displayName = "FormattedMessage";
var MemoizedFormattedMessage = reactExports.memo(FormattedMessage, areEqual);
MemoizedFormattedMessage.displayName = "MemoizedFormattedMessage";
createFormattedComponent("formatDate");
createFormattedComponent("formatTime");
createFormattedComponent("formatNumber");
createFormattedComponent("formatList");
createFormattedComponent("formatDisplayName");
createFormattedDateTimePartsComponent("formatDate");
createFormattedDateTimePartsComponent("formatTime");
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n10) {
    for (var e10 = 1; e10 < arguments.length; e10++) {
      var t10 = arguments[e10];
      for (var r10 in t10) ({}).hasOwnProperty.call(t10, r10) && (n10[r10] = t10[r10]);
    }
    return n10;
  }, _extends.apply(null, arguments);
}
function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
  };
}
function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
    const BaseContext = /* @__PURE__ */ reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [
      ...defaultContexts,
      defaultContext
    ];
    function Provider2(props) {
      const { scope, children, ...context } = props;
      const Context2 = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = reactExports.useMemo(
        () => context,
        Object.values(context)
      );
      return /* @__PURE__ */ reactExports.createElement(Context2.Provider, {
        value
      }, children);
    }
    function useContext(consumerName, scope) {
      const Context2 = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context = reactExports.useContext(Context2);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [
      Provider2,
      useContext
    ];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return /* @__PURE__ */ reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({
          [`__scope${scopeName}`]: {
            ...scope,
            [scopeName]: contexts
          }
        }),
        [
          scope,
          contexts
        ]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [
    $c512c27ab02ef895$export$fd42f52fd3ae1109,
    $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)
  ];
}
function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope1 = () => {
    const scopeHooks = scopes.map(
      (createScope) => ({
        useScope: createScope(),
        scopeName: createScope.scopeName
      })
    );
    return function useComposedScopes(overrideScopes) {
      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return {
          ...nextScopes,
          ...currentScope
        };
      }, {});
      return reactExports.useMemo(
        () => ({
          [`__scope${baseScope.scopeName}`]: nextScopes1
        }),
        [
          nextScopes1
        ]
      );
    };
  };
  createScope1.scopeName = baseScope.scopeName;
  return createScope1;
}
var reactDomExports = requireReactDom();
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
function $6ed0406888f73fc4$var$setRef$5(ref, value) {
  if (typeof ref === "function") ref(value);
  else if (ref !== null && ref !== void 0) ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af$5(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef$5(ref, node)
  );
}
const $5e63c961fc1ce211$export$8c6ed5c666ac1360$2 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable$2);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
        return /* @__PURE__ */ reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else return child;
    });
    return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone$2, _extends({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ reactExports.isValidElement(newElement) ? /* @__PURE__ */ reactExports.cloneElement(newElement, void 0, newChildren) : null);
  }
  return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone$2, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360$2.displayName = "Slot";
const $5e63c961fc1ce211$var$SlotClone$2 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ reactExports.isValidElement(children)) return /* @__PURE__ */ reactExports.cloneElement(children, {
    ...$5e63c961fc1ce211$var$mergeProps$2(slotProps, children.props),
    ref: $6ed0406888f73fc4$export$43e446d32b3d21af$5(forwardedRef, children.ref)
  });
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone$2.displayName = "SlotClone";
const $5e63c961fc1ce211$export$d9f1ccf0bdb05d45$2 = ({ children }) => {
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable$2(child) {
  return /* @__PURE__ */ reactExports.isValidElement(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45$2;
}
function $5e63c961fc1ce211$var$mergeProps$2(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) overrideProps[propName] = (...args) => {
      childPropValue === null || childPropValue === void 0 || childPropValue(...args);
      slotPropValue === null || slotPropValue === void 0 || slotPropValue(...args);
    };
    else if (propName === "style") overrideProps[propName] = {
      ...slotPropValue,
      ...childPropValue
    };
    else if (propName === "className") overrideProps[propName] = [
      slotPropValue,
      childPropValue
    ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}
const $8927f6f2acc4f386$var$NODES = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
const $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node) => {
  const Node2 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360$2 : node;
    reactExports.useEffect(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []);
    return /* @__PURE__ */ reactExports.createElement(Comp, _extends({}, primitiveProps, {
      ref: forwardedRef
    }));
  });
  Node2.displayName = `Primitive.${node}`;
  return {
    ...primitive,
    [node]: Node2
  };
}, {});
function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {
  if (target) reactDomExports.flushSync(
    () => target.dispatchEvent(event)
  );
}
function $6ed0406888f73fc4$var$setRef$4(ref, value) {
  if (typeof ref === "function") ref(value);
  else if (ref !== null && ref !== void 0) ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af$4(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef$4(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05$3(...refs) {
  return reactExports.useCallback($6ed0406888f73fc4$export$43e446d32b3d21af$4(...refs), refs);
}
const $5e63c961fc1ce211$export$8c6ed5c666ac1360$1 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable$1);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
        return /* @__PURE__ */ reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else return child;
    });
    return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone$1, _extends({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ reactExports.isValidElement(newElement) ? /* @__PURE__ */ reactExports.cloneElement(newElement, void 0, newChildren) : null);
  }
  return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone$1, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360$1.displayName = "Slot";
const $5e63c961fc1ce211$var$SlotClone$1 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ reactExports.isValidElement(children)) return /* @__PURE__ */ reactExports.cloneElement(children, {
    ...$5e63c961fc1ce211$var$mergeProps$1(slotProps, children.props),
    ref: $6ed0406888f73fc4$export$43e446d32b3d21af$4(forwardedRef, children.ref)
  });
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone$1.displayName = "SlotClone";
const $5e63c961fc1ce211$export$d9f1ccf0bdb05d45$1 = ({ children }) => {
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable$1(child) {
  return /* @__PURE__ */ reactExports.isValidElement(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45$1;
}
function $5e63c961fc1ce211$var$mergeProps$1(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) overrideProps[propName] = (...args) => {
      childPropValue === null || childPropValue === void 0 || childPropValue(...args);
      slotPropValue === null || slotPropValue === void 0 || slotPropValue(...args);
    };
    else if (propName === "style") overrideProps[propName] = {
      ...slotPropValue,
      ...childPropValue
    };
    else if (propName === "className") overrideProps[propName] = [
      slotPropValue,
      childPropValue
    ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}
function $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {
  const PROVIDER_NAME2 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope] = $c512c27ab02ef895$export$50c7b4e9d9f19c1(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME2, {
    collectionRef: {
      current: null
    },
    itemMap: /* @__PURE__ */ new Map()
  });
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = spe.useRef(null);
    const itemMap = spe.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ spe.createElement(CollectionProviderImpl, {
      scope,
      itemMap,
      collectionRef: ref
    }, children);
  };
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = /* @__PURE__ */ spe.forwardRef((props, forwardedRef) => {
    const { scope, children } = props;
    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$3(forwardedRef, context.collectionRef);
    return /* @__PURE__ */ spe.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360$1, {
      ref: composedRefs
    }, children);
  });
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = /* @__PURE__ */ spe.forwardRef((props, forwardedRef) => {
    const { scope, children, ...itemData } = props;
    const ref = spe.useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$3(forwardedRef, ref);
    const context = useCollectionContext(ITEM_SLOT_NAME, scope);
    spe.useEffect(() => {
      context.itemMap.set(ref, {
        ref,
        ...itemData
      });
      return () => void context.itemMap.delete(ref);
    });
    return /* @__PURE__ */ spe.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360$1, {
      [ITEM_DATA_ATTR]: "",
      ref: composedRefs
    }, children);
  });
  function useCollection(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = spe.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a10, b10) => orderedNodes.indexOf(a10.ref.current) - orderedNodes.indexOf(b10.ref.current)
      );
      return orderedItems;
    }, [
      context.collectionRef,
      context.itemMap
    ]);
    return getItems;
  }
  return [
    {
      Provider: CollectionProvider,
      Slot: CollectionSlot,
      ItemSlot: CollectionItemSlot
    },
    useCollection,
    createCollectionScope
  ];
}
function $6ed0406888f73fc4$var$setRef$3(ref, value) {
  if (typeof ref === "function") ref(value);
  else if (ref !== null && ref !== void 0) ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af$3(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef$3(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05$2(...refs) {
  return reactExports.useCallback($6ed0406888f73fc4$export$43e446d32b3d21af$3(...refs), refs);
}
const $f631663db3294ace$var$DirectionContext = /* @__PURE__ */ reactExports.createContext(void 0);
function $f631663db3294ace$export$b39126d51d94e6f3(localDir) {
  const globalDir = reactExports.useContext($f631663db3294ace$var$DirectionContext);
  return localDir || globalDir || "ltr";
}
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(
    () => (...args) => {
      var _callbackRef$current;
      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
    },
    []
  );
}
function $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp) {
  const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") onEscapeKeyDown(event);
    };
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [
    onEscapeKeyDown
  ]);
}
const $5cb92bef7577960e$var$CONTEXT_UPDATE = "dismissableLayer.update";
const $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
const $5cb92bef7577960e$var$FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
let $5cb92bef7577960e$var$originalBodyPointerEvents;
const $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
const $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;
  const context = reactExports.useContext($5cb92bef7577960e$var$DismissableLayerContext);
  const [node1, setNode] = reactExports.useState(null);
  const [, force] = reactExports.useState({});
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$2(
    forwardedRef,
    (node) => setNode(node)
  );
  const layers = Array.from(context.layers);
  const [highestLayerWithOutsidePointerEventsDisabled] = [
    ...context.layersWithOutsidePointerEventsDisabled
  ].slice(-1);
  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
  const index2 = node1 ? layers.indexOf(node1) : -1;
  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
  const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
  const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {
    const target = event.target;
    const isPointerDownOnBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
    onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented) onDismiss === null || onDismiss === void 0 || onDismiss();
  });
  const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {
    const target = event.target;
    const isFocusInBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (isFocusInBranch) return;
    onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented) onDismiss === null || onDismiss === void 0 || onDismiss();
  });
  $addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {
    const isHighestLayer = index2 === context.layers.size - 1;
    if (!isHighestLayer) return;
    onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  });
  reactExports.useEffect(() => {
    if (!node1) return;
    if (disableOutsidePointerEvents) {
      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
        $5cb92bef7577960e$var$originalBodyPointerEvents = document.body.style.pointerEvents;
        document.body.style.pointerEvents = "none";
      }
      context.layersWithOutsidePointerEventsDisabled.add(node1);
    }
    context.layers.add(node1);
    $5cb92bef7577960e$var$dispatchUpdate();
    return () => {
      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) document.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;
    };
  }, [
    node1,
    disableOutsidePointerEvents,
    context
  ]);
  reactExports.useEffect(() => {
    return () => {
      if (!node1) return;
      context.layers.delete(node1);
      context.layersWithOutsidePointerEventsDisabled.delete(node1);
      $5cb92bef7577960e$var$dispatchUpdate();
    };
  }, [
    node1,
    context
  ]);
  reactExports.useEffect(() => {
    const handleUpdate = () => force({});
    document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
    return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
  }, []);
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, layerProps, {
    ref: composedRefs,
    style: {
      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
      ...props.style
    },
    onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),
    onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),
    onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
  }));
});
function $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside) {
  const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {
            discrete: true
          });
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = {
          originalEvent: event
        };
        if (event.pointerType === "touch") {
          document.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          document.addEventListener("click", handleClickRef.current, {
            once: true
          });
        } else handleAndDispatchPointerDownOutsideEvent2();
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      document.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      document.removeEventListener("pointerdown", handlePointerDown);
      document.removeEventListener("click", handleClickRef.current);
    };
  }, [
    handlePointerDownOutside
  ]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function $5cb92bef7577960e$var$useFocusOutside(onFocusOutside) {
  const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = {
          originalEvent: event
        };
        $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    document.addEventListener("focusin", handleFocus);
    return () => document.removeEventListener("focusin", handleFocus);
  }, [
    handleFocusOutside
  ]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function $5cb92bef7577960e$var$dispatchUpdate() {
  const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler) target.addEventListener(name, handler, {
    once: true
  });
  if (discrete) $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);
  else target.dispatchEvent(event);
}
let $3db38b7d1fb3fe6a$var$count = 0;
function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
  reactExports.useEffect(() => {
    var _edgeGuards$, _edgeGuards$2;
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());
    document.body.insertAdjacentElement("beforeend", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());
    $3db38b7d1fb3fe6a$var$count++;
    return () => {
      if ($3db38b7d1fb3fe6a$var$count === 1) document.querySelectorAll("[data-radix-focus-guard]").forEach(
        (node) => node.remove()
      );
      $3db38b7d1fb3fe6a$var$count--;
    };
  }, []);
}
function $3db38b7d1fb3fe6a$var$createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}
const $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
const $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
const $d3863c46a17e8a28$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
const $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;
  const [container1, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);
  const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$2(
    forwardedRef,
    (node) => setContainer(node)
  );
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container1) return;
        const target = event.target;
        if (container1.contains(target)) lastFocusedElementRef.current = target;
        else $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
          select: true
        });
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container1) return;
        if (!container1.contains(event.relatedTarget)) $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
          select: true
        });
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
      };
    }
  }, [
    trapped,
    container1,
    focusScope.paused
  ]);
  reactExports.useEffect(() => {
    if (container1) {
      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container1.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {
            select: true
          });
          if (document.activeElement === previouslyFocusedElement) $d3863c46a17e8a28$var$focus(container1);
        }
      }
      return () => {
        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container1.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
            select: true
          });
          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [
    container1,
    onMountAutoFocus,
    onUnmountAutoFocus,
    focusScope
  ]);
  const handleKeyDown = reactExports.useCallback((event) => {
    if (!loop && !trapped) return;
    if (focusScope.paused) return;
    const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
    const focusedElement = document.activeElement;
    if (isTabKey && focusedElement) {
      const container = event.currentTarget;
      const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);
      const hasTabbableElementsInside = first && last;
      if (!hasTabbableElementsInside) {
        if (focusedElement === container) event.preventDefault();
      } else {
        if (!event.shiftKey && focusedElement === last) {
          event.preventDefault();
          if (loop) $d3863c46a17e8a28$var$focus(first, {
            select: true
          });
        } else if (event.shiftKey && focusedElement === first) {
          event.preventDefault();
          if (loop) $d3863c46a17e8a28$var$focus(last, {
            select: true
          });
        }
      }
    }
  }, [
    loop,
    trapped,
    focusScope.paused
  ]);
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    tabIndex: -1
  }, scopeProps, {
    ref: composedRefs,
    onKeyDown: handleKeyDown
  }));
});
function $d3863c46a17e8a28$var$focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    $d3863c46a17e8a28$var$focus(candidate, {
      select
    });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function $d3863c46a17e8a28$var$getTabbableEdges(container) {
  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);
  const first = $d3863c46a17e8a28$var$findVisible(candidates, container);
  const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);
  return [
    first,
    last
  ];
}
function $d3863c46a17e8a28$var$getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function $d3863c46a17e8a28$var$findVisible(elements, container) {
  for (const element of elements) {
    if (!$d3863c46a17e8a28$var$isHidden(element, {
      upTo: container
    })) return element;
  }
}
function $d3863c46a17e8a28$var$isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function $d3863c46a17e8a28$var$isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function $d3863c46a17e8a28$var$focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({
      preventScroll: true
    });
    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select) element.select();
  }
}
const $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();
function $d3863c46a17e8a28$var$createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _stack$;
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();
    }
  };
}
function $d3863c46a17e8a28$var$arrayRemove(array, item) {
  const updatedArray = [
    ...array
  ];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) updatedArray.splice(index2, 1);
  return updatedArray;
}
function $d3863c46a17e8a28$var$removeLinks(items) {
  return items.filter(
    (item) => item.tagName !== "A"
  );
}
const $9f79659886946c16$export$e5c5a5f917a5871c$4 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
};
const $1746a345f3d73bb7$var$useReactId$2 = React["useId".toString()] || (() => void 0);
let $1746a345f3d73bb7$var$count$2 = 0;
function $1746a345f3d73bb7$export$f680877a34711e37$2(deterministicId) {
  const [id, setId] = reactExports.useState($1746a345f3d73bb7$var$useReactId$2());
  $9f79659886946c16$export$e5c5a5f917a5871c$4(() => {
    setId(
      (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count$2++)
    );
  }, [
    deterministicId
  ]);
  return deterministicId || (id ? `radix-${id}` : "");
}
function t$2(t10) {
  return t10.split("-")[0];
}
function e$2(t10) {
  return t10.split("-")[1];
}
function n$3(e10) {
  return ["top", "bottom"].includes(t$2(e10)) ? "x" : "y";
}
function r$3(t10) {
  return "y" === t10 ? "height" : "width";
}
function i$3(i10, o10, a10) {
  let { reference: l10, floating: s10 } = i10;
  const c10 = l10.x + l10.width / 2 - s10.width / 2, f10 = l10.y + l10.height / 2 - s10.height / 2, u10 = n$3(o10), m10 = r$3(u10), g10 = l10[m10] / 2 - s10[m10] / 2, d10 = "x" === u10;
  let p10;
  switch (t$2(o10)) {
    case "top":
      p10 = { x: c10, y: l10.y - s10.height };
      break;
    case "bottom":
      p10 = { x: c10, y: l10.y + l10.height };
      break;
    case "right":
      p10 = { x: l10.x + l10.width, y: f10 };
      break;
    case "left":
      p10 = { x: l10.x - s10.width, y: f10 };
      break;
    default:
      p10 = { x: l10.x, y: l10.y };
  }
  switch (e$2(o10)) {
    case "start":
      p10[u10] -= g10 * (a10 && d10 ? -1 : 1);
      break;
    case "end":
      p10[u10] += g10 * (a10 && d10 ? -1 : 1);
  }
  return p10;
}
const o$3 = async (t10, e10, n10) => {
  const { placement: r10 = "bottom", strategy: o10 = "absolute", middleware: a10 = [], platform: l10 } = n10, s10 = await (null == l10.isRTL ? void 0 : l10.isRTL(e10));
  let c10 = await l10.getElementRects({ reference: t10, floating: e10, strategy: o10 }), { x: f10, y: u10 } = i$3(c10, r10, s10), m10 = r10, g10 = {}, d10 = 0;
  for (let n11 = 0; n11 < a10.length; n11++) {
    const { name: p10, fn: h10 } = a10[n11], { x: y10, y: x10, data: w10, reset: v10 } = await h10({ x: f10, y: u10, initialPlacement: r10, placement: m10, strategy: o10, middlewareData: g10, rects: c10, platform: l10, elements: { reference: t10, floating: e10 } });
    f10 = null != y10 ? y10 : f10, u10 = null != x10 ? x10 : u10, g10 = { ...g10, [p10]: { ...g10[p10], ...w10 } }, v10 && d10 <= 50 && (d10++, "object" == typeof v10 && (v10.placement && (m10 = v10.placement), v10.rects && (c10 = true === v10.rects ? await l10.getElementRects({ reference: t10, floating: e10, strategy: o10 }) : v10.rects), { x: f10, y: u10 } = i$3(c10, m10, s10)), n11 = -1);
  }
  return { x: f10, y: u10, placement: m10, strategy: o10, middlewareData: g10 };
};
function a$4(t10) {
  return "number" != typeof t10 ? function(t11) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t11 };
  }(t10) : { top: t10, right: t10, bottom: t10, left: t10 };
}
function l$4(t10) {
  return { ...t10, top: t10.y, left: t10.x, right: t10.x + t10.width, bottom: t10.y + t10.height };
}
async function s$3(t10, e10) {
  var n10;
  void 0 === e10 && (e10 = {});
  const { x: r10, y: i10, platform: o10, rects: s10, elements: c10, strategy: f10 } = t10, { boundary: u10 = "clippingAncestors", rootBoundary: m10 = "viewport", elementContext: g10 = "floating", altBoundary: d10 = false, padding: p10 = 0 } = e10, h10 = a$4(p10), y10 = c10[d10 ? "floating" === g10 ? "reference" : "floating" : g10], x10 = l$4(await o10.getClippingRect({ element: null == (n10 = await (null == o10.isElement ? void 0 : o10.isElement(y10))) || n10 ? y10 : y10.contextElement || await (null == o10.getDocumentElement ? void 0 : o10.getDocumentElement(c10.floating)), boundary: u10, rootBoundary: m10, strategy: f10 })), w10 = l$4(o10.convertOffsetParentRelativeRectToViewportRelativeRect ? await o10.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: "floating" === g10 ? { ...s10.floating, x: r10, y: i10 } : s10.reference, offsetParent: await (null == o10.getOffsetParent ? void 0 : o10.getOffsetParent(c10.floating)), strategy: f10 }) : s10[g10]);
  return { top: x10.top - w10.top + h10.top, bottom: w10.bottom - x10.bottom + h10.bottom, left: x10.left - w10.left + h10.left, right: w10.right - x10.right + h10.right };
}
const c$3 = Math.min, f$3 = Math.max;
function u$3(t10, e10, n10) {
  return f$3(t10, c$3(e10, n10));
}
const m$3 = (t10) => ({ name: "arrow", options: t10, async fn(i10) {
  const { element: o10, padding: l10 = 0 } = null != t10 ? t10 : {}, { x: s10, y: c10, placement: f10, rects: m10, platform: g10 } = i10;
  if (null == o10) return {};
  const d10 = a$4(l10), p10 = { x: s10, y: c10 }, h10 = n$3(f10), y10 = e$2(f10), x10 = r$3(h10), w10 = await g10.getDimensions(o10), v10 = "y" === h10 ? "top" : "left", b10 = "y" === h10 ? "bottom" : "right", R10 = m10.reference[x10] + m10.reference[h10] - p10[h10] - m10.floating[x10], A10 = p10[h10] - m10.reference[h10], P10 = await (null == g10.getOffsetParent ? void 0 : g10.getOffsetParent(o10));
  let T10 = P10 ? "y" === h10 ? P10.clientHeight || 0 : P10.clientWidth || 0 : 0;
  0 === T10 && (T10 = m10.floating[x10]);
  const O10 = R10 / 2 - A10 / 2, D10 = d10[v10], L10 = T10 - w10[x10] - d10[b10], k10 = T10 / 2 - w10[x10] / 2 + O10, E10 = u$3(D10, k10, L10), C10 = ("start" === y10 ? d10[v10] : d10[b10]) > 0 && k10 !== E10 && m10.reference[x10] <= m10.floating[x10];
  return { [h10]: p10[h10] - (C10 ? k10 < D10 ? D10 - k10 : L10 - k10 : 0), data: { [h10]: E10, centerOffset: k10 - E10 } };
} }), g$2 = { left: "right", right: "left", bottom: "top", top: "bottom" };
function d$3(t10) {
  return t10.replace(/left|right|bottom|top/g, (t11) => g$2[t11]);
}
function p$3(t10, i10, o10) {
  void 0 === o10 && (o10 = false);
  const a10 = e$2(t10), l10 = n$3(t10), s10 = r$3(l10);
  let c10 = "x" === l10 ? a10 === (o10 ? "end" : "start") ? "right" : "left" : "start" === a10 ? "bottom" : "top";
  return i10.reference[s10] > i10.floating[s10] && (c10 = d$3(c10)), { main: c10, cross: d$3(c10) };
}
const h$3 = { start: "end", end: "start" };
function y$3(t10) {
  return t10.replace(/start|end/g, (t11) => h$3[t11]);
}
const x$3 = ["top", "right", "bottom", "left"];
x$3.reduce((t10, e10) => t10.concat(e10, e10 + "-start", e10 + "-end"), []);
const b$3 = function(e10) {
  return void 0 === e10 && (e10 = {}), { name: "flip", options: e10, async fn(n10) {
    var r10;
    const { placement: i10, middlewareData: o10, rects: a10, initialPlacement: l10, platform: c10, elements: f10 } = n10, { mainAxis: u10 = true, crossAxis: m10 = true, fallbackPlacements: g10, fallbackStrategy: h10 = "bestFit", flipAlignment: x10 = true, ...w10 } = e10, v10 = t$2(i10), b10 = g10 || (v10 === l10 || !x10 ? [d$3(l10)] : function(t10) {
      const e11 = d$3(t10);
      return [y$3(t10), e11, y$3(e11)];
    }(l10)), R10 = [l10, ...b10], A10 = await s$3(n10, w10), P10 = [];
    let T10 = (null == (r10 = o10.flip) ? void 0 : r10.overflows) || [];
    if (u10 && P10.push(A10[v10]), m10) {
      const { main: t10, cross: e11 } = p$3(i10, a10, await (null == c10.isRTL ? void 0 : c10.isRTL(f10.floating)));
      P10.push(A10[t10], A10[e11]);
    }
    if (T10 = [...T10, { placement: i10, overflows: P10 }], !P10.every((t10) => t10 <= 0)) {
      var O10, D10;
      const t10 = (null != (O10 = null == (D10 = o10.flip) ? void 0 : D10.index) ? O10 : 0) + 1, e11 = R10[t10];
      if (e11) return { data: { index: t10, overflows: T10 }, reset: { placement: e11 } };
      let n11 = "bottom";
      switch (h10) {
        case "bestFit": {
          var L10;
          const t11 = null == (L10 = T10.map((t12) => [t12, t12.overflows.filter((t13) => t13 > 0).reduce((t13, e12) => t13 + e12, 0)]).sort((t12, e12) => t12[1] - e12[1])[0]) ? void 0 : L10[0].placement;
          t11 && (n11 = t11);
          break;
        }
        case "initialPlacement":
          n11 = l10;
      }
      if (i10 !== n11) return { reset: { placement: n11 } };
    }
    return {};
  } };
};
function R$2(t10, e10) {
  return { top: t10.top - e10.height, right: t10.right - e10.width, bottom: t10.bottom - e10.height, left: t10.left - e10.width };
}
function A$1(t10) {
  return x$3.some((e10) => t10[e10] >= 0);
}
const P$2 = function(t10) {
  let { strategy: e10 = "referenceHidden", ...n10 } = void 0 === t10 ? {} : t10;
  return { name: "hide", async fn(t11) {
    const { rects: r10 } = t11;
    switch (e10) {
      case "referenceHidden": {
        const e11 = R$2(await s$3(t11, { ...n10, elementContext: "reference" }), r10.reference);
        return { data: { referenceHiddenOffsets: e11, referenceHidden: A$1(e11) } };
      }
      case "escaped": {
        const e11 = R$2(await s$3(t11, { ...n10, altBoundary: true }), r10.floating);
        return { data: { escapedOffsets: e11, escaped: A$1(e11) } };
      }
      default:
        return {};
    }
  } };
};
const T$2 = function(r10) {
  return void 0 === r10 && (r10 = 0), { name: "offset", options: r10, async fn(i10) {
    const { x: o10, y: a10 } = i10, l10 = await async function(r11, i11) {
      const { placement: o11, platform: a11, elements: l11 } = r11, s10 = await (null == a11.isRTL ? void 0 : a11.isRTL(l11.floating)), c10 = t$2(o11), f10 = e$2(o11), u10 = "x" === n$3(o11), m10 = ["left", "top"].includes(c10) ? -1 : 1, g10 = s10 && u10 ? -1 : 1, d10 = "function" == typeof i11 ? i11(r11) : i11;
      let { mainAxis: p10, crossAxis: h10, alignmentAxis: y10 } = "number" == typeof d10 ? { mainAxis: d10, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d10 };
      return f10 && "number" == typeof y10 && (h10 = "end" === f10 ? -1 * y10 : y10), u10 ? { x: h10 * g10, y: p10 * m10 } : { x: p10 * m10, y: h10 * g10 };
    }(i10, r10);
    return { x: o10 + l10.x, y: a10 + l10.y, data: l10 };
  } };
};
function O$1(t10) {
  return "x" === t10 ? "y" : "x";
}
const D$2 = function(e10) {
  return void 0 === e10 && (e10 = {}), { name: "shift", options: e10, async fn(r10) {
    const { x: i10, y: o10, placement: a10 } = r10, { mainAxis: l10 = true, crossAxis: c10 = false, limiter: f10 = { fn: (t10) => {
      let { x: e11, y: n10 } = t10;
      return { x: e11, y: n10 };
    } }, ...m10 } = e10, g10 = { x: i10, y: o10 }, d10 = await s$3(r10, m10), p10 = n$3(t$2(a10)), h10 = O$1(p10);
    let y10 = g10[p10], x10 = g10[h10];
    if (l10) {
      const t10 = "y" === p10 ? "bottom" : "right";
      y10 = u$3(y10 + d10["y" === p10 ? "top" : "left"], y10, y10 - d10[t10]);
    }
    if (c10) {
      const t10 = "y" === h10 ? "bottom" : "right";
      x10 = u$3(x10 + d10["y" === h10 ? "top" : "left"], x10, x10 - d10[t10]);
    }
    const w10 = f10.fn({ ...r10, [p10]: y10, [h10]: x10 });
    return { ...w10, data: { x: w10.x - i10, y: w10.y - o10 } };
  } };
}, L$2 = function(e10) {
  return void 0 === e10 && (e10 = {}), { options: e10, fn(r10) {
    const { x: i10, y: o10, placement: a10, rects: l10, middlewareData: s10 } = r10, { offset: c10 = 0, mainAxis: f10 = true, crossAxis: u10 = true } = e10, m10 = { x: i10, y: o10 }, g10 = n$3(a10), d10 = O$1(g10);
    let p10 = m10[g10], h10 = m10[d10];
    const y10 = "function" == typeof c10 ? c10({ ...l10, placement: a10 }) : c10, x10 = "number" == typeof y10 ? { mainAxis: y10, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...y10 };
    if (f10) {
      const t10 = "y" === g10 ? "height" : "width", e11 = l10.reference[g10] - l10.floating[t10] + x10.mainAxis, n10 = l10.reference[g10] + l10.reference[t10] - x10.mainAxis;
      p10 < e11 ? p10 = e11 : p10 > n10 && (p10 = n10);
    }
    if (u10) {
      var w10, v10, b10, R10;
      const e11 = "y" === g10 ? "width" : "height", n10 = ["top", "left"].includes(t$2(a10)), r11 = l10.reference[d10] - l10.floating[e11] + (n10 && null != (w10 = null == (v10 = s10.offset) ? void 0 : v10[d10]) ? w10 : 0) + (n10 ? 0 : x10.crossAxis), i11 = l10.reference[d10] + l10.reference[e11] + (n10 ? 0 : null != (b10 = null == (R10 = s10.offset) ? void 0 : R10[d10]) ? b10 : 0) - (n10 ? x10.crossAxis : 0);
      h10 < r11 ? h10 = r11 : h10 > i11 && (h10 = i11);
    }
    return { [g10]: p10, [d10]: h10 };
  } };
};
function n$2(t10) {
  return t10 && t10.document && t10.location && t10.alert && t10.setInterval;
}
function o$2(t10) {
  if (null == t10) return window;
  if (!n$2(t10)) {
    const e10 = t10.ownerDocument;
    return e10 && e10.defaultView || window;
  }
  return t10;
}
function i$2(t10) {
  return o$2(t10).getComputedStyle(t10);
}
function r$2(t10) {
  return n$2(t10) ? "" : t10 ? (t10.nodeName || "").toLowerCase() : "";
}
function l$3() {
  const t10 = navigator.userAgentData;
  return null != t10 && t10.brands ? t10.brands.map((t11) => t11.brand + "/" + t11.version).join(" ") : navigator.userAgent;
}
function c$2(t10) {
  return t10 instanceof o$2(t10).HTMLElement;
}
function f$2(t10) {
  return t10 instanceof o$2(t10).Element;
}
function s$2(t10) {
  if ("undefined" == typeof ShadowRoot) return false;
  return t10 instanceof o$2(t10).ShadowRoot || t10 instanceof ShadowRoot;
}
function u$2(t10) {
  const { overflow: e10, overflowX: n10, overflowY: o10 } = i$2(t10);
  return /auto|scroll|overlay|hidden/.test(e10 + o10 + n10);
}
function d$2(t10) {
  return ["table", "td", "th"].includes(r$2(t10));
}
function h$2(t10) {
  const e10 = /firefox/i.test(l$3()), n10 = i$2(t10);
  return "none" !== n10.transform || "none" !== n10.perspective || "paint" === n10.contain || ["transform", "perspective"].includes(n10.willChange) || e10 && "filter" === n10.willChange || e10 && !!n10.filter && "none" !== n10.filter;
}
function a$3() {
  return !/^((?!chrome|android).)*safari/i.test(l$3());
}
const g$1 = Math.min, p$2 = Math.max, m$2 = Math.round;
function w$2(t10, e10, n10) {
  var i10, r10, l10, s10;
  void 0 === e10 && (e10 = false), void 0 === n10 && (n10 = false);
  const u10 = t10.getBoundingClientRect();
  let d10 = 1, h10 = 1;
  e10 && c$2(t10) && (d10 = t10.offsetWidth > 0 && m$2(u10.width) / t10.offsetWidth || 1, h10 = t10.offsetHeight > 0 && m$2(u10.height) / t10.offsetHeight || 1);
  const g10 = f$2(t10) ? o$2(t10) : window, p10 = !a$3() && n10, w10 = (u10.left + (p10 && null != (i10 = null == (r10 = g10.visualViewport) ? void 0 : r10.offsetLeft) ? i10 : 0)) / d10, v10 = (u10.top + (p10 && null != (l10 = null == (s10 = g10.visualViewport) ? void 0 : s10.offsetTop) ? l10 : 0)) / h10, y10 = u10.width / d10, x10 = u10.height / h10;
  return { width: y10, height: x10, top: v10, right: w10 + y10, bottom: v10 + x10, left: w10, x: w10, y: v10 };
}
function v$3(t10) {
  return (e10 = t10, (e10 instanceof o$2(e10).Node ? t10.ownerDocument : t10.document) || window.document).documentElement;
  var e10;
}
function y$2(t10) {
  return f$2(t10) ? { scrollLeft: t10.scrollLeft, scrollTop: t10.scrollTop } : { scrollLeft: t10.pageXOffset, scrollTop: t10.pageYOffset };
}
function x$2(t10) {
  return w$2(v$3(t10)).left + y$2(t10).scrollLeft;
}
function b$2(t10, e10, n10) {
  const o10 = c$2(e10), i10 = v$3(e10), l10 = w$2(t10, o10 && function(t11) {
    const e11 = w$2(t11);
    return m$2(e11.width) !== t11.offsetWidth || m$2(e11.height) !== t11.offsetHeight;
  }(e10), "fixed" === n10);
  let f10 = { scrollLeft: 0, scrollTop: 0 };
  const s10 = { x: 0, y: 0 };
  if (o10 || !o10 && "fixed" !== n10) if (("body" !== r$2(e10) || u$2(i10)) && (f10 = y$2(e10)), c$2(e10)) {
    const t11 = w$2(e10, true);
    s10.x = t11.x + e10.clientLeft, s10.y = t11.y + e10.clientTop;
  } else i10 && (s10.x = x$2(i10));
  return { x: l10.left + f10.scrollLeft - s10.x, y: l10.top + f10.scrollTop - s10.y, width: l10.width, height: l10.height };
}
function L$1(t10) {
  return "html" === r$2(t10) ? t10 : t10.assignedSlot || t10.parentNode || (s$2(t10) ? t10.host : null) || v$3(t10);
}
function R$1(t10) {
  return c$2(t10) && "fixed" !== getComputedStyle(t10).position ? t10.offsetParent : null;
}
function T$1(t10) {
  const e10 = o$2(t10);
  let n10 = R$1(t10);
  for (; n10 && d$2(n10) && "static" === getComputedStyle(n10).position; ) n10 = R$1(n10);
  return n10 && ("html" === r$2(n10) || "body" === r$2(n10) && "static" === getComputedStyle(n10).position && !h$2(n10)) ? e10 : n10 || function(t11) {
    let e11 = L$1(t11);
    for (s$2(e11) && (e11 = e11.host); c$2(e11) && !["html", "body"].includes(r$2(e11)); ) {
      if (h$2(e11)) return e11;
      e11 = e11.parentNode;
    }
    return null;
  }(t10) || e10;
}
function W$1(t10) {
  if (c$2(t10)) return { width: t10.offsetWidth, height: t10.offsetHeight };
  const e10 = w$2(t10);
  return { width: e10.width, height: e10.height };
}
function E$1(t10) {
  const e10 = L$1(t10);
  return ["html", "body", "#document"].includes(r$2(e10)) ? t10.ownerDocument.body : c$2(e10) && u$2(e10) ? e10 : E$1(e10);
}
function H$2(t10, e10) {
  var n10;
  void 0 === e10 && (e10 = []);
  const i10 = E$1(t10), r10 = i10 === (null == (n10 = t10.ownerDocument) ? void 0 : n10.body), l10 = o$2(i10), c10 = r10 ? [l10].concat(l10.visualViewport || [], u$2(i10) ? i10 : []) : i10, f10 = e10.concat(c10);
  return r10 ? f10 : f10.concat(H$2(c10));
}
function C$1(e10, n10, r10) {
  return "viewport" === n10 ? l$4(function(t10, e11) {
    const n11 = o$2(t10), i10 = v$3(t10), r11 = n11.visualViewport;
    let l10 = i10.clientWidth, c10 = i10.clientHeight, f10 = 0, s10 = 0;
    if (r11) {
      l10 = r11.width, c10 = r11.height;
      const t11 = a$3();
      (t11 || !t11 && "fixed" === e11) && (f10 = r11.offsetLeft, s10 = r11.offsetTop);
    }
    return { width: l10, height: c10, x: f10, y: s10 };
  }(e10, r10)) : f$2(n10) ? function(t10, e11) {
    const n11 = w$2(t10, false, "fixed" === e11), o10 = n11.top + t10.clientTop, i10 = n11.left + t10.clientLeft;
    return { top: o10, left: i10, x: i10, y: o10, right: i10 + t10.clientWidth, bottom: o10 + t10.clientHeight, width: t10.clientWidth, height: t10.clientHeight };
  }(n10, r10) : l$4(function(t10) {
    var e11;
    const n11 = v$3(t10), o10 = y$2(t10), r11 = null == (e11 = t10.ownerDocument) ? void 0 : e11.body, l10 = p$2(n11.scrollWidth, n11.clientWidth, r11 ? r11.scrollWidth : 0, r11 ? r11.clientWidth : 0), c10 = p$2(n11.scrollHeight, n11.clientHeight, r11 ? r11.scrollHeight : 0, r11 ? r11.clientHeight : 0);
    let f10 = -o10.scrollLeft + x$2(t10);
    const s10 = -o10.scrollTop;
    return "rtl" === i$2(r11 || n11).direction && (f10 += p$2(n11.clientWidth, r11 ? r11.clientWidth : 0) - l10), { width: l10, height: c10, x: f10, y: s10 };
  }(v$3(e10)));
}
function S$2(t10) {
  const e10 = H$2(t10), n10 = ["absolute", "fixed"].includes(i$2(t10).position) && c$2(t10) ? T$1(t10) : t10;
  return f$2(n10) ? e10.filter((t11) => f$2(t11) && function(t12, e11) {
    const n11 = null == e11.getRootNode ? void 0 : e11.getRootNode();
    if (t12.contains(e11)) return true;
    if (n11 && s$2(n11)) {
      let n12 = e11;
      do {
        if (n12 && t12 === n12) return true;
        n12 = n12.parentNode || n12.host;
      } while (n12);
    }
    return false;
  }(t11, n10) && "body" !== r$2(t11)) : [];
}
const D$1 = { getClippingRect: function(t10) {
  let { element: e10, boundary: n10, rootBoundary: o10, strategy: i10 } = t10;
  const r10 = [..."clippingAncestors" === n10 ? S$2(e10) : [].concat(n10), o10], l10 = r10[0], c10 = r10.reduce((t11, n11) => {
    const o11 = C$1(e10, n11, i10);
    return t11.top = p$2(o11.top, t11.top), t11.right = g$1(o11.right, t11.right), t11.bottom = g$1(o11.bottom, t11.bottom), t11.left = p$2(o11.left, t11.left), t11;
  }, C$1(e10, l10, i10));
  return { width: c10.right - c10.left, height: c10.bottom - c10.top, x: c10.left, y: c10.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t10) {
  let { rect: e10, offsetParent: n10, strategy: o10 } = t10;
  const i10 = c$2(n10), l10 = v$3(n10);
  if (n10 === l10) return e10;
  let f10 = { scrollLeft: 0, scrollTop: 0 };
  const s10 = { x: 0, y: 0 };
  if ((i10 || !i10 && "fixed" !== o10) && (("body" !== r$2(n10) || u$2(l10)) && (f10 = y$2(n10)), c$2(n10))) {
    const t11 = w$2(n10, true);
    s10.x = t11.x + n10.clientLeft, s10.y = t11.y + n10.clientTop;
  }
  return { ...e10, x: e10.x - f10.scrollLeft + s10.x, y: e10.y - f10.scrollTop + s10.y };
}, isElement: f$2, getDimensions: W$1, getOffsetParent: T$1, getDocumentElement: v$3, getElementRects: (t10) => {
  let { reference: e10, floating: n10, strategy: o10 } = t10;
  return { reference: b$2(e10, T$1(n10), o10), floating: { ...W$1(n10), x: 0, y: 0 } };
}, getClientRects: (t10) => Array.from(t10.getClientRects()), isRTL: (t10) => "rtl" === i$2(t10).direction };
function N$1(t10, e10, n10, o10) {
  void 0 === o10 && (o10 = {});
  const { ancestorScroll: i10 = true, ancestorResize: r10 = true, elementResize: l10 = true, animationFrame: c10 = false } = o10, s10 = i10 && !c10, u10 = r10 && !c10, d10 = s10 || u10 ? [...f$2(t10) ? H$2(t10) : [], ...H$2(e10)] : [];
  d10.forEach((t11) => {
    s10 && t11.addEventListener("scroll", n10, { passive: true }), u10 && t11.addEventListener("resize", n10);
  });
  let h10, a10 = null;
  if (l10) {
    let o11 = true;
    a10 = new ResizeObserver(() => {
      o11 || n10(), o11 = false;
    }), f$2(t10) && !c10 && a10.observe(t10), a10.observe(e10);
  }
  let g10 = c10 ? w$2(t10) : null;
  return c10 && function e11() {
    const o11 = w$2(t10);
    !g10 || o11.x === g10.x && o11.y === g10.y && o11.width === g10.width && o11.height === g10.height || n10();
    g10 = o11, h10 = requestAnimationFrame(e11);
  }(), n10(), () => {
    var t11;
    d10.forEach((t12) => {
      s10 && t12.removeEventListener("scroll", n10), u10 && t12.removeEventListener("resize", n10);
    }), null == (t11 = a10) || t11.disconnect(), a10 = null, c10 && cancelAnimationFrame(h10);
  };
}
const z$1 = (t10, n10, o10) => o$3(t10, n10, { platform: D$1, ...o10 });
var index$2 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual$2(a10, b10) {
  if (a10 === b10) {
    return true;
  }
  if (typeof a10 !== typeof b10) {
    return false;
  }
  if (typeof a10 === "function" && a10.toString() === b10.toString()) {
    return true;
  }
  let length, i10, keys;
  if (a10 && b10 && typeof a10 == "object") {
    if (Array.isArray(a10)) {
      length = a10.length;
      if (length != b10.length) return false;
      for (i10 = length; i10-- !== 0; ) {
        if (!deepEqual$2(a10[i10], b10[i10])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a10);
    length = keys.length;
    if (length !== Object.keys(b10).length) {
      return false;
    }
    for (i10 = length; i10-- !== 0; ) {
      if (!Object.prototype.hasOwnProperty.call(b10, keys[i10])) {
        return false;
      }
    }
    for (i10 = length; i10-- !== 0; ) {
      const key = keys[i10];
      if (key === "_owner" && a10.$$typeof) {
        continue;
      }
      if (!deepEqual$2(a10[key], b10[key])) {
        return false;
      }
    }
    return true;
  }
  return a10 !== a10 && b10 !== b10;
}
function useLatestRef$2(value) {
  const ref = reactExports.useRef(value);
  index$2(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$2(_temp) {
  let {
    middleware,
    placement = "bottom",
    strategy = "absolute",
    whileElementsMounted
  } = _temp === void 0 ? {} : _temp;
  const reference = reactExports.useRef(null);
  const floating = reactExports.useRef(null);
  const whileElementsMountedRef = useLatestRef$2(whileElementsMounted);
  const cleanupRef = reactExports.useRef(null);
  const [data, setData] = reactExports.useState({
    // Setting these to `null` will allow the consumer to determine if
    // `computePosition()` has run yet
    x: null,
    y: null,
    strategy,
    placement,
    middlewareData: {}
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual$2(latestMiddleware == null ? void 0 : latestMiddleware.map((_ref) => {
    let {
      options
    } = _ref;
    return options;
  }), middleware == null ? void 0 : middleware.map((_ref2) => {
    let {
      options
    } = _ref2;
    return options;
  }))) {
    setLatestMiddleware(middleware);
  }
  const update = reactExports.useCallback(() => {
    if (!reference.current || !floating.current) {
      return;
    }
    z$1(reference.current, floating.current, {
      middleware: latestMiddleware,
      placement,
      strategy
    }).then((data2) => {
      if (isMountedRef.current) {
        reactDomExports.flushSync(() => {
          setData(data2);
        });
      }
    });
  }, [latestMiddleware, placement, strategy]);
  index$2(() => {
    if (isMountedRef.current) {
      update();
    }
  }, [update]);
  const isMountedRef = reactExports.useRef(false);
  index$2(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  const runElementMountCallback = reactExports.useCallback(() => {
    if (typeof cleanupRef.current === "function") {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (reference.current && floating.current) {
      if (whileElementsMountedRef.current) {
        const cleanupFn = whileElementsMountedRef.current(reference.current, floating.current, update);
        cleanupRef.current = cleanupFn;
      } else {
        update();
      }
    }
  }, [update, whileElementsMountedRef]);
  const setReference = reactExports.useCallback((node) => {
    reference.current = node;
    runElementMountCallback();
  }, [runElementMountCallback]);
  const setFloating = reactExports.useCallback((node) => {
    floating.current = node;
    runElementMountCallback();
  }, [runElementMountCallback]);
  const refs = reactExports.useMemo(() => ({
    reference,
    floating
  }), []);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    reference: setReference,
    floating: setFloating
  }), [data, update, refs, setReference, setFloating]);
}
const arrow$7 = (options) => {
  const {
    element,
    padding
  } = options;
  function isRef(value) {
    return Object.prototype.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(args) {
      if (isRef(element)) {
        if (element.current != null) {
          return m$3({
            element: element.current,
            padding
          }).fn(args);
        }
        return {};
      } else if (element) {
        return m$3({
          element,
          padding
        }).fn(args);
      }
      return {};
    }
  };
};
const $7e8f5cd07187803e$export$21b07c8f274aebd5 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.svg, _extends({}, arrowProps, {
    ref: forwardedRef,
    width,
    height,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none"
  }), props.asChild ? children : /* @__PURE__ */ reactExports.createElement("polygon", {
    points: "0,0 30,0 15,10"
  }));
});
const $7e8f5cd07187803e$export$be92b6f5f03c0fe9 = $7e8f5cd07187803e$export$21b07c8f274aebd5;
function $6ed0406888f73fc4$var$setRef$2(ref, value) {
  if (typeof ref === "function") ref(value);
  else if (ref !== null && ref !== void 0) ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af$2(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef$2(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05$1(...refs) {
  return reactExports.useCallback($6ed0406888f73fc4$export$43e446d32b3d21af$2(...refs), refs);
}
const $9f79659886946c16$export$e5c5a5f917a5871c$3 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
};
const $9f79659886946c16$export$e5c5a5f917a5871c$2 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
};
function $db6c3485150b8e66$export$1ab7ae714698c4b8(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  $9f79659886946c16$export$e5c5a5f917a5871c$2(() => {
    if (element) {
      setSize({
        width: element.offsetWidth,
        height: element.offsetHeight
      });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) return;
        if (!entries.length) return;
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({
          width,
          height
        });
      });
      resizeObserver.observe(element, {
        box: "border-box"
      });
      return () => resizeObserver.unobserve(element);
    } else
      setSize(void 0);
  }, [
    element
  ]);
  return size2;
}
const $cf1ac5d9fe0e8206$var$POPPER_NAME = "Popper";
const [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME);
const [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);
const $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = reactExports.useState(null);
  return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$var$PopperProvider, {
    scope: __scopePopper,
    anchor,
    onAnchorChange: setAnchor
  }, children);
};
const $cf1ac5d9fe0e8206$var$ANCHOR_NAME = "PopperAnchor";
const $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopePopper, virtualRef, ...anchorProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME, __scopePopper);
  const ref = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$1(forwardedRef, ref);
  reactExports.useEffect(() => {
    context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);
  });
  return virtualRef ? null : /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, anchorProps, {
    ref: composedRefs
  }));
});
const $cf1ac5d9fe0e8206$var$CONTENT_NAME = "PopperContent";
const [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);
const [$cf1ac5d9fe0e8206$var$PositionContextProvider, $cf1ac5d9fe0e8206$var$usePositionContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, {
  hasParent: false,
  positionUpdateFns: /* @__PURE__ */ new Set()
});
const $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$hide, _middlewareData$trans, _middlewareData$trans2;
  const { __scopePopper, side = "bottom", sideOffset = 0, align = "center", alignOffset = 0, arrowPadding = 0, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = "partial", hideWhenDetached = false, avoidCollisions = true, ...contentProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
  const [content, setContent] = reactExports.useState(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$1(
    forwardedRef,
    (node) => setContent(node)
  );
  const [arrow2, setArrow] = reactExports.useState(null);
  const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow2);
  const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
  const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
  const desiredPlacement = side + (align !== "center" ? "-" + align : "");
  const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...collisionPaddingProp
  };
  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
    collisionBoundary
  ];
  const hasExplicitBoundaries = boundary.length > 0;
  const detectOverflowOptions = {
    padding: collisionPadding,
    boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),
    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
    altBoundary: hasExplicitBoundaries
  };
  const { reference, floating, strategy, x: x10, y: y10, placement, middlewareData, update } = useFloating$2({
    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
    strategy: "fixed",
    placement: desiredPlacement,
    whileElementsMounted: N$1,
    middleware: [
      T$2({
        mainAxis: sideOffset + arrowHeight,
        alignmentAxis: alignOffset
      }),
      avoidCollisions ? D$2({
        mainAxis: true,
        crossAxis: false,
        limiter: sticky === "partial" ? L$2() : void 0,
        ...detectOverflowOptions
      }) : void 0,
      arrow2 ? arrow$7({
        element: arrow2,
        padding: arrowPadding
      }) : void 0,
      avoidCollisions ? b$3({
        ...detectOverflowOptions
      }) : void 0,
      $cf1ac5d9fe0e8206$var$transformOrigin({
        arrowWidth,
        arrowHeight
      }),
      hideWhenDetached ? P$2({
        strategy: "referenceHidden"
      }) : void 0
    ].filter($cf1ac5d9fe0e8206$var$isDefined)
  });
  $9f79659886946c16$export$e5c5a5f917a5871c$3(() => {
    reference(context.anchor);
  }, [
    reference,
    context.anchor
  ]);
  const isPlaced = x10 !== null && y10 !== null;
  const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
  const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
  const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
  const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
  const [contentZIndex, setContentZIndex] = reactExports.useState();
  $9f79659886946c16$export$e5c5a5f917a5871c$3(() => {
    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [
    content
  ]);
  const { hasParent, positionUpdateFns } = $cf1ac5d9fe0e8206$var$usePositionContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
  const isRoot = !hasParent;
  reactExports.useLayoutEffect(() => {
    if (!isRoot) {
      positionUpdateFns.add(update);
      return () => {
        positionUpdateFns.delete(update);
      };
    }
  }, [
    isRoot,
    positionUpdateFns,
    update
  ]);
  reactExports.useLayoutEffect(() => {
    if (isRoot && isPlaced) Array.from(positionUpdateFns).reverse().forEach(
      (fn2) => requestAnimationFrame(fn2)
    );
  }, [
    isRoot,
    isPlaced,
    positionUpdateFns
  ]);
  const commonProps = {
    "data-side": placedSide,
    "data-align": placedAlign,
    ...contentProps,
    ref: composedRefs,
    style: {
      ...contentProps.style,
      // if the PopperContent hasn't been placed yet (not all measurements done)
      // we prevent animations so that users's animation don't kick in too early referring wrong sides
      animation: !isPlaced ? "none" : void 0,
      // hide the content if using the hide middleware and should be hidden
      opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0
    }
  };
  return /* @__PURE__ */ reactExports.createElement("div", {
    ref: floating,
    "data-radix-popper-content-wrapper": "",
    style: {
      position: strategy,
      left: 0,
      top: 0,
      transform: isPlaced ? `translate3d(${Math.round(x10)}px, ${Math.round(y10)}px, 0)` : "translate3d(0, -200%, 0)",
      // keep off the page when measuring
      minWidth: "max-content",
      zIndex: contentZIndex,
      ["--radix-popper-transform-origin"]: [
        (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
        (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
      ].join(" ")
    }
  }, /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$var$PopperContentProvider, {
    scope: __scopePopper,
    placedSide,
    onArrowChange: setArrow,
    arrowX,
    arrowY,
    shouldHideArrow: cannotCenterArrow
  }, isRoot ? /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$var$PositionContextProvider, {
    scope: __scopePopper,
    hasParent: true,
    positionUpdateFns
  }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, commonProps)) : /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, commonProps)));
});
const $cf1ac5d9fe0e8206$var$ARROW_NAME = "PopperArrow";
const $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
const $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0 = /* @__PURE__ */ reactExports.forwardRef(function $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd02(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = $cf1ac5d9fe0e8206$var$useContentContext($cf1ac5d9fe0e8206$var$ARROW_NAME, __scopePopper);
  const baseSide = $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ reactExports.createElement("span", {
      ref: contentContext.onArrowChange,
      style: {
        position: "absolute",
        left: contentContext.arrowX,
        top: contentContext.arrowY,
        [baseSide]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[contentContext.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: `rotate(180deg)`,
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[contentContext.placedSide],
        visibility: contentContext.shouldHideArrow ? "hidden" : void 0
      }
    }, /* @__PURE__ */ reactExports.createElement($7e8f5cd07187803e$export$be92b6f5f03c0fe9, _extends({}, arrowProps, {
      ref: forwardedRef,
      style: {
        ...arrowProps.style,
        // ensures the element can be measured correctly (mostly for if SVG)
        display: "block"
      }
    })))
  );
});
/* @__PURE__ */ Object.assign($cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0, {
  displayName: $cf1ac5d9fe0e8206$var$ARROW_NAME
});
function $cf1ac5d9fe0e8206$var$isDefined(value) {
  return value !== void 0;
}
function $cf1ac5d9fe0e8206$var$isNotNull(value) {
  return value !== null;
}
const $cf1ac5d9fe0e8206$var$transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
    const noArrowAlign = {
      start: "0%",
      center: "50%",
      end: "100%"
    }[placedAlign];
    const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
    const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
    let x10 = "";
    let y10 = "";
    if (placedSide === "bottom") {
      x10 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y10 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x10 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y10 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x10 = `${-arrowHeight}px`;
      y10 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x10 = `${rects.floating.width + arrowHeight}px`;
      y10 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return {
      data: {
        x: x10,
        y: y10
      }
    };
  }
});
function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [
    side,
    align
  ];
}
const $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9;
const $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d;
const $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;
const $cf1ac5d9fe0e8206$export$21b07c8f274aebd5 = $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0;
const $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  var _globalThis$document;
  const { container = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body, ...portalProps } = props;
  return container ? /* @__PURE__ */ ReactDOM.createPortal(/* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, portalProps, {
    ref: forwardedRef
  })), container) : null;
});
function $fe963b355347cc68$export$3e6543de14f8614f(initialState2, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState !== null && nextState !== void 0 ? nextState : state;
  }, initialState2);
}
const $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {
  const { present, children } = props;
  const presence = $921a889cee6df7e8$var$usePresence(present);
  const child = typeof children === "function" ? children({
    present: presence.isPresent
  }) : reactExports.Children.only(children);
  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$2(presence.ref, child.ref);
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? /* @__PURE__ */ reactExports.cloneElement(child, {
    ref
  }) : null;
};
$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
function $921a889cee6df7e8$var$usePresence(present) {
  const [node1, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef({});
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState2 = present ? "mounted" : "unmounted";
  const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState2, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [
    state
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c$4(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles);
      if (present) send("MOUNT");
      else if (currentAnimationName === "none" || (styles === null || styles === void 0 ? void 0 : styles.display) === "none")
        send("UNMOUNT");
      else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) send("ANIMATION_OUT");
        else send("UNMOUNT");
      }
      prevPresentRef.current = present;
    }
  }, [
    present,
    send
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c$4(() => {
    if (node1) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node1 && isCurrentAnimation)
          reactDomExports.flushSync(
            () => send("ANIMATION_END")
          );
      };
      const handleAnimationStart = (event) => {
        if (event.target === node1)
          prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
      };
      node1.addEventListener("animationstart", handleAnimationStart);
      node1.addEventListener("animationcancel", handleAnimationEnd);
      node1.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node1.removeEventListener("animationstart", handleAnimationStart);
        node1.removeEventListener("animationcancel", handleAnimationEnd);
        node1.removeEventListener("animationend", handleAnimationEnd);
      };
    } else
      send("ANIMATION_END");
  }, [
    node1,
    send
  ]);
  return {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(state),
    ref: reactExports.useCallback((node) => {
      if (node) stylesRef.current = getComputedStyle(node);
      setNode(node);
    }, [])
  };
}
function $921a889cee6df7e8$var$getAnimationName(styles) {
  return (styles === null || styles === void 0 ? void 0 : styles.animationName) || "none";
}
function $6ed0406888f73fc4$var$setRef$1(ref, value) {
  if (typeof ref === "function") ref(value);
  else if (ref !== null && ref !== void 0) ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af$1(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef$1(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
  return reactExports.useCallback($6ed0406888f73fc4$export$43e446d32b3d21af$1(...refs), refs);
}
const $9f79659886946c16$export$e5c5a5f917a5871c$1 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
};
const $1746a345f3d73bb7$var$useReactId$1 = React["useId".toString()] || (() => void 0);
let $1746a345f3d73bb7$var$count$1 = 0;
function $1746a345f3d73bb7$export$f680877a34711e37$1(deterministicId) {
  const [id, setId] = reactExports.useState($1746a345f3d73bb7$var$useReactId$1());
  $9f79659886946c16$export$e5c5a5f917a5871c$1(() => {
    setId(
      (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count$1++)
    );
  }, [
    deterministicId
  ]);
  return id ? `radix-${id}` : "";
}
function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {
} }) {
  const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value1 = isControlled ? prop : uncontrolledProp;
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  const setValue = reactExports.useCallback((nextValue) => {
    if (isControlled) {
      const setter = nextValue;
      const value = typeof nextValue === "function" ? setter(prop) : nextValue;
      if (value !== prop) handleChange(value);
    } else setUncontrolledProp(nextValue);
  }, [
    isControlled,
    prop,
    setUncontrolledProp,
    handleChange
  ]);
  return [
    value1,
    setValue
  ];
}
function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {
  const uncontrolledState = reactExports.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = reactExports.useRef(value);
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [
    value,
    prevValueRef,
    handleChange
  ]);
  return uncontrolledState;
}
const $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
const $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
const $d7bdfb9eb0fdf311$var$GROUP_NAME = "RovingFocusGroup";
const [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($d7bdfb9eb0fdf311$var$GROUP_NAME);
const [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d7bdfb9eb0fdf311$var$GROUP_NAME, [
  $d7bdfb9eb0fdf311$var$createCollectionScope
]);
const [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);
const $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$Collection.Provider, {
    scope: props.__scopeRovingFocusGroup
  }, /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$Collection.Slot, {
    scope: props.__scopeRovingFocusGroup
  }, /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, _extends({}, props, {
    ref: forwardedRef
  }))));
});
const $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeRovingFocusGroup, orientation, loop = false, dir, currentTabStopId: currentTabStopIdProp, defaultCurrentTabStopId, onCurrentTabStopIdChange, onEntryFocus, ...groupProps } = props;
  const ref = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = reactExports.useState(false);
  const handleEntryFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEntryFocus);
  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
    }
  }, [
    handleEntryFocus
  ]);
  return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$RovingFocusProvider, {
    scope: __scopeRovingFocusGroup,
    orientation,
    dir: direction,
    loop,
    currentTabStopId,
    onItemFocus: reactExports.useCallback(
      (tabStopId) => setCurrentTabStopId(tabStopId),
      [
        setCurrentTabStopId
      ]
    ),
    onItemShiftTab: reactExports.useCallback(
      () => setIsTabbingBackOut(true),
      []
    )
  }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    tabIndex: isTabbingBackOut ? -1 : 0,
    "data-orientation": orientation
  }, groupProps, {
    ref: composedRefs,
    style: {
      outline: "none",
      ...props.style
    },
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, () => {
      isClickFocusRef.current = true;
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, (event) => {
      const isKeyboardFocus = !isClickFocusRef.current;
      if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
        const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);
        event.currentTarget.dispatchEvent(entryFocusEvent);
        if (!entryFocusEvent.defaultPrevented) {
          const items = getItems().filter(
            (item) => item.focusable
          );
          const activeItem = items.find(
            (item) => item.active
          );
          const currentItem = items.find(
            (item) => item.id === currentTabStopId
          );
          const candidateItems = [
            activeItem,
            currentItem,
            ...items
          ].filter(Boolean);
          const candidateNodes = candidateItems.map(
            (item) => item.ref.current
          );
          $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);
        }
      }
      isClickFocusRef.current = false;
    }),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onBlur,
      () => setIsTabbingBackOut(false)
    )
  })));
});
const $d7bdfb9eb0fdf311$var$ITEM_NAME = "RovingFocusGroupItem";
const $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeRovingFocusGroup, focusable = true, active = false, ...itemProps } = props;
  const id = $1746a345f3d73bb7$export$f680877a34711e37$1();
  const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);
  const isCurrentTabStop = context.currentTabStopId === id;
  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
  return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {
    scope: __scopeRovingFocusGroup,
    id,
    focusable,
    active
  }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
    tabIndex: isCurrentTabStop ? 0 : -1,
    "data-orientation": context.orientation
  }, itemProps, {
    ref: forwardedRef,
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
      if (!focusable) event.preventDefault();
      else context.onItemFocus(id);
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocus,
      () => context.onItemFocus(id)
    ),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      if (event.key === "Tab" && event.shiftKey) {
        context.onItemShiftTab();
        return;
      }
      if (event.target !== event.currentTarget) return;
      const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);
      if (focusIntent !== void 0) {
        event.preventDefault();
        const items = getItems().filter(
          (item) => item.focusable
        );
        let candidateNodes = items.map(
          (item) => item.ref.current
        );
        if (focusIntent === "last") candidateNodes.reverse();
        else if (focusIntent === "prev" || focusIntent === "next") {
          if (focusIntent === "prev") candidateNodes.reverse();
          const currentIndex = candidateNodes.indexOf(event.currentTarget);
          candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
        }
        setTimeout(
          () => $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)
        );
      }
    })
  })));
});
const $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {
  const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && [
    "ArrowLeft",
    "ArrowRight"
  ].includes(key)) return void 0;
  if (orientation === "horizontal" && [
    "ArrowUp",
    "ArrowDown"
  ].includes(key)) return void 0;
  return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key];
}
function $d7bdfb9eb0fdf311$var$focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function $d7bdfb9eb0fdf311$var$wrapArray(array, startIndex) {
  return array.map(
    (_10, index2) => array[(startIndex + index2) % array.length]
  );
}
const $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;
const $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;
const $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
        return /* @__PURE__ */ reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else return child;
    });
    return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ reactExports.isValidElement(newElement) ? /* @__PURE__ */ reactExports.cloneElement(newElement, void 0, newChildren) : null);
  }
  return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
const $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ reactExports.isValidElement(children)) return /* @__PURE__ */ reactExports.cloneElement(children, {
    ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
    ref: $6ed0406888f73fc4$export$43e446d32b3d21af$3(forwardedRef, children.ref)
  });
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
const $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable(child) {
  return /* @__PURE__ */ reactExports.isValidElement(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) overrideProps[propName] = (...args) => {
      childPropValue === null || childPropValue === void 0 || childPropValue(...args);
      slotPropValue === null || slotPropValue === void 0 || slotPropValue(...args);
    };
    else if (propName === "style") overrideProps[propName] = {
      ...slotPropValue,
      ...childPropValue
    };
    else if (propName === "className") overrideProps[propName] = [
      slotPropValue,
      childPropValue
    ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x10) {
    return Boolean(x10);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e10) {
          console.error("aria-hidden: cannot operate on ", node, e10);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef$5(initialValue, callback) {
  var ref = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef$5(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a10) {
  return a10;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x10) {
          return x10 !== item;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
      }
      buffer = {
        push: function(x10) {
          return cb2(x10);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x10) {
          pendingQueue.push(x10);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$2 = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target, __assign({}, rest));
};
SideCar$2.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$2;
}
var effectCar$1 = createSidecarMedium();
var nothing$1 = function() {
  return;
};
var RemoveScroll$1 = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a2 = reactExports.useState({
    onScrollCapture: nothing$1,
    onWheelCapture: nothing$1,
    onTouchMoveCapture: nothing$1
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b2 = props.as, Container = _b2 === void 0 ? "div" : _b2, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar$1, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll$1.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll$1.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  console.log("FUCK")
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a2) {
    var styles = _a2.styles, dynamic = _a2.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x10) {
  return parseInt(x10 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs2 = window.getComputedStyle(document.body);
  var left = cs2[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top2 = cs2[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs2[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top2), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top2 = _a2.top, right = _a2.right, gap = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top2, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  reactExports.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a2) {
  var noRelative = _a2.noRelative, noImportant = _a2.noImportant, _b2 = _a2.gapMode, gapMode = _b2 === void 0 ? "margin" : _b2;
  useLockAttribute();
  var gap = reactExports.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported$1 = false;
if (typeof window !== "undefined") {
  try {
    var options$1 = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported$1 = true;
        return true;
      }
    });
    window.addEventListener("test", options$1, options$1);
    window.removeEventListener("test", options$1, options$1);
  } catch (err) {
    passiveSupported$1 = false;
  }
}
var nonPassive$1 = passiveSupported$1 ? { passive: false } : false;
var elementCouldBeVScrolled$1 = function(node) {
  var styles = window.getComputedStyle(node);
  return styles.overflowY !== "hidden" && // not-not-scrollable
  !(styles.overflowY === styles.overflowX && styles.overflowY === "visible");
};
var elementCouldBeHScrolled$1 = function(node) {
  var styles = window.getComputedStyle(node);
  return styles.overflowX !== "hidden" && // not-not-scrollable
  !(styles.overflowY === styles.overflowX && styles.overflowX === "visible");
};
var locationCouldBeScrolled$1 = function(axis, node) {
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled$1(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables$1(axis, current), s10 = _a2[1], d10 = _a2[2];
      if (s10 > d10) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables$1 = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables$1 = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled$1 = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled$1(node) : elementCouldBeHScrolled$1(node);
};
var getScrollVariables$1 = function(axis, node) {
  return axis === "v" ? getVScrollVariables$1(node) : getHScrollVariables$1(node);
};
var getDirectionFactor$1 = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll$1 = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor$1(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a2 = getScrollVariables$1(axis, target), position = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled$1(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (availableScroll === 0 || false)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (availableScrollTop === 0 || false)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY$1 = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY$1 = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef$1 = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare$1 = function(x10, y10) {
  return x10[0] === y10[0] && x10[1] === y10[1];
};
var generateStyle$1 = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter$1 = 0;
var lockStack$1 = [];
function RemoveScrollSideCar$1(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id = reactExports.useState(idCounter$1++)[0];
  var Style2 = reactExports.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef$1), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY$1(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled$1(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled$1(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll$1(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack$1.length || lockStack$1[lockStack$1.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY$1(event) : getTouchXY$1(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e10) {
      return e10.name === event.type && e10.target === event.target && deltaCompare$1(e10.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      event.preventDefault();
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef$1).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        event.preventDefault();
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e10) {
        return e10 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY$1(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY$1(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY$1(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack$1.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive$1);
    document.addEventListener("touchmove", shouldPrevent, nonPassive$1);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive$1);
    return function() {
      lockStack$1 = lockStack$1.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive$1);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive$1);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive$1);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle$1(id) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}
const SideCar$1 = exportSidecar(effectCar$1, RemoveScrollSideCar$1);
var ReactRemoveScroll$1 = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll$1, __assign({}, props, { ref, sideCar: SideCar$1 }));
});
ReactRemoveScroll$1.classNames = RemoveScroll$1.classNames;
const $6cc32821e9371a1c$var$SELECTION_KEYS = [
  "Enter",
  " "
];
const $6cc32821e9371a1c$var$FIRST_KEYS = [
  "ArrowDown",
  "PageUp",
  "Home"
];
const $6cc32821e9371a1c$var$LAST_KEYS = [
  "ArrowUp",
  "PageDown",
  "End"
];
const $6cc32821e9371a1c$var$FIRST_LAST_KEYS = [
  ...$6cc32821e9371a1c$var$FIRST_KEYS,
  ...$6cc32821e9371a1c$var$LAST_KEYS
];
const $6cc32821e9371a1c$var$SUB_OPEN_KEYS = {
  ltr: [
    ...$6cc32821e9371a1c$var$SELECTION_KEYS,
    "ArrowRight"
  ],
  rtl: [
    ...$6cc32821e9371a1c$var$SELECTION_KEYS,
    "ArrowLeft"
  ]
};
const $6cc32821e9371a1c$var$SUB_CLOSE_KEYS = {
  ltr: [
    "ArrowLeft"
  ],
  rtl: [
    "ArrowRight"
  ]
};
const $6cc32821e9371a1c$var$MENU_NAME = "Menu";
const [$6cc32821e9371a1c$var$Collection, $6cc32821e9371a1c$var$useCollection, $6cc32821e9371a1c$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($6cc32821e9371a1c$var$MENU_NAME);
const [$6cc32821e9371a1c$var$createMenuContext, $6cc32821e9371a1c$export$4027731b685e72eb] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($6cc32821e9371a1c$var$MENU_NAME, [
  $6cc32821e9371a1c$var$createCollectionScope,
  $cf1ac5d9fe0e8206$export$722aac194ae923,
  $d7bdfb9eb0fdf311$export$c7109489551a4f4
]);
const $6cc32821e9371a1c$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
const $6cc32821e9371a1c$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
const [$6cc32821e9371a1c$var$MenuProvider, $6cc32821e9371a1c$var$useMenuContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);
const [$6cc32821e9371a1c$var$MenuRootProvider, $6cc32821e9371a1c$var$useMenuRootContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);
const $6cc32821e9371a1c$export$d9b273488cd8ce6f = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  const [content, setContent] = reactExports.useState(null);
  const isUsingKeyboardRef = reactExports.useRef(false);
  const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);
  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
  reactExports.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, {
        capture: true,
        once: true
      });
      document.addEventListener("pointermove", handlePointer, {
        capture: true,
        once: true
      });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, {
      capture: true
    });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, {
        capture: true
      });
      document.removeEventListener("pointerdown", handlePointer, {
        capture: true
      });
      document.removeEventListener("pointermove", handlePointer, {
        capture: true
      });
    };
  }, []);
  return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuProvider, {
    scope: __scopeMenu,
    open,
    onOpenChange: handleOpenChange,
    content,
    onContentChange: setContent
  }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuRootProvider, {
    scope: __scopeMenu,
    onClose: reactExports.useCallback(
      () => handleOpenChange(false),
      [
        handleOpenChange
      ]
    ),
    isUsingKeyboardRef,
    dir: direction,
    modal
  }, children)));
};
const $6cc32821e9371a1c$export$9fa5ebd18bee4d43 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...anchorProps } = props;
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({}, popperScope, anchorProps, {
    ref: forwardedRef
  }));
});
const $6cc32821e9371a1c$var$PORTAL_NAME = "MenuPortal";
const [$6cc32821e9371a1c$var$PortalProvider, $6cc32821e9371a1c$var$usePortalContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, {
  forceMount: void 0
});
const $6cc32821e9371a1c$export$793392f970497feb = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, __scopeMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$PortalProvider, {
    scope: __scopeMenu,
    forceMount
  }, /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ reactExports.createElement($f1701beae083dbae$export$602eac185826482c, {
    asChild: true,
    container
  }, children)));
};
const $6cc32821e9371a1c$var$CONTENT_NAME = "MenuContent";
const [$6cc32821e9371a1c$var$MenuContentProvider, $6cc32821e9371a1c$var$useMenuContentContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$CONTENT_NAME);
const $6cc32821e9371a1c$export$479f0f2f71193efe = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$Collection.Provider, {
    scope: props.__scopeMenu
  }, /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$Collection.Slot, {
    scope: props.__scopeMenu
  }, rootContext.modal ? /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuRootContentModal, _extends({}, contentProps, {
    ref: forwardedRef
  })) : /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuRootContentNonModal, _extends({}, contentProps, {
    ref: forwardedRef
  })))));
});
const $6cc32821e9371a1c$var$MenuRootContentModal = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const ref = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$2(forwardedRef, ref);
  reactExports.useEffect(() => {
    const content = ref.current;
    if (content) return hideOthers(content);
  }, []);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuContentImpl, _extends({}, props, {
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: context.open,
    disableOutsideScroll: true,
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocusOutside,
      (event) => event.preventDefault(),
      {
        checkForDefaultPrevented: false
      }
    ),
    onDismiss: () => context.onOpenChange(false)
  }));
});
const $6cc32821e9371a1c$var$MenuRootContentNonModal = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuContentImpl, _extends({}, props, {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    disableOutsideScroll: false,
    onDismiss: () => context.onOpenChange(false)
  }));
});
const $6cc32821e9371a1c$var$MenuContentImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, loop = false, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, disableOutsideScroll, ...contentProps } = props;
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);
  const getItems = $6cc32821e9371a1c$var$useCollection(__scopeMenu);
  const [currentItemId, setCurrentItemId] = reactExports.useState(null);
  const contentRef = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$2(forwardedRef, contentRef, context.onContentChange);
  const timerRef = reactExports.useRef(0);
  const searchRef = reactExports.useRef("");
  const pointerGraceTimerRef = reactExports.useRef(0);
  const pointerGraceIntentRef = reactExports.useRef(null);
  const pointerDirRef = reactExports.useRef("right");
  const lastPointerXRef = reactExports.useRef(0);
  const ScrollLockWrapper = disableOutsideScroll ? ReactRemoveScroll$1 : reactExports.Fragment;
  const scrollLockWrapperProps = disableOutsideScroll ? {
    as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
    allowPinchZoom: true
  } : void 0;
  const handleTypeaheadSearch = (key) => {
    var _items$find, _items$find2;
    const search = searchRef.current + key;
    const items = getItems().filter(
      (item) => !item.disabled
    );
    const currentItem = document.activeElement;
    const currentMatch = (_items$find = items.find(
      (item) => item.ref.current === currentItem
    )) === null || _items$find === void 0 ? void 0 : _items$find.textValue;
    const values = items.map(
      (item) => item.textValue
    );
    const nextMatch = $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch);
    const newItem = (_items$find2 = items.find(
      (item) => item.textValue === nextMatch
    )) === null || _items$find2 === void 0 ? void 0 : _items$find2.ref.current;
    (function updateSearch(value) {
      searchRef.current = value;
      window.clearTimeout(timerRef.current);
      if (value !== "") timerRef.current = window.setTimeout(
        () => updateSearch(""),
        1e3
      );
    })(search);
    if (newItem)
      setTimeout(
        () => newItem.focus()
      );
  };
  reactExports.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
  const isPointerMovingToSubmenu = reactExports.useCallback((event) => {
    var _pointerGraceIntentRe, _pointerGraceIntentRe2;
    const isMovingTowards = pointerDirRef.current === ((_pointerGraceIntentRe = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe === void 0 ? void 0 : _pointerGraceIntentRe.side);
    return isMovingTowards && $6cc32821e9371a1c$var$isPointerInGraceArea(event, (_pointerGraceIntentRe2 = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe2 === void 0 ? void 0 : _pointerGraceIntentRe2.area);
  }, []);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuContentProvider, {
    scope: __scopeMenu,
    searchRef,
    onItemEnter: reactExports.useCallback((event) => {
      if (isPointerMovingToSubmenu(event)) event.preventDefault();
    }, [
      isPointerMovingToSubmenu
    ]),
    onItemLeave: reactExports.useCallback((event) => {
      var _contentRef$current;
      if (isPointerMovingToSubmenu(event)) return;
      (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.focus();
      setCurrentItemId(null);
    }, [
      isPointerMovingToSubmenu
    ]),
    onTriggerLeave: reactExports.useCallback((event) => {
      if (isPointerMovingToSubmenu(event)) event.preventDefault();
    }, [
      isPointerMovingToSubmenu
    ]),
    pointerGraceTimerRef,
    onPointerGraceIntentChange: reactExports.useCallback((intent) => {
      pointerGraceIntentRef.current = intent;
    }, [])
  }, /* @__PURE__ */ reactExports.createElement(ScrollLockWrapper, scrollLockWrapperProps, /* @__PURE__ */ reactExports.createElement($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: true,
    trapped: trapFocus,
    onMountAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onOpenAutoFocus, (event) => {
      var _contentRef$current2;
      event.preventDefault();
      (_contentRef$current2 = contentRef.current) === null || _contentRef$current2 === void 0 || _contentRef$current2.focus();
    }),
    onUnmountAutoFocus: onCloseAutoFocus
  }, /* @__PURE__ */ reactExports.createElement($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    onDismiss
  }, /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends({
    asChild: true
  }, rovingFocusGroupScope, {
    dir: rootContext.dir,
    orientation: "vertical",
    loop,
    currentTabStopId: currentItemId,
    onCurrentTabStopIdChange: setCurrentItemId,
    onEntryFocus: (event) => {
      if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
    }
  }), /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
    role: "menu",
    "aria-orientation": "vertical",
    "data-state": $6cc32821e9371a1c$var$getOpenState(context.open),
    dir: rootContext.dir
  }, popperScope, contentProps, {
    ref: composedRefs,
    style: {
      outline: "none",
      ...contentProps.style
    },
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onKeyDown, (event) => {
      const target = event.target;
      const isKeyDownInside = target.closest('[role="menu"]') === event.currentTarget;
      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
      const isCharacterKey = event.key.length === 1;
      if (isKeyDownInside) {
        if (event.key === "Tab") event.preventDefault();
        if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
      }
      const content = contentRef.current;
      if (event.target !== content) return;
      if (!$6cc32821e9371a1c$var$FIRST_LAST_KEYS.includes(event.key)) return;
      event.preventDefault();
      const items = getItems().filter(
        (item) => !item.disabled
      );
      const candidateNodes = items.map(
        (item) => item.ref.current
      );
      if ($6cc32821e9371a1c$var$LAST_KEYS.includes(event.key)) candidateNodes.reverse();
      $6cc32821e9371a1c$var$focusFirst(candidateNodes);
    }),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, (event) => {
      if (!event.currentTarget.contains(event.target)) {
        window.clearTimeout(timerRef.current);
        searchRef.current = "";
      }
    }),
    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
      const target = event.target;
      const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
      if (event.currentTarget.contains(target) && pointerXHasChanged) {
        const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
        pointerDirRef.current = newDir;
        lastPointerXRef.current = event.clientX;
      }
    }))
  })))))));
});
const $6cc32821e9371a1c$export$22a631d1f72787bb = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...groupProps } = props;
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    role: "group"
  }, groupProps, {
    ref: forwardedRef
  }));
});
const $6cc32821e9371a1c$var$ITEM_NAME = "MenuItem";
const $6cc32821e9371a1c$var$ITEM_SELECT = "menu.itemSelect";
const $6cc32821e9371a1c$export$2ce376c2cc3355c8 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { disabled = false, onSelect, ...itemProps } = props;
  const ref = reactExports.useRef(null);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);
  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$2(forwardedRef, ref);
  const isPointerDownRef = reactExports.useRef(false);
  const handleSelect = () => {
    const menuItem = ref.current;
    if (!disabled && menuItem) {
      const itemSelectEvent = new CustomEvent($6cc32821e9371a1c$var$ITEM_SELECT, {
        bubbles: true,
        cancelable: true
      });
      menuItem.addEventListener(
        $6cc32821e9371a1c$var$ITEM_SELECT,
        (event) => onSelect === null || onSelect === void 0 ? void 0 : onSelect(event),
        {
          once: true
        }
      );
      $8927f6f2acc4f386$export$6d1a0317bde7de7f(menuItem, itemSelectEvent);
      if (itemSelectEvent.defaultPrevented) isPointerDownRef.current = false;
      else rootContext.onClose();
    }
  };
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuItemImpl, _extends({}, itemProps, {
    ref: composedRefs,
    disabled,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, handleSelect),
    onPointerDown: (event) => {
      var _props$onPointerDown;
      (_props$onPointerDown = props.onPointerDown) === null || _props$onPointerDown === void 0 || _props$onPointerDown.call(props, event);
      isPointerDownRef.current = true;
    },
    onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event) => {
      var _event$currentTarget;
      if (!isPointerDownRef.current) (_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || _event$currentTarget.click();
    }),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      const isTypingAhead = contentContext.searchRef.current !== "";
      if (disabled || isTypingAhead && event.key === " ") return;
      if ($6cc32821e9371a1c$var$SELECTION_KEYS.includes(event.key)) {
        event.currentTarget.click();
        event.preventDefault();
      }
    })
  }));
});
const $6cc32821e9371a1c$var$MenuItemImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, __scopeMenu);
  const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);
  const ref = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$2(forwardedRef, ref);
  const [isFocused, setIsFocused] = reactExports.useState(false);
  const [textContent, setTextContent] = reactExports.useState("");
  reactExports.useEffect(() => {
    const menuItem = ref.current;
    if (menuItem) {
      var _menuItem$textContent;
      setTextContent(((_menuItem$textContent = menuItem.textContent) !== null && _menuItem$textContent !== void 0 ? _menuItem$textContent : "").trim());
    }
  }, [
    itemProps.children
  ]);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$Collection.ItemSlot, {
    scope: __scopeMenu,
    disabled,
    textValue: textValue !== null && textValue !== void 0 ? textValue : textContent
  }, /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends({
    asChild: true
  }, rovingFocusGroupScope, {
    focusable: !disabled
  }), /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    role: "menuitem",
    "data-highlighted": isFocused ? "" : void 0,
    "aria-disabled": disabled || void 0,
    "data-disabled": disabled ? "" : void 0
  }, itemProps, {
    ref: composedRefs,
    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
      if (disabled) contentContext.onItemLeave(event);
      else {
        contentContext.onItemEnter(event);
        if (!event.defaultPrevented) {
          const item = event.currentTarget;
          item.focus();
        }
      }
    })),
    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse(
      (event) => contentContext.onItemLeave(event)
    )),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocus,
      () => setIsFocused(true)
    ),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onBlur,
      () => setIsFocused(false)
    )
  }))));
});
const $6cc32821e9371a1c$export$f6f243521332502d = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$ItemIndicatorProvider, {
    scope: props.__scopeMenu,
    checked
  }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$2ce376c2cc3355c8, _extends({
    role: "menuitemcheckbox",
    "aria-checked": checked
  }, checkboxItemProps, {
    ref: forwardedRef,
    "data-state": $6cc32821e9371a1c$var$getCheckedState(checked),
    onSelect: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      checkboxItemProps.onSelect,
      () => onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange(!checked),
      {
        checkForDefaultPrevented: false
      }
    )
  })));
});
const $6cc32821e9371a1c$var$RADIO_GROUP_NAME = "MenuRadioGroup";
const [$6cc32821e9371a1c$var$RadioGroupProvider, $6cc32821e9371a1c$var$useRadioGroupContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$RADIO_GROUP_NAME, {
  value: void 0,
  onValueChange: () => {
  }
});
const $6cc32821e9371a1c$export$ea2200c9eee416b3 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { value, onValueChange, ...groupProps } = props;
  const handleValueChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onValueChange);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$RadioGroupProvider, {
    scope: props.__scopeMenu,
    value,
    onValueChange: handleValueChange
  }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$22a631d1f72787bb, _extends({}, groupProps, {
    ref: forwardedRef
  })));
});
const $6cc32821e9371a1c$var$RADIO_ITEM_NAME = "MenuRadioItem";
const $6cc32821e9371a1c$export$69bd225e9817f6d0 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { value, ...radioItemProps } = props;
  const context = $6cc32821e9371a1c$var$useRadioGroupContext($6cc32821e9371a1c$var$RADIO_ITEM_NAME, props.__scopeMenu);
  const checked = value === context.value;
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$ItemIndicatorProvider, {
    scope: props.__scopeMenu,
    checked
  }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$2ce376c2cc3355c8, _extends({
    role: "menuitemradio",
    "aria-checked": checked
  }, radioItemProps, {
    ref: forwardedRef,
    "data-state": $6cc32821e9371a1c$var$getCheckedState(checked),
    onSelect: $e42e1063c40fb3ef$export$b9ecd428b558ff10(radioItemProps.onSelect, () => {
      var _context$onValueChang;
      return (_context$onValueChang = context.onValueChange) === null || _context$onValueChang === void 0 ? void 0 : _context$onValueChang.call(context, value);
    }, {
      checkForDefaultPrevented: false
    })
  })));
});
const $6cc32821e9371a1c$var$ITEM_INDICATOR_NAME = "MenuItemIndicator";
const [$6cc32821e9371a1c$var$ItemIndicatorProvider, $6cc32821e9371a1c$var$useItemIndicatorContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, {
  checked: false
});
const $6cc32821e9371a1c$export$a2593e23056970a3 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
  const indicatorContext = $6cc32821e9371a1c$var$useItemIndicatorContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, __scopeMenu);
  return /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || indicatorContext.checked
  }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, itemIndicatorProps, {
    ref: forwardedRef,
    "data-state": $6cc32821e9371a1c$var$getCheckedState(indicatorContext.checked)
  })));
});
const $6cc32821e9371a1c$export$1cec7dcdd713e220 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...separatorProps } = props;
  return /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    role: "separator",
    "aria-orientation": "horizontal"
  }, separatorProps, {
    ref: forwardedRef
  }));
});
const $6cc32821e9371a1c$export$bcdda4773debf5fa = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeMenu, ...arrowProps } = props;
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {
    ref: forwardedRef
  }));
});
const $6cc32821e9371a1c$var$SUB_NAME = "MenuSub";
const [$6cc32821e9371a1c$var$MenuSubProvider, $6cc32821e9371a1c$var$useMenuSubContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$SUB_NAME);
const $6cc32821e9371a1c$export$71bdb9d1e2909932 = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$SUB_NAME, __scopeMenu);
  const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
  const [trigger2, setTrigger] = reactExports.useState(null);
  const [content, setContent] = reactExports.useState(null);
  const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);
  reactExports.useEffect(() => {
    if (parentMenuContext.open === false) handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [
    parentMenuContext.open,
    handleOpenChange
  ]);
  return /* @__PURE__ */ reactExports.createElement($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuProvider, {
    scope: __scopeMenu,
    open,
    onOpenChange: handleOpenChange,
    content,
    onContentChange: setContent
  }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuSubProvider, {
    scope: __scopeMenu,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37$2(),
    triggerId: $1746a345f3d73bb7$export$f680877a34711e37$2(),
    trigger: trigger2,
    onTriggerChange: setTrigger
  }, children)));
};
const $6cc32821e9371a1c$var$SUB_TRIGGER_NAME = "MenuSubTrigger";
const $6cc32821e9371a1c$export$5fbbb3ba7297405f = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
  const subContext = $6cc32821e9371a1c$var$useMenuSubContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
  const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
  const openTimerRef = reactExports.useRef(null);
  const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
  const scope = {
    __scopeMenu: props.__scopeMenu
  };
  const clearOpenTimer = reactExports.useCallback(() => {
    if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
    openTimerRef.current = null;
  }, []);
  reactExports.useEffect(
    () => clearOpenTimer,
    [
      clearOpenTimer
    ]
  );
  reactExports.useEffect(() => {
    const pointerGraceTimer = pointerGraceTimerRef.current;
    return () => {
      window.clearTimeout(pointerGraceTimer);
      onPointerGraceIntentChange(null);
    };
  }, [
    pointerGraceTimerRef,
    onPointerGraceIntentChange
  ]);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$9fa5ebd18bee4d43, _extends({
    asChild: true
  }, scope), /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuItemImpl, _extends({
    id: subContext.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": context.open,
    "aria-controls": subContext.contentId,
    "data-state": $6cc32821e9371a1c$var$getOpenState(context.open)
  }, props, {
    ref: $6ed0406888f73fc4$export$43e446d32b3d21af$3(forwardedRef, subContext.onTriggerChange),
    onClick: (event) => {
      var _props$onClick;
      (_props$onClick = props.onClick) === null || _props$onClick === void 0 || _props$onClick.call(props, event);
      if (props.disabled || event.defaultPrevented) return;
      event.currentTarget.focus();
      if (!context.open) context.onOpenChange(true);
    },
    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
      contentContext.onItemEnter(event);
      if (event.defaultPrevented) return;
      if (!props.disabled && !context.open && !openTimerRef.current) {
        contentContext.onPointerGraceIntentChange(null);
        openTimerRef.current = window.setTimeout(() => {
          context.onOpenChange(true);
          clearOpenTimer();
        }, 100);
      }
    })),
    onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse((event) => {
      var _context$content;
      clearOpenTimer();
      const contentRect = (_context$content = context.content) === null || _context$content === void 0 ? void 0 : _context$content.getBoundingClientRect();
      if (contentRect) {
        var _context$content2;
        const side = (_context$content2 = context.content) === null || _context$content2 === void 0 ? void 0 : _context$content2.dataset.side;
        const rightSide = side === "right";
        const bleed = rightSide ? -5 : 5;
        const contentNearEdge = contentRect[rightSide ? "left" : "right"];
        const contentFarEdge = contentRect[rightSide ? "right" : "left"];
        contentContext.onPointerGraceIntentChange({
          area: [
            // consistently within polygon bounds
            {
              x: event.clientX + bleed,
              y: event.clientY
            },
            {
              x: contentNearEdge,
              y: contentRect.top
            },
            {
              x: contentFarEdge,
              y: contentRect.top
            },
            {
              x: contentFarEdge,
              y: contentRect.bottom
            },
            {
              x: contentNearEdge,
              y: contentRect.bottom
            }
          ],
          side
        });
        window.clearTimeout(pointerGraceTimerRef.current);
        pointerGraceTimerRef.current = window.setTimeout(
          () => contentContext.onPointerGraceIntentChange(null),
          300
        );
      } else {
        contentContext.onTriggerLeave(event);
        if (event.defaultPrevented) return;
        contentContext.onPointerGraceIntentChange(null);
      }
    })),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      const isTypingAhead = contentContext.searchRef.current !== "";
      if (props.disabled || isTypingAhead && event.key === " ") return;
      if ($6cc32821e9371a1c$var$SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
        var _context$content3;
        context.onOpenChange(true);
        (_context$content3 = context.content) === null || _context$content3 === void 0 || _context$content3.focus();
        event.preventDefault();
      }
    })
  })));
});
const $6cc32821e9371a1c$var$SUB_CONTENT_NAME = "MenuSubContent";
const $6cc32821e9371a1c$export$e7142ab31822bde6 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const { forceMount = portalContext.forceMount, ...subContentProps } = props;
  const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
  const subContext = $6cc32821e9371a1c$var$useMenuSubContext($6cc32821e9371a1c$var$SUB_CONTENT_NAME, props.__scopeMenu);
  const ref = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$2(forwardedRef, ref);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$Collection.Provider, {
    scope: props.__scopeMenu
  }, /* @__PURE__ */ reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$Collection.Slot, {
    scope: props.__scopeMenu
  }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$var$MenuContentImpl, _extends({
    id: subContext.contentId,
    "aria-labelledby": subContext.triggerId
  }, subContentProps, {
    ref: composedRefs,
    align: "start",
    side: rootContext.dir === "rtl" ? "left" : "right",
    disableOutsidePointerEvents: false,
    disableOutsideScroll: false,
    trapFocus: false,
    onOpenAutoFocus: (event) => {
      var _ref$current;
      if (rootContext.isUsingKeyboardRef.current) (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.focus();
      event.preventDefault();
    },
    onCloseAutoFocus: (event) => event.preventDefault(),
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusOutside, (event) => {
      if (event.target !== subContext.trigger) context.onOpenChange(false);
    }),
    onEscapeKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onEscapeKeyDown, rootContext.onClose),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      const isKeyDownInside = event.currentTarget.contains(event.target);
      const isCloseKey = $6cc32821e9371a1c$var$SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
      if (isKeyDownInside && isCloseKey) {
        var _subContext$trigger;
        context.onOpenChange(false);
        (_subContext$trigger = subContext.trigger) === null || _subContext$trigger === void 0 || _subContext$trigger.focus();
        event.preventDefault();
      }
    })
  })))));
});
function $6cc32821e9371a1c$var$getOpenState(open) {
  return open ? "open" : "closed";
}
function $6cc32821e9371a1c$var$getCheckedState(checked) {
  return checked ? "checked" : "unchecked";
}
function $6cc32821e9371a1c$var$focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function $6cc32821e9371a1c$var$wrapArray(array, startIndex) {
  return array.map(
    (_10, index2) => array[(startIndex + index2) % array.length]
  );
}
function $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every(
    (char) => char === search[0]
  );
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = $6cc32821e9371a1c$var$wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter(
    (v10) => v10 !== currentMatch
  );
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function $6cc32821e9371a1c$var$isPointInPolygon(point, polygon) {
  const { x: x10, y: y10 } = point;
  let inside = false;
  for (let i10 = 0, j10 = polygon.length - 1; i10 < polygon.length; j10 = i10++) {
    const xi2 = polygon[i10].x;
    const yi2 = polygon[i10].y;
    const xj2 = polygon[j10].x;
    const yj2 = polygon[j10].y;
    const intersect = yi2 > y10 !== yj2 > y10 && x10 < (xj2 - xi2) * (y10 - yi2) / (yj2 - yi2) + xi2;
    if (intersect) inside = !inside;
  }
  return inside;
}
function $6cc32821e9371a1c$var$isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = {
    x: event.clientX,
    y: event.clientY
  };
  return $6cc32821e9371a1c$var$isPointInPolygon(cursorPos, area);
}
function $6cc32821e9371a1c$var$whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
const $6cc32821e9371a1c$export$be92b6f5f03c0fe9 = $6cc32821e9371a1c$export$d9b273488cd8ce6f;
const $6cc32821e9371a1c$export$b688253958b8dfe7 = $6cc32821e9371a1c$export$9fa5ebd18bee4d43;
const $6cc32821e9371a1c$export$602eac185826482c = $6cc32821e9371a1c$export$793392f970497feb;
const $6cc32821e9371a1c$export$7c6e2c02157bb7d2 = $6cc32821e9371a1c$export$479f0f2f71193efe;
const $6cc32821e9371a1c$export$6d08773d2e66f8f2 = $6cc32821e9371a1c$export$2ce376c2cc3355c8;
const $6cc32821e9371a1c$export$16ce288f89fa631c = $6cc32821e9371a1c$export$f6f243521332502d;
const $6cc32821e9371a1c$export$a98f0dcb43a68a25 = $6cc32821e9371a1c$export$ea2200c9eee416b3;
const $6cc32821e9371a1c$export$371ab307eab489c0 = $6cc32821e9371a1c$export$69bd225e9817f6d0;
const $6cc32821e9371a1c$export$c3468e2714d175fa = $6cc32821e9371a1c$export$a2593e23056970a3;
const $6cc32821e9371a1c$export$1ff3c3f08ae963c0 = $6cc32821e9371a1c$export$1cec7dcdd713e220;
const $6cc32821e9371a1c$export$21b07c8f274aebd5 = $6cc32821e9371a1c$export$bcdda4773debf5fa;
const $6cc32821e9371a1c$export$d7a01e11500dfb6f = $6cc32821e9371a1c$export$71bdb9d1e2909932;
const $6cc32821e9371a1c$export$2ea8a7a591ac5eac = $6cc32821e9371a1c$export$5fbbb3ba7297405f;
const $6cc32821e9371a1c$export$6d4de93b380beddf = $6cc32821e9371a1c$export$e7142ab31822bde6;
const $1b0217ee4a91d156$var$CONTEXT_MENU_NAME = "ContextMenu";
const [$1b0217ee4a91d156$var$createContextMenuContext, $1b0217ee4a91d156$export$1059331f43ddcc82] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($1b0217ee4a91d156$var$CONTEXT_MENU_NAME, [
  $6cc32821e9371a1c$export$4027731b685e72eb
]);
const $1b0217ee4a91d156$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb();
const [$1b0217ee4a91d156$var$ContextMenuProvider, $1b0217ee4a91d156$var$useContextMenuContext] = $1b0217ee4a91d156$var$createContextMenuContext($1b0217ee4a91d156$var$CONTEXT_MENU_NAME);
const $1b0217ee4a91d156$export$8dc6765e8be191c7 = (props) => {
  const { __scopeContextMenu, children, onOpenChange, dir, modal = true } = props;
  const [open1, setOpen] = reactExports.useState(false);
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  const handleOpenChangeProp = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);
  const handleOpenChange = reactExports.useCallback((open) => {
    setOpen(open);
    handleOpenChangeProp(open);
  }, [
    handleOpenChangeProp
  ]);
  return /* @__PURE__ */ reactExports.createElement($1b0217ee4a91d156$var$ContextMenuProvider, {
    scope: __scopeContextMenu,
    open: open1,
    onOpenChange: handleOpenChange,
    modal
  }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$be92b6f5f03c0fe9, _extends({}, menuScope, {
    dir,
    open: open1,
    onOpenChange: handleOpenChange,
    modal
  }), children));
};
const $1b0217ee4a91d156$var$TRIGGER_NAME = "ContextMenuTrigger";
const $1b0217ee4a91d156$export$be6fc7b1d5b0beb9 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...triggerProps } = props;
  const context = $1b0217ee4a91d156$var$useContextMenuContext($1b0217ee4a91d156$var$TRIGGER_NAME, __scopeContextMenu);
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  const pointRef = reactExports.useRef({
    x: 0,
    y: 0
  });
  const virtualRef = reactExports.useRef({
    getBoundingClientRect: () => DOMRect.fromRect({
      width: 0,
      height: 0,
      ...pointRef.current
    })
  });
  const longPressTimerRef = reactExports.useRef(0);
  const clearLongPress = reactExports.useCallback(
    () => window.clearTimeout(longPressTimerRef.current),
    []
  );
  const handleOpen = (event) => {
    pointRef.current = {
      x: event.clientX,
      y: event.clientY
    };
    context.onOpenChange(true);
  };
  reactExports.useEffect(
    () => clearLongPress,
    [
      clearLongPress
    ]
  );
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$b688253958b8dfe7, _extends({}, menuScope, {
    virtualRef
  })), /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
    "data-state": context.open ? "open" : "closed"
  }, triggerProps, {
    ref: forwardedRef,
    style: {
      WebkitTouchCallout: "none",
      ...props.style
    },
    onContextMenu: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onContextMenu, (event) => {
      clearLongPress();
      handleOpen(event);
      event.preventDefault();
    }),
    onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, $1b0217ee4a91d156$var$whenTouchOrPen((event) => {
      clearLongPress();
      longPressTimerRef.current = window.setTimeout(
        () => handleOpen(event),
        700
      );
    })),
    onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress)),
    onPointerCancel: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerCancel, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress)),
    onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress))
  })));
});
const $1b0217ee4a91d156$export$14afd0be83e45060 = (props) => {
  const { __scopeContextMenu, ...portalProps } = props;
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$602eac185826482c, _extends({}, menuScope, portalProps));
};
const $1b0217ee4a91d156$var$CONTENT_NAME = "ContextMenuContent";
const $1b0217ee4a91d156$export$572205900c9369e = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...contentProps } = props;
  const context = $1b0217ee4a91d156$var$useContextMenuContext($1b0217ee4a91d156$var$CONTENT_NAME, __scopeContextMenu);
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  const hasInteractedOutsideRef = reactExports.useRef(false);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$7c6e2c02157bb7d2, _extends({}, menuScope, contentProps, {
    ref: forwardedRef,
    side: "right",
    sideOffset: 2,
    align: "start",
    onCloseAutoFocus: (event) => {
      var _props$onCloseAutoFoc;
      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
      if (!event.defaultPrevented && hasInteractedOutsideRef.current) event.preventDefault();
      hasInteractedOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      var _props$onInteractOuts;
      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
      if (!event.defaultPrevented && !context.modal) hasInteractedOutsideRef.current = true;
    },
    style: {
      ...props.style,
      // re-namespace exposed content custom property
      ["--radix-context-menu-content-transform-origin"]: "var(--radix-popper-transform-origin)"
    }
  }));
});
const $1b0217ee4a91d156$export$16a26dc176a49100 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...itemProps } = props;
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$6d08773d2e66f8f2, _extends({}, menuScope, itemProps, {
    ref: forwardedRef
  }));
});
const $1b0217ee4a91d156$export$f47d0a58228a61e2 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...arrowProps } = props;
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$21b07c8f274aebd5, _extends({}, menuScope, arrowProps, {
    ref: forwardedRef
  }));
});
const $1b0217ee4a91d156$export$5bc21d1c00c4b201 = (props) => {
  const { __scopeContextMenu, children, onOpenChange, open: openProp, defaultOpen } = props;
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  const [open, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$d7a01e11500dfb6f, _extends({}, menuScope, {
    open,
    onOpenChange: setOpen
  }), children);
};
const $1b0217ee4a91d156$export$30b2b5c64556d316 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...triggerItemProps } = props;
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$2ea8a7a591ac5eac, _extends({}, menuScope, triggerItemProps, {
    ref: forwardedRef
  }));
});
const $1b0217ee4a91d156$export$2c967063bd2dc512 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...subContentProps } = props;
  const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$6d4de93b380beddf, _extends({}, menuScope, subContentProps, {
    ref: forwardedRef,
    style: {
      ...props.style,
      // re-namespace exposed content custom property
      ["--radix-context-menu-content-transform-origin"]: "var(--radix-popper-transform-origin)"
    }
  }));
});
function $1b0217ee4a91d156$var$whenTouchOrPen(handler) {
  return (event) => event.pointerType !== "mouse" ? handler(event) : void 0;
}
const $1b0217ee4a91d156$export$be92b6f5f03c0fe9 = $1b0217ee4a91d156$export$8dc6765e8be191c7;
const $1b0217ee4a91d156$export$41fb9f06171c75f4 = $1b0217ee4a91d156$export$be6fc7b1d5b0beb9;
const $1b0217ee4a91d156$export$602eac185826482c = $1b0217ee4a91d156$export$14afd0be83e45060;
const $1b0217ee4a91d156$export$7c6e2c02157bb7d2 = $1b0217ee4a91d156$export$572205900c9369e;
const $1b0217ee4a91d156$export$d7a01e11500dfb6f = $1b0217ee4a91d156$export$5bc21d1c00c4b201;
const $1b0217ee4a91d156$export$2ea8a7a591ac5eac = $1b0217ee4a91d156$export$30b2b5c64556d316;
const $1b0217ee4a91d156$export$6d4de93b380beddf = $1b0217ee4a91d156$export$2c967063bd2dc512;
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i10;
  for (i10 = 0; i10 < sourceKeys.length; i10++) {
    key = sourceKeys[i10];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded$3 = ["color"];
var AlignBottomIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$3);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M9 3C9 2.44772 8.55229 2 8 2H7C6.44772 2 6 2.44772 6 3L6 14H1.5C1.22386 14 1 14.2239 1 14.5C1 14.7761 1.22386 15 1.5 15L6 15H9H13.5C13.7761 15 14 14.7761 14 14.5C14 14.2239 13.7761 14 13.5 14H9V3Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4 = ["color"];
var AlignCenterHorizontallyIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$4);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M1.99988 6C1.44759 6 0.999877 6.44772 0.999877 7L0.999877 8C0.999877 8.55228 1.44759 9 1.99988 9L6.99988 9L6.99988 13.5C6.99988 13.7761 7.22374 14 7.49988 14C7.77602 14 7.99988 13.7761 7.99988 13.5L7.99988 9L12.9999 9C13.5522 9 13.9999 8.55228 13.9999 8L13.9999 7C13.9999 6.44772 13.5522 6 12.9999 6L7.99988 6L7.99988 1.5C7.99988 1.22386 7.77602 1 7.49988 1C7.22373 1 6.99988 1.22386 6.99988 1.5L6.99988 6L1.99988 6Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$5 = ["color"];
var AlignCenterVerticallyIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$5);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M6.99988 1C6.44759 1 5.99988 1.44772 5.99988 2V7H1.49988C1.22374 7 0.999878 7.22386 0.999878 7.5C0.999878 7.77614 1.22374 8 1.49988 8H5.99988V13C5.99988 13.5523 6.44759 14 6.99988 14H7.99988C8.55216 14 8.99988 13.5523 8.99988 13V8H13.4999C13.776 8 13.9999 7.77614 13.9999 7.5C13.9999 7.22386 13.776 7 13.4999 7H8.99988V2C8.99988 1.44772 8.55216 1 7.99988 1L6.99988 1Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$6 = ["color"];
var AlignLeftIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$6);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M0.499995 0.999995C0.223855 0.999995 -5.58458e-07 1.22385 -5.46388e-07 1.49999L-2.18554e-08 13.4999C-9.78492e-09 13.776 0.223855 13.9999 0.499995 13.9999C0.776136 13.9999 0.999991 13.776 0.999991 13.4999L0.999991 8.99993L12 8.99993C12.5523 8.99993 13 8.55222 13 7.99993L13 6.99994C13 6.44766 12.5523 5.99995 12 5.99995L0.999991 5.99995L0.999991 1.49999C0.999991 1.22385 0.776135 0.999995 0.499995 0.999995Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$7 = ["color"];
var AlignRightIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$7);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M14.4999 1C14.2237 1 13.9999 1.22386 13.9999 1.5L13.9999 6L2.99988 6C2.44759 6 1.99988 6.44772 1.99988 7L1.99988 8C1.99988 8.55228 2.44759 9 2.99988 9L13.9999 9L13.9999 13.5C13.9999 13.7761 14.2237 14 14.4999 14C14.776 14 14.9999 13.7761 14.9999 13.5L14.9999 9L14.9999 6L14.9999 1.5C14.9999 1.22386 14.776 1 14.4999 1Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$8 = ["color"];
var AlignTopIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$8);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M1.5 0C1.22386 0 1 0.223858 1 0.5C1 0.776142 1.22386 1 1.5 1H6V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V1H13.5C13.7761 1 14 0.776142 14 0.5C14 0.223858 13.7761 0 13.5 0H9H6H1.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$a = ["color"];
var AngleIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$a);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M8.8914 2.1937C9.1158 2.35464 9.16725 2.66701 9.00631 2.89141L2.47388 12H13.5C13.7761 12 14 12.2239 14 12.5C14 12.7762 13.7761 13 13.5 13H1.5C1.31254 13 1.14082 12.8952 1.0552 12.7284C0.969578 12.5616 0.984438 12.361 1.09369 12.2086L8.19369 2.30862C8.35462 2.08422 8.667 2.03277 8.8914 2.1937ZM11.1 6.50001C11.1 6.22387 11.3238 6.00001 11.6 6.00001C11.8761 6.00001 12.1 6.22387 12.1 6.50001C12.1 6.77615 11.8761 7.00001 11.6 7.00001C11.3238 7.00001 11.1 6.77615 11.1 6.50001ZM10.4 4.00001C10.1239 4.00001 9.90003 4.22387 9.90003 4.50001C9.90003 4.77615 10.1239 5.00001 10.4 5.00001C10.6762 5.00001 10.9 4.77615 10.9 4.50001C10.9 4.22387 10.6762 4.00001 10.4 4.00001ZM12.1 8.50001C12.1 8.22387 12.3238 8.00001 12.6 8.00001C12.8761 8.00001 13.1 8.22387 13.1 8.50001C13.1 8.77615 12.8761 9.00001 12.6 9.00001C12.3238 9.00001 12.1 8.77615 12.1 8.50001ZM13.4 10C13.1239 10 12.9 10.2239 12.9 10.5C12.9 10.7761 13.1239 11 13.4 11C13.6762 11 13.9 10.7761 13.9 10.5C13.9 10.2239 13.6762 10 13.4 10Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$e = ["color"];
var ArrowDownIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$e);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M7.5 2C7.77614 2 8 2.22386 8 2.5L8 11.2929L11.1464 8.14645C11.3417 7.95118 11.6583 7.95118 11.8536 8.14645C12.0488 8.34171 12.0488 8.65829 11.8536 8.85355L7.85355 12.8536C7.75979 12.9473 7.63261 13 7.5 13C7.36739 13 7.24021 12.9473 7.14645 12.8536L3.14645 8.85355C2.95118 8.65829 2.95118 8.34171 3.14645 8.14645C3.34171 7.95118 3.65829 7.95118 3.85355 8.14645L7 11.2929L7 2.5C7 2.22386 7.22386 2 7.5 2Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$i = ["color"];
var ArrowTopRightIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$i);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L10.2929 4L6 4C5.72386 4 5.5 3.77614 5.5 3.5C5.5 3.22386 5.72386 3 6 3L11.5 3C11.6326 3 11.7598 3.05268 11.8536 3.14645C11.9473 3.24022 12 3.36739 12 3.5L12 9.00001C12 9.27615 11.7761 9.50001 11.5 9.50001C11.2239 9.50001 11 9.27615 11 9.00001V4.70711L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$j = ["color"];
var ArrowUpIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$j);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M7.14645 2.14645C7.34171 1.95118 7.65829 1.95118 7.85355 2.14645L11.8536 6.14645C12.0488 6.34171 12.0488 6.65829 11.8536 6.85355C11.6583 7.04882 11.3417 7.04882 11.1464 6.85355L8 3.70711L8 12.5C8 12.7761 7.77614 13 7.5 13C7.22386 13 7 12.7761 7 12.5L7 3.70711L3.85355 6.85355C3.65829 7.04882 3.34171 7.04882 3.14645 6.85355C2.95118 6.65829 2.95118 6.34171 3.14645 6.14645L7.14645 2.14645Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$k = ["color"];
var AspectRatioIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$k);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M2.5 2H12.5C12.7761 2 13 2.22386 13 2.5V12.5C13 12.7761 12.7761 13 12.5 13H2.5C2.22386 13 2 12.7761 2 12.5V2.5C2 2.22386 2.22386 2 2.5 2ZM1 2.5C1 1.67157 1.67157 1 2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5ZM7.5 4C7.77614 4 8 3.77614 8 3.5C8 3.22386 7.77614 3 7.5 3C7.22386 3 7 3.22386 7 3.5C7 3.77614 7.22386 4 7.5 4ZM8 5.5C8 5.77614 7.77614 6 7.5 6C7.22386 6 7 5.77614 7 5.5C7 5.22386 7.22386 5 7.5 5C7.77614 5 8 5.22386 8 5.5ZM7.5 8C7.77614 8 8 7.77614 8 7.5C8 7.22386 7.77614 7 7.5 7C7.22386 7 7 7.22386 7 7.5C7 7.77614 7.22386 8 7.5 8ZM10 7.5C10 7.77614 9.77614 8 9.5 8C9.22386 8 9 7.77614 9 7.5C9 7.22386 9.22386 7 9.5 7C9.77614 7 10 7.22386 10 7.5ZM11.5 8C11.7761 8 12 7.77614 12 7.5C12 7.22386 11.7761 7 11.5 7C11.2239 7 11 7.22386 11 7.5C11 7.77614 11.2239 8 11.5 8Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$F = ["color"];
var BoxIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$F);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M12.5 2H2.5C2.22386 2 2 2.22386 2 2.5V12.5C2 12.7761 2.22386 13 2.5 13H12.5C12.7761 13 13 12.7761 13 12.5V2.5C13 2.22386 12.7761 2 12.5 2ZM2.5 1C1.67157 1 1 1.67157 1 2.5V12.5C1 13.3284 1.67157 14 2.5 14H12.5C13.3284 14 14 13.3284 14 12.5V2.5C14 1.67157 13.3284 1 12.5 1H2.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$T = ["color"];
var CheckIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$T);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$Y = ["color"];
var ChevronRightIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$Y);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$_ = ["color"];
var CircleIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$_);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M0.877075 7.49991C0.877075 3.84222 3.84222 0.877075 7.49991 0.877075C11.1576 0.877075 14.1227 3.84222 14.1227 7.49991C14.1227 11.1576 11.1576 14.1227 7.49991 14.1227C3.84222 14.1227 0.877075 11.1576 0.877075 7.49991ZM7.49991 1.82708C4.36689 1.82708 1.82708 4.36689 1.82708 7.49991C1.82708 10.6329 4.36689 13.1727 7.49991 13.1727C10.6329 13.1727 13.1727 10.6329 13.1727 7.49991C13.1727 4.36689 10.6329 1.82708 7.49991 1.82708Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$10 = ["color"];
var ClipboardIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$10);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M5 2V1H10V2H5ZM4.75 0C4.33579 0 4 0.335786 4 0.75V1H3.5C2.67157 1 2 1.67157 2 2.5V12.5C2 13.3284 2.67157 14 3.5 14H11.5C12.3284 14 13 13.3284 13 12.5V2.5C13 1.67157 12.3284 1 11.5 1H11V0.75C11 0.335786 10.6642 0 10.25 0H4.75ZM11 2V2.25C11 2.66421 10.6642 3 10.25 3H4.75C4.33579 3 4 2.66421 4 2.25V2H3.5C3.22386 2 3 2.22386 3 2.5V12.5C3 12.7761 3.22386 13 3.5 13H11.5C11.7761 13 12 12.7761 12 12.5V2.5C12 2.22386 11.7761 2 11.5 2H11Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$1h = ["color"];
var CopyIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$1h);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M1 9.50006C1 10.3285 1.67157 11.0001 2.5 11.0001H4L4 10.0001H2.5C2.22386 10.0001 2 9.7762 2 9.50006L2 2.50006C2 2.22392 2.22386 2.00006 2.5 2.00006L9.5 2.00006C9.77614 2.00006 10 2.22392 10 2.50006V4.00002H5.5C4.67158 4.00002 4 4.67159 4 5.50002V12.5C4 13.3284 4.67158 14 5.5 14H12.5C13.3284 14 14 13.3284 14 12.5V5.50002C14 4.67159 13.3284 4.00002 12.5 4.00002H11V2.50006C11 1.67163 10.3284 1.00006 9.5 1.00006H2.5C1.67157 1.00006 1 1.67163 1 2.50006V9.50006ZM5 5.50002C5 5.22388 5.22386 5.00002 5.5 5.00002H12.5C12.7761 5.00002 13 5.22388 13 5.50002V12.5C13 12.7762 12.7761 13 12.5 13H5.5C5.22386 13 5 12.7762 5 12.5V5.50002Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$1r = ["color"];
var Cross2Icon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$1r);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$1x = ["color"];
var CursorArrowIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$1x);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M3.29227 0.048984C3.47033 -0.032338 3.67946 -0.00228214 3.8274 0.125891L12.8587 7.95026C13.0134 8.08432 13.0708 8.29916 13.0035 8.49251C12.9362 8.68586 12.7578 8.81866 12.5533 8.82768L9.21887 8.97474L11.1504 13.2187C11.2648 13.47 11.1538 13.7664 10.9026 13.8808L8.75024 14.8613C8.499 14.9758 8.20255 14.8649 8.08802 14.6137L6.15339 10.3703L3.86279 12.7855C3.72196 12.934 3.50487 12.9817 3.31479 12.9059C3.1247 12.8301 3 12.6461 3 12.4414V0.503792C3 0.308048 3.11422 0.130306 3.29227 0.048984ZM4 1.59852V11.1877L5.93799 9.14425C6.05238 9.02363 6.21924 8.96776 6.38319 8.99516C6.54715 9.02256 6.68677 9.12965 6.75573 9.2809L8.79056 13.7441L10.0332 13.178L8.00195 8.71497C7.93313 8.56376 7.94391 8.38824 8.03072 8.24659C8.11753 8.10494 8.26903 8.01566 8.435 8.00834L11.2549 7.88397L4 1.59852Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$1I = ["color"];
var DotFilledIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$1I);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M9.875 7.5C9.875 8.81168 8.81168 9.875 7.5 9.875C6.18832 9.875 5.125 8.81168 5.125 7.5C5.125 6.18832 6.18832 5.125 7.5 5.125C8.81168 5.125 9.875 6.18832 9.875 7.5Z",
    fill: color
  }));
});
var _excluded$1J = ["color"];
var DotsHorizontalIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$1J);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M3.625 7.5C3.625 8.12132 3.12132 8.625 2.5 8.625C1.87868 8.625 1.375 8.12132 1.375 7.5C1.375 6.87868 1.87868 6.375 2.5 6.375C3.12132 6.375 3.625 6.87868 3.625 7.5ZM8.625 7.5C8.625 8.12132 8.12132 8.625 7.5 8.625C6.87868 8.625 6.375 8.12132 6.375 7.5C6.375 6.87868 6.87868 6.375 7.5 6.375C8.12132 6.375 8.625 6.87868 8.625 7.5ZM12.5 8.625C13.1213 8.625 13.625 8.12132 13.625 7.5C13.625 6.87868 13.1213 6.375 12.5 6.375C11.8787 6.375 11.375 6.87868 11.375 7.5C11.375 8.12132 11.8787 8.625 12.5 8.625Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$23 = ["color"];
var ExternalLinkIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$23);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M3 2C2.44772 2 2 2.44772 2 3V12C2 12.5523 2.44772 13 3 13H12C12.5523 13 13 12.5523 13 12V8.5C13 8.22386 12.7761 8 12.5 8C12.2239 8 12 8.22386 12 8.5V12H3V3L6.5 3C6.77614 3 7 2.77614 7 2.5C7 2.22386 6.77614 2 6.5 2H3ZM12.8536 2.14645C12.9015 2.19439 12.9377 2.24964 12.9621 2.30861C12.9861 2.36669 12.9996 2.4303 13 2.497L13 2.5V2.50049V5.5C13 5.77614 12.7761 6 12.5 6C12.2239 6 12 5.77614 12 5.5V3.70711L6.85355 8.85355C6.65829 9.04882 6.34171 9.04882 6.14645 8.85355C5.95118 8.65829 5.95118 8.34171 6.14645 8.14645L11.2929 3H9.5C9.22386 3 9 2.77614 9 2.5C9 2.22386 9.22386 2 9.5 2H12.4999H12.5C12.5678 2 12.6324 2.01349 12.6914 2.03794C12.7504 2.06234 12.8056 2.09851 12.8536 2.14645Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$2m = ["color"];
var GitHubLogoIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$2m);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M7.49933 0.25C3.49635 0.25 0.25 3.49593 0.25 7.50024C0.25 10.703 2.32715 13.4206 5.2081 14.3797C5.57084 14.446 5.70302 14.2222 5.70302 14.0299C5.70302 13.8576 5.69679 13.4019 5.69323 12.797C3.67661 13.235 3.25112 11.825 3.25112 11.825C2.92132 10.9874 2.44599 10.7644 2.44599 10.7644C1.78773 10.3149 2.49584 10.3238 2.49584 10.3238C3.22353 10.375 3.60629 11.0711 3.60629 11.0711C4.25298 12.1788 5.30335 11.8588 5.71638 11.6732C5.78225 11.205 5.96962 10.8854 6.17658 10.7043C4.56675 10.5209 2.87415 9.89918 2.87415 7.12104C2.87415 6.32925 3.15677 5.68257 3.62053 5.17563C3.54576 4.99226 3.29697 4.25521 3.69174 3.25691C3.69174 3.25691 4.30015 3.06196 5.68522 3.99973C6.26337 3.83906 6.8838 3.75895 7.50022 3.75583C8.1162 3.75895 8.73619 3.83906 9.31523 3.99973C10.6994 3.06196 11.3069 3.25691 11.3069 3.25691C11.7026 4.25521 11.4538 4.99226 11.3795 5.17563C11.8441 5.68257 12.1245 6.32925 12.1245 7.12104C12.1245 9.9063 10.4292 10.5192 8.81452 10.6985C9.07444 10.9224 9.30633 11.3648 9.30633 12.0413C9.30633 13.0102 9.29742 13.7922 9.29742 14.0299C9.29742 14.2239 9.42828 14.4496 9.79591 14.3788C12.6746 13.4179 14.75 10.7025 14.75 7.50024C14.75 3.49593 11.5036 0.25 7.49933 0.25Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$2p = ["color"];
var GroupIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$2p);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M1.44995 0.949951C1.31734 0.949951 1.19016 1.00263 1.0964 1.0964C1.00263 1.19017 0.949951 1.31735 0.949951 1.44995L0.949966 3.44995C0.949969 3.7261 1.17383 3.94995 1.44997 3.94995C1.72611 3.94995 1.94997 3.72609 1.94997 3.44995L1.94995 1.94995H3.44997C3.72611 1.94995 3.94997 1.72609 3.94997 1.44995C3.94997 1.17381 3.72611 0.949951 3.44997 0.949951H1.44995ZM5.94995 0.949951C5.67381 0.949951 5.44995 1.17381 5.44995 1.44995C5.44995 1.72609 5.67381 1.94995 5.94995 1.94995H8.94995C9.22609 1.94995 9.44995 1.72609 9.44995 1.44995C9.44995 1.17381 9.22609 0.949951 8.94995 0.949951H5.94995ZM5.44995 13.45C5.44995 13.1738 5.67381 12.95 5.94995 12.95H8.94995C9.22609 12.95 9.44995 13.1738 9.44995 13.45C9.44995 13.7261 9.22609 13.95 8.94995 13.95H5.94995C5.67381 13.95 5.44995 13.7261 5.44995 13.45ZM1.94995 5.94995C1.94995 5.67381 1.72609 5.44995 1.44995 5.44995C1.17381 5.44995 0.949951 5.67381 0.949951 5.94995V8.94995C0.949951 9.22609 1.17381 9.44995 1.44995 9.44995C1.72609 9.44995 1.94995 9.22609 1.94995 8.94995V5.94995ZM13.45 5.44995C13.7261 5.44995 13.95 5.67381 13.95 5.94995V8.94995C13.95 9.22609 13.7261 9.44995 13.45 9.44995C13.1738 9.44995 12.95 9.22609 12.95 8.94995V5.94995C12.95 5.67381 13.1738 5.44995 13.45 5.44995ZM11.45 0.949951C11.1738 0.949951 10.95 1.17381 10.95 1.44995C10.95 1.72609 11.1738 1.94995 11.45 1.94995H12.9499V3.44995C12.9499 3.72609 13.1738 3.94995 13.4499 3.94995C13.7261 3.94995 13.9499 3.72609 13.9499 3.44995V1.44995C13.9499 1.17381 13.7252 0.949951 13.449 0.949951H11.45ZM1.44995 10.95C1.72609 10.95 1.94995 11.1738 1.94995 11.45V12.95H3.44997C3.72611 12.95 3.94997 13.1738 3.94997 13.45C3.94997 13.7261 3.72611 13.95 3.44997 13.95H1.44995C1.17381 13.95 0.949951 13.7261 0.949951 13.45V11.45C0.949951 11.1738 1.17381 10.95 1.44995 10.95ZM13.95 11.45C13.95 11.1738 13.7261 10.95 13.45 10.95C13.1738 10.9499 12.95 11.1738 12.95 11.4499L12.9491 12.95H11.45C11.1738 12.95 10.95 13.1738 10.95 13.45C10.95 13.7261 11.1738 13.95 11.45 13.95H13.4499C13.7261 13.95 13.9499 13.7261 13.9499 13.45L13.95 11.45Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$2s = ["color"];
var HamburgerMenuIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$2s);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M1.5 3C1.22386 3 1 3.22386 1 3.5C1 3.77614 1.22386 4 1.5 4H13.5C13.7761 4 14 3.77614 14 3.5C14 3.22386 13.7761 3 13.5 3H1.5ZM1 7.5C1 7.22386 1.22386 7 1.5 7H13.5C13.7761 7 14 7.22386 14 7.5C14 7.77614 13.7761 8 13.5 8H1.5C1.22386 8 1 7.77614 1 7.5ZM1 11.5C1 11.2239 1.22386 11 1.5 11H13.5C13.7761 11 14 11.2239 14 11.5C14 11.7761 13.7761 12 13.5 12H1.5C1.22386 12 1 11.7761 1 11.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$2w = ["color"];
var HeartFilledIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$2w);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M1.35248 4.90532C1.35248 2.94498 2.936 1.35248 4.89346 1.35248C6.25769 1.35248 6.86058 1.92336 7.50002 2.93545C8.13946 1.92336 8.74235 1.35248 10.1066 1.35248C12.064 1.35248 13.6476 2.94498 13.6476 4.90532C13.6476 6.74041 12.6013 8.50508 11.4008 9.96927C10.2636 11.3562 8.92194 12.5508 8.00601 13.3664C7.94645 13.4194 7.88869 13.4709 7.83291 13.5206C7.64324 13.6899 7.3568 13.6899 7.16713 13.5206C7.11135 13.4709 7.05359 13.4194 6.99403 13.3664C6.0781 12.5508 4.73641 11.3562 3.59926 9.96927C2.39872 8.50508 1.35248 6.74041 1.35248 4.90532Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$2C = ["color"];
var ImageIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$2C);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5C1 1.67157 1.67157 1 2.5 1ZM2.5 2C2.22386 2 2 2.22386 2 2.5V8.3636L3.6818 6.6818C3.76809 6.59551 3.88572 6.54797 4.00774 6.55007C4.12975 6.55216 4.24568 6.60372 4.32895 6.69293L7.87355 10.4901L10.6818 7.6818C10.8575 7.50607 11.1425 7.50607 11.3182 7.6818L13 9.3636V2.5C13 2.22386 12.7761 2 12.5 2H2.5ZM2 12.5V9.6364L3.98887 7.64753L7.5311 11.4421L8.94113 13H2.5C2.22386 13 2 12.7761 2 12.5ZM12.5 13H10.155L8.48336 11.153L11 8.6364L13 10.6364V12.5C13 12.7761 12.7761 13 12.5 13ZM6.64922 5.5C6.64922 5.03013 7.03013 4.64922 7.5 4.64922C7.96987 4.64922 8.35078 5.03013 8.35078 5.5C8.35078 5.96987 7.96987 6.35078 7.5 6.35078C7.03013 6.35078 6.64922 5.96987 6.64922 5.5ZM7.5 3.74922C6.53307 3.74922 5.74922 4.53307 5.74922 5.5C5.74922 6.46693 6.53307 7.25078 7.5 7.25078C8.46693 7.25078 9.25078 6.46693 9.25078 5.5C9.25078 4.53307 8.46693 3.74922 7.5 3.74922Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$2_ = ["color"];
var LockClosedIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$2_);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M5 4.63601C5 3.76031 5.24219 3.1054 5.64323 2.67357C6.03934 2.24705 6.64582 1.9783 7.5014 1.9783C8.35745 1.9783 8.96306 2.24652 9.35823 2.67208C9.75838 3.10299 10 3.75708 10 4.63325V5.99999H5V4.63601ZM4 5.99999V4.63601C4 3.58148 4.29339 2.65754 4.91049 1.99307C5.53252 1.32329 6.42675 0.978302 7.5014 0.978302C8.57583 0.978302 9.46952 1.32233 10.091 1.99162C10.7076 2.65557 11 3.57896 11 4.63325V5.99999H12C12.5523 5.99999 13 6.44771 13 6.99999V13C13 13.5523 12.5523 14 12 14H3C2.44772 14 2 13.5523 2 13V6.99999C2 6.44771 2.44772 5.99999 3 5.99999H4ZM3 6.99999H12V13H3V6.99999Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$2$ = ["color"];
var LockOpen1Icon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$2$);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M7.4986 0C6.3257 0 5.36107 0.38943 4.73753 1.19361C4.23745 1.83856 4 2.68242 4 3.63325H5C5 2.84313 5.19691 2.23312 5.5278 1.80636C5.91615 1.30552 6.55152 1 7.4986 1C8.35683 1 8.96336 1.26502 9.35846 1.68623C9.75793 2.11211 10 2.76044 10 3.63601V6H3C2.44772 6 2 6.44772 2 7V13C2 13.5523 2.44772 14 3 14H12C12.5523 14 13 13.5523 13 13V7C13 6.44771 12.5523 6 12 6H11V3.63601C11 2.58135 10.7065 1.66167 10.0878 1.0021C9.46477 0.337871 8.57061 0 7.4986 0ZM3 7H12V13H3V7Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3b = ["color"];
var MixerVerticalIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$3b);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M5 1.5C5 1.22386 4.77614 1 4.5 1C4.22386 1 4 1.22386 4 1.5L4 7C4 7.01671 4.00082 7.03323 4.00242 7.04952C2.86009 7.28022 2 8.28967 2 9.5C2 10.7103 2.86009 11.7198 4.00242 11.9505C4.00082 11.9668 4 11.9833 4 12V13.5C4 13.7761 4.22386 14 4.5 14C4.77614 14 5 13.7761 5 13.5V12C5 11.9833 4.99918 11.9668 4.99758 11.9505C6.1399 11.7198 7 10.7103 7 9.5C7 8.28967 6.1399 7.28022 4.99758 7.04952C4.99918 7.03323 5 7.01671 5 7L5 1.5ZM11 1.5C11 1.22386 10.7761 1 10.5 1C10.2239 1 10 1.22386 10 1.5V3C10 3.01671 10.0008 3.03323 10.0024 3.04952C8.8601 3.28022 8 4.28967 8 5.5C8 6.71033 8.8601 7.71978 10.0024 7.95048C10.0008 7.96677 10 7.98329 10 8V13.5C10 13.7761 10.2239 14 10.5 14C10.7761 14 11 13.7761 11 13.5V8C11 7.98329 10.9992 7.96677 10.9976 7.95048C12.1399 7.71978 13 6.71033 13 5.5C13 4.28967 12.1399 3.28022 10.9976 3.04952C10.9992 3.03323 11 3.01671 11 3V1.5ZM4.5 8C3.67157 8 3 8.67157 3 9.5C3 10.3284 3.67157 11 4.5 11C5.32843 11 6 10.3284 6 9.5C6 8.67157 5.32843 8 4.5 8ZM9 5.5C9 4.67157 9.67157 4 10.5 4C11.3284 4 12 4.67157 12 5.5C12 6.32843 11.3284 7 10.5 7C9.67157 7 9 6.32843 9 5.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3n = ["color"];
var Pencil1Icon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$3n);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M11.8536 1.14645C11.6583 0.951184 11.3417 0.951184 11.1465 1.14645L3.71455 8.57836C3.62459 8.66832 3.55263 8.77461 3.50251 8.89155L2.04044 12.303C1.9599 12.491 2.00189 12.709 2.14646 12.8536C2.29103 12.9981 2.50905 13.0401 2.69697 12.9596L6.10847 11.4975C6.2254 11.4474 6.3317 11.3754 6.42166 11.2855L13.8536 3.85355C14.0488 3.65829 14.0488 3.34171 13.8536 3.14645L11.8536 1.14645ZM4.42166 9.28547L11.5 2.20711L12.7929 3.5L5.71455 10.5784L4.21924 11.2192L3.78081 10.7808L4.42166 9.28547Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3o = ["color"];
var Pencil2Icon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$3o);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M12.1464 1.14645C12.3417 0.951184 12.6583 0.951184 12.8535 1.14645L14.8535 3.14645C15.0488 3.34171 15.0488 3.65829 14.8535 3.85355L10.9109 7.79618C10.8349 7.87218 10.7471 7.93543 10.651 7.9835L6.72359 9.94721C6.53109 10.0435 6.29861 10.0057 6.14643 9.85355C5.99425 9.70137 5.95652 9.46889 6.05277 9.27639L8.01648 5.34897C8.06455 5.25283 8.1278 5.16507 8.2038 5.08907L12.1464 1.14645ZM12.5 2.20711L8.91091 5.79618L7.87266 7.87267L8.12731 8.12732L10.2038 7.08907L13.7929 3.5L12.5 2.20711ZM9.99998 2L8.99998 3H4.9C4.47171 3 4.18056 3.00039 3.95552 3.01877C3.73631 3.03668 3.62421 3.06915 3.54601 3.10899C3.35785 3.20487 3.20487 3.35785 3.10899 3.54601C3.06915 3.62421 3.03669 3.73631 3.01878 3.95552C3.00039 4.18056 3 4.47171 3 4.9V11.1C3 11.5283 3.00039 11.8194 3.01878 12.0445C3.03669 12.2637 3.06915 12.3758 3.10899 12.454C3.20487 12.6422 3.35785 12.7951 3.54601 12.891C3.62421 12.9309 3.73631 12.9633 3.95552 12.9812C4.18056 12.9996 4.47171 13 4.9 13H11.1C11.5283 13 11.8194 12.9996 12.0445 12.9812C12.2637 12.9633 12.3758 12.9309 12.454 12.891C12.6422 12.7951 12.7951 12.6422 12.891 12.454C12.9309 12.3758 12.9633 12.2637 12.9812 12.0445C12.9996 11.8194 13 11.5283 13 11.1V6.99998L14 5.99998V11.1V11.1207C14 11.5231 14 11.8553 13.9779 12.1259C13.9549 12.407 13.9057 12.6653 13.782 12.908C13.5903 13.2843 13.2843 13.5903 12.908 13.782C12.6653 13.9057 12.407 13.9549 12.1259 13.9779C11.8553 14 11.5231 14 11.1207 14H11.1H4.9H4.87934C4.47686 14 4.14468 14 3.87409 13.9779C3.59304 13.9549 3.33469 13.9057 3.09202 13.782C2.7157 13.5903 2.40973 13.2843 2.21799 12.908C2.09434 12.6653 2.04506 12.407 2.0221 12.1259C1.99999 11.8553 1.99999 11.5231 2 11.1207V11.1206V11.1V4.9V4.87935V4.87932V4.87931C1.99999 4.47685 1.99999 4.14468 2.0221 3.87409C2.04506 3.59304 2.09434 3.33469 2.21799 3.09202C2.40973 2.71569 2.7157 2.40973 3.09202 2.21799C3.33469 2.09434 3.59304 2.04506 3.87409 2.0221C4.14468 1.99999 4.47685 1.99999 4.87932 2H4.87935H4.9H9.99998Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3s = ["color"];
var PinBottomIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$3s);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M13.5 13.95C13.7485 13.95 13.95 13.7485 13.95 13.5C13.95 13.2514 13.7485 13.05 13.5 13.05L1.49995 13.05C1.25142 13.05 1.04995 13.2514 1.04995 13.5C1.04995 13.7485 1.25142 13.95 1.49995 13.95L13.5 13.95ZM11.0681 7.5683C11.2439 7.39257 11.2439 7.10764 11.0681 6.93191C10.8924 6.75617 10.6075 6.75617 10.4317 6.93191L7.94993 9.41371L7.94993 1.49998C7.94993 1.25146 7.74846 1.04998 7.49993 1.04998C7.2514 1.04998 7.04993 1.25146 7.04993 1.49998L7.04993 9.41371L4.56813 6.93191C4.39239 6.75617 4.10746 6.75617 3.93173 6.93191C3.75599 7.10764 3.75599 7.39257 3.93173 7.5683L7.18173 10.8183C7.35746 10.994 7.64239 10.994 7.81812 10.8183L11.0681 7.5683Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3v = ["color"];
var PinTopIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$3v);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M1.50005 1.05005C1.25152 1.05005 1.05005 1.25152 1.05005 1.50005C1.05005 1.74858 1.25152 1.95005 1.50005 1.95005L13.5 1.95005C13.7486 1.95005 13.95 1.74858 13.95 1.50005C13.95 1.25152 13.7486 1.05005 13.5 1.05005H1.50005ZM3.93188 7.43169C3.75614 7.60743 3.75614 7.89236 3.93188 8.06809C4.10761 8.24383 4.39254 8.24383 4.56827 8.06809L7.05007 5.58629V13.5C7.05007 13.7485 7.25155 13.95 7.50007 13.95C7.7486 13.95 7.95007 13.7485 7.95007 13.5L7.95007 5.58629L10.4319 8.06809C10.6076 8.24383 10.8925 8.24383 11.0683 8.06809C11.244 7.89235 11.244 7.60743 11.0683 7.43169L7.81827 4.18169C7.64254 4.00596 7.35761 4.00596 7.18188 4.18169L3.93188 7.43169Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3x = ["color"];
var PlusIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$3x);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M8 2.75C8 2.47386 7.77614 2.25 7.5 2.25C7.22386 2.25 7 2.47386 7 2.75V7H2.75C2.47386 7 2.25 7.22386 2.25 7.5C2.25 7.77614 2.47386 8 2.75 8H7V12.25C7 12.5261 7.22386 12.75 7.5 12.75C7.77614 12.75 8 12.5261 8 12.25V8H12.25C12.5261 8 12.75 7.77614 12.75 7.5C12.75 7.22386 12.5261 7 12.25 7H8V2.75Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3z = ["color"];
var QuestionMarkIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$3z);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M5.07505 4.10001C5.07505 2.91103 6.25727 1.92502 7.50005 1.92502C8.74283 1.92502 9.92505 2.91103 9.92505 4.10001C9.92505 5.19861 9.36782 5.71436 8.61854 6.37884L8.58757 6.4063C7.84481 7.06467 6.92505 7.87995 6.92505 9.5C6.92505 9.81757 7.18248 10.075 7.50005 10.075C7.81761 10.075 8.07505 9.81757 8.07505 9.5C8.07505 8.41517 8.62945 7.90623 9.38156 7.23925L9.40238 7.22079C10.1496 6.55829 11.075 5.73775 11.075 4.10001C11.075 2.12757 9.21869 0.775024 7.50005 0.775024C5.7814 0.775024 3.92505 2.12757 3.92505 4.10001C3.92505 4.41758 4.18249 4.67501 4.50005 4.67501C4.81761 4.67501 5.07505 4.41758 5.07505 4.10001ZM7.50005 13.3575C7.9833 13.3575 8.37505 12.9657 8.37505 12.4825C8.37505 11.9992 7.9833 11.6075 7.50005 11.6075C7.0168 11.6075 6.62505 11.9992 6.62505 12.4825C6.62505 12.9657 7.0168 13.3575 7.50005 13.3575Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$3I = ["color"];
var RotateCounterClockwiseIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$3I);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M7.59664 2.93628C7.76085 3.06401 8.00012 2.94698 8.00012 2.73895V1.99998C9.98143 2 11.1848 2.3637 11.9105 3.08945C12.6363 3.81522 13 5.0186 13 6.99998C13 7.27613 13.2239 7.49998 13.5 7.49998C13.7761 7.49998 14 7.27613 14 6.99998C14 4.9438 13.6325 3.39719 12.6176 2.38234C11.6028 1.36752 10.0562 0.999999 8.00012 0.999984V0.261266C8.00012 0.0532293 7.76085 -0.0637944 7.59664 0.063928L6.00384 1.30277C5.87516 1.40286 5.87516 1.59735 6.00384 1.69744L7.59664 2.93628ZM9.5 5H2.5C2.22386 5 2 5.22386 2 5.5V12.5C2 12.7761 2.22386 13 2.5 13H9.5C9.77614 13 10 12.7761 10 12.5V5.5C10 5.22386 9.77614 5 9.5 5ZM2.5 4C1.67157 4 1 4.67157 1 5.5V12.5C1 13.3284 1.67157 14 2.5 14H9.5C10.3284 14 11 13.3284 11 12.5V5.5C11 4.67157 10.3284 4 9.5 4H2.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$42 = ["color"];
var SpaceEvenlyHorizontallyIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$42);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M14.4999 0.999992C14.2237 0.999992 13.9999 1.22385 13.9999 1.49999L13.9999 13.4999C13.9999 13.776 14.2237 13.9999 14.4999 13.9999C14.776 13.9999 14.9999 13.776 14.9999 13.4999L14.9999 1.49999C14.9999 1.22385 14.776 0.999992 14.4999 0.999992ZM0.499996 0.999992C0.223856 0.999992 -9.78509e-09 1.22385 -2.18556e-08 1.49999L4.07279e-07 13.4999C3.95208e-07 13.776 0.223855 13.9999 0.499996 13.9999C0.776136 13.9999 0.999992 13.776 0.999992 13.4999L0.999992 1.49999C0.999992 1.22385 0.776136 0.999992 0.499996 0.999992ZM1.99998 6.99994C1.99998 6.44766 2.44769 5.99995 2.99998 5.99995L5.99995 5.99995C6.55223 5.99995 6.99994 6.44766 6.99994 6.99994L6.99994 7.99993C6.99994 8.55221 6.55223 8.99992 5.99995 8.99992L2.99998 8.99992C2.4477 8.99992 1.99998 8.55221 1.99998 7.99993L1.99998 6.99994ZM8.99993 5.99995C8.44765 5.99995 7.99993 6.44766 7.99993 6.99994L7.99993 7.99993C7.99993 8.55221 8.44765 8.99992 8.99993 8.99992L11.9999 8.99992C12.5522 8.99992 12.9999 8.55221 12.9999 7.99993L12.9999 6.99994C12.9999 6.44766 12.5522 5.99995 11.9999 5.99995L8.99993 5.99995Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$43 = ["color"];
var SpaceEvenlyVerticallyIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$43);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M0.999878 0.5C0.999878 0.223858 1.22374 0 1.49988 0H13.4999C13.776 0 13.9999 0.223858 13.9999 0.5C13.9999 0.776142 13.776 1 13.4999 1H1.49988C1.22374 1 0.999878 0.776142 0.999878 0.5ZM7 2C6.44772 2 6 2.44772 6 3V6C6 6.55228 6.44772 7 7 7H8C8.55228 7 9 6.55228 9 6V3C9 2.44772 8.55228 2 8 2H7ZM7 8C6.44772 8 6 8.44771 6 9V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V9C9 8.44772 8.55228 8 8 8H7ZM1.49988 14C1.22374 14 0.999878 14.2239 0.999878 14.5C0.999878 14.7761 1.22374 15 1.49988 15H13.4999C13.776 15 13.9999 14.7761 13.9999 14.5C13.9999 14.2239 13.776 14 13.4999 14H1.49988Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$48 = ["color"];
var SquareIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$48);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M1 1H1.5H13.5H14V1.5V13.5V14H13.5H1.5H1V13.5V1.5V1ZM2 2V13H13V2H2Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4f = ["color"];
var StretchHorizontallyIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$4f);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M14.4999 0.999992C14.2237 0.999992 13.9999 1.22385 13.9999 1.49999L13.9999 5.99995L0.999992 5.99995L0.999992 1.49999C0.999992 1.22385 0.776136 0.999992 0.499996 0.999992C0.223856 0.999992 -9.78509e-09 1.22385 -2.18556e-08 1.49999L4.07279e-07 13.4999C3.95208e-07 13.776 0.223855 13.9999 0.499996 13.9999C0.776136 13.9999 0.999992 13.776 0.999992 13.4999L0.999992 8.99992L13.9999 8.99992L13.9999 13.4999C13.9999 13.776 14.2237 13.9999 14.4999 13.9999C14.776 13.9999 14.9999 13.776 14.9999 13.4999L14.9999 1.49999C14.9999 1.22385 14.776 0.999992 14.4999 0.999992Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4g = ["color"];
var StretchVerticallyIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$4g);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M0.999878 0.5C0.999878 0.223858 1.22374 0 1.49988 0H13.4999C13.776 0 13.9999 0.223858 13.9999 0.5C13.9999 0.776142 13.776 1 13.4999 1H6H1.49988C1.22374 1 0.999878 0.776142 0.999878 0.5ZM9 14V1L6 1V14H1.49988C1.22374 14 0.999878 14.2239 0.999878 14.5C0.999878 14.7761 1.22374 15 1.49988 15H13.4999C13.776 15 13.9999 14.7761 13.9999 14.5C13.9999 14.2239 13.776 14 13.4999 14H9Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4n = ["color"];
var TextIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$4n);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M3.94993 2.95002L3.94993 4.49998C3.94993 4.74851 3.74845 4.94998 3.49993 4.94998C3.2514 4.94998 3.04993 4.74851 3.04993 4.49998V2.50004C3.04993 2.45246 3.05731 2.40661 3.07099 2.36357C3.12878 2.18175 3.29897 2.05002 3.49993 2.05002H11.4999C11.6553 2.05002 11.7922 2.12872 11.8731 2.24842C11.9216 2.32024 11.9499 2.40682 11.9499 2.50002L11.9499 2.50004V4.49998C11.9499 4.74851 11.7485 4.94998 11.4999 4.94998C11.2514 4.94998 11.0499 4.74851 11.0499 4.49998V2.95002H8.04993V12.05H9.25428C9.50281 12.05 9.70428 12.2515 9.70428 12.5C9.70428 12.7486 9.50281 12.95 9.25428 12.95H5.75428C5.50575 12.95 5.30428 12.7486 5.30428 12.5C5.30428 12.2515 5.50575 12.05 5.75428 12.05H6.94993V2.95002H3.94993Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4p = ["color"];
var TextAlignCenterIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$4p);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM4 7.5C4 7.22386 4.22386 7 4.5 7H10.5C10.7761 7 11 7.22386 11 7.5C11 7.77614 10.7761 8 10.5 8H4.5C4.22386 8 4 7.77614 4 7.5ZM3 10.5C3 10.2239 3.22386 10 3.5 10H11.5C11.7761 10 12 10.2239 12 10.5C12 10.7761 11.7761 11 11.5 11H3.5C3.22386 11 3 10.7761 3 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4q = ["color"];
var TextAlignJustifyIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$4q);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M2.5 4C2.22386 4 2 4.22386 2 4.5C2 4.77614 2.22386 5 2.5 5H12.5C12.7761 5 13 4.77614 13 4.5C13 4.22386 12.7761 4 12.5 4H2.5ZM2 7.5C2 7.22386 2.22386 7 2.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H2.5C2.22386 8 2 7.77614 2 7.5ZM2 10.5C2 10.2239 2.22386 10 2.5 10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H2.5C2.22386 11 2 10.7761 2 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4r = ["color"];
var TextAlignLeftIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$4r);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM2 7.5C2 7.22386 2.22386 7 2.5 7H7.5C7.77614 7 8 7.22386 8 7.5C8 7.77614 7.77614 8 7.5 8H2.5C2.22386 8 2 7.77614 2 7.5ZM2 10.5C2 10.2239 2.22386 10 2.5 10H10.5C10.7761 10 11 10.2239 11 10.5C11 10.7761 10.7761 11 10.5 11H2.5C2.22386 11 2 10.7761 2 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4t = ["color"];
var TextAlignRightIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$4t);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM7 7.5C7 7.22386 7.22386 7 7.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H7.5C7.22386 8 7 7.77614 7 7.5ZM4 10.5C4 10.2239 4.22386 10 4.5 10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H4.5C4.22386 11 4 10.7761 4 10.5Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4L = ["color"];
var TwitterLogoIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$4L);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M7.23336 4.69629C7.23336 2.96884 8.63335 1.56857 10.36 1.56857C11.3736 1.56857 12.183 2.04804 12.7254 2.74385C13.3079 2.62467 13.8557 2.40913 14.3513 2.11508C14.1559 2.72598 13.7424 3.2396 13.2033 3.56463C13.2038 3.56568 13.2042 3.56674 13.2047 3.56779C13.7334 3.50361 14.2364 3.36302 14.7048 3.15546L14.7037 3.15715C14.3667 3.66183 13.9431 4.10736 13.4561 4.47034C13.4823 4.64672 13.4956 4.82427 13.4956 5.00079C13.4956 8.6871 10.6873 12.9746 5.52122 12.9746C3.93906 12.9746 2.46544 12.511 1.22505 11.7152C0.992632 11.5661 0.925108 11.2568 1.07423 11.0244C1.0874 11.0038 1.10183 10.9846 1.11734 10.9666C1.20582 10.8202 1.37438 10.7309 1.5554 10.7522C2.47066 10.8601 3.38568 10.7485 4.19219 10.3962C3.39226 10.0434 2.77129 9.35975 2.50204 8.51974C2.45359 8.3686 2.48835 8.20311 2.59351 8.08422C2.59716 8.0801 2.60087 8.07606 2.60464 8.0721C1.96391 7.50819 1.55973 6.68208 1.55973 5.76143V5.72759C1.55973 5.56814 1.64411 5.42059 1.78155 5.33974C1.82671 5.31317 1.87537 5.29511 1.92532 5.28558C1.70549 4.86154 1.58116 4.37984 1.58116 3.86958C1.58116 3.40165 1.58384 2.81192 1.91332 2.28081C1.98718 2.16175 2.10758 2.08915 2.2364 2.07195C2.42588 2.01237 2.64087 2.06969 2.77406 2.23302C3.86536 3.57126 5.44066 4.49583 7.23366 4.73961L7.23336 4.69629ZM5.52122 11.9746C4.73387 11.9746 3.97781 11.8435 3.27248 11.6023C4.13012 11.4538 4.95307 11.1159 5.66218 10.5602C5.81211 10.4427 5.87182 10.2435 5.81126 10.0629C5.7507 9.88234 5.583 9.75943 5.39255 9.75607C4.68968 9.74366 4.06712 9.39716 3.67793 8.86845C3.86828 8.85306 4.05428 8.82039 4.23445 8.77167C4.43603 8.71716 4.57363 8.53114 4.56674 8.32243C4.55985 8.11372 4.41029 7.93718 4.20555 7.89607C3.42694 7.73977 2.79883 7.16764 2.56169 6.42174C2.76255 6.47025 2.97102 6.4991 3.18482 6.5061C3.38563 6.51267 3.56646 6.38533 3.62795 6.19405C3.68943 6.00277 3.61666 5.79391 3.44963 5.68224C2.86523 5.29155 2.48116 4.62464 2.48116 3.86958C2.48116 3.70213 2.48352 3.55268 2.49355 3.41719C3.85115 4.79913 5.70873 5.68931 7.77588 5.79338C7.93225 5.80126 8.08328 5.73543 8.18395 5.61553C8.28463 5.49562 8.32332 5.33548 8.28851 5.18284C8.25255 5.02517 8.23336 4.86284 8.23336 4.69629C8.23336 3.52085 9.18591 2.56857 10.36 2.56857C11.5943 2.56857 12.4956 3.71208 12.4956 5.00079C12.4956 8.25709 10.0202 11.9746 5.52122 11.9746Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$4R = ["color"];
var VercelLogoIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$4R);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M7.49998 1L6.92321 2.00307L1.17498 12L0.599976 13H1.7535H13.2464H14.4L13.825 12L8.07674 2.00307L7.49998 1ZM7.49998 3.00613L2.3285 12H12.6714L7.49998 3.00613Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var e$1 = "colors", t$1 = "sizes", r$1 = "space", n$1 = { gap: r$1, gridGap: r$1, columnGap: r$1, gridColumnGap: r$1, rowGap: r$1, gridRowGap: r$1, inset: r$1, insetBlock: r$1, insetBlockEnd: r$1, insetBlockStart: r$1, insetInline: r$1, insetInlineEnd: r$1, insetInlineStart: r$1, margin: r$1, marginTop: r$1, marginRight: r$1, marginBottom: r$1, marginLeft: r$1, marginBlock: r$1, marginBlockEnd: r$1, marginBlockStart: r$1, marginInline: r$1, marginInlineEnd: r$1, marginInlineStart: r$1, padding: r$1, paddingTop: r$1, paddingRight: r$1, paddingBottom: r$1, paddingLeft: r$1, paddingBlock: r$1, paddingBlockEnd: r$1, paddingBlockStart: r$1, paddingInline: r$1, paddingInlineEnd: r$1, paddingInlineStart: r$1, top: r$1, right: r$1, bottom: r$1, left: r$1, scrollMargin: r$1, scrollMarginTop: r$1, scrollMarginRight: r$1, scrollMarginBottom: r$1, scrollMarginLeft: r$1, scrollMarginX: r$1, scrollMarginY: r$1, scrollMarginBlock: r$1, scrollMarginBlockEnd: r$1, scrollMarginBlockStart: r$1, scrollMarginInline: r$1, scrollMarginInlineEnd: r$1, scrollMarginInlineStart: r$1, scrollPadding: r$1, scrollPaddingTop: r$1, scrollPaddingRight: r$1, scrollPaddingBottom: r$1, scrollPaddingLeft: r$1, scrollPaddingX: r$1, scrollPaddingY: r$1, scrollPaddingBlock: r$1, scrollPaddingBlockEnd: r$1, scrollPaddingBlockStart: r$1, scrollPaddingInline: r$1, scrollPaddingInlineEnd: r$1, scrollPaddingInlineStart: r$1, fontSize: "fontSizes", background: e$1, backgroundColor: e$1, backgroundImage: e$1, borderImage: e$1, border: e$1, borderBlock: e$1, borderBlockEnd: e$1, borderBlockStart: e$1, borderBottom: e$1, borderBottomColor: e$1, borderColor: e$1, borderInline: e$1, borderInlineEnd: e$1, borderInlineStart: e$1, borderLeft: e$1, borderLeftColor: e$1, borderRight: e$1, borderRightColor: e$1, borderTop: e$1, borderTopColor: e$1, caretColor: e$1, color: e$1, columnRuleColor: e$1, fill: e$1, outline: e$1, outlineColor: e$1, stroke: e$1, textDecorationColor: e$1, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: t$1, minBlockSize: t$1, maxBlockSize: t$1, inlineSize: t$1, minInlineSize: t$1, maxInlineSize: t$1, width: t$1, minWidth: t$1, maxWidth: t$1, height: t$1, minHeight: t$1, maxHeight: t$1, flexBasis: t$1, gridTemplateColumns: t$1, gridTemplateRows: t$1, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" }, i$1 = (e10, t10) => "function" == typeof t10 ? { "()": Function.prototype.toString.call(t10) } : t10, o$1 = () => {
  const e10 = /* @__PURE__ */ Object.create(null);
  return (t10, r10, ...n10) => {
    const o10 = ((e11) => JSON.stringify(e11, i$1))(t10);
    return o10 in e10 ? e10[o10] : e10[o10] = r10(t10, ...n10);
  };
}, l$2 = Symbol.for("sxs.internal"), s$1 = (e10, t10) => Object.defineProperties(e10, Object.getOwnPropertyDescriptors(t10)), a$2 = (e10) => {
  for (const t10 in e10) return true;
  return false;
}, { hasOwnProperty: c$1 } = Object.prototype, d$1 = (e10) => e10.includes("-") ? e10 : e10.replace(/[A-Z]/g, (e11) => "-" + e11.toLowerCase()), g = /\s+(?![^()]*\))/, p$1 = (e10) => (t10) => e10(..."string" == typeof t10 ? String(t10).split(g) : [t10]), u$1 = { appearance: (e10) => ({ WebkitAppearance: e10, appearance: e10 }), backfaceVisibility: (e10) => ({ WebkitBackfaceVisibility: e10, backfaceVisibility: e10 }), backdropFilter: (e10) => ({ WebkitBackdropFilter: e10, backdropFilter: e10 }), backgroundClip: (e10) => ({ WebkitBackgroundClip: e10, backgroundClip: e10 }), boxDecorationBreak: (e10) => ({ WebkitBoxDecorationBreak: e10, boxDecorationBreak: e10 }), clipPath: (e10) => ({ WebkitClipPath: e10, clipPath: e10 }), content: (e10) => ({ content: e10.includes('"') || e10.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e10) ? e10 : `"${e10}"` }), hyphens: (e10) => ({ WebkitHyphens: e10, hyphens: e10 }), maskImage: (e10) => ({ WebkitMaskImage: e10, maskImage: e10 }), maskSize: (e10) => ({ WebkitMaskSize: e10, maskSize: e10 }), tabSize: (e10) => ({ MozTabSize: e10, tabSize: e10 }), textSizeAdjust: (e10) => ({ WebkitTextSizeAdjust: e10, textSizeAdjust: e10 }), userSelect: (e10) => ({ WebkitUserSelect: e10, userSelect: e10 }), marginBlock: p$1((e10, t10) => ({ marginBlockStart: e10, marginBlockEnd: t10 || e10 })), marginInline: p$1((e10, t10) => ({ marginInlineStart: e10, marginInlineEnd: t10 || e10 })), maxSize: p$1((e10, t10) => ({ maxBlockSize: e10, maxInlineSize: t10 || e10 })), minSize: p$1((e10, t10) => ({ minBlockSize: e10, minInlineSize: t10 || e10 })), paddingBlock: p$1((e10, t10) => ({ paddingBlockStart: e10, paddingBlockEnd: t10 || e10 })), paddingInline: p$1((e10, t10) => ({ paddingInlineStart: e10, paddingInlineEnd: t10 || e10 })) }, h$1 = /([\d.]+)([^]*)/, f$1 = (e10, t10) => e10.length ? e10.reduce((e11, r10) => (e11.push(...t10.map((e12) => e12.includes("&") ? e12.replace(/&/g, /[ +>|~]/.test(r10) && /&.*&/.test(e12) ? `:is(${r10})` : r10) : r10 + " " + e12)), e11), []) : t10, m$1 = (e10, t10) => e10 in b$1 && "string" == typeof t10 ? t10.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (t11, r10, n10, i10) => r10 + ("stretch" === n10 ? `-moz-available${i10};${d$1(e10)}:${r10}-webkit-fill-available` : `-moz-fit-content${i10};${d$1(e10)}:${r10}fit-content`) + i10) : String(t10), b$1 = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 }, S$1 = (e10) => e10 ? e10 + "-" : "", k$2 = (e10, t10, r10) => e10.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (e11, n10, i10, o10, l10) => "$" == o10 == !!i10 ? e11 : (n10 || "--" == o10 ? "calc(" : "") + "var(--" + ("$" === o10 ? S$1(t10) + (l10.includes("$") ? "" : S$1(r10)) + l10.replace(/\$/g, "-") : l10) + ")" + (n10 || "--" == o10 ? "*" + (n10 || "") + (i10 || "1") + ")" : "")), y$1 = /\s*,\s*(?![^()]*\))/, B = Object.prototype.toString, $ = (e10, t10, r10, n10, i10) => {
  let o10, l10, s10;
  const a10 = (e11, t11, r11) => {
    let c10, g10;
    const p10 = (e12) => {
      for (c10 in e12) {
        const R10 = 64 === c10.charCodeAt(0), z10 = R10 && Array.isArray(e12[c10]) ? e12[c10] : [e12[c10]];
        for (g10 of z10) {
          const e13 = /[A-Z]/.test($10 = c10) ? $10 : $10.replace(/-[^]/g, (e14) => e14[1].toUpperCase()), z11 = "object" == typeof g10 && g10 && g10.toString === B && (!n10.utils[e13] || !t11.length);
          if (e13 in n10.utils && !z11) {
            const t12 = n10.utils[e13];
            if (t12 !== l10) {
              l10 = t12, p10(t12(g10)), l10 = null;
              continue;
            }
          } else if (e13 in u$1) {
            const t12 = u$1[e13];
            if (t12 !== s10) {
              s10 = t12, p10(t12(g10)), s10 = null;
              continue;
            }
          }
          if (R10 && (b10 = c10.slice(1) in n10.media ? "@media " + n10.media[c10.slice(1)] : c10, c10 = b10.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (e14, t12, r12, n11, i11, o11) => {
            const l11 = h$1.test(t12), s11 = 0.0625 * (l11 ? -1 : 1), [a11, c11] = l11 ? [n11, t12] : [t12, n11];
            return "(" + ("=" === r12[0] ? "" : ">" === r12[0] === l11 ? "max-" : "min-") + a11 + ":" + ("=" !== r12[0] && 1 === r12.length ? c11.replace(h$1, (e15, t13, n12) => Number(t13) + s11 * (">" === r12 ? 1 : -1) + n12) : c11) + (i11 ? ") and (" + (">" === i11[0] ? "min-" : "max-") + a11 + ":" + (1 === i11.length ? o11.replace(h$1, (e15, t13, r13) => Number(t13) + s11 * (">" === i11 ? -1 : 1) + r13) : o11) : "") + ")";
          })), z11) {
            const e14 = R10 ? r11.concat(c10) : [...r11], n11 = R10 ? [...t11] : f$1(t11, c10.split(y$1));
            void 0 !== o10 && i10(x$1(...o10)), o10 = void 0, a10(g10, n11, e14);
          } else void 0 === o10 && (o10 = [[], t11, r11]), c10 = R10 || 36 !== c10.charCodeAt(0) ? c10 : `--${S$1(n10.prefix)}${c10.slice(1).replace(/\$/g, "-")}`, g10 = z11 ? g10 : "number" == typeof g10 ? g10 && e13 in I ? String(g10) + "px" : String(g10) : k$2(m$1(e13, null == g10 ? "" : g10), n10.prefix, n10.themeMap[e13]), o10[0].push(`${R10 ? `${c10} ` : `${d$1(c10)}:`}${g10}`);
        }
      }
      var b10, $10;
    };
    p10(e11), void 0 !== o10 && i10(x$1(...o10)), o10 = void 0;
  };
  a10(e10, t10, r10);
}, x$1 = (e10, t10, r10) => `${r10.map((e11) => `${e11}{`).join("")}${t10.length ? `${t10.join(",")}{` : ""}${e10.join(";")}${t10.length ? "}" : ""}${Array(r10.length ? r10.length + 1 : 0).join("}")}`, I = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 }, R = (e10) => String.fromCharCode(e10 + (e10 > 25 ? 39 : 97)), z = (e10) => ((e11) => {
  let t10, r10 = "";
  for (t10 = Math.abs(e11); t10 > 52; t10 = t10 / 52 | 0) r10 = R(t10 % 52) + r10;
  return R(t10 % 52) + r10;
})(((e11, t10) => {
  let r10 = t10.length;
  for (; r10; ) e11 = 33 * e11 ^ t10.charCodeAt(--r10);
  return e11;
})(5381, JSON.stringify(e10)) >>> 0), W = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"], j = (e10) => {
  if (e10.href && !e10.href.startsWith(location.origin)) return false;
  try {
    return !!e10.cssRules;
  } catch (e11) {
    return false;
  }
}, E = (e10) => {
  let t10;
  const r10 = () => {
    const { cssRules: e11 } = t10.sheet;
    return [].map.call(e11, (r11, n11) => {
      const { cssText: i10 } = r11;
      let o10 = "";
      if (i10.startsWith("--sxs")) return "";
      if (e11[n11 - 1] && (o10 = e11[n11 - 1].cssText).startsWith("--sxs")) {
        if (!r11.cssRules.length) return "";
        for (const e12 in t10.rules) if (t10.rules[e12].group === r11) return `--sxs{--sxs:${[...t10.rules[e12].cache].join(" ")}}${i10}`;
        return r11.cssRules.length ? `${o10}${i10}` : "";
      }
      return i10;
    }).join("");
  }, n10 = () => {
    if (t10) {
      const { rules: e11, sheet: r11 } = t10;
      if (!r11.deleteRule) {
        for (; 3 === Object(Object(r11.cssRules)[0]).type; ) r11.cssRules.splice(0, 1);
        r11.cssRules = [];
      }
      for (const t11 in e11) delete e11[t11];
    }
    const i10 = Object(e10).styleSheets || [];
    for (const e11 of i10) if (j(e11)) {
      for (let i11 = 0, o11 = e11.cssRules; o11[i11]; ++i11) {
        const l11 = Object(o11[i11]);
        if (1 !== l11.type) continue;
        const s10 = Object(o11[i11 + 1]);
        if (4 !== s10.type) continue;
        ++i11;
        const { cssText: a10 } = l11;
        if (!a10.startsWith("--sxs")) continue;
        const c10 = a10.slice(14, -3).trim().split(/\s+/), d10 = W[c10[0]];
        d10 && (t10 || (t10 = { sheet: e11, reset: n10, rules: {}, toString: r10 }), t10.rules[d10] = { group: s10, index: i11, cache: new Set(c10) });
      }
      if (t10) break;
    }
    if (!t10) {
      const i11 = (e11, t11) => ({ type: t11, cssRules: [], insertRule(e12, t12) {
        this.cssRules.splice(t12, 0, i11(e12, { import: 3, undefined: 1 }[(e12.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return "@media{}" === e11 ? `@media{${[].map.call(this.cssRules, (e12) => e12.cssText).join("")}}` : e11;
      } });
      t10 = { sheet: e10 ? (e10.head || e10).appendChild(document.createElement("style")).sheet : i11("", "text/css"), rules: {}, reset: n10, toString: r10 };
    }
    const { sheet: o10, rules: l10 } = t10;
    for (let e11 = W.length - 1; e11 >= 0; --e11) {
      const t11 = W[e11];
      if (!l10[t11]) {
        const r11 = W[e11 + 1], n11 = l10[r11] ? l10[r11].index : o10.cssRules.length;
        o10.insertRule("@media{}", n11), o10.insertRule(`--sxs{--sxs:${e11}}`, n11), l10[t11] = { group: o10.cssRules[n11 + 1], index: n11, cache: /* @__PURE__ */ new Set([e11]) };
      }
      v$2(l10[t11]);
    }
  };
  return n10(), t10;
}, v$2 = (e10) => {
  const t10 = e10.group;
  let r10 = t10.cssRules.length;
  e10.apply = (e11) => {
    try {
      t10.insertRule(e11, r10), ++r10;
    } catch (e12) {
    }
  };
}, T = Symbol(), w$1 = o$1(), M = (e10, t10) => w$1(e10, () => (...r10) => {
  let n10 = { type: null, composers: /* @__PURE__ */ new Set() };
  for (const t11 of r10) if (null != t11) if (t11[l$2]) {
    null == n10.type && (n10.type = t11[l$2].type);
    for (const e11 of t11[l$2].composers) n10.composers.add(e11);
  } else t11.constructor !== Object || t11.$$typeof ? null == n10.type && (n10.type = t11) : n10.composers.add(C(t11, e10));
  return null == n10.type && (n10.type = "span"), n10.composers.size || n10.composers.add(["PJLV", {}, [], [], {}, []]), P$1(e10, n10, t10);
}), C = ({ variants: e10, compoundVariants: t10, defaultVariants: r10, ...n10 }, i10) => {
  const o10 = `${S$1(i10.prefix)}c-${z(n10)}`, l10 = [], s10 = [], d10 = /* @__PURE__ */ Object.create(null), g10 = [];
  for (const e11 in r10) d10[e11] = String(r10[e11]);
  if ("object" == typeof e10 && e10) for (const t11 in e10) {
    p10 = d10, u10 = t11, c$1.call(p10, u10) || (d10[t11] = "undefined");
    const r11 = e10[t11];
    for (const e11 in r11) {
      const n11 = { [t11]: String(e11) };
      "undefined" === String(e11) && g10.push(t11);
      const i11 = r11[e11], o11 = [n11, i11, !a$2(i11)];
      l10.push(o11);
    }
  }
  var p10, u10;
  if ("object" == typeof t10 && t10) for (const e11 of t10) {
    let { css: t11, ...r11 } = e11;
    t11 = "object" == typeof t11 && t11 || {};
    for (const e12 in r11) r11[e12] = String(r11[e12]);
    const n11 = [r11, t11, !a$2(t11)];
    s10.push(n11);
  }
  return [o10, n10, l10, s10, d10, g10];
}, P$1 = (e10, t10, r10) => {
  const [n10, i10, o10, a10] = L(t10.composers), c10 = "function" == typeof t10.type || t10.type.$$typeof ? ((e11) => {
    function t11() {
      for (let r11 = 0; r11 < t11[T].length; r11++) {
        const [n11, i11] = t11[T][r11];
        e11.rules[n11].apply(i11);
      }
      return t11[T] = [], null;
    }
    return t11[T] = [], t11.rules = {}, W.forEach((e12) => t11.rules[e12] = { apply: (r11) => t11[T].push([e12, r11]) }), t11;
  })(r10) : null, d10 = (c10 || r10).rules, g10 = `.${n10}${i10.length > 1 ? `:where(.${i10.slice(1).join(".")})` : ""}`, p10 = (l10) => {
    l10 = "object" == typeof l10 && l10 || A;
    const { css: s10, ...p11 } = l10, u10 = {};
    for (const e11 in o10) if (delete p11[e11], e11 in l10) {
      let t11 = l10[e11];
      "object" == typeof t11 && t11 ? u10[e11] = { "@initial": o10[e11], ...t11 } : (t11 = String(t11), u10[e11] = "undefined" !== t11 || a10.has(e11) ? t11 : o10[e11]);
    } else u10[e11] = o10[e11];
    const h10 = /* @__PURE__ */ new Set([...i10]);
    for (const [n11, i11, o11, l11] of t10.composers) {
      r10.rules.styled.cache.has(n11) || (r10.rules.styled.cache.add(n11), $(i11, [`.${n11}`], [], e10, (e11) => {
        d10.styled.apply(e11);
      }));
      const t11 = O(o11, u10, e10.media), s11 = O(l11, u10, e10.media, true);
      for (const i12 of t11) if (void 0 !== i12) for (const [t12, o12, l12] of i12) {
        const i13 = `${n11}-${z(o12)}-${t12}`;
        h10.add(i13);
        const s12 = (l12 ? r10.rules.resonevar : r10.rules.onevar).cache, a11 = l12 ? d10.resonevar : d10.onevar;
        s12.has(i13) || (s12.add(i13), $(o12, [`.${i13}`], [], e10, (e11) => {
          a11.apply(e11);
        }));
      }
      for (const t12 of s11) if (void 0 !== t12) for (const [i12, o12] of t12) {
        const t13 = `${n11}-${z(o12)}-${i12}`;
        h10.add(t13), r10.rules.allvar.cache.has(t13) || (r10.rules.allvar.cache.add(t13), $(o12, [`.${t13}`], [], e10, (e11) => {
          d10.allvar.apply(e11);
        }));
      }
    }
    if ("object" == typeof s10 && s10) {
      const t11 = `${n10}-i${z(s10)}-css`;
      h10.add(t11), r10.rules.inline.cache.has(t11) || (r10.rules.inline.cache.add(t11), $(s10, [`.${t11}`], [], e10, (e11) => {
        d10.inline.apply(e11);
      }));
    }
    for (const e11 of String(l10.className || "").trim().split(/\s+/)) e11 && h10.add(e11);
    const f10 = p11.className = [...h10].join(" ");
    return { type: t10.type, className: f10, selector: g10, props: p11, toString: () => f10, deferredInjector: c10 };
  };
  return s$1(p10, { className: n10, selector: g10, [l$2]: t10, toString: () => (r10.rules.styled.cache.has(n10) || p10(), n10) });
}, L = (e10) => {
  let t10 = "";
  const r10 = [], n10 = {}, i10 = [];
  for (const [o10, , , , l10, s10] of e10) {
    "" === t10 && (t10 = o10), r10.push(o10), i10.push(...s10);
    for (const e11 in l10) {
      const t11 = l10[e11];
      (void 0 === n10[e11] || "undefined" !== t11 || s10.includes(t11)) && (n10[e11] = t11);
    }
  }
  return [t10, r10, n10, new Set(i10)];
}, O = (e10, t10, r10, n10) => {
  const i10 = [];
  e: for (let [o10, l10, s10] of e10) {
    if (s10) continue;
    let e11, a10 = 0, c10 = false;
    for (e11 in o10) {
      const n11 = o10[e11];
      let i11 = t10[e11];
      if (i11 !== n11) {
        if ("object" != typeof i11 || !i11) continue e;
        {
          let e12, t11, o11 = 0;
          for (const l11 in i11) {
            if (n11 === String(i11[l11])) {
              if ("@initial" !== l11) {
                const e13 = l11.slice(1);
                (t11 = t11 || []).push(e13 in r10 ? r10[e13] : l11.replace(/^@media ?/, "")), c10 = true;
              }
              a10 += o11, e12 = true;
            }
            ++o11;
          }
          if (t11 && t11.length && (l10 = { ["@media " + t11.join(", ")]: l10 }), !e12) continue e;
        }
      }
    }
    (i10[a10] = i10[a10] || []).push([n10 ? "cv" : `${e11}-${o10[e11]}`, l10, c10]);
  }
  return i10;
}, A = {}, N = o$1(), D = (e10, t10) => N(e10, () => (...r10) => {
  const n10 = () => {
    for (let n11 of r10) {
      n11 = "object" == typeof n11 && n11 || {};
      let r11 = z(n11);
      if (!t10.rules.global.cache.has(r11)) {
        if (t10.rules.global.cache.add(r11), "@import" in n11) {
          let e11 = [].indexOf.call(t10.sheet.cssRules, t10.rules.themed.group) - 1;
          for (let r12 of [].concat(n11["@import"])) r12 = r12.includes('"') || r12.includes("'") ? r12 : `"${r12}"`, t10.sheet.insertRule(`@import ${r12};`, e11++);
          delete n11["@import"];
        }
        $(n11, [], [], e10, (e11) => {
          t10.rules.global.apply(e11);
        });
      }
    }
    return "";
  };
  return s$1(n10, { toString: n10 });
}), H$1 = o$1(), V = (e10, t10) => H$1(e10, () => (r10) => {
  const n10 = `${S$1(e10.prefix)}k-${z(r10)}`, i10 = () => {
    if (!t10.rules.global.cache.has(n10)) {
      t10.rules.global.cache.add(n10);
      const i11 = [];
      $(r10, [], [], e10, (e11) => i11.push(e11));
      const o10 = `@keyframes ${n10}{${i11.join("")}}`;
      t10.rules.global.apply(o10);
    }
    return n10;
  };
  return s$1(i10, { get name() {
    return i10();
  }, toString: i10 });
}), G = class {
  constructor(e10, t10, r10, n10) {
    this.token = null == e10 ? "" : String(e10), this.value = null == t10 ? "" : String(t10), this.scale = null == r10 ? "" : String(r10), this.prefix = null == n10 ? "" : String(n10);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + S$1(this.prefix) + S$1(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
}, F = o$1(), J = (e10, t10) => F(e10, () => (r10, n10) => {
  n10 = "object" == typeof r10 && r10 || Object(n10);
  const i10 = `.${r10 = (r10 = "string" == typeof r10 ? r10 : "") || `${S$1(e10.prefix)}t-${z(n10)}`}`, o10 = {}, l10 = [];
  for (const t11 in n10) {
    o10[t11] = {};
    for (const r11 in n10[t11]) {
      const i11 = `--${S$1(e10.prefix)}${t11}-${r11}`, s11 = k$2(String(n10[t11][r11]), e10.prefix, t11);
      o10[t11][r11] = new G(r11, s11, t11, e10.prefix), l10.push(`${i11}:${s11}`);
    }
  }
  const s10 = () => {
    if (l10.length && !t10.rules.themed.cache.has(r10)) {
      t10.rules.themed.cache.add(r10);
      const i11 = `${n10 === e10.theme ? ":root," : ""}.${r10}{${l10.join(";")}}`;
      t10.rules.themed.apply(i11);
    }
    return r10;
  };
  return { ...o10, get className() {
    return s10();
  }, selector: i10, toString: s10 };
}), U = o$1();
var X, Y = o$1(), q = (e10) => {
  const t10 = ((e11) => {
    let t11 = false;
    const r10 = U(e11, (e12) => {
      t11 = true;
      const r11 = "prefix" in (e12 = "object" == typeof e12 && e12 || {}) ? String(e12.prefix) : "", i10 = "object" == typeof e12.media && e12.media || {}, o10 = "object" == typeof e12.root ? e12.root || null : globalThis.document || null, l10 = "object" == typeof e12.theme && e12.theme || {}, s10 = { prefix: r11, media: i10, theme: l10, themeMap: "object" == typeof e12.themeMap && e12.themeMap || { ...n$1 }, utils: "object" == typeof e12.utils && e12.utils || {} }, a10 = E(o10), c10 = { css: M(s10, a10), globalCss: D(s10, a10), keyframes: V(s10, a10), createTheme: J(s10, a10), reset() {
        a10.reset(), c10.theme.toString();
      }, theme: {}, sheet: a10, config: s10, prefix: r11, getCssText: a10.toString, toString: a10.toString };
      return String(c10.theme = c10.createTheme(l10)), c10;
    });
    return t11 || r10.reset(), r10;
  })(e10);
  return t10.styled = (({ config: e11, sheet: t11 }) => Y(e11, () => {
    const r10 = M(e11, t11);
    return (...e12) => {
      const t12 = r10(...e12), n10 = t12[l$2].type, i10 = spe.forwardRef((e13, r11) => {
        const i11 = e13 && e13.as || n10, { props: o10, deferredInjector: l10 } = t12(e13);
        return delete o10.as, o10.ref = r11, l10 ? spe.createElement(spe.Fragment, null, spe.createElement(i11, o10), spe.createElement(l10, null)) : spe.createElement(i11, o10);
      });
      return i10.className = t12.className, i10.displayName = `Styled.${n10.displayName || n10.name || n10}`, i10.selector = t12.selector, i10.toString = () => t12.selector, i10[l$2] = t12[l$2], i10;
    };
  }))(t10), t10;
}, K = () => X || (X = q()), re = (...e10) => K().styled(...e10);
function $6ed0406888f73fc4$var$setRef(ref, value) {
  if (typeof ref === "function") ref(value);
  else if (ref !== null && ref !== void 0) ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef(ref, node)
  );
}
const $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
};
const $1746a345f3d73bb7$var$useReactId = React["useId".toString()] || (() => void 0);
let $1746a345f3d73bb7$var$count = 0;
function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
  const [id, setId] = reactExports.useState($1746a345f3d73bb7$var$useReactId());
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    setId(
      (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
    );
  }, [
    deterministicId
  ]);
  return deterministicId || (id ? `radix-${id}` : "");
}
const $d08ef79370b62062$var$DROPDOWN_MENU_NAME = "DropdownMenu";
const [$d08ef79370b62062$var$createDropdownMenuContext, $d08ef79370b62062$export$c0623cd925aeb687] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d08ef79370b62062$var$DROPDOWN_MENU_NAME, [
  $6cc32821e9371a1c$export$4027731b685e72eb
]);
const $d08ef79370b62062$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb();
const [$d08ef79370b62062$var$DropdownMenuProvider, $d08ef79370b62062$var$useDropdownMenuContext] = $d08ef79370b62062$var$createDropdownMenuContext($d08ef79370b62062$var$DROPDOWN_MENU_NAME);
const $d08ef79370b62062$export$e44a253a59704894 = (props) => {
  const { __scopeDropdownMenu, children, dir, open: openProp, defaultOpen, onOpenChange, modal = true } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  const triggerRef = reactExports.useRef(null);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ reactExports.createElement($d08ef79370b62062$var$DropdownMenuProvider, {
    scope: __scopeDropdownMenu,
    triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),
    triggerRef,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    open,
    onOpenChange: setOpen,
    onOpenToggle: reactExports.useCallback(
      () => setOpen(
        (prevOpen) => !prevOpen
      ),
      [
        setOpen
      ]
    ),
    modal
  }, /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$be92b6f5f03c0fe9, _extends({}, menuScope, {
    open,
    onOpenChange: setOpen,
    dir,
    modal
  }), children));
};
const $d08ef79370b62062$var$TRIGGER_NAME = "DropdownMenuTrigger";
const $d08ef79370b62062$export$d2469213b3befba9 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
  const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$TRIGGER_NAME, __scopeDropdownMenu);
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$b688253958b8dfe7, _extends({
    asChild: true
  }, menuScope), /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    id: context.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": context.open ? true : void 0,
    "aria-controls": context.open ? context.contentId : void 0,
    "data-state": context.open ? "open" : "closed",
    "data-disabled": disabled ? "" : void 0,
    disabled
  }, triggerProps, {
    ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, context.triggerRef),
    onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, (event) => {
      if (!disabled && event.button === 0 && event.ctrlKey === false) {
        context.onOpenToggle();
        if (!context.open) event.preventDefault();
      }
    }),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      if (disabled) return;
      if ([
        "Enter",
        " "
      ].includes(event.key)) context.onOpenToggle();
      if (event.key === "ArrowDown") context.onOpenChange(true);
      if ([
        " ",
        "ArrowDown"
      ].includes(event.key)) event.preventDefault();
    })
  })));
});
const $d08ef79370b62062$export$cd369b4d4d54efc9 = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$602eac185826482c, _extends({}, menuScope, portalProps));
};
const $d08ef79370b62062$var$CONTENT_NAME = "DropdownMenuContent";
const $d08ef79370b62062$export$6e76d93a37c01248 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...contentProps } = props;
  const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$CONTENT_NAME, __scopeDropdownMenu);
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  const hasInteractedOutsideRef = reactExports.useRef(false);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$7c6e2c02157bb7d2, _extends({
    id: context.contentId,
    "aria-labelledby": context.triggerId
  }, menuScope, contentProps, {
    ref: forwardedRef,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
      var _context$triggerRef$c;
      if (!hasInteractedOutsideRef.current) (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
      hasInteractedOutsideRef.current = false;
      event.preventDefault();
    }),
    onInteractOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onInteractOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
    }),
    style: {
      ...props.style,
      // re-namespace exposed content custom property
      ["--radix-dropdown-menu-content-transform-origin"]: "var(--radix-popper-transform-origin)"
    }
  }));
});
const $d08ef79370b62062$export$ed97964d1871885d = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$6d08773d2e66f8f2, _extends({}, menuScope, itemProps, {
    ref: forwardedRef
  }));
});
const $d08ef79370b62062$export$53a69729da201fa9 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$16ce288f89fa631c, _extends({}, menuScope, checkboxItemProps, {
    ref: forwardedRef
  }));
});
const $d08ef79370b62062$export$3323ad73d55f587e = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$a98f0dcb43a68a25, _extends({}, menuScope, radioGroupProps, {
    ref: forwardedRef
  }));
});
const $d08ef79370b62062$export$e4f69b41b1637536 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$371ab307eab489c0, _extends({}, menuScope, radioItemProps, {
    ref: forwardedRef
  }));
});
const $d08ef79370b62062$export$42355ae145153fb6 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$c3468e2714d175fa, _extends({}, menuScope, itemIndicatorProps, {
    ref: forwardedRef
  }));
});
const $d08ef79370b62062$export$da160178fd3bc7e9 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$1ff3c3f08ae963c0, _extends({}, menuScope, separatorProps, {
    ref: forwardedRef
  }));
});
const $d08ef79370b62062$export$34b8980744021ec5 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...arrowProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$21b07c8f274aebd5, _extends({}, menuScope, arrowProps, {
    ref: forwardedRef
  }));
});
const $d08ef79370b62062$export$2f307d81a64f5442 = (props) => {
  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$d7a01e11500dfb6f, _extends({}, menuScope, {
    open,
    onOpenChange: setOpen
  }), children);
};
const $d08ef79370b62062$export$21dcb7ec56f874cf = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$2ea8a7a591ac5eac, _extends({}, menuScope, subTriggerProps, {
    ref: forwardedRef
  }));
});
const $d08ef79370b62062$export$f34ec8bc2482cc5f = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ reactExports.createElement($6cc32821e9371a1c$export$6d4de93b380beddf, _extends({}, menuScope, subContentProps, {
    ref: forwardedRef,
    style: {
      ...props.style,
      // re-namespace exposed content custom property
      ["--radix-dropdown-menu-content-transform-origin"]: "var(--radix-popper-transform-origin)"
    }
  }));
});
const $d08ef79370b62062$export$be92b6f5f03c0fe9 = $d08ef79370b62062$export$e44a253a59704894;
const $d08ef79370b62062$export$41fb9f06171c75f4 = $d08ef79370b62062$export$d2469213b3befba9;
const $d08ef79370b62062$export$602eac185826482c = $d08ef79370b62062$export$cd369b4d4d54efc9;
const $d08ef79370b62062$export$7c6e2c02157bb7d2 = $d08ef79370b62062$export$6e76d93a37c01248;
const $d08ef79370b62062$export$6d08773d2e66f8f2 = $d08ef79370b62062$export$ed97964d1871885d;
const $d08ef79370b62062$export$16ce288f89fa631c = $d08ef79370b62062$export$53a69729da201fa9;
const $d08ef79370b62062$export$a98f0dcb43a68a25 = $d08ef79370b62062$export$3323ad73d55f587e;
const $d08ef79370b62062$export$371ab307eab489c0 = $d08ef79370b62062$export$e4f69b41b1637536;
const $d08ef79370b62062$export$c3468e2714d175fa = $d08ef79370b62062$export$42355ae145153fb6;
const $d08ef79370b62062$export$1ff3c3f08ae963c0 = $d08ef79370b62062$export$da160178fd3bc7e9;
const $d08ef79370b62062$export$21b07c8f274aebd5 = $d08ef79370b62062$export$34b8980744021ec5;
const $d08ef79370b62062$export$d7a01e11500dfb6f = $d08ef79370b62062$export$2f307d81a64f5442;
const $d08ef79370b62062$export$2ea8a7a591ac5eac = $d08ef79370b62062$export$21dcb7ec56f874cf;
const $d08ef79370b62062$export$6d4de93b380beddf = $d08ef79370b62062$export$f34ec8bc2482cc5f;
function composeEventHandlers$4(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i10 = 0; i10 < cleanups.length; i10++) {
          const cleanup = cleanups[i10];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i10], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return reactExports.useCallback(composeRefs(...refs), refs);
}
function createContextScope$3(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      var _a2;
      const { scope, children, ...context } = props;
      const Context2 = ((_a2 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a2[index2]) || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context2.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      var _a2;
      const Context2 = ((_a2 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a2[index2]) || BaseContext;
      const context = reactExports.useContext(Context2);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes$3(createScope, ...createContextScopeDeps)];
}
function composeContextScopes$3(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function composeEventHandlers$3(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
  const Slot2 = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = reactExports.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
          return reactExports.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
  const SlotClone = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (reactExports.isValidElement(children)) {
      const childrenRef = getElementRef$1(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== reactExports.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return reactExports.cloneElement(children, props2);
    }
    return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
function isSlottable(child) {
  return reactExports.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$1(element) {
  var _a2, _b2;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b2 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b2.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var NODES$6 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive$6 = NODES$6.reduce((primitive, node) => {
  const Slot2 = /* @__PURE__ */ createSlot(`Primitive.${node}`);
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) reactDomExports.flushSync(() => target.dispatchEvent(event));
}
function useCallbackRef$4(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => {
    var _a2;
    return (_a2 = callbackRef.current) == null ? void 0 : _a2.call(callbackRef, ...args);
  }, []);
}
function useCallbackRef$3(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => {
    var _a2;
    return (_a2 = callbackRef.current) == null ? void 0 : _a2.call(callbackRef, ...args);
  }, []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef$3(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = reactExports.useContext(DismissableLayerContext);
    const [node, setNode] = reactExports.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = reactExports.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    reactExports.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    reactExports.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    reactExports.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$6.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers$3(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers$3(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers$3(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
  const context = reactExports.useContext(DismissableLayerContext);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$6.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef$4(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef$4(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var useLayoutEffect2 = (globalThis == null ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
};
var useReactId = React[" useId ".trim().toString()] || (() => void 0);
var count$1 = 0;
function useId(deterministicId) {
  const [id, setId] = reactExports.useState(useReactId());
  useLayoutEffect2(() => {
    setId((reactId) => reactId ?? String(count$1++));
  }, [deterministicId]);
  return id ? `radix-${id}` : "";
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v10) => ({
  x: v10,
  y: v10
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr2 = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl2 : lr2;
      return isStart ? lr2 : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x10,
    y: y10,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y10,
    left: x10,
    right: x10 + width,
    bottom: y10 + height,
    x: x10,
    y: y10
  };
}
function computeCoordsFromPlacement$1(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$3 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x10,
    y: y10
  } = computeCoordsFromPlacement$1(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i10 = 0; i10 < validMiddleware.length; i10++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i10];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x: x10,
      y: y10,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x10 = nextX != null ? nextX : x10;
    y10 = nextY != null ? nextY : y10;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x10,
          y: y10
        } = computeCoordsFromPlacement$1(rects, statefulPlacement, rtl));
      }
      i10 = -1;
    }
  }
  return {
    x: x10,
    y: y10,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow$1(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x10,
    y: y10,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x10,
    y: y10,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$6 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x10,
      y: y10,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x10,
      y: y10
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$5 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          var _overflowsData$;
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
          if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d10) => d10.overflows[0] <= 0).sort((a10, b10) => a10.overflows[1] - b10.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d10) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d10.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d10) => [d10.placement, d10.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a10, b10) => a10[1] - b10[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets$1(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped$1(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$5 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow$1(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets$1(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped$1(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow$1(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets$1(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped$1(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords$1(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$5 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x10,
        y: y10,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords$1(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x10 + diffCoords.x,
        y: y10 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$5 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x10,
        y: y10,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x11,
              y: y11
            } = _ref;
            return {
              x: x11,
              y: y11
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x10,
        y: y10
      };
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x10,
          y: limitedCoords.y - y10,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$5 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x10,
        y: y10,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x10,
        y: y10
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$5 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e10) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions$1(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement$1(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale$1(element) {
  const domElement = unwrapElement$1(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $10
  } = getCssDimensions$1(domElement);
  let x10 = ($10 ? round(rect.width) : rect.width) / width;
  let y10 = ($10 ? round(rect.height) : rect.height) / height;
  if (!x10 || !Number.isFinite(x10)) {
    x10 = 1;
  }
  if (!y10 || !Number.isFinite(y10)) {
    y10 = 1;
  }
  return {
    x: x10,
    y: y10
  };
}
const noOffsets$1 = /* @__PURE__ */ createCoords(0);
function getVisualOffsets$1(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets$1;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets$1(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect$1(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement$1(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale$1(offsetParent);
      }
    } else {
      scale = getScale$1(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets$1(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets$1(domElement) : createCoords(0);
  let x10 = (clientRect.left + visualOffsets.x) / scale.x;
  let y10 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale$1(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top2 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x10 *= iframeScale.x;
      y10 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x10 += left;
      y10 += top2;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x10,
    y: y10
  });
}
function getWindowScrollBarX$1(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect$1(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset$1(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x10 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX$1(documentElement, htmlRect)
  ));
  const y10 = htmlRect.top + scroll.scrollTop;
  return {
    x: x10,
    y: y10
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect$1(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect$1(offsetParent);
      scale = getScale$1(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset$1(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects$1(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect$1(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x10 = -scroll.scrollLeft + getWindowScrollBarX$1(element);
  const y10 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x10 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x10,
    y: y10
  };
}
function getViewportRect$1(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x10 = 0;
  let y10 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x10 = visualViewport.offsetLeft;
      y10 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x10,
    y: y10
  };
}
function getInnerBoundingClientRect$1(element, strategy) {
  const clientRect = getBoundingClientRect$1(element, true, strategy === "fixed");
  const top2 = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale$1(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x10 = left * scale.x;
  const y10 = top2 * scale.y;
  return {
    width,
    height,
    x: x10,
    y: y10
  };
}
function getClientRectFromClippingAncestor$1(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect$1(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect$1(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect$1(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets$1(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor$1(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor$1(parentNode, stopNode);
}
function getClippingElementAncestors$1(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor$1(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect$1(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors$1(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor$1(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor$1(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions$1(element) {
  const {
    width,
    height
  } = getCssDimensions$1(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent$1(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect$1(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX$1(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect$1(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset$1(documentElement, scroll) : createCoords(0);
  const x10 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y10 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x10,
    y: y10,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned$1(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent$1(element, polyfill2) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill2) {
    return polyfill2(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent$1(element, polyfill2) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned$1(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent$1(element, polyfill2);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned$1(offsetParent)) {
    offsetParent = getTrueOffsetParent$1(offsetParent, polyfill2);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned$1(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects$1 = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent$1;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent$1(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL$1(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform$1 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect$1,
  getDocumentElement,
  getClippingRect: getClippingRect$1,
  getOffsetParent: getOffsetParent$1,
  getElementRects: getElementRects$1,
  getClientRects: getClientRects$1,
  getDimensions: getDimensions$1,
  getScale: getScale$1,
  isElement,
  isRTL: isRTL$1
};
function rectsAreEqual$1(a10, b10) {
  return a10.x === b10.x && a10.y === b10.y && a10.width === b10.width && a10.height === b10.height;
}
function observeMove$1(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top: top2,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top2);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top2 + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual$1(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate$1(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement$1(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove$1(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect$1(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect$1(reference);
    if (prevRefRect && !rectsAreEqual$1(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$4 = offset$5;
const shift$4 = shift$5;
const flip$4 = flip$5;
const size$4 = size$5;
const hide$4 = hide$5;
const arrow$5 = arrow$6;
const limitShift$4 = limitShift$5;
const computePosition$2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform: platform$1,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$3(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index$1 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual$1(a10, b10) {
  if (a10 === b10) {
    return true;
  }
  if (typeof a10 !== typeof b10) {
    return false;
  }
  if (typeof a10 === "function" && a10.toString() === b10.toString()) {
    return true;
  }
  let length;
  let i10;
  let keys;
  if (a10 && b10 && typeof a10 === "object") {
    if (Array.isArray(a10)) {
      length = a10.length;
      if (length !== b10.length) return false;
      for (i10 = length; i10-- !== 0; ) {
        if (!deepEqual$1(a10[i10], b10[i10])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a10);
    length = keys.length;
    if (length !== Object.keys(b10).length) {
      return false;
    }
    for (i10 = length; i10-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b10, keys[i10])) {
        return false;
      }
    }
    for (i10 = length; i10-- !== 0; ) {
      const key = keys[i10];
      if (key === "_owner" && a10.$$typeof) {
        continue;
      }
      if (!deepEqual$1(a10[key], b10[key])) {
        return false;
      }
    }
    return true;
  }
  return a10 !== a10 && b10 !== b10;
}
function getDPR$1(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR$1(element, value) {
  const dpr = getDPR$1(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef$1(value) {
  const ref = reactExports.useRef(value);
  index$1(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual$1(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef$1(whileElementsMounted);
  const platformRef = useLatestRef$1(platform2);
  const openRef = useLatestRef$1(open);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition$2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual$1(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index$1(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$1(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x10 = roundByDPR$1(elements.floating, data.x);
    const y10 = roundByDPR$1(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x10 + "px, " + y10 + "px)",
        ...getDPR$1(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x10,
      top: y10
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$5({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$5({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset$3 = (options, deps) => ({
  ...offset$4(options),
  options: [options, deps]
});
const shift$3 = (options, deps) => ({
  ...shift$4(options),
  options: [options, deps]
});
const limitShift$3 = (options, deps) => ({
  ...limitShift$4(options),
  options: [options, deps]
});
const flip$3 = (options, deps) => ({
  ...flip$4(options),
  options: [options, deps]
});
const size$3 = (options, deps) => ({
  ...size$4(options),
  options: [options, deps]
});
const hide$3 = (options, deps) => ({
  ...hide$4(options),
  options: [options, deps]
});
const arrow$4 = (options, deps) => ({
  ...arrow$1$1(options),
  options: [options, deps]
});
var NODES$5 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive$5 = NODES$5.reduce((primitive, node) => {
  const Slot2 = /* @__PURE__ */ createSlot(`Primitive.${node}`);
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
var NAME$2 = "Arrow";
var Arrow$3 = reactExports.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive$5.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$3.displayName = NAME$2;
var Root$3 = Arrow$3;
function useCallbackRef$2(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => {
    var _a2;
    return (_a2 = callbackRef.current) == null ? void 0 : _a2.call(callbackRef, ...args);
  }, []);
}
function useSize$1(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
var POPPER_NAME$1 = "Popper";
var [createPopperContext$1, createPopperScope$1] = createContextScope$3(POPPER_NAME$1);
var [PopperProvider$1, usePopperContext$1] = createPopperContext$1(POPPER_NAME$1);
var Popper$1 = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider$1, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper$1.displayName = POPPER_NAME$1;
var ANCHOR_NAME$2 = "PopperAnchor";
var PopperAnchor$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext$1(ANCHOR_NAME$2, __scopePopper);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$5.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor$1.displayName = ANCHOR_NAME$2;
var CONTENT_NAME$5 = "PopperContent";
var [PopperContentProvider$1, useContentContext$1] = createPopperContext$1(CONTENT_NAME$5);
var PopperContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext$1(CONTENT_NAME$5, __scopePopper);
    const [content, setContent] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow2, setArrow] = reactExports.useState(null);
    const arrowSize = useSize$1(arrow2);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull$1),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating$1({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate$1(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset$3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift$3({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift$3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip$3({ ...detectOverflowOptions }),
        size$3({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow2 && arrow$4({ element: arrow2, padding: arrowPadding }),
        transformOrigin$1({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide$3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement$1(placement);
    const handlePlaced = useCallbackRef$2(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a2 = middlewareData.arrow) == null ? void 0 : _a2.x;
    const arrowY = (_b2 = middlewareData.arrow) == null ? void 0 : _b2.y;
    const cannotCenterArrow = ((_c2 = middlewareData.arrow) == null ? void 0 : _c2.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = reactExports.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d2 = middlewareData.transformOrigin) == null ? void 0 : _d2.x,
            (_e2 = middlewareData.transformOrigin) == null ? void 0 : _e2.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f2 = middlewareData.hide) == null ? void 0 : _f2.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider$1,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive$5.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent$1.displayName = CONTENT_NAME$5;
var ARROW_NAME$3 = "PopperArrow";
var OPPOSITE_SIDE$1 = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow$1 = reactExports.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext$1(ARROW_NAME$3, __scopePopper);
  const baseSide = OPPOSITE_SIDE$1[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$3,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow$1.displayName = ARROW_NAME$3;
function isNotNull$1(value) {
  return value !== null;
}
var transformOrigin$1 = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a2, _b2, _c2;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a2 = middlewareData.arrow) == null ? void 0 : _a2.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement$1(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b2 = middlewareData.arrow) == null ? void 0 : _b2.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c2 = middlewareData.arrow) == null ? void 0 : _c2.y) ?? 0) + arrowHeight / 2;
    let x10 = "";
    let y10 = "";
    if (placedSide === "bottom") {
      x10 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y10 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x10 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y10 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x10 = `${-arrowHeight}px`;
      y10 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x10 = `${rects.floating.width + arrowHeight}px`;
      y10 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x10, y: y10 } };
  }
});
function getSideAndAlignFromPlacement$1(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$3 = Popper$1;
var Anchor$1 = PopperAnchor$1;
var Content$2 = PopperContent$1;
var Arrow$2 = PopperArrow$1;
var NODES$4 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive$4 = NODES$4.reduce((primitive, node) => {
  const Slot2 = /* @__PURE__ */ createSlot(`Primitive.${node}`);
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
var PORTAL_NAME$4 = "Portal";
var Portal$1 = reactExports.forwardRef((props, forwardedRef) => {
  var _a2;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = reactExports.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a2 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a2.body);
  return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$4.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$1.displayName = PORTAL_NAME$4;
function useStateMachine(initialState2, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState2);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef(null);
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState2 = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState2, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: reactExports.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef(element) {
  var _a2, _b2;
  let getter = (_a2 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a2.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b2 = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b2.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var useInsertionEffect$2 = React[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
function useControllableState$2({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState$2({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  {
    const isControlledRef = reactExports.useRef(prop !== void 0);
    reactExports.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = reactExports.useCallback(
    (nextValue) => {
      var _a2;
      if (isControlled) {
        const value2 = isFunction$2(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          (_a2 = onChangeRef.current) == null ? void 0 : _a2.call(onChangeRef, value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState$2({
  defaultProp,
  onChange
}) {
  const [value, setValue] = reactExports.useState(defaultProp);
  const prevValueRef = reactExports.useRef(value);
  const onChangeRef = reactExports.useRef(onChange);
  useInsertionEffect$2(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  reactExports.useEffect(() => {
    var _a2;
    if (prevValueRef.current !== value) {
      (_a2 = onChangeRef.current) == null ? void 0 : _a2.call(onChangeRef, value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction$2(value) {
  return typeof value === "function";
}
var NODES$3 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive$3 = NODES$3.reduce((primitive, node) => {
  const Slot2 = /* @__PURE__ */ createSlot(`Primitive.${node}`);
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME$1 = "VisuallyHidden";
var VisuallyHidden = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$3.span,
      {
        ...props,
        ref: forwardedRef,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
      }
    );
  }
);
VisuallyHidden.displayName = NAME$1;
var Root$2 = VisuallyHidden;
var [createTooltipContext, createTooltipScope] = createContextScope$3("Tooltip", [
  createPopperScope$1
]);
var usePopperScope$1 = createPopperScope$1();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const isOpenDelayedRef = reactExports.useRef(true);
  const isPointerInTransitRef = reactExports.useRef(false);
  const skipDelayTimerRef = reactExports.useRef(0);
  reactExports.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayedRef,
      delayDuration,
      onOpen: reactExports.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        isOpenDelayedRef.current = false;
      }, []),
      onClose: reactExports.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => isOpenDelayedRef.current = true,
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: reactExports.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope$1(__scopeTooltip);
  const [trigger2, setTrigger] = reactExports.useState(null);
  const contentId = useId();
  const openTimerRef = reactExports.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = reactExports.useRef(false);
  const [open, setOpen] = useControllableState$2({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange == null ? void 0 : onOpenChange(open2);
    },
    caller: TOOLTIP_NAME
  });
  const stateAttribute = reactExports.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  reactExports.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$3, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger: trigger2,
      onTriggerChange: setTrigger,
      onTriggerEnter: reactExports.useCallback(() => {
        if (providerContext.isOpenDelayedRef.current) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
      onTriggerLeave: reactExports.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip.displayName = TOOLTIP_NAME;
var TRIGGER_NAME$3 = "TooltipTrigger";
var TooltipTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME$3, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME$3, __scopeTooltip);
    const popperScope = usePopperScope$1(__scopeTooltip);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = reactExports.useRef(false);
    const hasPointerMoveOpenedRef = reactExports.useRef(false);
    const handlePointerUp = reactExports.useCallback(() => isPointerDownRef.current = false, []);
    reactExports.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor$1, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$5.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers$4(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers$4(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers$4(props.onPointerDown, () => {
          if (context.open) {
            context.onClose();
          }
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers$4(props.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers$4(props.onBlur, context.onClose),
        onClick: composeEventHandlers$4(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME$3;
var PORTAL_NAME$3 = "TooltipPortal";
var [PortalProvider$2, usePortalContext$2] = createTooltipContext(PORTAL_NAME$3, {
  forceMount: void 0
});
var CONTENT_NAME$4 = "TooltipContent";
var TooltipContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$4, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME$4, props.__scopeTooltip);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = reactExports.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME$4, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME$4, props.__scopeTooltip);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = reactExports.useState(null);
  const { trigger: trigger2, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = reactExports.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = reactExports.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  reactExports.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  reactExports.useEffect(() => {
    if (trigger2 && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger2);
      trigger2.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger2.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger2, content, handleCreateGraceArea, handleRemoveGraceArea]);
  reactExports.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = (trigger2 == null ? void 0 : trigger2.contains(target)) || (content == null ? void 0 : content.contains(target));
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger2, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var Slottable$1 = /* @__PURE__ */ createSlottable("TooltipContent");
var TooltipContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME$4, __scopeTooltip);
    const popperScope = usePopperScope$1(__scopeTooltip);
    const { onClose } = context;
    reactExports.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    reactExports.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target == null ? void 0 : target.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Content$2,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable$1, { children }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root$2, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME$4;
var ARROW_NAME$2 = "TooltipArrow";
var TooltipArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope$1(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME$2,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow$2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME$2;
function getExitSideFromRect(point, rect) {
  const top2 = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top2, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top2:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top: top2, right, bottom, left } = rect;
  return [
    { x: left, y: top2 },
    { x: right, y: top2 },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x: x10, y: y10 } = point;
  let inside = false;
  for (let i10 = 0, j10 = polygon.length - 1; i10 < polygon.length; j10 = i10++) {
    const ii2 = polygon[i10];
    const jj2 = polygon[j10];
    const xi2 = ii2.x;
    const yi2 = ii2.y;
    const xj2 = jj2.x;
    const yj2 = jj2.y;
    const intersect = yi2 > y10 !== yj2 > y10 && x10 < (xj2 - xi2) * (y10 - yi2) / (yj2 - yi2) + xi2;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a10, b10) => {
    if (a10.x < b10.x) return -1;
    else if (a10.x > b10.x) return 1;
    else if (a10.y < b10.y) return -1;
    else if (a10.y > b10.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i10 = 0; i10 < points.length; i10++) {
    const p10 = points[i10];
    while (upperHull.length >= 2) {
      const q10 = upperHull[upperHull.length - 1];
      const r10 = upperHull[upperHull.length - 2];
      if ((q10.x - r10.x) * (p10.y - r10.y) >= (q10.y - r10.y) * (p10.x - r10.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p10);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i10 = points.length - 1; i10 >= 0; i10--) {
    const p10 = points[i10];
    while (lowerHull.length >= 2) {
      const q10 = lowerHull[lowerHull.length - 1];
      const r10 = lowerHull[lowerHull.length - 2];
      if ((q10.x - r10.x) * (p10.y - r10.y) >= (q10.y - r10.y) * (p10.x - r10.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p10);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider = TooltipProvider;
var Root3 = Tooltip;
var Trigger$2 = TooltipTrigger;
var Content2$2 = TooltipContent;
var Arrow2 = TooltipArrow;
var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
function addEvent(object, event, method, useCapture) {
  if (object.addEventListener) {
    object.addEventListener(event, method, useCapture);
  } else if (object.attachEvent) {
    object.attachEvent("on".concat(event), function() {
      method(window.event);
    });
  }
}
function getMods(modifier, key) {
  var mods = key.slice(0, key.length - 1);
  for (var i10 = 0; i10 < mods.length; i10++) {
    mods[i10] = modifier[mods[i10].toLowerCase()];
  }
  return mods;
}
function getKeys(key) {
  if (typeof key !== "string") key = "";
  key = key.replace(/\s/g, "");
  var keys = key.split(",");
  var index2 = keys.lastIndexOf("");
  for (; index2 >= 0; ) {
    keys[index2 - 1] += ",";
    keys.splice(index2, 1);
    index2 = keys.lastIndexOf("");
  }
  return keys;
}
function compareArray(a12, a22) {
  var arr1 = a12.length >= a22.length ? a12 : a22;
  var arr2 = a12.length >= a22.length ? a22 : a12;
  var isIndex = true;
  for (var i10 = 0; i10 < arr1.length; i10++) {
    if (arr2.indexOf(arr1[i10]) === -1) isIndex = false;
  }
  return isIndex;
}
var _keyMap = {
  backspace: 8,
  tab: 9,
  clear: 12,
  enter: 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": isff ? 173 : 189,
  "=": isff ? 61 : 187,
  ";": isff ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
};
var _modifier = {
  // shiftKey
  "": 16,
  shift: 16,
  // altKey
  "": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "": 91,
  cmd: 91,
  command: 91
};
var modifierMap = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
var _mods = {
  16: false,
  18: false,
  17: false,
  91: false
};
var _handlers = {};
for (var k$1 = 1; k$1 < 20; k$1++) {
  _keyMap["f".concat(k$1)] = 111 + k$1;
}
var _downKeys = [];
var winListendFocus = false;
var _scope = "all";
var elementHasBindEvent = [];
var code = function code2(x10) {
  return _keyMap[x10.toLowerCase()] || _modifier[x10.toLowerCase()] || x10.toUpperCase().charCodeAt(0);
};
function setScope(scope) {
  _scope = scope || "all";
}
function getScope() {
  return _scope || "all";
}
function getPressedKeyCodes() {
  return _downKeys.slice(0);
}
function filter(event) {
  var target = event.target || event.srcElement;
  var tagName = target.tagName;
  var flag = true;
  if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
    flag = false;
  }
  return flag;
}
function isPressed(keyCode) {
  if (typeof keyCode === "string") {
    keyCode = code(keyCode);
  }
  return _downKeys.indexOf(keyCode) !== -1;
}
function deleteScope(scope, newScope) {
  var handlers;
  var i10;
  if (!scope) scope = getScope();
  for (var key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers = _handlers[key];
      for (i10 = 0; i10 < handlers.length; ) {
        if (handlers[i10].scope === scope) handlers.splice(i10, 1);
        else i10++;
      }
    }
  }
  if (getScope() === scope) setScope(newScope || "all");
}
function clearModifier(event) {
  var key = event.keyCode || event.which || event.charCode;
  var i10 = _downKeys.indexOf(key);
  if (i10 >= 0) {
    _downKeys.splice(i10, 1);
  }
  if (event.key && event.key.toLowerCase() === "meta") {
    _downKeys.splice(0, _downKeys.length);
  }
  if (key === 93 || key === 224) key = 91;
  if (key in _mods) {
    _mods[key] = false;
    for (var k10 in _modifier) {
      if (_modifier[k10] === key) hotkeys[k10] = false;
    }
  }
}
function unbind(keysInfo) {
  if (typeof keysInfo === "undefined") {
    Object.keys(_handlers).forEach(function(key) {
      return delete _handlers[key];
    });
  } else if (Array.isArray(keysInfo)) {
    keysInfo.forEach(function(info) {
      if (info.key) eachUnbind(info);
    });
  } else if (typeof keysInfo === "object") {
    if (keysInfo.key) eachUnbind(keysInfo);
  } else if (typeof keysInfo === "string") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var scope = args[0], method = args[1];
    if (typeof scope === "function") {
      method = scope;
      scope = "";
    }
    eachUnbind({
      key: keysInfo,
      scope,
      method,
      splitKey: "+"
    });
  }
}
var eachUnbind = function eachUnbind2(_ref) {
  var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
  var multipleKeys = getKeys(key);
  multipleKeys.forEach(function(originKey) {
    var unbindKeys = originKey.split(splitKey);
    var len = unbindKeys.length;
    var lastKey = unbindKeys[len - 1];
    var keyCode = lastKey === "*" ? "*" : code(lastKey);
    if (!_handlers[keyCode]) return;
    if (!scope) scope = getScope();
    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
    _handlers[keyCode] = _handlers[keyCode].filter(function(record) {
      var isMatchingMethod = method ? record.method === method : true;
      return !(isMatchingMethod && record.scope === scope && compareArray(record.mods, mods));
    });
  });
};
function eventHandler(event, handler, scope, element) {
  if (handler.element !== element) {
    return;
  }
  var modifiersMatch;
  if (handler.scope === scope || handler.scope === "all") {
    modifiersMatch = handler.mods.length > 0;
    for (var y10 in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y10)) {
        if (!_mods[y10] && handler.mods.indexOf(+y10) > -1 || _mods[y10] && handler.mods.indexOf(+y10) === -1) {
          modifiersMatch = false;
        }
      }
    }
    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
      if (handler.method(event, handler) === false) {
        if (event.preventDefault) event.preventDefault();
        else event.returnValue = false;
        if (event.stopPropagation) event.stopPropagation();
        if (event.cancelBubble) event.cancelBubble = true;
      }
    }
  }
}
function dispatch(event, element) {
  var asterisk = _handlers["*"];
  var key = event.keyCode || event.which || event.charCode;
  if (!hotkeys.filter.call(this, event)) return;
  if (key === 93 || key === 224) key = 91;
  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);
  ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
    var keyNum = modifierMap[keyName];
    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum);
    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
    } else if (keyName === "metaKey" && event[keyName] && _downKeys.length === 3) {
      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
      }
    }
  });
  if (key in _mods) {
    _mods[key] = true;
    for (var k10 in _modifier) {
      if (_modifier[k10] === key) hotkeys[k10] = true;
    }
    if (!asterisk) return;
  }
  for (var e10 in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e10)) {
      _mods[e10] = event[modifierMap[e10]];
    }
  }
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
    if (_downKeys.indexOf(17) === -1) {
      _downKeys.push(17);
    }
    if (_downKeys.indexOf(18) === -1) {
      _downKeys.push(18);
    }
    _mods[17] = true;
    _mods[18] = true;
  }
  var scope = getScope();
  if (asterisk) {
    for (var i10 = 0; i10 < asterisk.length; i10++) {
      if (asterisk[i10].scope === scope && (event.type === "keydown" && asterisk[i10].keydown || event.type === "keyup" && asterisk[i10].keyup)) {
        eventHandler(event, asterisk[i10], scope, element);
      }
    }
  }
  if (!(key in _handlers)) return;
  for (var _i2 = 0; _i2 < _handlers[key].length; _i2++) {
    if (event.type === "keydown" && _handlers[key][_i2].keydown || event.type === "keyup" && _handlers[key][_i2].keyup) {
      if (_handlers[key][_i2].key) {
        var record = _handlers[key][_i2];
        var splitKey = record.splitKey;
        var keyShortcut = record.key.split(splitKey);
        var _downKeysCurrent = [];
        for (var a10 = 0; a10 < keyShortcut.length; a10++) {
          _downKeysCurrent.push(code(keyShortcut[a10]));
        }
        if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
          eventHandler(event, record, scope, element);
        }
      }
    }
  }
}
function isElementBind(element) {
  return elementHasBindEvent.indexOf(element) > -1;
}
function hotkeys(key, option, method) {
  _downKeys = [];
  var keys = getKeys(key);
  var mods = [];
  var scope = "all";
  var element = document;
  var i10 = 0;
  var keyup = false;
  var keydown = true;
  var splitKey = "+";
  var capture = false;
  if (method === void 0 && typeof option === "function") {
    method = option;
  }
  if (Object.prototype.toString.call(option) === "[object Object]") {
    if (option.scope) scope = option.scope;
    if (option.element) element = option.element;
    if (option.keyup) keyup = option.keyup;
    if (option.keydown !== void 0) keydown = option.keydown;
    if (option.capture !== void 0) capture = option.capture;
    if (typeof option.splitKey === "string") splitKey = option.splitKey;
  }
  if (typeof option === "string") scope = option;
  for (; i10 < keys.length; i10++) {
    key = keys[i10].split(splitKey);
    mods = [];
    if (key.length > 1) mods = getMods(_modifier, key);
    key = key[key.length - 1];
    key = key === "*" ? "*" : code(key);
    if (!(key in _handlers)) _handlers[key] = [];
    _handlers[key].push({
      keyup,
      keydown,
      scope,
      mods,
      shortcut: keys[i10],
      method,
      key: keys[i10],
      splitKey,
      element
    });
  }
  if (typeof element !== "undefined" && !isElementBind(element) && window) {
    elementHasBindEvent.push(element);
    addEvent(element, "keydown", function(e10) {
      dispatch(e10, element);
    }, capture);
    if (!winListendFocus) {
      winListendFocus = true;
      addEvent(window, "focus", function() {
        _downKeys = [];
      }, capture);
    }
    addEvent(element, "keyup", function(e10) {
      dispatch(e10, element);
      clearModifier(e10);
    }, capture);
  }
}
function trigger(shortcut) {
  var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(_handlers).forEach(function(key) {
    var data = _handlers[key].find(function(item) {
      return item.scope === scope && item.shortcut === shortcut;
    });
    if (data && data.method) {
      data.method();
    }
  });
}
var _api = {
  setScope,
  getScope,
  deleteScope,
  getPressedKeyCodes,
  isPressed,
  filter,
  trigger,
  unbind,
  keyMap: _keyMap,
  modifier: _modifier,
  modifierMap
};
for (var a$1 in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a$1)) {
    hotkeys[a$1] = _api[a$1];
  }
}
if (typeof window !== "undefined") {
  var _hotkeys = window.hotkeys;
  hotkeys.noConflict = function(deep) {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys;
    }
    return hotkeys;
  };
  window.hotkeys = hotkeys;
}
hotkeys.filter = function() {
  return true;
};
var tagFilter = function tagFilter2(_ref, enableOnTags) {
  var target = _ref.target;
  var targetTagName = target && target.tagName;
  return Boolean(targetTagName && enableOnTags && enableOnTags.includes(targetTagName));
};
var isKeyboardEventTriggeredByInput = function isKeyboardEventTriggeredByInput2(ev2) {
  return tagFilter(ev2, ["INPUT", "TEXTAREA", "SELECT"]);
};
function useHotkeys(keys, callback, options, deps) {
  if (options instanceof Array) {
    deps = options;
    options = void 0;
  }
  var _ref2 = options || {}, enableOnTags = _ref2.enableOnTags, filter2 = _ref2.filter, keyup = _ref2.keyup, keydown = _ref2.keydown, _ref2$filterPreventDe = _ref2.filterPreventDefault, filterPreventDefault = _ref2$filterPreventDe === void 0 ? true : _ref2$filterPreventDe, _ref2$enabled = _ref2.enabled, enabled = _ref2$enabled === void 0 ? true : _ref2$enabled, _ref2$enableOnContent = _ref2.enableOnContentEditable, enableOnContentEditable = _ref2$enableOnContent === void 0 ? false : _ref2$enableOnContent;
  var ref = reactExports.useRef(null);
  var memoisedCallback = reactExports.useCallback(function(keyboardEvent, hotkeysEvent) {
    var _keyboardEvent$target, _ref$current;
    if (filter2 && !filter2(keyboardEvent)) {
      return !filterPreventDefault;
    }
    if (isKeyboardEventTriggeredByInput(keyboardEvent) && !tagFilter(keyboardEvent, enableOnTags) || (_keyboardEvent$target = keyboardEvent.target) != null && _keyboardEvent$target.isContentEditable && !enableOnContentEditable) {
      return true;
    }
    if (ref.current === null || document.activeElement === ref.current || (_ref$current = ref.current) != null && _ref$current.contains(document.activeElement)) {
      callback(keyboardEvent, hotkeysEvent);
      return true;
    }
    return false;
  }, deps ? [ref, enableOnTags, filter2].concat(deps) : [ref, enableOnTags, filter2]);
  reactExports.useEffect(function() {
    if (!enabled) {
      hotkeys.unbind(keys, memoisedCallback);
      return;
    }
    if (keyup && keydown !== true) {
      options.keydown = false;
    }
    hotkeys(keys, options || {}, memoisedCallback);
    return function() {
      return hotkeys.unbind(keys, memoisedCallback);
    };
  }, [memoisedCallback, keys, enabled]);
  return ref;
}
hotkeys.isPressed;
function createContextScope$2(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      var _a2;
      const { scope, children, ...context } = props;
      const Context2 = ((_a2 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a2[index2]) || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context2.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      var _a2;
      const Context2 = ((_a2 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a2[index2]) || BaseContext;
      const context = reactExports.useContext(Context2);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes$2(createScope, ...createContextScopeDeps)];
}
function composeContextScopes$2(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function composeEventHandlers$2(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
function createContext2(rootComponentName, defaultContext) {
  const Context2 = reactExports.createContext(defaultContext);
  const Provider2 = (props) => {
    const { children, ...context } = props;
    const value = reactExports.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context2.Provider, { value, children });
  };
  Provider2.displayName = rootComponentName + "Provider";
  function useContext2(consumerName) {
    const context = reactExports.useContext(Context2);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider2, useContext2];
}
function createContextScope$1(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      var _a2;
      const { scope, children, ...context } = props;
      const Context2 = ((_a2 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a2[index2]) || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context2.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      var _a2;
      const Context2 = ((_a2 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a2[index2]) || BaseContext;
      const context = reactExports.useContext(Context2);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes$1(createScope, ...createContextScopeDeps)];
}
function composeContextScopes$1(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
var useInsertionEffect$1 = React[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
function useControllableState$1({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState$1({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  {
    const isControlledRef = reactExports.useRef(prop !== void 0);
    reactExports.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = reactExports.useCallback(
    (nextValue) => {
      var _a2;
      if (isControlled) {
        const value2 = isFunction$1(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          (_a2 = onChangeRef.current) == null ? void 0 : _a2.call(onChangeRef, value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState$1({
  defaultProp,
  onChange
}) {
  const [value, setValue] = reactExports.useState(defaultProp);
  const prevValueRef = reactExports.useRef(value);
  const onChangeRef = reactExports.useRef(onChange);
  useInsertionEffect$1(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  reactExports.useEffect(() => {
    var _a2;
    if (prevValueRef.current !== value) {
      (_a2 = onChangeRef.current) == null ? void 0 : _a2.call(onChangeRef, value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction$1(value) {
  return typeof value === "function";
}
var NODES$2 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive$2 = NODES$2.reduce((primitive, node) => {
  const Slot2 = /* @__PURE__ */ createSlot(`Primitive.${node}`);
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function useCallbackRef$1(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => {
    var _a2;
    return (_a2 = callbackRef.current) == null ? void 0 : _a2.call(callbackRef, ...args);
  }, []);
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = reactExports.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  reactExports.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = reactExports.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$2.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a2;
      stack = arrayRemove(stack, focusScope);
      (_a2 = stack[0]) == null ? void 0 : _a2.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var NODES$1 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive$1 = NODES$1.reduce((primitive, node) => {
  const Slot2 = /* @__PURE__ */ createSlot(`Primitive.${node}`);
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
var count = 0;
function useFocusGuards() {
  reactExports.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count++;
    return () => {
      if (count === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a2 = reactExports.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b2 = props.as, Container = _b2 === void 0 ? "div" : _b2, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables(axis, current), scrollHeight = _a2[1], clientHeight = _a2[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a2 = getScrollVariables(axis, target), position = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode.host || target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x10, y10) {
  return x10[0] === y10[0] && x10[1] === y10[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id = reactExports.useState(idCounter++)[0];
  var Style2 = reactExports.useState(styleSingleton)[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e10) {
      return e10.name === event.type && (e10.target === event.target || event.target === e10.shadowParent) && deltaCompare(e10.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e10) {
        return e10 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope$1(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = reactExports.useRef(null);
  const contentRef = reactExports.useRef(null);
  const [open, setOpen] = useControllableState$1({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME$2 = "DialogTrigger";
var DialogTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME$2, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState$1(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers$2(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME$2;
var PORTAL_NAME$2 = "DialogPortal";
var [PortalProvider$1, usePortalContext$1] = createDialogContext(PORTAL_NAME$2, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME$2, __scopeDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$1, { scope: __scopeDialog, forceMount, children: reactExports.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME$2;
var OVERLAY_NAME$1 = "DialogOverlay";
var DialogOverlay = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(OVERLAY_NAME$1, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME$1, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME$1;
var Slot$1 = /* @__PURE__ */ createSlot("DialogOverlay.RemoveScroll");
var DialogOverlayImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME$1, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot$1, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive$1.div,
        {
          "data-state": getState$1(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME$3 = "DialogContent";
var DialogContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(CONTENT_NAME$3, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME$3;
var DialogContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    reactExports.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers$2(props.onCloseAutoFocus, (event) => {
          var _a2;
          event.preventDefault();
          (_a2 = context.triggerRef.current) == null ? void 0 : _a2.focus();
        }),
        onPointerDownOutside: composeEventHandlers$2(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers$2(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a2, _b2;
          (_a2 = props.onCloseAutoFocus) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b2 = context.triggerRef.current) == null ? void 0 : _b2.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a2, _b2;
          (_a2 = props.onInteractOutside) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b2 = context.triggerRef.current) == null ? void 0 : _b2.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$3, __scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState$1(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning$1, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME$1 = "DialogTitle";
var DialogTitle = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME$1;
var DESCRIPTION_NAME$1 = "DialogDescription";
var DialogDescription = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME$1;
var CLOSE_NAME$1 = "DialogClose";
var DialogClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers$2(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME$1;
function getState$1(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME$3,
  titleName: TITLE_NAME$1,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  reactExports.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning$1 = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  reactExports.useEffect(() => {
    var _a2;
    const describedById = (_a2 = contentRef.current) == null ? void 0 : _a2.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root$1 = Dialog;
var Trigger$1 = DialogTrigger;
var Portal = DialogPortal;
var Overlay = DialogOverlay;
var Content$1 = DialogContent;
var Title = DialogTitle;
var Description = DialogDescription;
var Close = DialogClose;
function composeEventHandlers$1(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
var ROOT_NAME = "AlertDialog";
var [createAlertDialogContext, createAlertDialogScope] = createContextScope$2(ROOT_NAME, [
  createDialogScope
]);
var useDialogScope = createDialogScope();
var AlertDialog = (props) => {
  const { __scopeAlertDialog, ...alertDialogProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root$1, { ...dialogScope, ...alertDialogProps, modal: true });
};
AlertDialog.displayName = ROOT_NAME;
var TRIGGER_NAME$1 = "AlertDialogTrigger";
var AlertDialogTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...triggerProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$1, { ...dialogScope, ...triggerProps, ref: forwardedRef });
  }
);
AlertDialogTrigger.displayName = TRIGGER_NAME$1;
var PORTAL_NAME$1 = "AlertDialogPortal";
var AlertDialogPortal = (props) => {
  const { __scopeAlertDialog, ...portalProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { ...dialogScope, ...portalProps });
};
AlertDialogPortal.displayName = PORTAL_NAME$1;
var OVERLAY_NAME = "AlertDialogOverlay";
var AlertDialogOverlay = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...overlayProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay, { ...dialogScope, ...overlayProps, ref: forwardedRef });
  }
);
AlertDialogOverlay.displayName = OVERLAY_NAME;
var CONTENT_NAME$2 = "AlertDialogContent";
var [AlertDialogContentProvider, useAlertDialogContentContext] = createAlertDialogContext(CONTENT_NAME$2);
var Slottable = /* @__PURE__ */ createSlottable("AlertDialogContent");
var AlertDialogContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, children, ...contentProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const cancelRef = reactExports.useRef(null);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      WarningProvider,
      {
        contentName: CONTENT_NAME$2,
        titleName: TITLE_NAME,
        docsSlug: "alert-dialog",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDialogContentProvider, { scope: __scopeAlertDialog, cancelRef, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Content$1,
          {
            role: "alertdialog",
            ...dialogScope,
            ...contentProps,
            ref: composedRefs,
            onOpenAutoFocus: composeEventHandlers$1(contentProps.onOpenAutoFocus, (event) => {
              var _a2;
              event.preventDefault();
              (_a2 = cancelRef.current) == null ? void 0 : _a2.focus({ preventScroll: true });
            }),
            onPointerDownOutside: (event) => event.preventDefault(),
            onInteractOutside: (event) => event.preventDefault(),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable, { children }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef })
            ]
          }
        ) })
      }
    );
  }
);
AlertDialogContent.displayName = CONTENT_NAME$2;
var TITLE_NAME = "AlertDialogTitle";
var AlertDialogTitle = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...titleProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Title, { ...dialogScope, ...titleProps, ref: forwardedRef });
  }
);
AlertDialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "AlertDialogDescription";
var AlertDialogDescription = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeAlertDialog, ...descriptionProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Description, { ...dialogScope, ...descriptionProps, ref: forwardedRef });
});
AlertDialogDescription.displayName = DESCRIPTION_NAME;
var ACTION_NAME = "AlertDialogAction";
var AlertDialogAction = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...actionProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Close, { ...dialogScope, ...actionProps, ref: forwardedRef });
  }
);
AlertDialogAction.displayName = ACTION_NAME;
var CANCEL_NAME = "AlertDialogCancel";
var AlertDialogCancel = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...cancelProps } = props;
    const { cancelRef } = useAlertDialogContentContext(CANCEL_NAME, __scopeAlertDialog);
    const dialogScope = useDialogScope(__scopeAlertDialog);
    const ref = useComposedRefs(forwardedRef, cancelRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Close, { ...dialogScope, ...cancelProps, ref });
  }
);
AlertDialogCancel.displayName = CANCEL_NAME;
var DescriptionWarning = ({ contentRef }) => {
  const MESSAGE = `\`${CONTENT_NAME$2}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${CONTENT_NAME$2}\` by passing a \`${DESCRIPTION_NAME}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${CONTENT_NAME$2}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`;
  reactExports.useEffect(() => {
    var _a2;
    const hasDescription = document.getElementById(
      (_a2 = contentRef.current) == null ? void 0 : _a2.getAttribute("aria-describedby")
    );
    if (!hasDescription) console.warn(MESSAGE);
  }, [MESSAGE, contentRef]);
  return null;
};
var Root2$2 = AlertDialog;
var Trigger2 = AlertDialogTrigger;
var Portal2 = AlertDialogPortal;
var Overlay2 = AlertDialogOverlay;
var Content2$1 = AlertDialogContent;
var Action = AlertDialogAction;
var Cancel = AlertDialogCancel;
var Description2 = AlertDialogDescription;
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      var _a2;
      const { scope, children, ...context } = props;
      const Context2 = ((_a2 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a2[index2]) || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context2.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      var _a2;
      const Context2 = ((_a2 = scope == null ? void 0 : scope[scopeName]) == null ? void 0 : _a2[index2]) || BaseContext;
      const context = reactExports.useContext(Context2);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x10,
    y: y10
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i10 = 0; i10 < validMiddleware.length; i10++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i10];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x: x10,
      y: y10,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x10 = nextX != null ? nextX : x10;
    y10 = nextY != null ? nextY : y10;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x10,
          y: y10
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i10 = -1;
    }
  }
  return {
    x: x10,
    y: y10,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x10,
    y: y10,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x10,
    y: y10,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x10,
      y: y10,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x10,
      y: y10
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          var _overflowsData$;
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
          if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d10) => d10.overflows[0] <= 0).sort((a10, b10) => a10.overflows[1] - b10.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d10) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d10.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d10) => [d10.placement, d10.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a10, b10) => a10[1] - b10[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x10,
        y: y10,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x10 + diffCoords.x,
        y: y10 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x10,
        y: y10,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x11,
              y: y11
            } = _ref;
            return {
              x: x11,
              y: y11
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x10,
        y: y10
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x10,
          y: limitedCoords.y - y10,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x10,
        y: y10,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x10,
        y: y10
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $10
  } = getCssDimensions(domElement);
  let x10 = ($10 ? round(rect.width) : rect.width) / width;
  let y10 = ($10 ? round(rect.height) : rect.height) / height;
  if (!x10 || !Number.isFinite(x10)) {
    x10 = 1;
  }
  if (!y10 || !Number.isFinite(y10)) {
    y10 = 1;
  }
  return {
    x: x10,
    y: y10
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x10 = (clientRect.left + visualOffsets.x) / scale.x;
  let y10 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top2 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x10 *= iframeScale.x;
      y10 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x10 += left;
      y10 += top2;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x10,
    y: y10
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x10 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y10 = htmlRect.top + scroll.scrollTop;
  return {
    x: x10,
    y: y10
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x10 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y10 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x10 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x10,
    y: y10
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x10 = 0;
  let y10 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x10 = visualViewport.offsetLeft;
      y10 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x10,
    y: y10
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top2 = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x10 = left * scale.x;
  const y10 = top2 * scale.y;
  return {
    width,
    height,
    x: x10,
    y: y10
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x10 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y10 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x10,
    y: y10,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill2) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill2) {
    return polyfill2(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill2) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill2);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill2);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a10, b10) {
  return a10.x === b10.x && a10.y === b10.y && a10.width === b10.width && a10.height === b10.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top: top2,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top2);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top2 + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$2 = arrow$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual(a10, b10) {
  if (a10 === b10) {
    return true;
  }
  if (typeof a10 !== typeof b10) {
    return false;
  }
  if (typeof a10 === "function" && a10.toString() === b10.toString()) {
    return true;
  }
  let length;
  let i10;
  let keys;
  if (a10 && b10 && typeof a10 === "object") {
    if (Array.isArray(a10)) {
      length = a10.length;
      if (length !== b10.length) return false;
      for (i10 = length; i10-- !== 0; ) {
        if (!deepEqual(a10[i10], b10[i10])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a10);
    length = keys.length;
    if (length !== Object.keys(b10).length) {
      return false;
    }
    for (i10 = length; i10-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b10, keys[i10])) {
        return false;
      }
    }
    for (i10 = length; i10-- !== 0; ) {
      const key = keys[i10];
      if (key === "_owner" && a10.$$typeof) {
        continue;
      }
      if (!deepEqual(a10[key], b10[key])) {
        return false;
      }
    }
    return true;
  }
  return a10 !== a10 && b10 !== b10;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x10 = roundByDPR(elements.floating, data.x);
    const y10 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x10 + "px, " + y10 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x10,
      top: y10
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot2 = /* @__PURE__ */ createSlot(`Primitive.${node}`);
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
var NAME = "Arrow";
var Arrow$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME;
var Root = Arrow$1;
function useCallbackRef(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => {
    var _a2;
    return (_a2 = callbackRef.current) == null ? void 0 : _a2.call(callbackRef, ...args);
  }, []);
}
function useSize(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME$1 = "PopperAnchor";
var PopperAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME$1, __scopePopper);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      context.onAnchorChange((virtualRef == null ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME$1;
var CONTENT_NAME$1 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$1);
var PopperContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME$1, __scopePopper);
    const [content, setContent] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow$12, setArrow] = reactExports.useState(null);
    const arrowSize = useSize(arrow$12);
    const arrowWidth = (arrowSize == null ? void 0 : arrowSize.width) ?? 0;
    const arrowHeight = (arrowSize == null ? void 0 : arrowSize.height) ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced == null ? void 0 : handlePlaced();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = (_a2 = middlewareData.arrow) == null ? void 0 : _a2.x;
    const arrowY = (_b2 = middlewareData.arrow) == null ? void 0 : _b2.y;
    const cannotCenterArrow = ((_c2 = middlewareData.arrow) == null ? void 0 : _c2.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = reactExports.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            (_d2 = middlewareData.transformOrigin) == null ? void 0 : _d2.x,
            (_e2 = middlewareData.transformOrigin) == null ? void 0 : _e2.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((_f2 = middlewareData.hide) == null ? void 0 : _f2.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$1;
var ARROW_NAME$1 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = reactExports.forwardRef(function PopperArrow22(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$1, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$1;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _a2, _b2, _c2;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_a2 = middlewareData.arrow) == null ? void 0 : _a2.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (((_b2 = middlewareData.arrow) == null ? void 0 : _b2.x) ?? 0) + arrowWidth / 2;
    const arrowYCenter = (((_c2 = middlewareData.arrow) == null ? void 0 : _c2.y) ?? 0) + arrowHeight / 2;
    let x10 = "";
    let y10 = "";
    if (placedSide === "bottom") {
      x10 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y10 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x10 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y10 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x10 = `${-arrowHeight}px`;
      y10 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x10 = `${rects.floating.width + arrowHeight}px`;
      y10 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x10, y: y10 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$1 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow = PopperArrow;
var useInsertionEffect = React[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  {
    const isControlledRef = reactExports.useRef(prop !== void 0);
    reactExports.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = reactExports.useCallback(
    (nextValue) => {
      var _a2;
      if (isControlled) {
        const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          (_a2 = onChangeRef.current) == null ? void 0 : _a2.call(onChangeRef, value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = reactExports.useState(defaultProp);
  const prevValueRef = reactExports.useRef(value);
  const onChangeRef = reactExports.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  reactExports.useEffect(() => {
    var _a2;
    if (prevValueRef.current !== value) {
      (_a2 = onChangeRef.current) == null ? void 0 : _a2.call(onChangeRef, value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction(value) {
  return typeof value === "function";
}
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope(__scopePopover);
  const triggerRef = reactExports.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = reactExports.useState(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: POPOVER_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$1, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: reactExports.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: reactExports.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover.displayName = POPOVER_NAME;
var ANCHOR_NAME = "PopoverAnchor";
var PopoverAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context = usePopoverContext(ANCHOR_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    reactExports.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME;
var TRIGGER_NAME = "PopoverTrigger";
var PopoverTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context = usePopoverContext(TRIGGER_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger2 = /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger2 : /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: trigger2 });
  }
);
PopoverTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME = "PopoverPortal";
var [PortalProvider, usePortalContext] = createPopoverContext(PORTAL_NAME, {
  forceMount: void 0
});
var CONTENT_NAME = "PopoverContent";
var PopoverContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent.displayName = CONTENT_NAME;
var Slot = /* @__PURE__ */ createSlot("PopoverContent.RemoveScroll");
var PopoverContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a2;
          event.preventDefault();
          if (!isRightClickOutsideRef.current) (_a2 = context.triggerRef.current) == null ? void 0 : _a2.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a2, _b2;
          (_a2 = props.onCloseAutoFocus) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b2 = context.triggerRef.current) == null ? void 0 : _b2.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a2, _b2;
          (_a2 = props.onInteractOutside) == null ? void 0 : _a2.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b2 = context.triggerRef.current) == null ? void 0 : _b2.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props;
    const context = usePopoverContext(CONTENT_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Content,
              {
                "data-state": getState(context.open),
                role: "dialog",
                id: context.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME = "PopoverClose";
var PopoverClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = usePopoverContext(CLOSE_NAME, __scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME;
var ARROW_NAME = "PopoverArrow";
var PopoverArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
var Root2 = Popover;
var Anchor2 = PopoverAnchor;
var Trigger = PopoverTrigger;
var Content2 = PopoverContent;
const e = (() => {
  if ("undefined" == typeof self) return false;
  if ("top" in self && self !== top) try {
    top;
  } catch (e10) {
    return false;
  }
  else if ("showOpenFilePicker" in self) return "showOpenFilePicker";
  return false;
})(), t2 = e ? Promise.resolve().then(function() {
  return l$1;
}) : Promise.resolve().then(function() {
  return h;
});
async function n(...e10) {
  return (await t2).default(...e10);
}
const r = e ? Promise.resolve().then(function() {
  return y;
}) : Promise.resolve().then(function() {
  return P;
});
async function i(...e10) {
  return (await r).default(...e10);
}
const a = e ? Promise.resolve().then(function() {
  return m;
}) : Promise.resolve().then(function() {
  return k2;
});
async function o(...e10) {
  return (await a).default(...e10);
}
const s = async (e10) => {
  const t10 = await e10.getFile();
  return t10.handle = e10, t10;
};
var c = async (e10 = [{}]) => {
  Array.isArray(e10) || (e10 = [e10]);
  const t10 = [];
  e10.forEach((e11, n11) => {
    t10[n11] = { description: e11.description || "Files", accept: {} }, e11.mimeTypes ? e11.mimeTypes.map((r11) => {
      t10[n11].accept[r11] = e11.extensions || [];
    }) : t10[n11].accept["*/*"] = e11.extensions || [];
  });
  const n10 = await window.showOpenFilePicker({ id: e10[0].id, startIn: e10[0].startIn, types: t10, multiple: e10[0].multiple || false, excludeAcceptAllOption: e10[0].excludeAcceptAllOption || false }), r10 = await Promise.all(n10.map(s));
  return e10[0].multiple ? r10 : r10[0];
}, l$1 = { __proto__: null, default: c };
function u(e10) {
  function t10(e11) {
    if (Object(e11) !== e11) return Promise.reject(new TypeError(e11 + " is not an object."));
    var t11 = e11.done;
    return Promise.resolve(e11.value).then(function(e12) {
      return { value: e12, done: t11 };
    });
  }
  return u = function(e11) {
    this.s = e11, this.n = e11.next;
  }, u.prototype = { s: null, n: null, next: function() {
    return t10(this.n.apply(this.s, arguments));
  }, return: function(e11) {
    var n10 = this.s.return;
    return void 0 === n10 ? Promise.resolve({ value: e11, done: true }) : t10(n10.apply(this.s, arguments));
  }, throw: function(e11) {
    var n10 = this.s.return;
    return void 0 === n10 ? Promise.reject(e11) : t10(n10.apply(this.s, arguments));
  } }, new u(e10);
}
const p = async (e10, t10, n10 = e10.name, r10) => {
  const i10 = [], a10 = [];
  var o10, s10 = false, c10 = false;
  try {
    for (var l10, d10 = function(e11) {
      var t11, n11, r11, i11 = 2;
      for ("undefined" != typeof Symbol && (n11 = Symbol.asyncIterator, r11 = Symbol.iterator); i11--; ) {
        if (n11 && null != (t11 = e11[n11])) return t11.call(e11);
        if (r11 && null != (t11 = e11[r11])) return new u(t11.call(e11));
        n11 = "@@asyncIterator", r11 = "@@iterator";
      }
      throw new TypeError("Object is not async iterable");
    }(e10.values()); s10 = !(l10 = await d10.next()).done; s10 = false) {
      const o11 = l10.value, s11 = `${n10}/${o11.name}`;
      "file" === o11.kind ? a10.push(o11.getFile().then((t11) => (t11.directoryHandle = e10, t11.handle = o11, Object.defineProperty(t11, "webkitRelativePath", { configurable: true, enumerable: true, get: () => s11 })))) : "directory" !== o11.kind || !t10 || r10 && r10(o11) || i10.push(p(o11, t10, s11, r10));
    }
  } catch (e11) {
    c10 = true, o10 = e11;
  } finally {
    try {
      s10 && null != d10.return && await d10.return();
    } finally {
      if (c10) throw o10;
    }
  }
  return [...(await Promise.all(i10)).flat(), ...await Promise.all(a10)];
};
var d = async (e10 = {}) => {
  e10.recursive = e10.recursive || false, e10.mode = e10.mode || "read";
  const t10 = await window.showDirectoryPicker({ id: e10.id, startIn: e10.startIn, mode: e10.mode });
  return p(t10, e10.recursive, void 0, e10.skipDirectory);
}, y = { __proto__: null, default: d }, f = async (e10, t10 = [{}], n10 = null, r10 = false, i10 = null) => {
  Array.isArray(t10) || (t10 = [t10]), t10[0].fileName = t10[0].fileName || "Untitled";
  const a10 = [];
  let o10 = null;
  if (e10 instanceof Blob && e10.type ? o10 = e10.type : e10.headers && e10.headers.get("content-type") && (o10 = e10.headers.get("content-type")), t10.forEach((e11, t11) => {
    a10[t11] = { description: e11.description || "Files", accept: {} }, e11.mimeTypes ? (0 === t11 && o10 && e11.mimeTypes.push(o10), e11.mimeTypes.map((n11) => {
      a10[t11].accept[n11] = e11.extensions || [];
    })) : o10 ? a10[t11].accept[o10] = e11.extensions || [] : a10[t11].accept["*/*"] = e11.extensions || [];
  }), n10) try {
    await n10.getFile();
  } catch (e11) {
    if (n10 = null, r10) throw e11;
  }
  const s10 = n10 || await window.showSaveFilePicker({ suggestedName: t10[0].fileName, id: t10[0].id, startIn: t10[0].startIn, types: a10, excludeAcceptAllOption: t10[0].excludeAcceptAllOption || false });
  !n10 && i10 && i10(s10);
  const c10 = await s10.createWritable();
  if ("stream" in e10) {
    const t11 = e10.stream();
    return await t11.pipeTo(c10), s10;
  }
  return "body" in e10 ? (await e10.body.pipeTo(c10), s10) : (await c10.write(await e10), await c10.close(), s10);
}, m = { __proto__: null, default: f }, w = async (e10 = [{}]) => (Array.isArray(e10) || (e10 = [e10]), new Promise((t10, n10) => {
  const r10 = document.createElement("input");
  r10.type = "file";
  const i10 = [...e10.map((e11) => e11.mimeTypes || []), ...e10.map((e11) => e11.extensions || [])].join();
  r10.multiple = e10[0].multiple || false, r10.accept = i10 || "", r10.style.display = "none", document.body.append(r10);
  const a10 = (e11) => {
    "function" == typeof o10 && o10(), t10(e11);
  }, o10 = e10[0].legacySetup && e10[0].legacySetup(a10, () => o10(n10), r10), s10 = () => {
    window.removeEventListener("focus", s10), r10.remove();
  };
  r10.addEventListener("click", () => {
    window.addEventListener("focus", s10);
  }), r10.addEventListener("change", () => {
    window.removeEventListener("focus", s10), r10.remove(), a10(r10.multiple ? Array.from(r10.files) : r10.files[0]);
  }), "showPicker" in HTMLInputElement.prototype ? r10.showPicker() : r10.click();
})), h = { __proto__: null, default: w }, v$1 = async (e10 = [{}]) => (Array.isArray(e10) || (e10 = [e10]), e10[0].recursive = e10[0].recursive || false, new Promise((t10, n10) => {
  const r10 = document.createElement("input");
  r10.type = "file", r10.webkitdirectory = true;
  const i10 = (e11) => {
    "function" == typeof a10 && a10(), t10(e11);
  }, a10 = e10[0].legacySetup && e10[0].legacySetup(i10, () => a10(n10), r10);
  r10.addEventListener("change", () => {
    let t11 = Array.from(r10.files);
    e10[0].recursive ? e10[0].recursive && e10[0].skipDirectory && (t11 = t11.filter((t12) => t12.webkitRelativePath.split("/").every((t13) => !e10[0].skipDirectory({ name: t13, kind: "directory" })))) : t11 = t11.filter((e11) => 2 === e11.webkitRelativePath.split("/").length), i10(t11);
  }), "showPicker" in HTMLInputElement.prototype ? r10.showPicker() : r10.click();
})), P = { __proto__: null, default: v$1 }, b = async (e10, t10 = {}) => {
  Array.isArray(t10) && (t10 = t10[0]);
  const n10 = document.createElement("a");
  let r10 = e10;
  "body" in e10 && (r10 = await async function(e11, t11) {
    const n11 = e11.getReader(), r11 = new ReadableStream({ start: (e12) => async function t12() {
      return n11.read().then(({ done: n12, value: r12 }) => {
        if (!n12) return e12.enqueue(r12), t12();
        e12.close();
      });
    }() }), i11 = new Response(r11), a11 = await i11.blob();
    return n11.releaseLock(), new Blob([a11], { type: t11 });
  }(e10.body, e10.headers.get("content-type"))), n10.download = t10.fileName || "Untitled", n10.href = URL.createObjectURL(await r10);
  const i10 = () => {
    "function" == typeof a10 && a10();
  }, a10 = t10.legacySetup && t10.legacySetup(i10, () => a10(), n10);
  return n10.addEventListener("click", () => {
    setTimeout(() => URL.revokeObjectURL(n10.href), 3e4), i10();
  }), n10.click(), null;
}, k2 = { __proto__: null, default: b };
const QDe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  directoryOpen: i,
  directoryOpenLegacy: v$1,
  directoryOpenModern: d,
  fileOpen: n,
  fileOpenLegacy: w,
  fileOpenModern: c,
  fileSave: o,
  fileSaveLegacy: b,
  fileSaveModern: f,
  supported: e
}, Symbol.toStringTag, { value: "Module" }));
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore$1(dbName, storeName) {
  let dbp;
  const getDB = () => {
    if (dbp)
      return dbp;
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    dbp = promisifyRequest(request);
    dbp.then((db2) => {
      db2.onclose = () => dbp = void 0;
    }, () => {
    });
    return dbp;
  };
  return (txMode, callback) => getDB().then((db2) => callback(db2.transaction(storeName, txMode).objectStore(storeName)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore$1("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
const __vite_import_meta_env__$1 = {};
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState2 = () => state;
  const getInitialState = () => initialState2;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState: getState2, getInitialState, subscribe, destroy };
  const initialState2 = state = createState(setState, getState2, api);
  return api;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
var vanilla = (createState) => {
  if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production") {
    console.warn(
      "[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'."
    );
  }
  return createStore(createState);
};
var withSelector = { exports: {} };
var withSelector_production = {};
var shim = { exports: {} };
var useSyncExternalStoreShim_production = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_production;
function requireUseSyncExternalStoreShim_production() {
  if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
  hasRequiredUseSyncExternalStoreShim_production = 1;
  var React2 = requireReact();
  function is2(x10, y10) {
    return x10 === y10 && (0 !== x10 || 1 / x10 === 1 / y10) || x10 !== x10 && y10 !== y10;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is2, useState = React2.useState, useEffect = React2.useEffect, useLayoutEffect = React2.useLayoutEffect, useDebugValue2 = React2.useDebugValue;
  function useSyncExternalStore$2(subscribe, getSnapshot) {
    var value = getSnapshot(), _useState = useState({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
    useLayoutEffect(
      function() {
        inst.value = value;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      },
      [subscribe, value, getSnapshot]
    );
    useEffect(
      function() {
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        });
      },
      [subscribe]
    );
    useDebugValue2(value);
    return value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch (error) {
      return true;
    }
  }
  function useSyncExternalStore$1(subscribe, getSnapshot) {
    return getSnapshot();
  }
  var shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
  useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React2.useSyncExternalStore ? React2.useSyncExternalStore : shim2;
  return useSyncExternalStoreShim_production;
}
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim.exports;
  hasRequiredShim = 1;
  {
    shim.exports = requireUseSyncExternalStoreShim_production();
  }
  return shim.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_production;
function requireWithSelector_production() {
  if (hasRequiredWithSelector_production) return withSelector_production;
  hasRequiredWithSelector_production = 1;
  var React2 = requireReact(), shim2 = requireShim();
  function is2(x10, y10) {
    return x10 === y10 && (0 !== x10 || 1 / x10 === 1 / y10) || x10 !== x10 && y10 !== y10;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore = shim2.useSyncExternalStore, useRef = React2.useRef, useEffect = React2.useEffect, useMemo = React2.useMemo, useDebugValue2 = React2.useDebugValue;
  withSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef(null);
    if (null === instRef.current) {
      var inst = { hasValue: false, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            hasMemo = true;
            memoizedSnapshot = nextSnapshot;
            nextSnapshot = selector(nextSnapshot);
            if (void 0 !== isEqual && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          currentSelection = memoizedSelection;
          if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
            return memoizedSnapshot = nextSnapshot, currentSelection;
          memoizedSnapshot = nextSnapshot;
          return memoizedSelection = nextSelection;
        }
        var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          null === maybeGetServerSnapshot ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector, isEqual]
    );
    var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    useEffect(
      function() {
        inst.hasValue = true;
        inst.value = value;
      },
      [value]
    );
    useDebugValue2(value);
    return value;
  };
  return withSelector_production;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  if (hasRequiredWithSelector) return withSelector.exports;
  hasRequiredWithSelector = 1;
  {
    withSelector.exports = requireWithSelector_production();
  }
  return withSelector.exports;
}
var withSelectorExports = requireWithSelector();
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports);
const __vite_import_meta_env__ = {};
const { useDebugValue } = spe;
const { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;
let didWarnAboutEqualityFn = false;
const identity = (arg) => arg;
function useStore(api, selector = identity, equalityFn) {
  if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice);
  return slice;
}
const createImpl = (createState) => {
  if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && typeof createState !== "function") {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api = typeof createState === "function" ? createStore(createState) : createState;
  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create2 = (createState) => createState ? createImpl(createState) : createImpl;
var react = (createState) => {
  if ((__vite_import_meta_env__ ? "production" : void 0) !== "production") {
    console.warn(
      "[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`."
    );
  }
  return create2(createState);
};
var rs = Object.defineProperty, fc = Object.defineProperties, Sc = Object.getOwnPropertyDescriptor, bc = Object.getOwnPropertyDescriptors, Tc = Object.getOwnPropertyNames, gr = Object.getOwnPropertySymbols;
var ss = Object.prototype.hasOwnProperty, Xi = Object.prototype.propertyIsEnumerable;
var os = (r10, e10, t10) => e10 in r10 ? rs(r10, e10, { enumerable: true, configurable: true, writable: true, value: t10 }) : r10[e10] = t10, S = (r10, e10) => {
  for (var t10 in e10 || (e10 = {})) ss.call(e10, t10) && os(r10, t10, e10[t10]);
  if (gr) for (var t10 of gr(e10)) Xi.call(e10, t10) && os(r10, t10, e10[t10]);
  return r10;
}, x = (r10, e10) => fc(r10, bc(e10));
var Je = (r10, e10) => {
  var t10 = {};
  for (var n10 in r10) ss.call(r10, n10) && e10.indexOf(n10) < 0 && (t10[n10] = r10[n10]);
  if (r10 != null && gr) for (var n10 of gr(r10)) e10.indexOf(n10) < 0 && Xi.call(r10, n10) && (t10[n10] = r10[n10]);
  return t10;
};
var yc = (r10, e10) => {
  for (var t10 in e10) rs(r10, t10, { get: e10[t10], enumerable: true });
}, fr = (r10, e10, t10, n10) => {
  if (e10 && typeof e10 == "object" || typeof e10 == "function") for (let o10 of Tc(e10)) !ss.call(r10, o10) && o10 !== "default" && rs(r10, o10, { get: () => e10[o10], enumerable: !(n10 = Sc(e10, o10)) || n10.enumerable });
  return r10;
};
var l = (r10, e10, t10) => (os(r10, typeof e10 != "symbol" ? e10 + "" : e10, t10), t10);
var pe = (r10, e10, t10) => new Promise((n10, o10) => {
  var s10 = (i10) => {
    try {
      d10(t10.next(i10));
    } catch (c10) {
      o10(c10);
    }
  }, a10 = (i10) => {
    try {
      d10(t10.throw(i10));
    } catch (c10) {
      o10(c10);
    }
  }, d10 = (i10) => i10.done ? n10(i10.value) : Promise.resolve(i10.value).then(s10, a10);
  d10((t10 = t10.apply(r10, e10)).next());
});
var { styled: H2, createTheme: kc } = q({ themeMap: S({}, n$1), theme: { colors: { bounds: "rgba(65, 132, 244, 1.000)", boundsBg: "rgba(65, 132, 244, 0.05)", hover: "#ececec", overlay: "rgba(0, 0, 0, 0.15)", overlayContrast: "rgba(255, 255, 255, 0.15)", panel: "#fefefe", panelContrast: "#ffffff", selected: "rgba(66, 133, 244, 1.000)", selectedContrast: "#fefefe", text: "#333333", tooltip: "#1d1d1d", tooltipContrast: "#ffffff", warn: "rgba(255, 100, 100, 1)", canvas: "rgb(248, 249, 250)" }, shadows: { 2: "0px 1px 1px rgba(0, 0, 0, 0.14)", 3: "0px 2px 3px rgba(0, 0, 0, 0.14)", 4: "0px 4px 5px -1px rgba(0, 0, 0, 0.14)", 8: "0px 12px 17px rgba(0, 0, 0, 0.14)", 12: "0px 12px 17px rgba(0, 0, 0, 0.14)", 24: "0px 24px 38px rgba(0, 0, 0, 0.14)", key: "1px 1px rgba(0,0,0,1)", panel: `0px 0px 16px -1px rgba(0, 0, 0, 0.05), 
        0px 0px 16px -8px rgba(0, 0, 0, 0.05), 
        0px 0px 16px -12px rgba(0, 0, 0, 0.12),
        0px 0px 2px 0px rgba(0, 0, 0, 0.08)` }, space: { 0: "2px", 1: "3px", 2: "4px", 3: "8px", 4: "12px", 5: "16px", 6: "32px", 7: "48px" }, fontSizes: { 0: "10px", 1: "12px", 2: "13px", 3: "16px", 4: "18px" }, fonts: { ui: '"Recursive", system-ui, sans-serif', body: '"Recursive", system-ui, sans-serif', mono: '"Recursive Mono", monospace' }, fontWeights: {}, lineHeights: {}, letterSpacings: {}, sizes: {}, borderWidths: { 0: "$1" }, borderStyles: {}, radii: { 0: "2px", 1: "4px", 2: "8px", 3: "12px", 4: "16px" }, zIndices: {}, transitions: {} }, media: { micro: "(max-width: 370px)", sm: "(min-width: 640px)", md: "(min-width: 768px)", lg: "(min-width: 1024px)" }, utils: { zStrokeWidth: () => (r10) => Array.isArray(r10) ? { strokeWidth: `calc(${r10[0]}px / var(--camera-zoom))` } : { strokeWidth: `calc(${r10}px / var(--camera-zoom))` } } }), is = kc({ colors: { bounds: "rgba(38, 150, 255, 1.000)", boundsBg: "rgba(38, 150, 255, 0.05)", hover: "#444A50", overlay: "rgba(0, 0, 0, 0.15)", overlayContrast: "rgba(255, 255, 255, 0.15)", panel: "#363D44", panelContrast: "#49555f", selected: "rgba(38, 150, 255, 1.000)", selectedContrast: "#fefefe", text: "#f8f9fa", tooltip: "#1d1d1d", tooltipContrast: "#ffffff", canvas: "#212529" }, shadows: { 2: "0px 1px 1px rgba(0, 0, 0, 0.24)", 3: "0px 2px 3px rgba(0, 0, 0, 0.24)", 4: "0px 4px 5px -1px rgba(0, 0, 0, 0.24)", 8: "0px 12px 17px rgba(0, 0, 0, 0.24)", 12: "0px 12px 17px rgba(0, 0, 0, 0.24)", 24: "0px 24px 38px rgba(0, 0, 0, 0.24)", panel: `0px 0px 16px -1px rgba(0, 0, 0, 0.05), 
      0px 0px 16px -8px rgba(0, 0, 0, 0.09), 
      0px 0px 16px -12px rgba(0, 0, 0, 0.2)` } });
var Pe = H2("hr", { height: 0, paddingTop: 1, width: "calc(100%+8px)", backgroundColor: "$hover", border: "none", margin: "$2 -4px" });
var Rt = H2("div", { position: "relative", overflow: "hidden", userSelect: "none", WebkitUserSelect: "none", display: "flex", flexDirection: "column", zIndex: 99997, minWidth: 180, pointerEvents: "all", backgroundColor: "$panel", border: "1px solid $panelContrast", boxShadow: "$panel", padding: "$2 $2", borderRadius: "$3", font: "$ui", maxHeight: "100vh", overflowY: "auto", overflowX: "hidden", "&::webkit-scrollbar": { display: "none" }, "-ms-overflow-style": "none", scrollbarWidth: "none", variants: { size: { small: { minWidth: 72 } }, overflow: { true: { maxHeight: "60vh" } } } });
var Ic = () => C$2.isDarwin() ? "" : "Ctrl";
function po({ variant: r10, children: e10 }) {
  return reactExports.createElement(Cc, { variant: r10 }, e10.split("").map((t10, n10) => reactExports.createElement("span", { key: n10 }, t10.replace("#", Ic()))));
}
var Cc = H2("kbd", { marginLeft: "$3", textShadow: "$2", textAlign: "center", fontSize: "$0", fontFamily: "$ui", color: "$text", background: "none", fontWeight: 400, gap: "$1", display: "flex", alignItems: "center", "& > span": { padding: "$0", borderRadius: "$0", display: "flex", alignItems: "center", justifyContent: "center" }, variants: { variant: { tooltip: { "& > span": { color: "$tooltipContrast", background: "$overlayContrast", boxShadow: "$key", width: "20px", height: "20px" } }, menu: {} } } });
var ut = H2("div", { height: "100%", borderRadius: "4px", marginRight: "1px", width: "fit-content", display: "grid", alignItems: "center", justifyContent: "center", outline: "none", border: "none", pointerEvents: "all", cursor: "pointer", color: "currentColor", "& svg": { height: 16, width: 16, strokeWidth: 1 }, "& > *": { gridRow: 1, gridColumn: 1 } });
var Qe = { "@initial": "mobile", "@micro": "micro", "@sm": "small", "@md": "medium", "@lg": "large" };
var je = reactExports.forwardRef((p10, u10) => {
  var m10 = p10, { onClick: r10, isActive: e10 = false, isWarning: t10 = false, hasIndicator: n10 = false, hasArrow: o10 = false, disabled: s10 = false, variant: a10, kbd: d10, children: i10 } = m10, c10 = Je(m10, ["onClick", "isActive", "isWarning", "hasIndicator", "hasArrow", "disabled", "variant", "kbd", "children"]);
  return reactExports.createElement(Ec, S({ ref: u10, bp: Qe, isWarning: t10, isActive: e10, disabled: s10, onClick: r10, variant: a10 }, c10), reactExports.createElement(qi, null, i10, d10 ? reactExports.createElement(po, { variant: "menu" }, d10) : void 0, n10 && reactExports.createElement($d08ef79370b62062$export$c3468e2714d175fa, { dir: "ltr" }, reactExports.createElement(ut, null, reactExports.createElement(CheckIcon, null))), o10 && reactExports.createElement(ut, null, reactExports.createElement(ChevronRightIcon, null))));
}), qi = H2("div", { height: "100%", width: "100%", backgroundColor: "$panel", borderRadius: "$2", display: "flex", gap: "$1", flexDirection: "row", alignItems: "center", padding: "0 $3", justifyContent: "space-between", border: "1px solid transparent", "& svg": { position: "relative", stroke: "$overlay", strokeWidth: 1, zIndex: 1 }, [`& > ${ut}`]: { paddingLeft: "$3" } }), Ec = H2("button", { position: "relative", width: "100%", background: "none", border: "none", cursor: "pointer", height: 32, minHeight: 32, outline: "none", color: "$text", fontFamily: "$ui", fontWeight: 400, fontSize: "$1", borderRadius: 4, userSelect: "none", WebkitUserSelect: "none", margin: 0, padding: "0 0", "&[data-disabled]": { opacity: 0.3 }, "&:disabled": { opacity: 0.3 }, [`&:focus:not(:disabled) ${qi}`]: { backgroundColor: "$hover" }, "& a": { textDecoration: "none", color: "$text" }, variants: { bp: { mobile: {}, small: {} }, variant: { styleMenu: { margin: "$1 0 $1 0" }, wide: { gridColumn: "1 / span 4" } }, size: { icon: { padding: "4px ", width: "auto" } }, isWarning: { true: { color: "$warn" } }, isActive: { true: { backgroundColor: "$hover" }, false: {} } } });
function Le({ children: r10, label: e10, kbd: t10, id: n10, side: o10 = "top" }) {
  return reactExports.createElement("span", { id: n10 }, reactExports.createElement(Provider, null, reactExports.createElement(Root3, null, reactExports.createElement(Trigger$2, { dir: "ltr", asChild: true }, reactExports.createElement("span", null, r10)), reactExports.createElement(Bc, { dir: "ltr", side: o10, sideOffset: 8 }, e10, t10 ? reactExports.createElement(po, { variant: "tooltip" }, t10) : null, reactExports.createElement(Rc, null)))));
}
var Bc = H2(Content2$2, { borderRadius: 3, padding: "$3 $3 $3 $3", fontSize: "$1", backgroundColor: "$tooltip", color: "$tooltipContrast", boxShadow: "$3", display: "flex", alignItems: "center", fontFamily: "$ui", userSelect: "none", WebkitUserSelect: "none" }), Rc = H2(Arrow2, { fill: "$tooltip", margin: "0 8px" });
function Sr() {
  let r10 = me(), { openDialog: e10 } = br(), t10 = reactExports.useCallback((d10) => pe(this, null, function* () {
    var i10, c10;
    d10 && r10.callbacks.onOpenProject && d10.preventDefault(), (c10 = (i10 = r10.callbacks).onNewProject) == null || c10.call(i10, r10, e10);
  }), [r10, e10]), n10 = reactExports.useCallback((d10) => {
    var i10, c10;
    d10 && r10.callbacks.onOpenProject && d10.preventDefault(), (c10 = (i10 = r10.callbacks).onSaveProject) == null || c10.call(i10, r10);
  }, [r10]), o10 = reactExports.useCallback((d10) => {
    var i10, c10;
    d10 && r10.callbacks.onOpenProject && d10.preventDefault(), (c10 = (i10 = r10.callbacks).onSaveProjectAs) == null || c10.call(i10, r10);
  }, [r10]), s10 = reactExports.useCallback((d10) => pe(this, null, function* () {
    var i10, c10;
    d10 && r10.callbacks.onOpenProject && d10.preventDefault(), (c10 = (i10 = r10.callbacks).onOpenProject) == null || c10.call(i10, r10, e10);
  }), [r10, e10]), a10 = reactExports.useCallback((d10) => pe(this, null, function* () {
    var i10, c10;
    d10 && r10.callbacks.onOpenMedia && d10.preventDefault(), (c10 = (i10 = r10.callbacks).onOpenMedia) == null || c10.call(i10, r10);
  }), [r10]);
  return { onNewProject: t10, onSaveProject: n10, onSaveProjectAs: o10, onOpenProject: s10, onOpenMedia: a10 };
}
var ls = class {
  constructor() {
    l(this, "onPinchStart");
    l(this, "onPinchEnd");
    l(this, "onPinch");
    l(this, "onKeyDown");
    l(this, "onKeyUp");
    l(this, "onPointerMove");
    l(this, "onPointerUp");
    l(this, "onPan");
    l(this, "onZoom");
    l(this, "onPointerDown");
    l(this, "onPointCanvas");
    l(this, "onDoubleClickCanvas");
    l(this, "onRightPointCanvas");
    l(this, "onDragCanvas");
    l(this, "onReleaseCanvas");
    l(this, "onPointShape");
    l(this, "onDoubleClickShape");
    l(this, "onRightPointShape");
    l(this, "onDragShape");
    l(this, "onHoverShape");
    l(this, "onUnhoverShape");
    l(this, "onReleaseShape");
    l(this, "onPointBounds");
    l(this, "onDoubleClickBounds");
    l(this, "onRightPointBounds");
    l(this, "onDragBounds");
    l(this, "onHoverBounds");
    l(this, "onUnhoverBounds");
    l(this, "onReleaseBounds");
    l(this, "onPointBoundsHandle");
    l(this, "onDoubleClickBoundsHandle");
    l(this, "onRightPointBoundsHandle");
    l(this, "onDragBoundsHandle");
    l(this, "onHoverBoundsHandle");
    l(this, "onUnhoverBoundsHandle");
    l(this, "onReleaseBoundsHandle");
    l(this, "onPointHandle");
    l(this, "onDoubleClickHandle");
    l(this, "onRightPointHandle");
    l(this, "onDragHandle");
    l(this, "onHoverHandle");
    l(this, "onUnhoverHandle");
    l(this, "onReleaseHandle");
    l(this, "onShapeBlur");
    l(this, "onShapeClone");
  }
}, Lc = ((o10) => (o10.Idle = "idle", o10.Connecting = "connecting", o10.Connected = "connected", o10.Disconnected = "disconnected", o10))(Lc || {}), We = ((p10) => (p10.Transform = "transform", p10.Translate = "translate", p10.TransformSingle = "transformSingle", p10.Brush = "brush", p10.Arrow = "arrow", p10.Draw = "draw", p10.Erase = "erase", p10.Rotate = "rotate", p10.Handle = "handle", p10.Grid = "grid", p10.Edit = "edit", p10))(We || {}), At = ((h10) => (h10.Idle = "idle", h10.PointingHandle = "pointingHandle", h10.PointingBounds = "pointingBounds", h10.PointingBoundsHandle = "pointingBoundsHandle", h10.TranslatingLabel = "translatingLabel", h10.TranslatingHandle = "translatingHandle", h10.Translating = "translating", h10.Transforming = "transforming", h10.Rotating = "rotating", h10.Pinching = "pinching", h10.Brushing = "brushing", h10.Creating = "creating", h10.EditingText = "editing-text", h10))(At || {}), ds = ((o10) => (o10.Backward = "backward", o10.Forward = "forward", o10.ToFront = "toFront", o10.ToBack = "toBack", o10))(ds || {}), Tr = ((a10) => (a10.Top = "top", a10.CenterVertical = "centerVertical", a10.Bottom = "bottom", a10.Left = "left", a10.CenterHorizontal = "centerHorizontal", a10.Right = "right", a10))(Tr || {}), yr = ((t10) => (t10.Horizontal = "horizontal", t10.Vertical = "vertical", t10))(yr || {}), wr = ((t10) => (t10.Horizontal = "horizontal", t10.Vertical = "vertical", t10))(wr || {}), cs = ((t10) => (t10.Horizontal = "horizontal", t10.Vertical = "vertical", t10))(cs || {}), Ie = ((p10) => (p10.Sticky = "sticky", p10.Ellipse = "ellipse", p10.Rectangle = "rectangle", p10.Triangle = "triangle", p10.Draw = "draw", p10.Arrow = "arrow", p10.Line = "line", p10.Text = "text", p10.Group = "group", p10.Image = "image", p10.Video = "video", p10))(Ie || {}), xr = ((e10) => (e10.Arrow = "arrow", e10))(xr || {}), ps = ((m10) => (m10.White = "white", m10.LightGray = "lightGray", m10.Gray = "gray", m10.Black = "black", m10.Green = "green", m10.Cyan = "cyan", m10.Blue = "blue", m10.Indigo = "indigo", m10.Violet = "violet", m10.Red = "red", m10.Orange = "orange", m10.Yellow = "yellow", m10))(ps || {}), kr = ((n10) => (n10.Small = "small", n10.Medium = "medium", n10.Large = "large", n10))(kr || {}), yn = ((o10) => (o10.Draw = "draw", o10.Solid = "solid", o10.Dashed = "dashed", o10.Dotted = "dotted", o10))(yn || {}), Hc = ((o10) => (o10.Small = "small", o10.Medium = "medium", o10.Large = "large", o10.ExtraLarge = "extraLarge", o10))(Hc || {}), Gt = ((o10) => (o10.Start = "start", o10.Middle = "middle", o10.End = "end", o10.Justify = "justify", o10))(Gt || {}), Oo = ((o10) => (o10.Script = "script", o10.Sans = "sans", o10.Serif = "serif", o10.Mono = "mono", o10))(Oo || {}), us = ((t10) => (t10.Image = "image", t10.Video = "video", t10))(us || {}), mo = ((s10) => (s10.PNG = "png", s10.JPG = "jpeg", s10.WEBP = "webp", s10.SVG = "svg", s10.JSON = "json", s10))(mo || {}), Fo = ((o10) => (o10.Transparent = "transparent", o10.Auto = "auto", o10.Light = "light", o10.Dark = "dark", o10))(Fo || {});
function Ji(r10) {
  let e10 = me(), t10 = reactExports.useCallback((i10 = false) => {
    let c10 = r10.current;
    return i10 && (e10.isMenuOpen || e10.settings.keepStyleMenuOpen) ? true : c10 && (document.activeElement === c10 || c10.contains(document.activeElement));
  }, [r10]);
  reactExports.useEffect(() => {
    if (!e10) return;
    let i10 = (p10) => {
      if (!!t10(true)) {
        if (e10.readOnly) {
          e10.copy(void 0, p10);
          return;
        }
        e10.cut(void 0, p10);
      }
    }, c10 = (p10) => {
      !t10(true) || e10.copy(void 0, p10);
    }, u10 = (p10) => {
      !t10(true) || e10.readOnly || e10.paste(void 0, p10);
    };
    return document.addEventListener("cut", i10), document.addEventListener("copy", c10), document.addEventListener("paste", u10), () => {
      document.removeEventListener("cut", i10), document.removeEventListener("copy", c10), document.removeEventListener("paste", u10);
    };
  }, [e10]), useHotkeys("v,1", () => {
    !t10(true) || e10.selectTool("select");
  }, [e10, r10.current]), useHotkeys("d,p,2", () => {
    !t10(true) || e10.selectTool("draw");
  }, void 0, [e10]), useHotkeys("e,3", () => {
    !t10(true) || e10.selectTool("erase");
  }, void 0, [e10]), useHotkeys("r,4", () => {
    !t10(true) || e10.selectTool("rectangle");
  }, void 0, [e10]), useHotkeys("o,5", () => {
    !t10(true) || e10.selectTool("ellipse");
  }, void 0, [e10]), useHotkeys("g,6", () => {
    !t10() || e10.selectTool("triangle");
  }, void 0, [e10]), useHotkeys("l,7", () => {
    !t10(true) || e10.selectTool("line");
  }, void 0, [e10]), useHotkeys("a,8", () => {
    !t10(true) || e10.selectTool("arrow");
  }, void 0, [e10]), useHotkeys("t,9", () => {
    !t10(true) || e10.selectTool("text");
  }, void 0, [e10]), useHotkeys("s,0", () => {
    !t10(true) || e10.selectTool("sticky");
  }, void 0, [e10]), useHotkeys("ctrl+shift+d,+shift+d", (i10) => {
    !t10(true) || (e10.toggleDarkMode(), i10.preventDefault());
  }, void 0, [e10]), useHotkeys("ctrl+.,+.", () => {
    !t10(true) || e10.toggleFocusMode();
  }, void 0, [e10]), useHotkeys("ctrl+shift+g,+shift+g", () => {
    !t10(true) || e10.toggleGrid();
  }, void 0, [e10]);
  let { onNewProject: n10, onOpenProject: o10, onSaveProject: s10, onSaveProjectAs: a10, onOpenMedia: d10 } = Sr();
  useHotkeys("ctrl+n,+n", (i10) => {
    i10.preventDefault(), !!t10() && n10(i10);
  }, void 0, [e10]), useHotkeys("ctrl+s,+s", (i10) => {
    !t10() || s10(i10);
  }, void 0, [e10]), useHotkeys("ctrl+shift+s,+shift+s", (i10) => {
    !t10() || a10(i10);
  }, void 0, [e10]), useHotkeys("ctrl+alt+1,+alt+1", (i10) => {
    !t10() || e10.exportImage("svg", { scale: 2, quality: 1 });
  }, void 0, [e10]), useHotkeys("ctrl+alt+2,+alt+2", (i10) => {
    !t10() || e10.exportImage("png", { scale: 2, quality: 1 });
  }, void 0, [e10]), useHotkeys("ctrl+alt+3,+alt+3", (i10) => {
    !t10() || e10.exportImage("jpeg", { scale: 2, quality: 1 });
  }, void 0, [e10]), useHotkeys("ctrl+alt+4,+alt+4", (i10) => {
    !t10() || e10.exportImage("webp", { scale: 2, quality: 1 });
  }, void 0, [e10]), useHotkeys("ctrl+alt+5,+alt+5", (i10) => {
    !t10() || e10.exportJson();
  }, void 0, [e10]), useHotkeys("ctrl+o,+o", (i10) => {
    !t10() || o10(i10);
  }, void 0, [e10]), useHotkeys("ctrl+u,+u", (i10) => {
    !t10() || d10(i10);
  }, void 0, [e10]), useHotkeys("+z,ctrl+z", (i10) => {
    i10.preventDefault(), !!t10(true) && (e10.session ? e10.cancelSession() : e10.undo());
  }, void 0, [e10]), useHotkeys("ctrl+shift+z,+shift+z", () => {
    !t10(true) || (e10.session ? e10.cancelSession() : e10.redo());
  }, void 0, [e10]), useHotkeys("+u,ctrl+u", () => {
    !t10() || e10.undoSelect();
  }, void 0, [e10]), useHotkeys("ctrl+shift-u,+shift+u", () => {
    !t10() || e10.redoSelect();
  }, void 0, [e10]), useHotkeys("ctrl+=,+=,ctrl+num_add,+num_add", (i10) => {
    !t10(true) || (e10.zoomIn(), i10.preventDefault());
  }, void 0, [e10]), useHotkeys("ctrl+-,+-,ctrl+num_subtract,+num_subtract", (i10) => {
    !t10(true) || (e10.zoomOut(), i10.preventDefault());
  }, void 0, [e10]), useHotkeys("shift+0,ctrl+numpad_0,+numpad_0", () => {
    !t10(true) || e10.resetZoom();
  }, void 0, [e10]), useHotkeys("shift+1", () => {
    !t10(true) || e10.zoomToFit();
  }, void 0, [e10]), useHotkeys("shift+2", () => {
    !t10(true) || e10.zoomToSelection();
  }, void 0, [e10]), useHotkeys("ctrl+d,+d", (i10) => {
    !t10() || (e10.duplicate(), i10.preventDefault());
  }, void 0, [e10]), useHotkeys("shift+h", () => {
    !t10(true) || e10.flipHorizontal();
  }, void 0, [e10]), useHotkeys("shift+v", () => {
    !t10(true) || e10.flipVertical();
  }, void 0, [e10]), useHotkeys("escape", () => {
    !t10(true) || e10.cancel();
  }, void 0, [e10]), useHotkeys("backspace,del", () => {
    !t10() || e10.delete();
  }, void 0, [e10]), useHotkeys("+a,ctrl+a", () => {
    !t10(true) || e10.selectAll();
  }, void 0, [e10]), useHotkeys("up", () => {
    !t10() || e10.nudge([0, -1], false);
  }, void 0, [e10]), useHotkeys("right", () => {
    !t10() || e10.nudge([1, 0], false);
  }, void 0, [e10]), useHotkeys("down", () => {
    !t10() || e10.nudge([0, 1], false);
  }, void 0, [e10]), useHotkeys("left", () => {
    !t10() || e10.nudge([-1, 0], false);
  }, void 0, [e10]), useHotkeys("shift+up", () => {
    !t10() || e10.nudge([0, -1], true);
  }, void 0, [e10]), useHotkeys("shift+right", () => {
    !t10() || e10.nudge([1, 0], true);
  }, void 0, [e10]), useHotkeys("shift+down", () => {
    !t10() || e10.nudge([0, 1], true);
  }, void 0, [e10]), useHotkeys("shift+left", () => {
    !t10() || e10.nudge([-1, 0], true);
  }, void 0, [e10]), useHotkeys("+shift+l,ctrl+shift+l", () => {
    !t10() || e10.toggleLocked();
  }, void 0, [e10]), useHotkeys("+shift+c,ctrl+shift+c", (i10) => {
    !t10() || (e10.copySvg(), i10.preventDefault());
  }, void 0, [e10]), useHotkeys("+g,ctrl+g", (i10) => {
    !t10() || (e10.group(), i10.preventDefault());
  }, void 0, [e10]), useHotkeys("+shift+g,ctrl+shift+g", (i10) => {
    !t10() || (e10.ungroup(), i10.preventDefault());
  }, void 0, [e10]), useHotkeys("[", () => {
    !t10(true) || e10.moveBackward();
  }, void 0, [e10]), useHotkeys("]", () => {
    !t10(true) || e10.moveForward();
  }, void 0, [e10]), useHotkeys("shift+[", () => {
    !t10(true) || e10.moveToBack();
  }, void 0, [e10]), useHotkeys("shift+]", () => {
    !t10(true) || e10.moveToFront();
  }, void 0, [e10]), useHotkeys("ctrl+shift+backspace,+shift+backspace", (i10) => {
    !t10() || (e10.settings.isDebugMode && e10.resetDocument(), i10.preventDefault());
  }, void 0, [e10]), useHotkeys("alt+command+l,alt+ctrl+l", (i10) => {
    !t10(true) || (e10.style({ textAlign: "start" }), i10.preventDefault());
  }, void 0, [e10]), useHotkeys("alt+command+t,alt+ctrl+t", (i10) => {
    !t10(true) || (e10.style({ textAlign: "middle" }), i10.preventDefault());
  }, void 0, [e10]), useHotkeys("alt+command+r,alt+ctrl+r", (i10) => {
    !t10(true) || (e10.style({ textAlign: "end" }), i10.preventDefault());
  }, void 0, [e10]);
}
var hs = reactExports.createContext({}), zc = () => {
  let [r10, e10] = reactExports.useState(0);
  reactExports.useEffect(() => e10(1));
};
function me() {
  return reactExports.useContext(hs);
}
var ms = reactExports.createContext({});
function Lt() {
  let r10 = reactExports.useContext(ms);
  return zc(), r10;
}
var Oc = "", Fc = "", jc = "", Gc = "", Vc = " ", $c = "", Nc = "", Wc = "", Uc = "", Kc = "", _c = "", Yc = "", Zc = "", Xc = "", qc = "", Jc = "", Qc = "", ep = " ", tp = "", np = " ", op = "  ", rp = " ", sp = " ", ip = " ", ap = " ", lp = " ", dp = " ", cp = " ", pp = "  CAD", up = "   ", hp = "  ", mp = " ", gp = " ", fp = " ", Sp = "", bp = "", Tp = "", yp = "", wp = "", xp = " ", kp = " ", vp = " ", Ip = "  ", Cp = "", Dp = " ", Pp = "", Mp = "", Ep = " ", Bp = " ", Rp = " ", Ap = " ", Lp = " ", Hp = "", zp = "", Op = "  ", Fp = "    ", jp = "    ", Gp = "    ", Vp = "", $p = "", Np = "", Wp = "", Up = "", Kp = "", _p = "", Yp = "", Zp = "", Xp = "", qp = "", Jp = "  ", Qp = "   ", eu = "", tu = " ", nu = "  ", ou = " ", ru = " ", su = " ", iu = "  ", au = "", lu = " ", du = "  ", cu = " ", pu = " ", uu = "", hu = "", mu = "", gu = "", fu = "", Su = "", bu = "", Tu = " ", yu = "", wu = "", xu = "", ku = "", vu = "", Iu = "  ", Cu = "", Du = "{dots} ", Pu = " ", Mu = "", Eu = "", Bu = "", Ru = "", Au = "      ", Lu = "      ", Hu = "", zu = "", Ou = "", Fu = "  ", ju = "", Gu = " ", Vu = "   ", $u = " ", Nu = " ", Wu = "   ", Uu = " ", Ku = " ", _u = " ", Yu = " ", Zu = " ", Qi = { "style.menu.color": Oc, "style.menu.fill": Fc, "style.menu.dash": jc, "style.menu.size": Gc, "style.menu.keep.open": Vc, "style.menu.font": $c, "style.menu.align": Nc, styles: Wc, "zoom.in": Uc, "zoom.out": Kc, to: _c, "menu.tools": Yc, "menu.transform": Zc, "menu.file": Xc, "menu.edit": qc, "menu.view": Jc, "menu.preferences": Qc, "menu.sign.in": ep, "menu.sign.out": tp, "become.a.sponsor": np, "zoom.to.content": op, "zoom.to.selection": rp, "zoom.to.fit": sp, "zoom.to": ip, "preferences.dark.mode": ap, "preferences.focus.mode": lp, "preferences.debug.mode": dp, "preferences.show.grid": cp, "preferences.use.cad.selection": pp, "preferences.keep.stylemenu.open": up, "preferences.always.show.snaps": hp, "preferences.rotate.handles": mp, "preferences.binding.handles": gp, "preferences.clone.handles": fp, undo: Sp, redo: bp, cut: Tp, copy: yp, paste: wp, "copy.as": xp, "export.as": kp, "select.all": vp, "select.none": Ip, delete: Cp, "new.project": Dp, open: Pp, save: Mp, "save.as": Ep, "upload.media": Bp, "create.page": Rp, "new.page": Ap, "page.name": Lp, duplicate: Hp, cancel: zp, "copy.invite.link": Op, "copy.readonly.link": Fp, "create.multiplayer.project": jp, "copy.multiplayer.project": Gp, select: Vp, eraser: $p, draw: Np, arrow: Wp, text: Up, sticky: Kp, rectangle: _p, ellipse: Yp, triangle: Zp, line: Xp, rotate: qp, "lock.aspect.ratio": Jp, "unlock.aspect.ratio": Qp, group: eu, ungroup: tu, "move.to.back": nu, "move.backward": ou, "move.forward": ru, "move.to.front": su, "reset.angle": iu, lock: au, unlock: lu, "move.to.page": du, "flip.horizontal": cu, "flip.vertical": pu, move: uu, "to.front": hu, forward: mu, backward: gu, back: fu, language: Su, "translation.link": bu, "dock.position": Tu, bottom: yu, left: wu, right: xu, top: ku, page: vu, "keyboard.shortcuts": Iu, search: Cu, loading: Du, "export.background": Pu, transparent: Mu, auto: Eu, light: Bu, dark: Ru, "dialog.save.firsttime": Au, "dialog.save.again": Lu, "dialog.cancel": Hu, "dialog.no": zu, "dialog.yes": Ou, "enter.file.name": Fu, image: ju, "align.left": Gu, "align.center.x": Vu, "align.right": $u, "align.top": Nu, "align.center.y": Wu, "align.bottom": Uu, "distribute.x": Ku, "distribute.y": _u, "stretch.x": Yu, "stretch.y": Zu };
var Xu = "Farve", qu = "Fyld", Ju = "Streg", Qu = "Strrelse", eh = "Hold ben", th = "Skrifttype", nh = "Juster", oh = "Format", rh = "Zoom ind", sh = "Zoom ud", ih = "til", ah = "Vrktjer", lh = "Transformer", dh = "Fil", ch = "Rediger", ph = "Vis", uh = "Indstillinger", hh = "Log ind", mh = "Log ud", gh = "Bliv sponsor", fh = "Zoom til valgte", Sh = "Zoom til lrred", bh = "Zoom til", Th = "Zoom til indhold", yh = "Mrkt udseende", wh = "Fokus tilstand", xh = "Debug tilstand", kh = "Vis net", vh = "Brug CAD udvlgelse", Ih = "Hold formatmenuen ben", Ch = "Vis altid snaps", Dh = "Roteringshndtag", Ph = "Bindingshndtag", Mh = "Kloningshndtag", Eh = "Fortryd", Bh = "Gentag", Rh = "Klip", Ah = "Kopier", Lh = "Indst", Hh = "Kopier som", zh = "Eksporter som", Oh = "Vlg alt", Fh = "Fravlg alt", jh = "Slet", Gh = "Nyt projekt", Vh = "ben", $h = "Gem", Nh = "Gem som", Wh = "Upload medie", Uh = "Opret side", Kh = "Ny side", _h = "Sidenavn", Yh = "Dupliker", Zh = "Fortryd", Xh = "Kopier invitationslink", qh = "Opret multiplayer projekt", Jh = "Kopier til multiplayer projekt", Qh = "Vlg", em = "Viskelder", tm = "Tegn", nm = "Pil", om = "Tekst", rm = "Note", sm = "Rektangel", im = "Ellipse", am = "Trekant", lm = "Linje", dm = "Roter", cm = "Ls billedformat", pm = "Frigr billedformat", um = "Grupper", hm = "Opdel gruppe", mm = "Placer bagerst", gm = "Flyt tilbage", fm = "Flyt frem", Sm = "Lg forrest", bm = "Nulstil vinkel", Tm = "Ls", ym = "Ls op", wm = "Flyt til side", xm = "Vend vandret", km = "Vend lodret", vm = "Flyt", Im = "Forrest", Cm = "Frem", Dm = "Tilbage", Pm = "Bagerst", Mm = "Sprog", Em = "Justering nederst", Bm = "Vandret justering centreret", Rm = "Lodret justering centreret", Am = "Juster / distribuer", Lm = "Justering til venstre", Hm = "Justering til hjre", zm = "Justering verst", Om = "Kopier skrivebeskyttet link", Fm = "Vil du gemme ndringerne til dit projekt?", jm = "Vil du gemme dit projekt?", Gm = "Ja", Vm = "Nej", $m = "Fortryd", Nm = "Skriv filnavn", Wm = "Vandret distribuering", Um = "Lodret distribuering", Km = "Placering af vrktjslinje", _m = "Nederst", Ym = "Venstre", Zm = "Hjre", Xm = "verst", qm = "Baggrund ved eksport", Jm = "Automatisk", Qm = "Lys", eg = "Mrk", tg = "Billede", ng = "Tastaturgenveje", og = "Indlser", rg = "Side", sg = "Sg", ig = "Strk vandret", ag = "Strk lodret", lg = "Lr mere", dg = "Gennemsigtig", ea = { "style.menu.color": Xu, "style.menu.fill": qu, "style.menu.dash": Ju, "style.menu.size": Qu, "style.menu.keep.open": eh, "style.menu.font": th, "style.menu.align": nh, styles: oh, "zoom.in": rh, "zoom.out": sh, to: ih, "menu.tools": ah, "menu.transform": lh, "menu.file": dh, "menu.edit": ch, "menu.view": ph, "menu.preferences": uh, "menu.sign.in": hh, "menu.sign.out": mh, "become.a.sponsor": gh, "zoom.to.selection": fh, "zoom.to.fit": Sh, "zoom.to": bh, "zoom.to.content": Th, "preferences.dark.mode": yh, "preferences.focus.mode": wh, "preferences.debug.mode": xh, "preferences.show.grid": kh, "preferences.use.cad.selection": vh, "preferences.keep.stylemenu.open": Ih, "preferences.always.show.snaps": Ch, "preferences.rotate.handles": Dh, "preferences.binding.handles": Ph, "preferences.clone.handles": Mh, undo: Eh, redo: Bh, cut: Rh, copy: Ah, paste: Lh, "copy.as": Hh, "export.as": zh, "select.all": Oh, "select.none": Fh, delete: jh, "new.project": Gh, open: Vh, save: $h, "save.as": Nh, "upload.media": Wh, "create.page": Uh, "new.page": Kh, "page.name": _h, duplicate: Yh, cancel: Zh, "copy.invite.link": Xh, "create.multiplayer.project": qh, "copy.multiplayer.project": Jh, select: Qh, eraser: em, draw: tm, arrow: nm, text: om, sticky: rm, rectangle: sm, ellipse: im, triangle: am, line: lm, rotate: dm, "lock.aspect.ratio": cm, "unlock.aspect.ratio": pm, group: um, ungroup: hm, "move.to.back": mm, "move.backward": gm, "move.forward": fm, "move.to.front": Sm, "reset.angle": bm, lock: Tm, unlock: ym, "move.to.page": wm, "flip.horizontal": xm, "flip.vertical": km, move: vm, "to.front": Im, forward: Cm, backward: Dm, back: Pm, language: Mm, "align.bottom": Em, "align.center.x": Bm, "align.center.y": Rm, "align.distribute": Am, "align.left": Lm, "align.right": Hm, "align.top": zm, "copy.readonly.link": Om, "dialog.save.again": Fm, "dialog.save.firsttime": jm, "dialog.yes": Gm, "dialog.no": Vm, "dialog.cancel": $m, "enter.file.name": Nm, "distribute.x": Wm, "distribute.y": Um, "dock.position": Km, bottom: _m, left: Ym, right: Zm, top: Xm, "export.background": qm, auto: Jm, light: Qm, dark: eg, image: tg, "keyboard.shortcuts": ng, loading: og, page: rg, search: sg, "stretch.x": ig, "stretch.y": ag, "translation.link": lg, transparent: dg };
var cg = "Farbe", pg = "Fllen", ug = "Strich", hg = "Gre", mg = "Offen halten", gg = "Schriftart", fg = "Ausrichten", Sg = "Stile", bg = "Heranzoomen", Tg = "Herauszoomen", yg = "zu", wg = "Werkzeuge", xg = "Transformieren", kg = "Datei", vg = "Bearbeiten", Ig = "Ansicht", Cg = "Prferenzen", Dg = "Einloggen", Pg = "Ausloggen", Mg = "Sponsor werden", Eg = "Zurck zum Inhalt", Bg = "Zur Auswahl zoomen", Rg = "Zoom anpassen", Ag = "Zoomen nach", Lg = "Dunkler Modus", Hg = "Fokus Modus", zg = "Debug Modus", Og = "Gitter anzeigen", Fg = "CAD Auswahl verwenden", jg = "Stilmen offen halten", Gg = "Hilfslinien immer anzeigen", Vg = "Rotiergriffe", $g = "Bindegriffe", Ng = "Klongriffe", Wg = "Rckgngig machen", Ug = "Wiederherstellen", Kg = "Ausschneiden", _g = "Kopieren", Yg = "Einfgen", Zg = "Kopieren als", Xg = "Exportieren als", qg = "Alles auswhlen", Jg = "Nichts auswhlen", Qg = "Lschen", ef = "Neues Projekt", tf = "ffnen", nf = "Speichern", of = "Speichern als", rf = "Medien hochladen", sf = "Seite erstellen", af = "Neue Seite", lf = "Seitenname", df = "Duplizieren", cf = "Form Optionen", pf = "Fromen", uf = "Abbrechen", hf = "Einladungslink kopieren", mf = "Schreibgeschtzten Link kopieren", gf = "Geteiltes Projekt erstellen", ff = "In ein Geteiltes Projekt kopieren", Sf = "Auswhlen", bf = "Radierer", Tf = "Malen", yf = "Pfeil", wf = "Text", xf = "Notiz", kf = "Rechteck", vf = "Ellipse", If = "Dreieck", Cf = "Linie", Df = "Drehen", Pf = "Seitenverhltnis sperren", Mf = "Seitenverhltnis entsperren", Ef = "Gruppieren", Bf = "Gruppierung aufheben", Rf = "Nach Hinten verschieben", Af = "Rckwrts schieben", Lf = "Vorwrts schieben", Hf = "Nach Vorne verschieben", zf = "Winkel zurcksetzen", Of = "Sperren", Ff = "Entsperren", jf = "Ausrichten / Verteilen", Gf = "Zu Seite verschieben", Vf = "Horizontal spiegeln", $f = "Vertikal spiegeln", Nf = "Verschieben", Wf = "Nach Vorne", Uf = "Vorwrts", Kf = "Rckwrts", _f = "Hinten", Yf = "Sprache", Zf = "Mehr erfahren", Xf = "Dock Position", qf = "Unten", Jf = "Links", Qf = "Rechts", eS = "Oben", tS = "Seite", nS = "Tastaturkurzbefehle", oS = "Suche", rS = "Laden{dots}", sS = "Hintergrund Exportieren", iS = "Transparent", aS = "Auto", lS = "Hell", dS = "Dunkel", cS = "Github", pS = "Twitter", uS = "Discord", hS = "Bild", mS = "Links ausrichten", gS = "Horizontal mittig ausrichten", fS = "Rechts ausrichten", SS = "Oben ausrichten", bS = "Vertikal mittig ausrichten", TS = "Unten ausrichten", yS = "Horizontal verteilen", wS = "Vertikal verteilen", xS = "Horizontal strecken", kS = "Vertikal strecken", vS = "Mchten Sie Ihr aktuelles Projekt speichern?", IS = "Mchten Sie die nderungen an Ihrem aktuellen Projekt speichern?", CS = "Abbrechen", DS = "Nein", PS = "Ja", MS = "Dateiname eingeben", ES = "Probieren Sie das neue tldraw", BS = "Wei", RS = "hellgrau", AS = "Frau", LS = "Schwarz", HS = "Grn", zS = "Cyan", OS = "Blau", FS = "Indigo", jS = "Violett", GS = "Rot", VS = "Orange", $S = "Gelb", NS = "Durchgehend", WS = "Gestrichelt", US = "Gepunktet", KS = "Klein", _S = "Mittel", YS = "Gro", ta = { "style.menu.color": cg, "style.menu.fill": pg, "style.menu.dash": ug, "style.menu.size": hg, "style.menu.keep.open": mg, "style.menu.font": gg, "style.menu.align": fg, styles: Sg, "zoom.in": bg, "zoom.out": Tg, to: yg, "menu.tools": wg, "menu.transform": xg, "menu.file": kg, "menu.edit": vg, "menu.view": Ig, "menu.preferences": Cg, "menu.sign.in": Dg, "menu.sign.out": Pg, "become.a.sponsor": Mg, "zoom.to.content": Eg, "zoom.to.selection": Bg, "zoom.to.fit": Rg, "zoom.to": Ag, "preferences.dark.mode": Lg, "preferences.focus.mode": Hg, "preferences.debug.mode": zg, "preferences.show.grid": Og, "preferences.use.cad.selection": Fg, "preferences.keep.stylemenu.open": jg, "preferences.always.show.snaps": Gg, "preferences.rotate.handles": Vg, "preferences.binding.handles": $g, "preferences.clone.handles": Ng, undo: Wg, redo: Ug, cut: Kg, copy: _g, paste: Yg, "copy.as": Zg, "export.as": Xg, "select.all": qg, "select.none": Jg, delete: Qg, "new.project": ef, open: tf, save: nf, "save.as": of, "upload.media": rf, "create.page": sf, "new.page": af, "page.name": lf, duplicate: df, "shape.options": cf, shapes: pf, cancel: uf, "copy.invite.link": hf, "copy.readonly.link": mf, "create.multiplayer.project": gf, "copy.multiplayer.project": ff, select: Sf, eraser: bf, draw: Tf, arrow: yf, text: wf, sticky: xf, rectangle: kf, ellipse: vf, triangle: If, line: Cf, rotate: Df, "lock.aspect.ratio": Pf, "unlock.aspect.ratio": Mf, group: Ef, ungroup: Bf, "move.to.back": Rf, "move.backward": Af, "move.forward": Lf, "move.to.front": Hf, "reset.angle": zf, lock: Of, unlock: Ff, "align.distribute": jf, "move.to.page": Gf, "flip.horizontal": Vf, "flip.vertical": $f, move: Nf, "to.front": Wf, forward: Uf, backward: Kf, back: _f, language: Yf, "translation.link": Zf, "dock.position": Xf, bottom: qf, left: Jf, right: Qf, top: eS, page: tS, "keyboard.shortcuts": nS, search: oS, loading: rS, "export.background": sS, transparent: iS, auto: aS, light: lS, dark: dS, github: cS, twitter: pS, discord: uS, image: hS, "align.left": mS, "align.center.x": gS, "align.right": fS, "align.top": SS, "align.center.y": bS, "align.bottom": TS, "distribute.x": yS, "distribute.y": wS, "stretch.x": xS, "stretch.y": kS, "dialog.save.firsttime": vS, "dialog.save.again": IS, "dialog.cancel": CS, "dialog.no": DS, "dialog.yes": PS, "enter.file.name": MS, "tldraw-beta": ES, white: BS, lightGray: RS, gray: AS, black: LS, green: HS, cyan: zS, blue: OS, indigo: FS, violet: jS, red: GS, orange: VS, yellow: $S, solid: NS, dashed: WS, dotted: US, small: KS, medium: _S, large: YS };
var na = {};
var XS = "Color", qS = "Relleno", JS = "Lnea", QS = "Tamao", eb = "Mantener abierto", tb = "Fuente", nb = "Alineacin", ob = "Estilos", rb = "Acercar", sb = "Alejar", ib = "A", ab = "Herramientas", lb = "Transformar", db = "Archivo", cb = "Editar", pb = "Ver", ub = "Preferencias", hb = "Iniciar sesin", mb = "Cerrar sesin", gb = "Convirtete en patrocinador", fb = "Acercar al contenido", Sb = "Acercar a la seleccin", bb = "Ajustar a la ventana", Tb = "Acercar a", yb = "Modo oscuro", wb = "Modo concentracin", xb = "Modo depuracin", kb = "Mostrar cuadrcula", vb = "Usar seleccin CAD", Ib = "Mantener men de estilos abierto", Cb = "Mostrar puntos de ajuste", Db = "Control de rotacin", Pb = "Control de vinculacin", Mb = "Control de clonacin", Eb = "Deshacer", Bb = "Rehacer", Rb = "Cortar", Ab = "Copiar", Lb = "Pegar", Hb = "Copiar como", zb = "Exportar como", Ob = "Selecionar todo", Fb = "Selecionar nada", jb = "Borrar", Gb = "Nuevo Proyecto", Vb = "Abrir", $b = "Guardar", Nb = "Guardar como", Wb = "Subir medios", Ub = "Crear pgina", Kb = "Nueva pgina", _b = "Nombre de pgina", Yb = "Duplicar", Zb = "Opciones de formas", Xb = "Formas", qb = "Cancelar", Jb = "Copiar invitacin", Qb = "Copiar invitacin (solo lectura)", eT = "Crear proyecto multijugador", tT = "Copiar proyecto multijugador", nT = "Seleccionar", oT = "Borrador", rT = "Dibujar", sT = "Flecha", iT = "Texto", aT = "Pegatina", lT = "Rectngulo", dT = "Elipse", cT = "Tringulo", pT = "Lnea", uT = "Rotar", hT = "Bloquear relacin de aspecto", mT = "Desbloquear relacin de aspecto", gT = "Agrupar", fT = "Desagrupar", ST = "Mover al fondo", bT = "Mover atrs", TT = "Mover adelante", yT = "Mover al frente", wT = "Restablecer ngulo", xT = "Bloquear", kT = "Desbloquear", vT = "Alinear / Distribuir", IT = "Mover a pgina", CT = "Voltear horizontalmente", DT = "Voltear verticalmente", PT = "Mover", MT = "Al frente", ET = "Adelante", BT = "Atrs", RT = "Fondo", AT = "Idioma", LT = "Saber ms", HT = "Posicin del dock", zT = "Abajo", OT = "Izquierda", FT = "Derecha", jT = "Arriba", GT = "Pgina", VT = "Atajos de teclado", $T = "Buscar", NT = "Cargando{dots}", WT = "Exportar fondo", UT = "Transparente", KT = "Auto", _T = "Claro", YT = "Oscuro", ZT = "Github", XT = "Twitter", qT = "Discord", JT = "Imagen", QT = "Alinear a la izquierda", ey = "Alinear al centro horizontalmente", ty = "Alinear a la derecha", ny = "Alinear arriba", oy = "Alinear al centro verticalmente", ry = "Alinear abajo", sy = "Distribuir horizontalmente", iy = "Distribuir verticalmente", ay = "Estirar horizontalmente", ly = "Estirar verticalmente", dy = "Quieres guardar el proyecto actual?", cy = "Quieres guardar los cambios en el proyecto actual?", py = "Cancelar", uy = "No", hy = "S", my = "Introduce el nombre del arquivo", gy = "Prueba el nuevo tldraw", fy = "Blanco", Sy = "Gris claro", by = "Gris", Ty = "Negro", yy = "Verde", wy = "Cian", xy = "Azul", ky = "Indigo", vy = "Violeta", Iy = "Rojo", Cy = "Naranja", Dy = "Amarillo", Py = "Contnuo", My = "Discontnuo", Ey = "Punteado", By = "Pequeo", Ry = "Mediano", Ay = "Grande", oa = { "style.menu.color": XS, "style.menu.fill": qS, "style.menu.dash": JS, "style.menu.size": QS, "style.menu.keep.open": eb, "style.menu.font": tb, "style.menu.align": nb, styles: ob, "zoom.in": rb, "zoom.out": sb, to: ib, "menu.tools": ab, "menu.transform": lb, "menu.file": db, "menu.edit": cb, "menu.view": pb, "menu.preferences": ub, "menu.sign.in": hb, "menu.sign.out": mb, "become.a.sponsor": gb, "zoom.to.content": fb, "zoom.to.selection": Sb, "zoom.to.fit": bb, "zoom.to": Tb, "preferences.dark.mode": yb, "preferences.focus.mode": wb, "preferences.debug.mode": xb, "preferences.show.grid": kb, "preferences.use.cad.selection": vb, "preferences.keep.stylemenu.open": Ib, "preferences.always.show.snaps": Cb, "preferences.rotate.handles": Db, "preferences.binding.handles": Pb, "preferences.clone.handles": Mb, undo: Eb, redo: Bb, cut: Rb, copy: Ab, paste: Lb, "copy.as": Hb, "export.as": zb, "select.all": Ob, "select.none": Fb, delete: jb, "new.project": Gb, open: Vb, save: $b, "save.as": Nb, "upload.media": Wb, "create.page": Ub, "new.page": Kb, "page.name": _b, duplicate: Yb, "shape.options": Zb, shapes: Xb, cancel: qb, "copy.invite.link": Jb, "copy.readonly.link": Qb, "create.multiplayer.project": eT, "copy.multiplayer.project": tT, select: nT, eraser: oT, draw: rT, arrow: sT, text: iT, sticky: aT, rectangle: lT, ellipse: dT, triangle: cT, line: pT, rotate: uT, "lock.aspect.ratio": hT, "unlock.aspect.ratio": mT, group: gT, ungroup: fT, "move.to.back": ST, "move.backward": bT, "move.forward": TT, "move.to.front": yT, "reset.angle": wT, lock: xT, unlock: kT, "align.distribute": vT, "move.to.page": IT, "flip.horizontal": CT, "flip.vertical": DT, move: PT, "to.front": MT, forward: ET, backward: BT, back: RT, language: AT, "translation.link": LT, "dock.position": HT, bottom: zT, left: OT, right: FT, top: jT, page: GT, "keyboard.shortcuts": VT, search: $T, loading: NT, "export.background": WT, transparent: UT, auto: KT, light: _T, dark: YT, github: ZT, twitter: XT, discord: qT, image: JT, "align.left": QT, "align.center.x": ey, "align.right": ty, "align.top": ny, "align.center.y": oy, "align.bottom": ry, "distribute.x": sy, "distribute.y": iy, "stretch.x": ay, "stretch.y": ly, "dialog.save.firsttime": dy, "dialog.save.again": cy, "dialog.cancel": py, "dialog.no": uy, "dialog.yes": hy, "enter.file.name": my, "tldraw-beta": gy, white: fy, lightGray: Sy, gray: by, black: Ty, green: yy, cyan: wy, blue: xy, indigo: ky, violet: vy, red: Iy, orange: Cy, yellow: Dy, solid: Py, dashed: My, dotted: Ey, small: By, medium: Ry, large: Ay };
var Ly = "", Hy = "", zy = "", Oy = "", Fy = " ", jy = "", Gy = "", Vy = "", $y = "", Ny = "", Wy = "", Uy = "", Ky = " ", _y = "", Yy = "", Zy = "", Xy = "", qy = "", Jy = "", Qy = " ", ew = "  ", tw = "   ", nw = "   ", ow = " ", rw = " ", sw = " ", iw = " ", aw = "  ", lw = "    CAD", dw = "   ", cw = "     ", pw = " ", uw = " ", hw = " ", mw = "", gw = " ", fw = "", Sw = "", bw = "", Tw = " ", yw = " ", ww = " ", xw = " ", kw = "", vw = " ", Iw = "", Cw = "", Dw = " ", Pw = " ", Mw = " ", Ew = " ", Bw = " ", Rw = "", Aw = " ", Lw = "", Hw = "", zw = "  ", Ow = "   ", Fw = "   ", jw = "   ", Gw = "", Vw = "", $w = "", Nw = "", Ww = "", Uw = " ", Kw = "", _w = "", Yw = "", Zw = "", Xw = "", qw = "  ", Jw = "   ", Qw = "", ex = " ", tx = "  ", nx = "   ", ox = "   ", rx = "  ", sx = " ", ix = "", ax = " ", lx = " / ", dx = "  ", cx = " ", px = " ", ux = "", hx = " ", mx = "  ", gx = "  ", fx = " ", Sx = "", bx = " ", Tx = "  ", yx = "", wx = "", xx = "", kx = "", vx = "", Ix = " ", Cx = "", Dx = "{dots}", Px = " ", Mx = "", Ex = "", Bx = "", Rx = "", Ax = "", Lx = "", Hx = "", zx = "", Ox = "  ", Fx = "   ", jx = "  ", Gx = "  ", Vx = "   ", $x = "  ", Nx = " ", Wx = " ", Ux = " ", Kx = " ", _x = "       ", Yx = "          ", Zx = "", Xx = "", qx = "", Jx = "    ", Qx = " tldraw ", e0 = "", t0 = " ", n0 = "", o0 = "", r0 = "", s0 = "", i0 = "", a0 = "", l0 = "", d0 = "", c0 = "", p0 = "", u0 = "", h0 = "", m0 = "", g0 = "", f0 = "", S0 = "", ra = { "style.menu.color": Ly, "style.menu.fill": Hy, "style.menu.dash": zy, "style.menu.size": Oy, "style.menu.keep.open": Fy, "style.menu.font": jy, "style.menu.align": Gy, styles: Vy, "zoom.in": $y, "zoom.out": Ny, to: Wy, "menu.tools": Uy, "menu.transform": Ky, "menu.file": _y, "menu.edit": Yy, "menu.view": Zy, "menu.preferences": Xy, "menu.sign.in": qy, "menu.sign.out": Jy, "become.a.sponsor": Qy, "zoom.to.content": ew, "zoom.to.selection": tw, "zoom.to.fit": nw, "zoom.to": ow, "preferences.dark.mode": rw, "preferences.focus.mode": sw, "preferences.debug.mode": iw, "preferences.show.grid": aw, "preferences.use.cad.selection": lw, "preferences.keep.stylemenu.open": dw, "preferences.always.show.snaps": cw, "preferences.rotate.handles": pw, "preferences.binding.handles": uw, "preferences.clone.handles": hw, undo: mw, redo: gw, cut: fw, copy: Sw, paste: bw, "copy.as": Tw, "export.as": yw, "select.all": ww, "select.none": xw, delete: kw, "new.project": vw, open: Iw, save: Cw, "save.as": Dw, "upload.media": Pw, "create.page": Mw, "new.page": Ew, "page.name": Bw, duplicate: Rw, "shape.options": Aw, shapes: Lw, cancel: Hw, "copy.invite.link": zw, "copy.readonly.link": Ow, "create.multiplayer.project": Fw, "copy.multiplayer.project": jw, select: Gw, eraser: Vw, draw: $w, arrow: Nw, text: Ww, sticky: Uw, rectangle: Kw, ellipse: _w, triangle: Yw, line: Zw, rotate: Xw, "lock.aspect.ratio": qw, "unlock.aspect.ratio": Jw, group: Qw, ungroup: ex, "move.to.back": tx, "move.backward": nx, "move.forward": ox, "move.to.front": rx, "reset.angle": sx, lock: ix, unlock: ax, "align.distribute": lx, "move.to.page": dx, "flip.horizontal": cx, "flip.vertical": px, move: ux, "to.front": hx, forward: mx, backward: gx, back: fx, language: Sx, "translation.link": bx, "dock.position": Tx, bottom: yx, left: wx, right: xx, top: kx, page: vx, "keyboard.shortcuts": Ix, search: Cx, loading: Dx, "export.background": Px, transparent: Mx, auto: Ex, light: Bx, dark: Rx, github: Ax, twitter: Lx, discord: Hx, image: zx, "align.left": Ox, "align.center.x": Fx, "align.right": jx, "align.top": Gx, "align.center.y": Vx, "align.bottom": $x, "distribute.x": Nx, "distribute.y": Wx, "stretch.x": Ux, "stretch.y": Kx, "dialog.save.firsttime": _x, "dialog.save.again": Yx, "dialog.cancel": Zx, "dialog.no": Xx, "dialog.yes": qx, "enter.file.name": Jx, "tldraw-beta": Qx, white: e0, lightGray: t0, gray: n0, black: o0, green: r0, cyan: s0, blue: i0, indigo: a0, violet: l0, red: d0, orange: c0, yellow: p0, solid: u0, dashed: h0, dotted: m0, small: g0, medium: f0, large: S0 };
var b0 = "Couleur", T0 = "Remplir", y0 = "Bordure", w0 = "Taille", x0 = "Toujours afficher le menu", k0 = "Police", v0 = "Alignement", I0 = "Styles", C0 = "Zoom avant", D0 = "Zoom arrire", P0 = "", M0 = "Outils", E0 = "Transformation", B0 = "Fichier", R0 = "dition", A0 = "Afficher", L0 = "Prfrences", H0 = "S'authentifier", z0 = "Se dconnecter", O0 = "Devenir un sponsor", F0 = "Retour au contenu", j0 = "Ajuster le zoom  la slection", G0 = "Adapter le zoom au contenu", V0 = "Rtablir le zoom ", $0 = "Mode sombre", N0 = "Mode focus", W0 = "Afficher la barre dveloppeur", U0 = "Afficher la grille", K0 = "Utiliser la slection CAD", _0 = "Toujours afficher le menu styles", Y0 = "Afficher les repres dynamiques", Z0 = "Manier la rotation", X0 = "Manier les liaisons", q0 = "Manier le clonage", J0 = "Annuler", Q0 = "Rtablir", ek = "Couper", tk = "Copier", nk = "Coller", ok = "Copier au format", rk = "Exporter au format", sk = "Tout slectionner", ik = "Tout dslectionner", ak = "Supprimer", lk = "Nouveau project", dk = "Ouvrir", ck = "Enregistrer", pk = "Enregistrer sous", uk = "Importer un mdia", hk = "Crer une page", mk = "Nouvelle Page", gk = "Nom de la page", fk = "Dupliquer", Sk = "Annuler", bk = "Copier le lien d'invitation", Tk = "Copier le lien en lecture seule d'invitation", yk = "Crer un project multi-joueurs", wk = "Copier dans un projet multi-joueurs", xk = "Slection", kk = "Gomme", vk = "Crayon", Ik = "Flche", Ck = "Texte", Dk = "Note", Pk = "Rectangle", Mk = "Cercle", Ek = "Triangle", Bk = "Ligne", Rk = "Rotation", Ak = "Verrouiller les proportions", Lk = "Dverrouiller les proportions", Hk = "Grouper", zk = "Dgrouper", Ok = "Dplacer  l'arrire-plan", Fk = "Reculer d'un plan", jk = "Avancer d'un plan", Gk = "Placer au premier plan", Vk = "Rinitialiser la rotation", $k = "Verrouiller", Nk = "Dverrouiller", Wk = "Alignement / Rpartion", Uk = "Dplacer vers la page", Kk = "Retourner horizontalement", _k = "Retourner verticalement", Yk = "Disposition", Zk = "Placer au premier plan", Xk = "Avancer d'un plan", qk = "Reculer d'un plan", Jk = "Dplacer  l'arrire-plan", Qk = "Langage", e1 = "En savoir plus", t1 = "Position du dock", n1 = "En bas", o1 = " gauche", r1 = " droite", s1 = "En haut", i1 = "Page", a1 = "Raccourcis clavier", l1 = "Rechercher", d1 = "Chargement{dots}", c1 = "Couleur d'arrire-plan de l'export", p1 = "Transparent", u1 = "Automatique", h1 = "Clair", m1 = "Sombre", sa = { "style.menu.color": b0, "style.menu.fill": T0, "style.menu.dash": y0, "style.menu.size": w0, "style.menu.keep.open": x0, "style.menu.font": k0, "style.menu.align": v0, styles: I0, "zoom.in": C0, "zoom.out": D0, to: P0, "menu.tools": M0, "menu.transform": E0, "menu.file": B0, "menu.edit": R0, "menu.view": A0, "menu.preferences": L0, "menu.sign.in": H0, "menu.sign.out": z0, "become.a.sponsor": O0, "zoom.to.content": F0, "zoom.to.selection": j0, "zoom.to.fit": G0, "zoom.to": V0, "preferences.dark.mode": $0, "preferences.focus.mode": N0, "preferences.debug.mode": W0, "preferences.show.grid": U0, "preferences.use.cad.selection": K0, "preferences.keep.stylemenu.open": _0, "preferences.always.show.snaps": Y0, "preferences.rotate.handles": Z0, "preferences.binding.handles": X0, "preferences.clone.handles": q0, undo: J0, redo: Q0, cut: ek, copy: tk, paste: nk, "copy.as": ok, "export.as": rk, "select.all": sk, "select.none": ik, delete: ak, "new.project": lk, open: dk, save: ck, "save.as": pk, "upload.media": uk, "create.page": hk, "new.page": mk, "page.name": gk, duplicate: fk, cancel: Sk, "copy.invite.link": bk, "copy.readonly.link": Tk, "create.multiplayer.project": yk, "copy.multiplayer.project": wk, select: xk, eraser: kk, draw: vk, arrow: Ik, text: Ck, sticky: Dk, rectangle: Pk, ellipse: Mk, triangle: Ek, line: Bk, rotate: Rk, "lock.aspect.ratio": Ak, "unlock.aspect.ratio": Lk, group: Hk, ungroup: zk, "move.to.back": Ok, "move.backward": Fk, "move.forward": jk, "move.to.front": Gk, "reset.angle": Vk, lock: $k, unlock: Nk, "align.distribute": Wk, "move.to.page": Uk, "flip.horizontal": Kk, "flip.vertical": _k, move: Yk, "to.front": Zk, forward: Xk, backward: qk, back: Jk, language: Qk, "translation.link": e1, "dock.position": t1, bottom: n1, left: o1, right: r1, top: s1, page: i1, "keyboard.shortcuts": a1, search: l1, loading: d1, "export.background": c1, transparent: p1, auto: u1, light: h1, dark: m1 };
var g1 = "Cor", f1 = "Recheo", S1 = "Lia", b1 = "Tamao", T1 = "Manter aberto", y1 = "Fonte", w1 = "Aliamento", x1 = "Estilos", k1 = "Achegar", v1 = "Afastar", I1 = "A", C1 = "Ferramentas", D1 = "Transformar", P1 = "Arquivo", M1 = "Editar", E1 = "Ver", B1 = "Preferencias", R1 = "Iniciar sesin", A1 = "Pechar sesin", L1 = "Convrtete en patrocinador", H1 = "Achegar ao contido", z1 = "Achegar  seleccin", O1 = "Axustar  vent", F1 = "Achegar a", j1 = "Modo escuro", G1 = "Modo concentracin", V1 = "Modo depuracin", $1 = "Amosar cuadrcula", N1 = "Usar seleccin CAD", W1 = "Manter men de estilos aberto", U1 = "Amosar puntos de axuste", K1 = "Control de rotacin", _1 = "Control de vinculacin", Y1 = "Control de clonacin", Z1 = "Desfacer", X1 = "Refacer", q1 = "Cortar", J1 = "Copiar", Q1 = "Pegar", ev = "Copiar como", tv = "Exportar como", nv = "Selecionar todo", ov = "Selecionar nada", rv = "Borrar", sv = "Novo Proxecto", iv = "Abrir", av = "Gardar", lv = "Gardar como", dv = "Subir medios", cv = "Crear pxina", pv = "Nova pxina", uv = "Nome de pxina", hv = "Duplicar", mv = "Opcins de formas", gv = "Formas", fv = "Cancelar", Sv = "Copiar invitacin", bv = "Copiar invitacin (s lectura)", Tv = "Crear proxecto multixogador", yv = "Copiar proxecto multixogador", wv = "Seleccionar", xv = "Borrador", kv = "Debuxar", vv = "Frecha", Iv = "Texto", Cv = "Pegatina", Dv = "Rectngulo", Pv = "Elipse", Mv = "Tringulo", Ev = "Lia", Bv = "Rotar", Rv = "Bloquear relacin de aspecto", Av = "Desbloquear relacin de aspecto", Lv = "Agrupar", Hv = "Desagrupar", zv = "Mover ao fondo", Ov = "Mover atrs", Fv = "Mover adiante", jv = "Mover ao fronte", Gv = "Restablecer ngulo", Vv = "Bloquear", $v = "Desbloquear", Nv = "Aliar / Distribur", Wv = "Mover  pxina", Uv = "Voltear horizontalmente", Kv = "Voltear verticalmente", _v = "Mover", Yv = "Ao fronte", Zv = "Adilante", Xv = "Atrs", qv = "Fondo", Jv = "Idioma", Qv = "Saber mis", eI = "Posicin do dock", tI = "Abaixo", nI = "Esquerda", oI = "Dereita", rI = "Arriba", sI = "Pxina", iI = "Atallos de teclado", aI = "Buscar", lI = "Cargando{dots}", dI = "Exportar fondo", cI = "Transparente", pI = "Auto", uI = "Claro", hI = "Escuro", mI = "Github", gI = "Twitter", fI = "Discord", SI = "Imaxe", bI = "Aliar  esquerda", TI = "Aliar ao centro horizontalmente", yI = "Aliar  dereita", wI = "Aliar arriba", xI = "Aliar ao centro verticalmente", kI = "Aliar abaixo", vI = "Distribur horizontalmente", II = "Distribur verticalmente", CI = "Estirar horizontalmente", DI = "Estirar verticalmente", PI = "Queres gardar o proxecto actual?", MI = "Queres gardar os cambios ao proxecto actual?", EI = "Cancelar", BI = "No", RI = "S", AI = "Introduce o nome do arquivo", LI = "Proba o novo tldraw", HI = "Branco", zI = "Gris claro", OI = "Gris", FI = "Negro", jI = "Verde", GI = "Cian", VI = "Azul", $I = "Indigo", NI = "Violeta", WI = "Vermello", UI = "Laranxa", KI = "Amarelo", _I = "Contnuo", YI = "Discontnuo", ZI = "Punteado", XI = "Pequeno", qI = "Mediano", JI = "Grande", ia = { "style.menu.color": g1, "style.menu.fill": f1, "style.menu.dash": S1, "style.menu.size": b1, "style.menu.keep.open": T1, "style.menu.font": y1, "style.menu.align": w1, styles: x1, "zoom.in": k1, "zoom.out": v1, to: I1, "menu.tools": C1, "menu.transform": D1, "menu.file": P1, "menu.edit": M1, "menu.view": E1, "menu.preferences": B1, "menu.sign.in": R1, "menu.sign.out": A1, "become.a.sponsor": L1, "zoom.to.content": H1, "zoom.to.selection": z1, "zoom.to.fit": O1, "zoom.to": F1, "preferences.dark.mode": j1, "preferences.focus.mode": G1, "preferences.debug.mode": V1, "preferences.show.grid": $1, "preferences.use.cad.selection": N1, "preferences.keep.stylemenu.open": W1, "preferences.always.show.snaps": U1, "preferences.rotate.handles": K1, "preferences.binding.handles": _1, "preferences.clone.handles": Y1, undo: Z1, redo: X1, cut: q1, copy: J1, paste: Q1, "copy.as": ev, "export.as": tv, "select.all": nv, "select.none": ov, delete: rv, "new.project": sv, open: iv, save: av, "save.as": lv, "upload.media": dv, "create.page": cv, "new.page": pv, "page.name": uv, duplicate: hv, "shape.options": mv, shapes: gv, cancel: fv, "copy.invite.link": Sv, "copy.readonly.link": bv, "create.multiplayer.project": Tv, "copy.multiplayer.project": yv, select: wv, eraser: xv, draw: kv, arrow: vv, text: Iv, sticky: Cv, rectangle: Dv, ellipse: Pv, triangle: Mv, line: Ev, rotate: Bv, "lock.aspect.ratio": Rv, "unlock.aspect.ratio": Av, group: Lv, ungroup: Hv, "move.to.back": zv, "move.backward": Ov, "move.forward": Fv, "move.to.front": jv, "reset.angle": Gv, lock: Vv, unlock: $v, "align.distribute": Nv, "move.to.page": Wv, "flip.horizontal": Uv, "flip.vertical": Kv, move: _v, "to.front": Yv, forward: Zv, backward: Xv, back: qv, language: Jv, "translation.link": Qv, "dock.position": eI, bottom: tI, left: nI, right: oI, top: rI, page: sI, "keyboard.shortcuts": iI, search: aI, loading: lI, "export.background": dI, transparent: cI, auto: pI, light: uI, dark: hI, github: mI, twitter: gI, discord: fI, image: SI, "align.left": bI, "align.center.x": TI, "align.right": yI, "align.top": wI, "align.center.y": xI, "align.bottom": kI, "distribute.x": vI, "distribute.y": II, "stretch.x": CI, "stretch.y": DI, "dialog.save.firsttime": PI, "dialog.save.again": MI, "dialog.cancel": EI, "dialog.no": BI, "dialog.yes": RI, "enter.file.name": AI, "tldraw-beta": LI, white: HI, lightGray: zI, gray: OI, black: FI, green: jI, cyan: GI, blue: VI, indigo: $I, violet: NI, red: WI, orange: UI, yellow: KI, solid: _I, dashed: YI, dotted: ZI, small: XI, medium: qI, large: JI };
var QI = "", eC = "", tC = "", nC = "", oC = " ", rC = "", sC = "", iC = "", aC = " ", lC = " ", dC = "", cC = "", pC = "", uC = "", hC = "", mC = "", gC = "", fC = " ", SC = " ", bC = " ", TC = " ", yC = " ", wC = " ", xC = " ", kC = "()  ", vC = " CAD", IC = "   ", CC = "  ", DC = "  ", PC = "  ", MC = "  ", EC = "", BC = " ", RC = "", AC = "", LC = "", HC = " ", zC = " ", OC = " ", FC = " ", jC = "", GC = " ", VC = "", $C = "", NC = " ", WC = " ", UC = " ", KC = " ", _C = " ", YC = "", ZC = "", XC = "  ", qC = "   ", JC = "   ", QC = "", eD = "", tD = "", nD = "", oD = "", rD = "", sD = "", iD = "", aD = "", lD = "", dD = "", cD = "  -", pD = "   -", uD = "", hD = " ", mD = " ", gD = " ", fD = " ", SD = " ", bD = " ", TD = "", yD = " ", wD = " ", xD = " ", kD = " ", vD = "", ID = " ", CD = "", DD = "", PD = "", MD = "", aa = { "style.menu.color": QI, "style.menu.fill": eC, "style.menu.dash": tC, "style.menu.size": nC, "style.menu.keep.open": oC, "style.menu.font": rC, "style.menu.align": sC, styles: iC, "zoom.in": aC, "zoom.out": lC, to: dC, "menu.file": cC, "menu.edit": pC, "menu.view": uC, "menu.preferences": hC, "menu.sign.in": mC, "menu.sign.out": gC, "become.a.sponsor": fC, "zoom.to.selection": SC, "zoom.to.fit": bC, "zoom.to": TC, "preferences.dark.mode": yC, "preferences.focus.mode": wC, "preferences.debug.mode": xC, "preferences.show.grid": kC, "preferences.use.cad.selection": vC, "preferences.keep.stylemenu.open": IC, "preferences.always.show.snaps": CC, "preferences.rotate.handles": DC, "preferences.binding.handles": PC, "preferences.clone.handles": MC, undo: EC, redo: BC, cut: RC, copy: AC, paste: LC, "copy.as": HC, "export.as": zC, "select.all": OC, "select.none": FC, delete: jC, "new.project": GC, open: VC, save: $C, "save.as": NC, "upload.media": WC, "create.page": UC, "new.page": KC, "page.name": _C, duplicate: YC, cancel: ZC, "copy.invite.link": XC, "create.multiplayer.project": qC, "copy.multiplayer.project": JC, select: QC, eraser: eD, draw: tD, arrow: nD, text: oD, sticky: rD, rectangle: sD, ellipse: iD, triangle: aD, line: lD, rotate: dD, "lock.aspect.ratio": cD, "unlock.aspect.ratio": pD, group: uD, ungroup: hD, "move.to.back": mD, "move.backward": gD, "move.forward": fD, "move.to.front": SD, "reset.angle": bD, lock: TD, unlock: yD, "move.to.page": wD, "flip.horizontal": xD, "flip.vertical": kD, move: vD, "to.front": ID, forward: CD, backward: DD, back: PD, language: MD };
var ED = "Colore", BD = "Riempi", RD = "Tratteggo", AD = "Dimensione", LD = "Mantieni aperto", HD = "Font", zD = "Allineamento", OD = "Stile", FD = "Ingrandisci", jD = "Rimpicciolisci", GD = "Imposta", VD = "File", $D = "Modifica", ND = "Visualizzazione", WD = "Preferenze", UD = "Accedi", KD = "Esci", _D = "Sponsorizza", YD = "Adatta alla selezione", ZD = "Adatta", XD = "Ingrandisci", qD = "Modalit scura", JD = "Modalit zen", QD = "Modalit sviluppatore", eP = "Mostra griglia", tP = "Selezione CAD", nP = "Mantieni menu stile aperto", oP = "Mostra sempre le guide", rP = "Controlli d'inclinazione", sP = "Controlli d'associazione", iP = "Controlli di clonazione", aP = "Annulla", lP = "Ripristina", dP = "Taglia", cP = "Copia", pP = "Incolla", uP = "Copia come", hP = "Esporta come", mP = "Seleziona tutto", gP = "Deseleziona tutto", fP = "Elimina", SP = "Nuovo progetto", bP = "Apri", TP = "Salva", yP = "Salva come", wP = "Carica contenuti multimediali", xP = "Crea nuova pagina", kP = "Nuova pagina", vP = "Nome pagina", IP = "Pagina", CP = "Duplica", DP = "Chiudi", PP = "Copia link invito", MP = "Crea progetto multiplayer", EP = "Trasforma in progetto multiplayer", BP = "Seleziona", RP = "Gomma", AP = "Matita", LP = "Freccia", HP = "Casella di testo", zP = "Post-it", OP = "Rettangolo", FP = "Ellisse", jP = "Triangolo", GP = "Linea", VP = "Ruota", $P = "Blocca rapporto lati", NP = "Sblocca rapporto lati", WP = "Raggruppa", UP = "Separa", KP = "Muovi in fondo", _P = "Sposta indietro", YP = "Sposta avanti", ZP = "Muovi in fronte", XP = "Reimposta angolo", qP = "Blocca", JP = "Sblocca", QP = "Trasferisci a pagina", eM = "Ribalta orizzontalmente", tM = "Ribalta verticalmente", nM = "Sposta", oM = "In primo piano", rM = "Sposta avanti", sM = "Sposta indietro", iM = "In fondo", aM = "Lingua", lM = "Posizione dock", dM = "In basso", cM = "Sinistra", pM = "Destra", uM = "In Alto", la = { "style.menu.color": ED, "style.menu.fill": BD, "style.menu.dash": RD, "style.menu.size": AD, "style.menu.keep.open": LD, "style.menu.font": HD, "style.menu.align": zD, styles: OD, "zoom.in": FD, "zoom.out": jD, to: GD, "menu.file": VD, "menu.edit": $D, "menu.view": ND, "menu.preferences": WD, "menu.sign.in": UD, "menu.sign.out": KD, "become.a.sponsor": _D, "zoom.to.selection": YD, "zoom.to.fit": ZD, "zoom.to": XD, "preferences.dark.mode": qD, "preferences.focus.mode": JD, "preferences.debug.mode": QD, "preferences.show.grid": eP, "preferences.use.cad.selection": tP, "preferences.keep.stylemenu.open": nP, "preferences.always.show.snaps": oP, "preferences.rotate.handles": rP, "preferences.binding.handles": sP, "preferences.clone.handles": iP, undo: aP, redo: lP, cut: dP, copy: cP, paste: pP, "copy.as": uP, "export.as": hP, "select.all": mP, "select.none": gP, delete: fP, "new.project": SP, open: bP, save: TP, "save.as": yP, "upload.media": wP, "create.page": xP, "new.page": kP, "page.name": vP, page: IP, duplicate: CP, cancel: DP, "copy.invite.link": PP, "create.multiplayer.project": MP, "copy.multiplayer.project": EP, select: BP, eraser: RP, draw: AP, arrow: LP, text: HP, sticky: zP, rectangle: OP, ellipse: FP, triangle: jP, line: GP, rotate: VP, "lock.aspect.ratio": $P, "unlock.aspect.ratio": NP, group: WP, ungroup: UP, "move.to.back": KP, "move.backward": _P, "move.forward": YP, "move.to.front": ZP, "reset.angle": XP, lock: qP, unlock: JP, "move.to.page": QP, "flip.horizontal": eM, "flip.vertical": tM, move: nM, "to.front": oM, forward: rM, backward: sM, back: iM, language: aM, "dock.position": lM, bottom: dM, left: cM, right: pM, top: uM };
var hM = "", mM = "", gM = "", fM = "/", SM = "", bM = "", TM = "", yM = "", wM = "", xM = "", kM = " ", vM = "", IM = "", CM = "", DM = "", PM = "", MM = "", EM = "", BM = "", RM = "", AM = "", LM = "", HM = "", zM = "", OM = "", FM = "CAD", jM = "", GM = "", VM = "", $M = "", NM = "", WM = "", UM = "", KM = "", _M = "", YM = "", ZM = "", XM = "", qM = "", JM = "", QM = "", eE = "", tE = "", nE = "", oE = "", rE = "", sE = "", iE = "", aE = "", lE = "", dE = "", cE = "", pE = "", uE = "", hE = "", mE = "", gE = "", fE = "", SE = "", bE = "", TE = "", yE = "", wE = "", xE = "", kE = "", vE = "", IE = "", CE = "", DE = "", PE = "", ME = "", EE = "", BE = "", RE = "", AE = "", LE = "", HE = "", zE = "", OE = "", FE = "", jE = "", GE = "", VE = "", $E = "", NE = "", da = { "style.menu.color": hM, "style.menu.fill": mM, "style.menu.dash": gM, "style.menu.size": fM, "style.menu.keep.open": SM, "style.menu.font": bM, "style.menu.align": TM, styles: yM, "zoom.in": wM, "zoom.out": xM, to: kM, "menu.file": vM, "menu.edit": IM, "menu.view": CM, "menu.preferences": DM, "menu.sign.in": PM, "menu.sign.out": MM, "become.a.sponsor": EM, "zoom.to.selection": BM, "zoom.to.fit": RM, "zoom.to": AM, "preferences.dark.mode": LM, "preferences.focus.mode": HM, "preferences.debug.mode": zM, "preferences.show.grid": OM, "preferences.use.cad.selection": FM, "preferences.keep.stylemenu.open": jM, "preferences.always.show.snaps": GM, "preferences.rotate.handles": VM, "preferences.binding.handles": $M, "preferences.clone.handles": NM, undo: WM, redo: UM, cut: KM, copy: _M, paste: YM, "copy.as": ZM, "export.as": XM, "select.all": qM, "select.none": JM, delete: QM, "new.project": eE, open: tE, save: nE, "save.as": oE, "upload.media": rE, "create.page": sE, "new.page": iE, "page.name": aE, duplicate: lE, cancel: dE, "copy.invite.link": cE, "create.multiplayer.project": pE, "copy.multiplayer.project": uE, select: hE, eraser: mE, draw: gE, arrow: fE, text: SE, sticky: bE, rectangle: TE, ellipse: yE, triangle: wE, line: xE, rotate: kE, "lock.aspect.ratio": vE, "unlock.aspect.ratio": IE, group: CE, ungroup: DE, "move.to.back": PE, "move.backward": ME, "move.forward": EE, "move.to.front": BE, "reset.angle": RE, lock: AE, unlock: LE, "move.to.page": HE, "flip.horizontal": zE, "flip.vertical": OE, move: FE, "to.front": jE, forward: GE, backward: VE, back: $E, language: NE };
var WE = "", UE = "", KE = "", _E = "", YE = " ", ZE = "", XE = "", qE = "", JE = "", QE = "", eB = "To", tB = "", nB = "", oB = "", rB = "", sB = "", iB = "", aB = "", lB = "", dB = " ", cB = " ", pB = "  ", uB = " ", hB = "", mB = " ", gB = " ", fB = " ", SB = " ", bB = "CAD  ", TB = "   ", yB = "Snap  ", wB = " ", xB = " ", kB = " ", vB = "", IB = "", CB = "", DB = "", PB = "", MB = " ", EB = "", BB = " ", RB = " ", AB = "", LB = " ", HB = "", zB = "", OB = "  ", FB = " ", jB = "  ", GB = " ", VB = " ", $B = "", NB = "", WB = "  ", UB = "   ", KB = "   ", _B = "   ", YB = "", ZB = "", XB = "", qB = "", JB = "", QB = "", e2 = "", t22 = "", n2 = "", o2 = "", r2 = "", s2 = " ", i2 = "  ", a2 = "", l2 = " ", d2 = "  ", c2 = " ", p2 = " ", u2 = "  ", h2 = " ", m2 = "", g2 = " ", f2 = " /  ", S2 = " ", b2 = " ", T2 = " ", y2 = "", w2 = " ", x2 = "", k22 = "", v2 = " ", I2 = "", C2 = " ", D2 = " ", P2 = "", M2 = "", E2 = "", B2 = "", R2 = "", A2 = " ", L2 = "", H22 = "{dots}", z2 = " ", O2 = "", F2 = "", j2 = "", G2 = "", V2 = "Github", $2 = "Twitter", N2 = "Discord", W2 = "", U2 = " ", K2 = "  ", _2 = " ", Y2 = " ", Z2 = "  ", X2 = " ", q2 = "  ", J2 = "  ", Q2 = " ", eR = " ", tR = "  ?", nR = "   ?", oR = "", rR = "", sR = "", iR = "  ", aR = " tldraw ", ca = { "style.menu.color": WE, "style.menu.fill": UE, "style.menu.dash": KE, "style.menu.size": _E, "style.menu.keep.open": YE, "style.menu.font": ZE, "style.menu.align": XE, styles: qE, "zoom.in": JE, "zoom.out": QE, to: eB, "menu.tools": tB, "menu.transform": nB, "menu.file": oB, "menu.edit": rB, "menu.view": sB, "menu.preferences": iB, "menu.sign.in": aB, "menu.sign.out": lB, "become.a.sponsor": dB, "zoom.to.content": cB, "zoom.to.selection": pB, "zoom.to.fit": uB, "zoom.to": hB, "preferences.dark.mode": mB, "preferences.focus.mode": gB, "preferences.debug.mode": fB, "preferences.show.grid": SB, "preferences.use.cad.selection": bB, "preferences.keep.stylemenu.open": TB, "preferences.always.show.snaps": yB, "preferences.rotate.handles": wB, "preferences.binding.handles": xB, "preferences.clone.handles": kB, undo: vB, redo: IB, cut: CB, copy: DB, paste: PB, "copy.as": MB, "export.as": EB, "select.all": BB, "select.none": RB, delete: AB, "new.project": LB, open: HB, save: zB, "save.as": OB, "upload.media": FB, "create.page": jB, "new.page": GB, "page.name": VB, duplicate: $B, cancel: NB, "copy.invite.link": WB, "copy.readonly.link": UB, "create.multiplayer.project": KB, "copy.multiplayer.project": _B, select: YB, eraser: ZB, draw: XB, arrow: qB, text: JB, sticky: QB, rectangle: e2, ellipse: t22, triangle: n2, line: o2, rotate: r2, "lock.aspect.ratio": s2, "unlock.aspect.ratio": i2, group: a2, ungroup: l2, "move.to.back": d2, "move.backward": c2, "move.forward": p2, "move.to.front": u2, "reset.angle": h2, lock: m2, unlock: g2, "align.distribute": f2, "move.to.page": S2, "flip.horizontal": b2, "flip.vertical": T2, move: y2, "to.front": w2, forward: x2, backward: k22, back: v2, language: I2, "translation.link": C2, "dock.position": D2, bottom: P2, left: M2, right: E2, top: B2, page: R2, "keyboard.shortcuts": A2, search: L2, loading: H22, "export.background": z2, transparent: O2, auto: F2, light: j2, dark: G2, github: V2, twitter: $2, discord: N2, image: W2, "align.left": U2, "align.center.x": K2, "align.right": _2, "align.top": Y2, "align.center.y": Z2, "align.bottom": X2, "distribute.x": q2, "distribute.y": J2, "stretch.x": Q2, "stretch.y": eR, "dialog.save.firsttime": tR, "dialog.save.again": nR, "dialog.cancel": oR, "dialog.no": rR, "dialog.yes": sR, "enter.file.name": iR, "tldraw-beta": aR };
var lR = "", dR = "", cR = " ", pR = "", uR = "  ", hR = "", mR = "", gR = "", fR = " ", SR = " ", bR = "", TR = "", yR = "", wR = "", xR = "", kR = "", vR = "", IR = " ", CR = "", DR = " ", PR = "   ", MR = "   ", ER = "     ", BR = "  ", RR = " ", AR = " ", LR = " ", HR = "  ", zR = " CAD ", OR = "    ", FR = "    ", jR = " ", GR = " ", VR = "  ", $R = " ", NR = " ", WR = "", UR = " ", KR = " ", _R = " ", YR = " ", ZR = " ", XR = " ", qR = "", JR = " ", QR = "", eA = "", tA = " ", nA = " ", oA = " ", rA = " ", sA = " ", iA = "", aA = "", lA = "   ", dA = "    ", cA = "   ", pA = "     ", uA = "", hA = "", mA = "", gA = "", fA = "", SA = "", bA = "", TA = "", yA = "", wA = "", xA = "", kA = "  ", vA = "  ", IA = "", CA = " ", DA = "  ", PA = " ", MA = " ", EA = "  ", BA = " ", RA = "", AA = " ", LA = "  ", HA = " ", zA = " ", OA = "", FA = " ", jA = "", GA = "", VA = "", $A = "", NA = " ", WA = " ", UA = "", KA = "", _A = "", YA = "", ZA = "", XA = " ", qA = "", JA = "", QA = " ", eL = "", tL = "", nL = "", oL = "", pa = { "style.menu.color": lR, "style.menu.fill": dR, "style.menu.dash": cR, "style.menu.size": pR, "style.menu.keep.open": uR, "style.menu.font": hR, "style.menu.align": mR, styles: gR, "zoom.in": fR, "zoom.out": SR, to: bR, "menu.tools": TR, "menu.transform": yR, "menu.file": wR, "menu.edit": xR, "menu.view": kR, "menu.preferences": vR, "menu.sign.in": IR, "menu.sign.out": CR, "become.a.sponsor": DR, "zoom.to.content": PR, "zoom.to.selection": MR, "zoom.to.fit": ER, "zoom.to": BR, "preferences.dark.mode": RR, "preferences.focus.mode": AR, "preferences.debug.mode": LR, "preferences.show.grid": HR, "preferences.use.cad.selection": zR, "preferences.keep.stylemenu.open": OR, "preferences.always.show.snaps": FR, "preferences.rotate.handles": jR, "preferences.binding.handles": GR, "preferences.clone.handles": VR, undo: $R, redo: NR, cut: WR, copy: UR, paste: KR, "copy.as": _R, "export.as": YR, "select.all": ZR, "select.none": XR, delete: qR, "new.project": JR, open: QR, save: eA, "save.as": tA, "upload.media": nA, "create.page": oA, "new.page": rA, "page.name": sA, duplicate: iA, cancel: aA, "copy.invite.link": lA, "copy.readonly.link": dA, "create.multiplayer.project": cA, "copy.multiplayer.project": pA, select: uA, eraser: hA, draw: mA, arrow: gA, text: fA, sticky: SA, rectangle: bA, ellipse: TA, triangle: yA, line: wA, rotate: xA, "lock.aspect.ratio": kA, "unlock.aspect.ratio": vA, group: IA, ungroup: CA, "move.to.back": DA, "move.backward": PA, "move.forward": MA, "move.to.front": EA, "reset.angle": BA, lock: RA, unlock: AA, "move.to.page": LA, "flip.horizontal": HA, "flip.vertical": zA, move: OA, "to.front": FA, forward: jA, backward: GA, back: VA, language: $A, "translation.link": NA, "dock.position": WA, bottom: UA, left: KA, right: _A, top: YA, page: ZA, "keyboard.shortcuts": XA, search: qA, loading: JA, "export.background": QA, transparent: eL, auto: tL, light: nL, dark: oL };
var rL = "Color", sL = "Fill", iL = "Dash", aL = "Size", lL = "Keep Open", dL = "Font", cL = "Align", pL = "Styles", uL = "Zoom In", hL = "Zoom Out", mL = "To", gL = "Tools", fL = "Transform", SL = "File", bL = "Edit", TL = "View", yL = "Preferences", wL = "Sign In", xL = "Sign Out", kL = "Become a Sponsor", vL = "Back to content", IL = "Zoom to Selection", CL = "Zoom to Fit", DL = "Zoom to", PL = "Dark Mode", ML = "Focus Mode", EL = "Debug Mode", BL = "Show Grid", RL = "Use CAD Selection", AL = "Keep Style Menu Open", LL = "Always Show Snaps", HL = "Rotate Handles", zL = "Binding Handles", OL = "Clone Handles", FL = "Undo", jL = "Redo", GL = "Cut", VL = "Copy", $L = "Paste", NL = "Copy As", WL = "Export As", UL = "Select All", KL = "Select None", _L = "Delete", YL = "New Project", ZL = "Open", XL = "Save", qL = "Save As", JL = "Upload Media", QL = "Create Page", e5 = "New Page", t5 = "Page Name", n5 = "Duplicate", o5 = "Shape Options", r5 = "Shapes", s5 = "Cancel", i5 = "Copy Invite Link", a5 = "Copy ReadOnly Link", l5 = "Create a Multiplayer Project", d5 = "Copy to Multiplayer Project", c5 = "Select", p5 = "Eraser", u5 = "Draw", h5 = "Arrow", m5 = "Text", g5 = "Sticky", f5 = "Rectangle", S5 = "Ellipse", b5 = "Triangle", T5 = "Line", y5 = "Rotate", w5 = "Lock Aspect Ratio", x5 = "Unlock Aspect Ratio", k5 = "Group", v5 = "Ungroup", I5 = "Move to Back", C5 = "Move Backward", D5 = "Move Forward", P5 = "Move to Front", M5 = "Reset Angle", E5 = "Lock", B5 = "Unlock", R5 = "Align / Distribute", A5 = "Move to Page", L5 = "Flip Horizontal", H5 = "Flip Vertical", z5 = "Move", O5 = "To Front", F5 = "Forward", j5 = "Backward", G5 = "To Back", V5 = "Language", $5 = "Learn More", N5 = "Dock Position", W5 = "Bottom", U5 = "Left", K5 = "Right", _5 = "Top", Y5 = "Page", Z5 = "Keyboard shortcuts", X5 = "Search", q5 = "Loading{dots}", J5 = "Export Background", Q5 = "Transparent", e3 = "Auto", t3 = "Light", n3 = "Dark", o3 = "Github", r3 = "Twitter", s3 = "Discord", i3 = "Image", a3 = "Align Left", l3 = "Align Horizontal Center", d3 = "Align Right", c3 = "Align Top", p3 = "Align Vertical Center", u3 = "Align Bottom", h3 = "Distribute Horizontal", m3 = "Distribute Vertical", g3 = "Stretch Horizontal", f3 = "Stretch Vertical", S3 = "Do you want to save your current project?", b3 = "Do you want to save changes to your current project?", T3 = "Cancel", y3 = "No", w3 = "Yes", x3 = "Enter file name", k3 = "Try the new tldraw", v3 = "White", I3 = "Light gray", C3 = "Gray", D3 = "Black", P3 = "Green", M3 = "Cyan", E3 = "Blue", B3 = "Indigo", R3 = "Violet", A3 = "Red", L3 = "Orange", H3 = "Yellow", z3 = "Solid", O3 = "Dashed", F3 = "Dotted", j3 = "Small", G3 = "Medium", V3 = "Large", ua = { "style.menu.color": rL, "style.menu.fill": sL, "style.menu.dash": iL, "style.menu.size": aL, "style.menu.keep.open": lL, "style.menu.font": dL, "style.menu.align": cL, styles: pL, "zoom.in": uL, "zoom.out": hL, to: mL, "menu.tools": gL, "menu.transform": fL, "menu.file": SL, "menu.edit": bL, "menu.view": TL, "menu.preferences": yL, "menu.sign.in": wL, "menu.sign.out": xL, "become.a.sponsor": kL, "zoom.to.content": vL, "zoom.to.selection": IL, "zoom.to.fit": CL, "zoom.to": DL, "preferences.dark.mode": PL, "preferences.focus.mode": ML, "preferences.debug.mode": EL, "preferences.show.grid": BL, "preferences.use.cad.selection": RL, "preferences.keep.stylemenu.open": AL, "preferences.always.show.snaps": LL, "preferences.rotate.handles": HL, "preferences.binding.handles": zL, "preferences.clone.handles": OL, undo: FL, redo: jL, cut: GL, copy: VL, paste: $L, "copy.as": NL, "export.as": WL, "select.all": UL, "select.none": KL, delete: _L, "new.project": YL, open: ZL, save: XL, "save.as": qL, "upload.media": JL, "create.page": QL, "new.page": e5, "page.name": t5, duplicate: n5, "shape.options": o5, shapes: r5, cancel: s5, "copy.invite.link": i5, "copy.readonly.link": a5, "create.multiplayer.project": l5, "copy.multiplayer.project": d5, select: c5, eraser: p5, draw: u5, arrow: h5, text: m5, sticky: g5, rectangle: f5, ellipse: S5, triangle: b5, line: T5, rotate: y5, "lock.aspect.ratio": w5, "unlock.aspect.ratio": x5, group: k5, ungroup: v5, "move.to.back": I5, "move.backward": C5, "move.forward": D5, "move.to.front": P5, "reset.angle": M5, lock: E5, unlock: B5, "align.distribute": R5, "move.to.page": A5, "flip.horizontal": L5, "flip.vertical": H5, move: z5, "to.front": O5, forward: F5, backward: j5, back: G5, language: V5, "translation.link": $5, "dock.position": N5, bottom: W5, left: U5, right: K5, top: _5, page: Y5, "keyboard.shortcuts": Z5, search: X5, loading: q5, "export.background": J5, transparent: Q5, auto: e3, light: t3, dark: n3, github: o3, twitter: r3, discord: s3, image: i3, "align.left": a3, "align.center.x": l3, "align.right": d3, "align.top": c3, "align.center.y": p3, "align.bottom": u3, "distribute.x": h3, "distribute.y": m3, "stretch.x": g3, "stretch.y": f3, "dialog.save.firsttime": S3, "dialog.save.again": b3, "dialog.cancel": T3, "dialog.no": y3, "dialog.yes": w3, "enter.file.name": x3, "tldraw-beta": k3, white: v3, lightGray: I3, gray: C3, black: D3, green: P3, cyan: M3, blue: E3, indigo: B3, violet: R3, red: A3, orange: L3, yellow: H3, solid: z3, dashed: O3, dotted: F3, small: j3, medium: G3, large: V3 };
var $3 = "", N3 = " ", W3 = "", U3 = "", K3 = "", _3 = "", Y3 = "", Z3 = "", X3 = "", q3 = "", J3 = "", Q3 = "", e8 = "", t8 = "", n8 = "", o8 = "", r8 = "", s8 = "", i8 = "", a8 = "", l8 = " ", d8 = "  ", c8 = " ", p8 = " ", u8 = " ", h8 = " ", m8 = " ", g8 = " ", f8 = "CAD   ", S8 = "  ", b8 = "Always Show Snaps", T8 = "Rotate Handles", y8 = "Binding Handles", w8 = "Clone Handles", x8 = " ", k8 = "", v8 = "", I8 = "", C8 = "", D8 = " ", P8 = " ", M8 = " ", E8 = " ", B8 = "", R8 = " ", A8 = "", L8 = "", H8 = "  ", z8 = " ", O8 = " ", F8 = " ", j8 = " ", G8 = "", V8 = "", $8 = " ", N8 = " ", W8 = "  ", U8 = "  ", K8 = "", _8 = "", Y8 = "", Z8 = "", X8 = "", q8 = "", J8 = "", Q8 = "", e6 = "", t6 = "", n6 = "", o6 = " ", r6 = " ", s6 = "", i6 = "", a6 = " ", l6 = " ", d6 = " ", c6 = " ", p6 = " ", u6 = "", h6 = "", m6 = " / ", g6 = " ", f6 = " ", S6 = " ", b6 = "", T6 = "", y6 = "", w6 = "", x6 = "", k6 = "", v6 = " ", I6 = " ", C6 = "", D6 = "", P6 = "", M6 = "", E6 = "", B6 = "Keyboard shortcuts", R6 = "", A6 = "{dots}", L6 = " ", H6 = " ", z6 = "Auto", O6 = "", F6 = "", j6 = "Github", G6 = "Twitter", V6 = "Discord", $6 = "", N6 = " ", W6 = "  ", U6 = " ", K6 = " ", _6 = "  ", Y6 = " ", Z6 = " ", X6 = " ", q6 = " ", J6 = " ", Q6 = "   ?", eH = "     ?", tH = " ", nH = "", oH = "", rH = " ", sH = "tldraw ", ha = { "style.menu.color": $3, "style.menu.fill": N3, "style.menu.dash": W3, "style.menu.size": U3, "style.menu.keep.open": K3, "style.menu.font": _3, "style.menu.align": Y3, styles: Z3, "zoom.in": X3, "zoom.out": q3, to: J3, "menu.tools": Q3, "menu.transform": e8, "menu.file": t8, "menu.edit": n8, "menu.view": o8, "menu.preferences": r8, "menu.sign.in": s8, "menu.sign.out": i8, "become.a.sponsor": a8, "zoom.to.content": l8, "zoom.to.selection": d8, "zoom.to.fit": c8, "zoom.to": p8, "preferences.dark.mode": u8, "preferences.focus.mode": h8, "preferences.debug.mode": m8, "preferences.show.grid": g8, "preferences.use.cad.selection": f8, "preferences.keep.stylemenu.open": S8, "preferences.always.show.snaps": b8, "preferences.rotate.handles": T8, "preferences.binding.handles": y8, "preferences.clone.handles": w8, undo: x8, redo: k8, cut: v8, copy: I8, paste: C8, "copy.as": D8, "export.as": P8, "select.all": M8, "select.none": E8, delete: B8, "new.project": R8, open: A8, save: L8, "save.as": H8, "upload.media": z8, "create.page": O8, "new.page": F8, "page.name": j8, duplicate: G8, cancel: V8, "copy.invite.link": $8, "copy.readonly.link": N8, "create.multiplayer.project": W8, "copy.multiplayer.project": U8, select: K8, eraser: _8, draw: Y8, arrow: Z8, text: X8, sticky: q8, rectangle: J8, ellipse: Q8, triangle: e6, line: t6, rotate: n6, "lock.aspect.ratio": o6, "unlock.aspect.ratio": r6, group: s6, ungroup: i6, "move.to.back": a6, "move.backward": l6, "move.forward": d6, "move.to.front": c6, "reset.angle": p6, lock: u6, unlock: h6, "align.distribute": m6, "move.to.page": g6, "flip.horizontal": f6, "flip.vertical": S6, move: b6, "to.front": T6, forward: y6, backward: w6, back: x6, language: k6, "translation.link": v6, "dock.position": I6, bottom: C6, left: D6, right: P6, top: M6, page: E6, "keyboard.shortcuts": B6, search: R6, loading: A6, "export.background": L6, transparent: H6, auto: z6, light: O6, dark: F6, github: j6, twitter: G6, discord: V6, image: $6, "align.left": N6, "align.center.x": W6, "align.right": U6, "align.top": K6, "align.center.y": _6, "align.bottom": Y6, "distribute.x": Z6, "distribute.y": X6, "stretch.x": q6, "stretch.y": J6, "dialog.save.firsttime": Q6, "dialog.save.again": eH, "dialog.cancel": tH, "dialog.no": nH, "dialog.yes": oH, "enter.file.name": rH, "tldraw-beta": sH };
var iH = "Farge", aH = "Fyll", lH = "Linje", dH = "Strrelse", cH = "Hold pen", pH = "Teksttype", uH = "Juster", hH = "Stiler", mH = "Zoom inn", gH = "Zoom ut", fH = "til", SH = "Fil", bH = "Rediger", TH = "Vis", yH = "Preferanser", wH = "Logg inn", xH = "Logg ut", kH = "Bli en sponsor", vH = "Zoom til valg", IH = "Zoom for  passe", CH = "Zoom til", DH = "Mrk modus", PH = "Fokus modus", MH = "Debug modus", EH = "Vis rutenett", BH = "Bruk CAD seleksjon", RH = "Hold stilmeny pen", AH = "Vis alltid snaps", LH = "Vis roteringshndtak", HH = "Vis bindingshndtak", zH = "Vis kloningshndtak", OH = "Angre", FH = "Gjr om", jH = "Klipp ut", GH = "Kopier", VH = "Lim inn", $H = "Kopier som", NH = "Eksporter som", WH = "Velg alle", UH = "Velg ingen", KH = "Slett", _H = "Nytt prosjekt", YH = "pne", ZH = "Lagre", XH = "Lagre som", qH = "Last opp media", JH = "Opprett side", QH = "Ny side", e4 = "Sidenavn", t4 = "Dupliser", n4 = "Avbryt", o4 = "Kopier invitasjonslink", r4 = "Opprett et flerspiller prosjekt", s4 = "Kopier til flerspiller prosjekt", i4 = "Velg", a4 = "Viskelr", l4 = "Tegn", d4 = "Pil", c4 = "Tekst", p4 = "Lapp", u4 = "Rektangel", h4 = "Ellipse", m4 = "Trekant", g4 = "Linje", f4 = "Roter", S4 = "Ls strrelsesforhold", b4 = "Ls opp strrelsesforhold", T4 = "Grupper", y4 = "Avgrupper", w4 = "Flytt bakerst", x4 = "Flytt bakover", k4 = "Flytt forover", v4 = "Flytt til front", I4 = "Tilbakestill vinkel", C4 = "Ls", D4 = "Ls opp", P4 = "Flytt til side", M4 = "Snu horisontalt", E4 = "Snu vertikalt", B4 = "Flytt", R4 = "Foran", A4 = "Framover", L4 = "Bakover", H4 = "Bakerst", z4 = "Sprk", ma = { "style.menu.color": iH, "style.menu.fill": aH, "style.menu.dash": lH, "style.menu.size": dH, "style.menu.keep.open": cH, "style.menu.font": pH, "style.menu.align": uH, styles: hH, "zoom.in": mH, "zoom.out": gH, to: fH, "menu.file": SH, "menu.edit": bH, "menu.view": TH, "menu.preferences": yH, "menu.sign.in": wH, "menu.sign.out": xH, "become.a.sponsor": kH, "zoom.to.selection": vH, "zoom.to.fit": IH, "zoom.to": CH, "preferences.dark.mode": DH, "preferences.focus.mode": PH, "preferences.debug.mode": MH, "preferences.show.grid": EH, "preferences.use.cad.selection": BH, "preferences.keep.stylemenu.open": RH, "preferences.always.show.snaps": AH, "preferences.rotate.handles": LH, "preferences.binding.handles": HH, "preferences.clone.handles": zH, undo: OH, redo: FH, cut: jH, copy: GH, paste: VH, "copy.as": $H, "export.as": NH, "select.all": WH, "select.none": UH, delete: KH, "new.project": _H, open: YH, save: ZH, "save.as": XH, "upload.media": qH, "create.page": JH, "new.page": QH, "page.name": e4, duplicate: t4, cancel: n4, "copy.invite.link": o4, "create.multiplayer.project": r4, "copy.multiplayer.project": s4, select: i4, eraser: a4, draw: l4, arrow: d4, text: c4, sticky: p4, rectangle: u4, ellipse: h4, triangle: m4, line: g4, rotate: f4, "lock.aspect.ratio": S4, "unlock.aspect.ratio": b4, group: T4, ungroup: y4, "move.to.back": w4, "move.backward": x4, "move.forward": k4, "move.to.front": v4, "reset.angle": I4, lock: C4, unlock: D4, "move.to.page": P4, "flip.horizontal": M4, "flip.vertical": E4, move: B4, "to.front": R4, forward: A4, backward: L4, back: H4, language: z4 };
var O4 = "", F4 = "", j4 = "", G4 = "", V4 = " ", $4 = "", N4 = "", W4 = "", U4 = " ", K4 = " ", _4 = "", Y4 = "", Z4 = " ", X4 = "", q4 = "", J4 = "  ", Q4 = "  ", ez = " ", tz = "  ", nz = "  ", oz = " ", rz = " ", sz = " ", iz = " ", az = " ", lz = "CAD  ", dz = "   ", cz = "  ", pz = " ", uz = " ", hz = " ", mz = " ", gz = " ", fz = " ", Sz = " ", bz = " ", Tz = " ", yz = " ", wz = " ", xz = "   ", kz = "", vz = " ", Iz = "", Cz = " ", Dz = " ", Pz = "  ", Mz = "  ", Ez = "   ", Bz = " ", Rz = " ", Az = " ", Lz = "   ", Hz = "   ", zz = "   ", Oz = "", Fz = "", jz = " ", Gz = "", Vz = "", $z = "", Nz = "", Wz = "", Uz = "", Kz = "", _z = "", Yz = "   ", Zz = "   ", Xz = "", qz = "  ", Jz = " ", Qz = "  ", e9 = " ", t9 = "  ", n9 = "  ", o9 = " ", r9 = " ", s9 = " ", i9 = "  ", a9 = "  ", l9 = "", d9 = " ", c9 = "", p9 = "", u9 = " ", h9 = "", ga = { "style.menu.color": O4, "style.menu.fill": F4, "style.menu.dash": j4, "style.menu.size": G4, "style.menu.keep.open": V4, "style.menu.font": $4, "style.menu.align": N4, styles: W4, "zoom.in": U4, "zoom.out": K4, to: _4, "menu.file": Y4, "menu.edit": Z4, "menu.view": X4, "menu.preferences": q4, "menu.sign.in": J4, "menu.sign.out": Q4, "become.a.sponsor": ez, "zoom.to.selection": tz, "zoom.to.fit": nz, "zoom.to": oz, "preferences.dark.mode": rz, "preferences.focus.mode": sz, "preferences.debug.mode": iz, "preferences.show.grid": az, "preferences.use.cad.selection": lz, "preferences.keep.stylemenu.open": dz, "preferences.always.show.snaps": cz, "preferences.rotate.handles": pz, "preferences.binding.handles": uz, "preferences.clone.handles": hz, undo: mz, redo: gz, cut: fz, copy: Sz, paste: bz, "copy.as": Tz, "export.as": yz, "select.all": wz, "select.none": xz, delete: kz, "new.project": vz, open: Iz, save: Cz, "save.as": Dz, "upload.media": Pz, "create.page": Mz, "new.page": Ez, "page.name": Bz, duplicate: Rz, cancel: Az, "copy.invite.link": Lz, "create.multiplayer.project": Hz, "copy.multiplayer.project": zz, select: Oz, eraser: Fz, draw: jz, arrow: Gz, text: Vz, sticky: $z, rectangle: Nz, ellipse: Wz, triangle: Uz, line: Kz, rotate: _z, "lock.aspect.ratio": Yz, "unlock.aspect.ratio": Zz, group: Xz, ungroup: qz, "move.to.back": Jz, "move.backward": Qz, "move.forward": e9, "move.to.front": t9, "reset.angle": n9, lock: o9, unlock: r9, "move.to.page": s9, "flip.horizontal": i9, "flip.vertical": a9, move: l9, "to.front": d9, forward: c9, backward: p9, back: u9, language: h9 };
var m9 = "Farge", g9 = "Fyll", f9 = "Line", S9 = "Storleik", b9 = "Hald open", T9 = "Teksttype", y9 = "Tilpass", w9 = "Stilar", x9 = "Zoom inn", k9 = "Zoom ut", v9 = "til", I9 = "Fil", C9 = "Rediger", D9 = "Vis", P9 = "Innstillingar", M9 = "Logg inn", E9 = "Logg ut", B9 = "Vert sponsor", R9 = "Zoom til innhald", A9 = "Zoom til valte element", L9 = "Zoom for  passe", H9 = "Zoom til", z9 = "Mrkmodus", O9 = "Fokusmodus", F9 = "Debugmodus", j9 = "Vis rutenett", G9 = "Bruk CAD-val", V9 = "Hald stilmeny open", $9 = "Vis alltid snaps", N9 = "Vis roteringshandtak", W9 = "Vis bindingshandtak", U9 = "Vis kloningshandtak", K9 = "Angre", _9 = "Gjer om", Y9 = "Klipp ut", Z9 = "Kopier", X9 = "Lim inn", q9 = "Kopier som", J9 = "Eksporter som", Q9 = "Vel alle", eO = "Vel ingen", tO = "Slett", nO = "Nytt prosjekt", oO = "Opne", rO = "Lagre", sO = "Lagre som", iO = "Last opp media", aO = "Opprett side", lO = "Ny side", dO = "Sidenamn", cO = "Dupliser", pO = "Avbryt", uO = "Kopier invitasjonslenke", hO = "Kopier invitasjonslenke (skrivebeskytta)", mO = "Lag samarbeidsprosjekt", gO = "Kopier til samarbeidsprosjekt", fO = "Vel", SO = "Viskelr", bO = "Teikn", TO = "Pil", yO = "Tekst", wO = "Lapp", xO = "Rektangel", kO = "Runding", vO = "Trekant", IO = "Line", CO = "Roter", DO = "Ls storleiksforhold", PO = "Ls opp storleiksforhold", MO = "Grupper", EO = "Avgrupper", BO = "Flytt bakarst", RO = "Flytt bakover", AO = "Flytt framover", LO = "Flytt til front", HO = "Tilbakestill vinkel", zO = "Ls", OO = "Ls opp", FO = "Flytt til side", jO = "Snu horisontalt", GO = "Snu vertikalt", VO = "Flytt", $O = "Framme", NO = "Framover", WO = "Bakover", UO = "Bakarst", KO = "Sprk", _O = "Les meir", YO = "Dokkplassering", ZO = "Nede", XO = "Venstre", qO = "Hgre", JO = "Oppe", QO = "Side", e7 = "Snggtastar", t7 = "Sk", n7 = "Lastar{dots}", o7 = "Eksporter bakgrunn", r7 = "Gjennomsiktig", s7 = "Auto", i7 = "Lys", a7 = "Mrk", l7 = "Github", d7 = "Twitter", c7 = "Discord", p7 = "Bilete", u7 = "Venstrestill", h7 = "Midtstill horisontalt", m7 = "Hgrestill", g7 = "Still til toppen", f7 = "Midtstill vertikalt", S7 = "Still til botnen", b7 = "Distribuer horisontalt", T7 = "Distribuer vertikalt", y7 = "Strekk horisontalt", w7 = "Strekk vertikalt", x7 = "Vil du lagre det noverande prosjektet ditt?", k7 = "Vil du lagre endringane i det noverande prosjektet ditt?", v7 = "Avbryt", I7 = "Nei", C7 = "Ja", D7 = "Fyll inn filnamn", P7 = "Prv den nye tldraw", M7 = "Kvit", E7 = "Lys gr", B7 = "Gr", R7 = "Svart", A7 = "Grn", L7 = "Cyan", H7 = "Bk", z7 = "Indigo", O7 = "Fiol", F7 = "Raud", j7 = "Oransj", G7 = "Gul", V7 = "Heil", $7 = "Stipla", N7 = "Prikka", W7 = "Liten", U7 = "Mellomstor", K7 = "Stor", fa = { "style.menu.color": m9, "style.menu.fill": g9, "style.menu.dash": f9, "style.menu.size": S9, "style.menu.keep.open": b9, "style.menu.font": T9, "style.menu.align": y9, styles: w9, "zoom.in": x9, "zoom.out": k9, to: v9, "menu.file": I9, "menu.edit": C9, "menu.view": D9, "menu.preferences": P9, "menu.sign.in": M9, "menu.sign.out": E9, "become.a.sponsor": B9, "zoom.to.content": R9, "zoom.to.selection": A9, "zoom.to.fit": L9, "zoom.to": H9, "preferences.dark.mode": z9, "preferences.focus.mode": O9, "preferences.debug.mode": F9, "preferences.show.grid": j9, "preferences.use.cad.selection": G9, "preferences.keep.stylemenu.open": V9, "preferences.always.show.snaps": $9, "preferences.rotate.handles": N9, "preferences.binding.handles": W9, "preferences.clone.handles": U9, undo: K9, redo: _9, cut: Y9, copy: Z9, paste: X9, "copy.as": q9, "export.as": J9, "select.all": Q9, "select.none": eO, delete: tO, "new.project": nO, open: oO, save: rO, "save.as": sO, "upload.media": iO, "create.page": aO, "new.page": lO, "page.name": dO, duplicate: cO, cancel: pO, "copy.invite.link": uO, "copy.readonly.link": hO, "create.multiplayer.project": mO, "copy.multiplayer.project": gO, select: fO, eraser: SO, draw: bO, arrow: TO, text: yO, sticky: wO, rectangle: xO, ellipse: kO, triangle: vO, line: IO, rotate: CO, "lock.aspect.ratio": DO, "unlock.aspect.ratio": PO, group: MO, ungroup: EO, "move.to.back": BO, "move.backward": RO, "move.forward": AO, "move.to.front": LO, "reset.angle": HO, lock: zO, unlock: OO, "move.to.page": FO, "flip.horizontal": jO, "flip.vertical": GO, move: VO, "to.front": $O, forward: NO, backward: WO, back: UO, language: KO, "translation.link": _O, "dock.position": YO, bottom: ZO, left: XO, right: qO, top: JO, page: QO, "keyboard.shortcuts": e7, search: t7, loading: n7, "export.background": o7, transparent: r7, auto: s7, light: i7, dark: a7, github: l7, twitter: d7, discord: c7, image: p7, "align.left": u7, "align.center.x": h7, "align.right": m7, "align.top": g7, "align.center.y": f7, "align.bottom": S7, "distribute.x": b7, "distribute.y": T7, "stretch.x": y7, "stretch.y": w7, "dialog.save.firsttime": x7, "dialog.save.again": k7, "dialog.cancel": v7, "dialog.no": I7, "dialog.yes": C7, "enter.file.name": D7, "tldraw-beta": P7, white: M7, lightGray: E7, gray: B7, black: R7, green: A7, cyan: L7, blue: H7, indigo: z7, violet: O7, red: F7, orange: j7, yellow: G7, solid: V7, dashed: $7, dotted: N7, small: W7, medium: U7, large: K7 };
var _7 = "Kolor", Y7 = "Wypenienie", Z7 = "Linia", X7 = "Rozmiar", q7 = "Zachowaj otwarte", J7 = "Czcionka", Q7 = "Wyrwnanie", eF = "Style", tF = "Przybli", nF = "Oddal", oF = "do", rF = "Plik", sF = "Edycja", iF = "Widok", aF = "Preferencje", lF = "Zaloguj", dF = "Wyloguj", cF = "Zosta sponsorem", pF = "Przybli do zaznaczenia", uF = "Wypenij ekran", hF = "Przybli do", mF = "Tryb ciemny", gF = "Tryb skupienia", fF = "Tryb debugowania", SF = "Poka siatk", bF = "Uyj zaznaczania CAD", TF = "Zachowaj menu styli otwarte", yF = "Przycigaj obiekty", wF = "Uchwyty obrotu", xF = "Uchwyty powizania", kF = "Uchwyty klonujce", vF = "Cofnij", IF = "Powtrz", CF = "Wytnij", DF = "Kopiuj", PF = "Wklej", MF = "Kopiuj jako", EF = "Eksportuj jako", BF = "Zaznacz wszystko", RF = "Odznacz wszystko", AF = "Usu", LF = "Nowy projekt", HF = "Otwrz", zF = "Zapisz", OF = "Zapisz jako", FF = "Zaaduj multimedia", jF = "Utwrz stron", GF = "Nowa strona", VF = "Nazwa strony", $F = "Powiel", NF = "Anuluj", WF = "Kopiuj link zaproszenia", UF = "Stwrz projekt wieloosobowy", KF = "Kopiuj do projektu wieloosobowego", _F = "Zaznacz", YF = "Gumka", ZF = "Rysuj", XF = "Strzaka", qF = "Tekst", JF = "Naklejka", QF = "Prostokt", ej = "Elipsa", tj = "Trjkt", nj = "Linia", oj = "Obr", rj = "Zablokuj proporcje", sj = "Odblokuj proporcje", ij = "Grupuj", aj = "Rozgrupuj", lj = "Przenie na ty", dj = "Przesu do tyu", cj = "Przesu do przodu", pj = "Przenie na przd", uj = "Resetuj kt", hj = "Zablokuj", mj = "Odblokuj", gj = "Przenie na stron", fj = "Odwr w poziomie", Sj = "Odwr w pionie", bj = "Przenie", Tj = "Na wierzch", yj = "Do przodu", wj = "Do tyu", xj = "Na spd", kj = "Jzyk", vj = "Czytaj wicej", Ij = "Pozycja przybornika", Cj = "D", Dj = "Lewa", Pj = "Prawa", Mj = "Gra", Ej = "Strona", Bj = "Skrty klawiszowe", Rj = "Szukaj", Aj = "adowanie{dots}", Lj = "Eksportuj to", Hj = "Przezroczyste", zj = "Automatyczny", Oj = "Jasny", Fj = "Ciemny", jj = "Github", Gj = "Twitter", Vj = "Discord", $j = "Obraz", Nj = "Wyrwnaj do lewej", Wj = "Wycentruj poziomo", Uj = "Wyrwnaj do prawej", Kj = "Wyrwnaj do gry", _j = "Wycentruj pionowo", Yj = "Wyrwnaj do dou", Zj = "Roz poziomo", Xj = "Roz pionowo", qj = "Rozcignij poziomo", Jj = "Rozcignij pionowo", Qj = "Czy chcesz zapisa biecy projekt?", eG = "Czy chcesz zapisa zmiany w biecym projekcie?", tG = "Anuluj", nG = "Nie", oG = "Tak", rG = "Podaj nazw pliku", sG = "Wyprbuj nowy tldraw", Sa = { "style.menu.color": _7, "style.menu.fill": Y7, "style.menu.dash": Z7, "style.menu.size": X7, "style.menu.keep.open": q7, "style.menu.font": J7, "style.menu.align": Q7, styles: eF, "zoom.in": tF, "zoom.out": nF, to: oF, "menu.file": rF, "menu.edit": sF, "menu.view": iF, "menu.preferences": aF, "menu.sign.in": lF, "menu.sign.out": dF, "become.a.sponsor": cF, "zoom.to.selection": pF, "zoom.to.fit": uF, "zoom.to": hF, "preferences.dark.mode": mF, "preferences.focus.mode": gF, "preferences.debug.mode": fF, "preferences.show.grid": SF, "preferences.use.cad.selection": bF, "preferences.keep.stylemenu.open": TF, "preferences.always.show.snaps": yF, "preferences.rotate.handles": wF, "preferences.binding.handles": xF, "preferences.clone.handles": kF, undo: vF, redo: IF, cut: CF, copy: DF, paste: PF, "copy.as": MF, "export.as": EF, "select.all": BF, "select.none": RF, delete: AF, "new.project": LF, open: HF, save: zF, "save.as": OF, "upload.media": FF, "create.page": jF, "new.page": GF, "page.name": VF, duplicate: $F, cancel: NF, "copy.invite.link": WF, "create.multiplayer.project": UF, "copy.multiplayer.project": KF, select: _F, eraser: YF, draw: ZF, arrow: XF, text: qF, sticky: JF, rectangle: QF, ellipse: ej, triangle: tj, line: nj, rotate: oj, "lock.aspect.ratio": rj, "unlock.aspect.ratio": sj, group: ij, ungroup: aj, "move.to.back": lj, "move.backward": dj, "move.forward": cj, "move.to.front": pj, "reset.angle": uj, lock: hj, unlock: mj, "move.to.page": gj, "flip.horizontal": fj, "flip.vertical": Sj, move: bj, "to.front": Tj, forward: yj, backward: wj, back: xj, language: kj, "translation.link": vj, "dock.position": Ij, bottom: Cj, left: Dj, right: Pj, top: Mj, page: Ej, "keyboard.shortcuts": Bj, search: Rj, loading: Aj, "export.background": Lj, transparent: Hj, auto: zj, light: Oj, dark: Fj, github: jj, twitter: Gj, discord: Vj, image: $j, "align.left": Nj, "align.center.x": Wj, "align.right": Uj, "align.top": Kj, "align.center.y": _j, "align.bottom": Yj, "distribute.x": Zj, "distribute.y": Xj, "stretch.x": qj, "stretch.y": Jj, "dialog.save.firsttime": Qj, "dialog.save.again": eG, "dialog.cancel": tG, "dialog.no": nG, "dialog.yes": oG, "enter.file.name": rG, "tldraw-beta": sG };
var iG = "Cor", aG = "Preencher", lG = "Trao", dG = "Tamanho", cG = "Manter aberto", pG = "Fonte", uG = "Alinhamento", hG = "Estilos", mG = "Aumentar zoom", gG = "Diminuir zoom", fG = "para", SG = "Arquivo", bG = "Editar", TG = "Visualizar", yG = "Preferncias", wG = "Entrar", xG = "Sair", kG = "Torne-se um patrocinador", vG = "Zoom para a seleo", IG = "Zoom para ajuste", CG = "Zoom para", DG = "Modo Escuro", PG = "Modo Foco", MG = "Modo Debug", EG = "Mostrar Grade", BG = "Usar seleo CAD", RG = "Manter Menu de Estilos Aberto", AG = "Mostrar Pontos de Ajuste", LG = "Controle de Rotao", HG = "Controle de Vnculos", zG = "Controle de Clone", OG = "Desfazer", FG = "Refazer", jG = "Cortar", GG = "Copiar", VG = "Colar", $G = "Copiar como", NG = "Exportar como", WG = "Selecionar todos", UG = "Selecionar nenhum", KG = "Deletar", _G = "Novo Projeto", YG = "Abrir", ZG = "Salvar", XG = "Salvar Como", qG = "Carregar Mdia", JG = "Pgina", QG = "Procurar", eV = "Carregando{dots}", tV = "Exportar Fundo", nV = "Transparente", oV = "Automtico", rV = "Claro", sV = "Escuro", iV = "Ferramentas", aV = "Transformar", lV = "Voltar ao Contedo", dV = "Saiba Mais", cV = "Copiar Link ReadOnly", pV = "Alinhar / Distribuir", uV = "Criar Pgina", hV = "Nova Pgina", mV = "Nome da Pgina", gV = "Duplicar", fV = "Cancelar", SV = "Copiar Link de Convite", bV = "Criar um Projeto Multijogador", TV = "Copiar para Projeto Multijogador", yV = "Selecionar", wV = "Borracha", xV = "Desenhar", kV = "Seta", vV = "Texto", IV = "Adesivo", CV = "Retngulo", DV = "Elipse", PV = "Tringulo", MV = "Linha", EV = "Rotacionar", BV = "Travar Proporo da Tela", RV = "Destravar Proporo da Tela", AV = "Agrupar", LV = "Desagrupar", HV = "Recuar", zV = "Enviar para Trs", OV = "Avanar", FV = "Trazer para Frente", jV = "Reiniciar ngulo", GV = "Travar", VV = "Destravar", $V = "Mover para Pgina", NV = "Virar Horizontalmente", WV = "Virar Verticalmente", UV = "Mover", KV = "Para Frente", _V = "Avanar", YV = "Recuar", ZV = "Voltar", XV = "Idioma", qV = "Imagem", JV = "Atalhos de Teclado", QV = "Posio de Ferramentas", e$ = "Inferior", t$ = "Superior", n$ = "Direita", o$ = "Esquerda", r$ = "Alinhar  esquerda", s$ = "Alinhar ao centro na horizontal", i$ = "Alinhar  direita", a$ = "Alinhas em cima", l$ = "Alinhar ao centro na vertical", d$ = "Alinhar embaixo", c$ = "Distruibuir na horizontal", p$ = "Distruibuir na vertical", u$ = "Esticar na horizontal", h$ = "Esticar na vertical", m$ = "Voc deseja salvar seu projeto atual?", g$ = "Voc deseja salvar as mudanas ao projeto atual?", f$ = "Cancelar", S$ = "No", b$ = "Sim", T$ = "Insira o nome do arquivo", ba = { "style.menu.color": iG, "style.menu.fill": aG, "style.menu.dash": lG, "style.menu.size": dG, "style.menu.keep.open": cG, "style.menu.font": pG, "style.menu.align": uG, styles: hG, "zoom.in": mG, "zoom.out": gG, to: fG, "menu.file": SG, "menu.edit": bG, "menu.view": TG, "menu.preferences": yG, "menu.sign.in": wG, "menu.sign.out": xG, "become.a.sponsor": kG, "zoom.to.selection": vG, "zoom.to.fit": IG, "zoom.to": CG, "preferences.dark.mode": DG, "preferences.focus.mode": PG, "preferences.debug.mode": MG, "preferences.show.grid": EG, "preferences.use.cad.selection": BG, "preferences.keep.stylemenu.open": RG, "preferences.always.show.snaps": AG, "preferences.rotate.handles": LG, "preferences.binding.handles": HG, "preferences.clone.handles": zG, undo: OG, redo: FG, cut: jG, copy: GG, paste: VG, "copy.as": $G, "export.as": NG, "select.all": WG, "select.none": UG, delete: KG, "new.project": _G, open: YG, save: ZG, "save.as": XG, "upload.media": qG, page: JG, search: QG, loading: eV, "export.background": tV, transparent: nV, auto: oV, light: rV, dark: sV, "menu.tools": iV, "menu.transform": aV, "zoom.to.content": lV, "translation.link": dV, "copy.readonly.link": cV, "align.distribute": pV, "create.page": uV, "new.page": hV, "page.name": mV, duplicate: gV, cancel: fV, "copy.invite.link": SV, "create.multiplayer.project": bV, "copy.multiplayer.project": TV, select: yV, eraser: wV, draw: xV, arrow: kV, text: vV, sticky: IV, rectangle: CV, ellipse: DV, triangle: PV, line: MV, rotate: EV, "lock.aspect.ratio": BV, "unlock.aspect.ratio": RV, group: AV, ungroup: LV, "move.to.back": HV, "move.backward": zV, "move.forward": OV, "move.to.front": FV, "reset.angle": jV, lock: GV, unlock: VV, "move.to.page": $V, "flip.horizontal": NV, "flip.vertical": WV, move: UV, "to.front": KV, forward: _V, backward: YV, back: ZV, language: XV, image: qV, "keyboard.shortcuts": JV, "dock.position": QV, bottom: e$, top: t$, right: n$, left: o$, "align.left": r$, "align.center.x": s$, "align.right": i$, "align.top": a$, "align.center.y": l$, "align.bottom": d$, "distribute.x": c$, "distribute.y": p$, "stretch.x": u$, "stretch.y": h$, "dialog.save.firsttime": m$, "dialog.save.again": g$, "dialog.cancel": f$, "dialog.no": S$, "dialog.yes": b$, "enter.file.name": T$ };
var y$ = "Cor", w$ = "Preencher", x$ = "Trao", k$ = "Tamanho", v$ = "Manter aberto", I$ = "Fonte", C$ = "Alinhamento", D$ = "Estilos", P$ = "Aumentar zoom", M$ = "Diminuir zoom", E$ = "para", B$ = "Ficheiro", R$ = "Editar", A$ = "Visualizar", L$ = "Preferncias", H$ = "Entrar", z$ = "Sair", O$ = "Torne-se um patrocinador", F$ = "Zoom na seleo", j$ = "Zoom para caber", G$ = "Zoom para", V$ = "Modo Escuro", $$ = "Modo Foco", N$ = "Modo Debug", W$ = "Mostrar Grelha", U$ = "Usar seleo CAD", K$ = "Manter Menu de Estilos Aberto", _$ = "Mostrar Pontos de Ajuste", Y$ = "Controlo de Rotao", Z$ = "Controlo de Binds", X$ = "Controlo de Clone", q$ = "Desfazer", J$ = "Refazer", Q$ = "Cortar", eN = "Copiar", tN = "Colar", nN = "Copiar como", oN = "Exportar como", rN = "Selecionar todos", sN = "Selecionar nenhum", iN = "Apagar", aN = "Novo Projeto", lN = "Abrir", dN = "Salvar", cN = "Salvar Como", pN = "Upload Mdia", uN = "Criar Pgina", hN = "Nova Pgina", mN = "Nome da Pgina", gN = "Duplicar", fN = "Cancelar", SN = "Copiar Link de Convite", bN = "Criar um Projeto Multi-Utilizador", TN = "Copiar num Projeto Multi-Utilizador", yN = "Selecionar", wN = "Borracha", xN = "Desenhar", kN = "Seta", vN = "Texto", IN = "Post-it", CN = "Retngulo", DN = "Elipse", PN = "Tringulo", MN = "Linha", EN = "Rodar", BN = "Trancar a Proporo", RN = "Destrancar a Proporo", AN = "Agrupar", LN = "Desagrupar", HN = "Colocar no Fundo", zN = "Mover abaixo", ON = "Mover acima", FN = "Colocar  Frente", jN = "Reiniciar ngulo", GN = "Trancar", VN = "Destrancar", $N = "Mover para Pgina", NN = "Inverter Horizontalmente", WN = "Inverter Verticalmente", UN = "Mover", KN = "Para Frente", _N = "Avanar", YN = "Recuar", ZN = "Voltar", XN = "Lngua", Ta = { "style.menu.color": y$, "style.menu.fill": w$, "style.menu.dash": x$, "style.menu.size": k$, "style.menu.keep.open": v$, "style.menu.font": I$, "style.menu.align": C$, styles: D$, "zoom.in": P$, "zoom.out": M$, to: E$, "menu.file": B$, "menu.edit": R$, "menu.view": A$, "menu.preferences": L$, "menu.sign.in": H$, "menu.sign.out": z$, "become.a.sponsor": O$, "zoom.to.selection": F$, "zoom.to.fit": j$, "zoom.to": G$, "preferences.dark.mode": V$, "preferences.focus.mode": $$, "preferences.debug.mode": N$, "preferences.show.grid": W$, "preferences.use.cad.selection": U$, "preferences.keep.stylemenu.open": K$, "preferences.always.show.snaps": _$, "preferences.rotate.handles": Y$, "preferences.binding.handles": Z$, "preferences.clone.handles": X$, undo: q$, redo: J$, cut: Q$, copy: eN, paste: tN, "copy.as": nN, "export.as": oN, "select.all": rN, "select.none": sN, delete: iN, "new.project": aN, open: lN, save: dN, "save.as": cN, "upload.media": pN, "create.page": uN, "new.page": hN, "page.name": mN, duplicate: gN, cancel: fN, "copy.invite.link": SN, "create.multiplayer.project": bN, "copy.multiplayer.project": TN, select: yN, eraser: wN, draw: xN, arrow: kN, text: vN, sticky: IN, rectangle: CN, ellipse: DN, triangle: PN, line: MN, rotate: EN, "lock.aspect.ratio": BN, "unlock.aspect.ratio": RN, group: AN, ungroup: LN, "move.to.back": HN, "move.backward": zN, "move.forward": ON, "move.to.front": FN, "reset.angle": jN, lock: GN, unlock: VN, "move.to.page": $N, "flip.horizontal": NN, "flip.vertical": WN, move: UN, "to.front": KN, forward: _N, backward: YN, back: ZN, language: XN };
var qN = "", JN = "", QN = "", eW = "", tW = " ", nW = "", oW = "", rW = "", sW = "", iW = "", aW = "", lW = "", dW = "", cW = "", pW = "", uW = "", hW = "", mW = "", gW = "", fW = " ", SW = "  ", bW = "  ", TW = "   ", yW = " ", wW = " ", xW = " ", kW = " ", vW = " ", IW = " CAD ", CW = "   ", DW = "  ", PW = " ", MW = " ", EW = " ", BW = "", RW = "", AW = "", LW = "", HW = "", zW = " ", OW = " ", FW = " ", jW = " ", GW = "", VW = " ", $W = "", NW = "", WW = " ", UW = " ", KW = " ", _W = " ", YW = " ", ZW = "", XW = "", qW = "  ", JW = "    ", QW = "  ", eU = "   ", tU = "", nU = "", oU = "", rU = "", sU = "", iU = "", aU = "", lU = "", dU = "", cU = "", pU = "", uU = "  ", hU = "  ", mU = "", gU = "", fU = " ", SU = "   ", bU = " ", TU = "   ", yU = " ", wU = "", xU = "", kU = " / ", vU = "  ", IU = " ", CU = " ", DU = "", PU = "  ", MU = "", EU = "  ", BU = "", RU = "", AU = "", LU = "  ", HU = "", zU = "", OU = "", FU = "", jU = "", GU = " ", VU = "", $U = "", NU = " ", WU = "", UU = "", KU = "", _U = "", YU = "", ZU = "   ", XU = "   ", qU = "   ", JU = "   ", QU = "   ", eK = "   ", tK = " ", nK = " ", oK = " ", rK = " ", sK = "", iK = "    ", aK = "   ", lK = "  ,     .     !", dK = "  ?", cK = "    ?", pK = "", uK = "", hK = "", mK = "  ", ya = { "style.menu.color": qN, "style.menu.fill": JN, "style.menu.dash": QN, "style.menu.size": eW, "style.menu.keep.open": tW, "style.menu.font": nW, "style.menu.align": oW, styles: rW, "zoom.in": sW, "zoom.out": iW, to: aW, "menu.tools": lW, "menu.transform": dW, "menu.file": cW, "menu.edit": pW, "menu.view": uW, "menu.preferences": hW, "menu.sign.in": mW, "menu.sign.out": gW, "become.a.sponsor": fW, "zoom.to.content": SW, "zoom.to.selection": bW, "zoom.to.fit": TW, "zoom.to": yW, "preferences.dark.mode": wW, "preferences.focus.mode": xW, "preferences.debug.mode": kW, "preferences.show.grid": vW, "preferences.use.cad.selection": IW, "preferences.keep.stylemenu.open": CW, "preferences.always.show.snaps": DW, "preferences.rotate.handles": PW, "preferences.binding.handles": MW, "preferences.clone.handles": EW, undo: BW, redo: RW, cut: AW, copy: LW, paste: HW, "copy.as": zW, "export.as": OW, "select.all": FW, "select.none": jW, delete: GW, "new.project": VW, open: $W, save: NW, "save.as": WW, "upload.media": UW, "create.page": KW, "new.page": _W, "page.name": YW, duplicate: ZW, cancel: XW, "copy.invite.link": qW, "copy.readonly.link": JW, "create.multiplayer.project": QW, "copy.multiplayer.project": eU, select: tU, eraser: nU, draw: oU, arrow: rU, text: sU, sticky: iU, rectangle: aU, ellipse: lU, triangle: dU, line: cU, rotate: pU, "lock.aspect.ratio": uU, "unlock.aspect.ratio": hU, group: mU, ungroup: gU, "move.to.back": fU, "move.backward": SU, "move.forward": bU, "move.to.front": TU, "reset.angle": yU, lock: wU, unlock: xU, "align.distribute": kU, "move.to.page": vU, "flip.horizontal": IU, "flip.vertical": CU, move: DU, "to.front": PU, forward: MU, backward: EU, back: BU, language: RU, "translation.link": AU, "dock.position": LU, bottom: HU, left: zU, right: OU, top: FU, page: jU, "keyboard.shortcuts": GU, search: VU, loading: $U, "export.background": NU, transparent: WU, auto: UU, light: KU, dark: _U, image: YU, "align.left": ZU, "align.center.x": XU, "align.right": qU, "align.top": JU, "align.center.y": QU, "align.bottom": eK, "distribute.x": tK, "distribute.y": nK, "stretch.x": oK, "stretch.y": rK, share: sK, "copy.current.page.link": iK, "copy.project.link": aK, "data.too.big.encoded": lK, "dialog.save.firsttime": dK, "dialog.save.again": cK, "dialog.cancel": pK, "dialog.no": uK, "dialog.yes": hK, "enter.file.name": mK };
var gK = "Frg", fK = "Ifylld", SK = "Streck", bK = "Storlek", TK = "Hll stilmenyn ppen", yK = "Typsnitt", wK = "Justera", xK = "Utseende", kK = "Zooma in", vK = "Zooma ut", IK = "Till", CK = "Verktyg", DK = "Transform", PK = "Arkiv", MK = "Redigera", EK = "Innehll", BK = "Instllningar", RK = "Logga in", AK = "Logga ut", LK = "Bli en sponsor", HK = "Anpassa zoom till innehll", zK = "Anpassa zoom till urval", OK = "Anpassa zoom till skrm", FK = "Zooma till", jK = "Mrkt lge", GK = "Fokuslge", VK = "Debuglge", $K = "Visa rutnt", NK = "Vlj som i CAD-mjukvara", WK = "Hll stilmenyn ppen", UK = "Visa alltid fstpunkter", KK = "Rotationshandtag", _K = "Bindningshandtag", YK = "Kloningshandtag", ZK = "ngra", XK = "Gr om", qK = "Klipp ut", JK = "Kopiera", QK = "Klistra in", e_ = "Kopiera som", t_ = "Exportera till", n_ = "Vlj alla", o_ = "Vlj ingen", r_ = "Radera", s_ = "Nytt projekt", i_ = "ppna", a_ = "Spara", l_ = "Spara som", d_ = "Ladda upp media", c_ = "Skapa sida", p_ = "Ny sida", u_ = "Sidnamn", h_ = "Duplicera", m_ = "Avbryt", g_ = "Kopiera lnk med redigeringsrttigheter", f_ = "Kopiera lnk med lsrttigheter", S_ = "Skapa ett Multiplayer-projekt", b_ = "Kopiera till Multiplayer-project", T_ = "Vlj", y_ = "Radera", w_ = "Rita", x_ = "Pil", k_ = "Text", v_ = "Klisterlapp", I_ = "Rektangel", C_ = "Ellips", D_ = "Triangel", P_ = "Linje", M_ = "Rotera", E_ = "Ls storleksfrhllande", B_ = "Ls upp storleksfrhllande", R_ = "Gruppera", A_ = "Avgruppera", L_ = "Placera lngst bak", H_ = "Flytta bakt", z_ = "Flytta framt", O_ = "Placera lngst fram", F_ = "terstll vinkel", j_ = "Ls", G_ = "Ls upp", V_ = "Justera / Placera", $_ = "Flytta till sida", N_ = "Vnd horisontellt", W_ = "Vnd vertikalt", U_ = "Flytta", K_ = "Till lngst fram", __ = "Framt", Y_ = "Bakt", Z_ = "Till lngst bak", X_ = "Sprk", q_ = "Mer information", J_ = "Dockningsposition", Q_ = "Botten", eY = "Vnster", tY = "Hger", nY = "Topp", oY = "Sida", rY = "Tangentbordsgenvgar", sY = "Sk", iY = "Laddar{dots}", aY = "Exportbakgrund", lY = "Transparent", dY = "Auto", cY = "Ljus", pY = "Mrk", uY = "Github", hY = "Twitter", mY = "Discord", gY = "Bild", wa = { "style.menu.color": gK, "style.menu.fill": fK, "style.menu.dash": SK, "style.menu.size": bK, "style.menu.keep.open": TK, "style.menu.font": yK, "style.menu.align": wK, styles: xK, "zoom.in": kK, "zoom.out": vK, to: IK, "menu.tools": CK, "menu.transform": DK, "menu.file": PK, "menu.edit": MK, "menu.view": EK, "menu.preferences": BK, "menu.sign.in": RK, "menu.sign.out": AK, "become.a.sponsor": LK, "zoom.to.content": HK, "zoom.to.selection": zK, "zoom.to.fit": OK, "zoom.to": FK, "preferences.dark.mode": jK, "preferences.focus.mode": GK, "preferences.debug.mode": VK, "preferences.show.grid": $K, "preferences.use.cad.selection": NK, "preferences.keep.stylemenu.open": WK, "preferences.always.show.snaps": UK, "preferences.rotate.handles": KK, "preferences.binding.handles": _K, "preferences.clone.handles": YK, undo: ZK, redo: XK, cut: qK, copy: JK, paste: QK, "copy.as": e_, "export.as": t_, "select.all": n_, "select.none": o_, delete: r_, "new.project": s_, open: i_, save: a_, "save.as": l_, "upload.media": d_, "create.page": c_, "new.page": p_, "page.name": u_, duplicate: h_, cancel: m_, "copy.invite.link": g_, "copy.readonly.link": f_, "create.multiplayer.project": S_, "copy.multiplayer.project": b_, select: T_, eraser: y_, draw: w_, arrow: x_, text: k_, sticky: v_, rectangle: I_, ellipse: C_, triangle: D_, line: P_, rotate: M_, "lock.aspect.ratio": E_, "unlock.aspect.ratio": B_, group: R_, ungroup: A_, "move.to.back": L_, "move.backward": H_, "move.forward": z_, "move.to.front": O_, "reset.angle": F_, lock: j_, unlock: G_, "align.distribute": V_, "move.to.page": $_, "flip.horizontal": N_, "flip.vertical": W_, move: U_, "to.front": K_, forward: __, backward: Y_, back: Z_, language: X_, "translation.link": q_, "dock.position": J_, bottom: Q_, left: eY, right: tY, top: nY, page: oY, "keyboard.shortcuts": rY, search: sY, loading: iY, "export.background": aY, transparent: lY, auto: dY, light: cY, dark: pY, github: uY, twitter: hY, discord: mY, image: gY };
var fY = "", SY = "", bY = " ", TY = "", yY = " ", wY = "", xY = "", kY = "", vY = " ", IY = " ", CY = "", DY = "", PY = "", MY = "", EY = "", BY = "", RY = "", AY = "", LY = "", HY = " ", zY = " ", OY = "  ", FY = " ", jY = "", GY = " ", VY = " ", $Y = " ", NY = " ", WY = "CAD ", UY = "  ", KY = "  ", _Y = " ", YY = " ", ZY = " ", XY = " ", qY = " ", JY = "", QY = "", eZ = "", tZ = " ", nZ = " ", oZ = " ", rZ = " ", sZ = "", iZ = " ", aZ = "", lZ = "", dZ = " ", cZ = " ", pZ = " ", uZ = " ", hZ = " ", mZ = "", gZ = "", fZ = "  ", SZ = "  ", bZ = "  ", TZ = "  ", yZ = "", wZ = "Eraser", xZ = "", kZ = "", vZ = "", IZ = "", CZ = "", DZ = "", PZ = "", MZ = "", EZ = "", BZ = "  ", RZ = "  ", AZ = " ", LZ = " ", HZ = " ", zZ = " ", OZ = " ", FZ = " ", jZ = " ", GZ = " ", VZ = " ", $Z = " /", NZ = " ", WZ = " ", UZ = " ", KZ = "", _Z = "", YZ = "", ZZ = "", XZ = "", qZ = "", JZ = "  ", QZ = " ", eX = "", tX = "", nX = "", oX = "", rX = "", sX = " ", iX = "", aX = "Loading{dots}", lX = " ", dX = " ", cX = "", pX = "", uX = "", hX = "Github", mX = "Twitter", gX = "Discord", fX = "", SX = " ", bX = "  ", TX = " ", yX = " ", wX = "  ", xX = " ", kX = " ", vX = " ", IX = " ", CX = " ", DX = "    ?", PX = "    ?", MX = "", EX = "", BX = "", RX = "  ", xa = { "style.menu.color": fY, "style.menu.fill": SY, "style.menu.dash": bY, "style.menu.size": TY, "style.menu.keep.open": yY, "style.menu.font": wY, "style.menu.align": xY, styles: kY, "zoom.in": vY, "zoom.out": IY, to: CY, "menu.tools": DY, "menu.transform": PY, "menu.file": MY, "menu.edit": EY, "menu.view": BY, "menu.preferences": RY, "menu.sign.in": AY, "menu.sign.out": LY, "become.a.sponsor": HY, "zoom.to.content": zY, "zoom.to.selection": OY, "zoom.to.fit": FY, "zoom.to": jY, "preferences.dark.mode": GY, "preferences.focus.mode": VY, "preferences.debug.mode": $Y, "preferences.show.grid": NY, "preferences.use.cad.selection": WY, "preferences.keep.stylemenu.open": UY, "preferences.always.show.snaps": KY, "preferences.rotate.handles": _Y, "preferences.binding.handles": YY, "preferences.clone.handles": ZY, undo: XY, redo: qY, cut: JY, copy: QY, paste: eZ, "copy.as": tZ, "export.as": nZ, "select.all": oZ, "select.none": rZ, delete: sZ, "new.project": iZ, open: aZ, save: lZ, "save.as": dZ, "upload.media": cZ, "create.page": pZ, "new.page": uZ, "page.name": hZ, duplicate: mZ, cancel: gZ, "copy.invite.link": fZ, "copy.readonly.link": SZ, "create.multiplayer.project": bZ, "copy.multiplayer.project": TZ, select: yZ, eraser: wZ, draw: xZ, arrow: kZ, text: vZ, sticky: IZ, rectangle: CZ, ellipse: DZ, triangle: PZ, line: MZ, rotate: EZ, "lock.aspect.ratio": BZ, "unlock.aspect.ratio": RZ, group: AZ, ungroup: LZ, "move.to.back": HZ, "move.backward": zZ, "move.forward": OZ, "move.to.front": FZ, "reset.angle": jZ, lock: GZ, unlock: VZ, "align.distribute": $Z, "move.to.page": NZ, "flip.horizontal": WZ, "flip.vertical": UZ, move: KZ, "to.front": _Z, forward: YZ, backward: ZZ, back: XZ, language: qZ, "translation.link": JZ, "dock.position": QZ, bottom: eX, left: tX, right: nX, top: oX, page: rX, "keyboard.shortcuts": sX, search: iX, loading: aX, "export.background": lX, transparent: dX, auto: cX, light: pX, dark: uX, github: hX, twitter: mX, discord: gX, image: fX, "align.left": SX, "align.center.x": bX, "align.right": TX, "align.top": yX, "align.center.y": wX, "align.bottom": xX, "distribute.x": kX, "distribute.y": vX, "stretch.x": IX, "stretch.y": CX, "dialog.save.firsttime": DX, "dialog.save.again": PX, "dialog.cancel": MX, "dialog.no": EX, "dialog.yes": BX, "enter.file.name": RX };
var AX = "", LX = "", HX = "", zX = "", OX = "", FX = "", jX = "", GX = "", VX = "", $X = "", NX = "", WX = "", UX = "", KX = "", _X = "", YX = "", ZX = "", XX = "", qX = "", JX = "", QX = "", eq = "", tq = "", nq = "", oq = "", rq = "", sq = "", iq = "", aq = " CAD", lq = "", dq = "", cq = "", pq = "", uq = "", hq = "", mq = "", gq = "", fq = "", Sq = "", bq = "", Tq = "", yq = "", wq = "", xq = "", kq = "", vq = "", Iq = "", Cq = "", Dq = "", Pq = "", Mq = "", Eq = "", Bq = "", Rq = "", Aq = "", Lq = "", Hq = "", zq = "", Oq = "", Fq = "", jq = "", Gq = "", Vq = "", $q = "", Nq = "", Wq = "", Uq = "", Kq = "", _q = "", Yq = "", Zq = "", Xq = "", qq = "", Jq = "", Qq = "", eJ = "", tJ = "", nJ = "", oJ = "", rJ = "", sJ = " / ", iJ = "", aJ = "", lJ = "", dJ = "", cJ = "", pJ = "", uJ = "", hJ = "", mJ = "", gJ = "", fJ = "", SJ = "", bJ = "", TJ = "", yJ = "", wJ = "", xJ = "", kJ = "", vJ = "{dots}", IJ = "", CJ = "", DJ = "", PJ = "", MJ = "", EJ = "Github", BJ = "Twitter", RJ = "Discord", AJ = "", LJ = "", HJ = "", zJ = "", OJ = "", FJ = "", jJ = "", GJ = "", VJ = "", $J = "", NJ = "", WJ = "?", UJ = "?", KJ = "", _J = "", YJ = "", ZJ = "", ka = { "style.menu.color": AX, "style.menu.fill": LX, "style.menu.dash": HX, "style.menu.size": zX, "style.menu.keep.open": OX, "style.menu.font": FX, "style.menu.align": jX, styles: GX, "zoom.in": VX, "zoom.out": $X, to: NX, "menu.tools": WX, "menu.transform": UX, "menu.file": KX, "menu.edit": _X, "menu.view": YX, "menu.preferences": ZX, "menu.sign.in": XX, "menu.sign.out": qX, "become.a.sponsor": JX, "zoom.to.content": QX, "zoom.to.selection": eq, "zoom.to.fit": tq, "zoom.to": nq, "preferences.dark.mode": oq, "preferences.focus.mode": rq, "preferences.debug.mode": sq, "preferences.show.grid": iq, "preferences.use.cad.selection": aq, "preferences.keep.stylemenu.open": lq, "preferences.always.show.snaps": dq, "preferences.rotate.handles": cq, "preferences.binding.handles": pq, "preferences.clone.handles": uq, undo: hq, redo: mq, cut: gq, copy: fq, paste: Sq, "copy.as": bq, "export.as": Tq, "select.all": yq, "select.none": wq, delete: xq, "new.project": kq, open: vq, save: Iq, "save.as": Cq, "upload.media": Dq, "create.page": Pq, "new.page": Mq, "page.name": Eq, duplicate: Bq, cancel: Rq, "copy.invite.link": Aq, "copy.readonly.link": Lq, "create.multiplayer.project": Hq, "copy.multiplayer.project": zq, select: Oq, eraser: Fq, draw: jq, arrow: Gq, text: Vq, sticky: $q, rectangle: Nq, ellipse: Wq, triangle: Uq, line: Kq, rotate: _q, "lock.aspect.ratio": Yq, "unlock.aspect.ratio": Zq, group: Xq, ungroup: qq, "move.to.back": Jq, "move.backward": Qq, "move.forward": eJ, "move.to.front": tJ, "reset.angle": nJ, lock: oJ, unlock: rJ, "align.distribute": sJ, "move.to.page": iJ, "flip.horizontal": aJ, "flip.vertical": lJ, move: dJ, "to.front": cJ, forward: pJ, backward: uJ, back: hJ, language: mJ, "translation.link": gJ, "dock.position": fJ, bottom: SJ, left: bJ, right: TJ, top: yJ, page: wJ, "keyboard.shortcuts": xJ, search: kJ, loading: vJ, "export.background": IJ, transparent: CJ, auto: DJ, light: PJ, dark: MJ, github: EJ, twitter: BJ, discord: RJ, image: AJ, "align.left": LJ, "align.center.x": HJ, "align.right": zJ, "align.top": OJ, "align.center.y": FJ, "align.bottom": jJ, "distribute.x": GJ, "distribute.y": VJ, "stretch.x": $J, "stretch.y": NJ, "dialog.save.firsttime": WJ, "dialog.save.again": UJ, "dialog.cancel": KJ, "dialog.no": _J, "dialog.yes": YJ, "enter.file.name": ZJ };
var XJ = "Renk", qJ = "Doldur", JJ = "izgi", QJ = "Boyut", eQ = "Ak Tut", tQ = "Yaz Tipi", nQ = "Hizala", oQ = "Stiller", rQ = "Yaknlatr", sQ = "Uzaklatr", iQ = "", aQ = "Dosya", lQ = "Dzenle", dQ = "Grnt", cQ = "Tercihler", pQ = "Giri Yap", uQ = "Oturumu Kapat", hQ = "Sponsor Ol", mQ = "Seime Yaknlatr", gQ = "Sdrmak iin Yaknlatr", fQ = "Yaknlatr", SQ = "Karanlk Mod", bQ = "Odak Modu", TQ = "Debug Modu", yQ = "Izgaray Gster", wQ = "CAD Seimi Kullan", xQ = "Stil Mensn Ak Tut", kQ = "Hiza izgilerini Hep Gster", vQ = "Rotasyon Kontrolcleri", IQ = "Balama Kontrolcleri", CQ = "Klon Kontrolcleri", DQ = "Geri Al", PQ = "Yinele", MQ = "Kes", EQ = "Kopyala", BQ = "Yaptr", RQ = "Olarak Kopyala", AQ = "Olarak Dar Aktar", LQ = "Hepsini Se", HQ = "Hibirini Seme", zQ = "Sil", OQ = "Yeni Proje", FQ = "A", jQ = "Kaydet", GQ = "Farkl Kaydet", VQ = "Medya Ykle", $Q = "Sayfa Olutur", NQ = "Yeni Sayfa", WQ = "Sayfa smi", UQ = "Kopya Olutur", KQ = "ptal", _Q = "Davet Linkini Kopyala", YQ = "ok Oyunculu Proje Olutur", ZQ = "ok Oyunculu Projeye Kopyala", XQ = "Se", qQ = "Silgi", JQ = "izim", QQ = "Ok", eee = "Yaz", tee = "Yapkan", nee = "Dikdrtgen", oee = "Elips", ree = "gen", see = "izgi", iee = "Dndr", aee = "En Boy Orann Kilitle", lee = "En Boy Oran Kilidini A", dee = "Grupla", cee = "Gruplamay Kaldr", pee = "Arkaya Ta", uee = "En Arkaya Ta", hee = "En ne Ta", mee = "ne Ta", gee = "Ay Sfrla", fee = "Kilitle", See = "Kilidini A", bee = "Sayfaya Ta", Tee = "Yatay evir", yee = "Dikey evir", wee = "Ta", xee = "ne", kee = "En ne", vee = "En Arkaya", Iee = "Arkaya", Cee = "Dil", va = { "style.menu.color": XJ, "style.menu.fill": qJ, "style.menu.dash": JJ, "style.menu.size": QJ, "style.menu.keep.open": eQ, "style.menu.font": tQ, "style.menu.align": nQ, styles: oQ, "zoom.in": rQ, "zoom.out": sQ, to: iQ, "menu.file": aQ, "menu.edit": lQ, "menu.view": dQ, "menu.preferences": cQ, "menu.sign.in": pQ, "menu.sign.out": uQ, "become.a.sponsor": hQ, "zoom.to.selection": mQ, "zoom.to.fit": gQ, "zoom.to": fQ, "preferences.dark.mode": SQ, "preferences.focus.mode": bQ, "preferences.debug.mode": TQ, "preferences.show.grid": yQ, "preferences.use.cad.selection": wQ, "preferences.keep.stylemenu.open": xQ, "preferences.always.show.snaps": kQ, "preferences.rotate.handles": vQ, "preferences.binding.handles": IQ, "preferences.clone.handles": CQ, undo: DQ, redo: PQ, cut: MQ, copy: EQ, paste: BQ, "copy.as": RQ, "export.as": AQ, "select.all": LQ, "select.none": HQ, delete: zQ, "new.project": OQ, open: FQ, save: jQ, "save.as": GQ, "upload.media": VQ, "create.page": $Q, "new.page": NQ, "page.name": WQ, duplicate: UQ, cancel: KQ, "copy.invite.link": _Q, "create.multiplayer.project": YQ, "copy.multiplayer.project": ZQ, select: XQ, eraser: qQ, draw: JQ, arrow: QQ, text: eee, sticky: tee, rectangle: nee, ellipse: oee, triangle: ree, line: see, rotate: iee, "lock.aspect.ratio": aee, "unlock.aspect.ratio": lee, group: dee, ungroup: cee, "move.to.back": pee, "move.backward": uee, "move.forward": hee, "move.to.front": mee, "reset.angle": gee, lock: fee, unlock: See, "move.to.page": bee, "flip.horizontal": Tee, "flip.vertical": yee, move: wee, "to.front": xee, forward: kee, backward: vee, back: Iee, language: Cee };
var Dee = "", Pee = "", Mee = "", Eee = "", Bee = " ", Ree = "", Aee = "", Lee = "", Hee = "", zee = "", Oee = "", Fee = "", jee = "", Gee = "", Vee = "", $ee = "", Nee = "", Wee = " ", Uee = "  ", Kee = "   ", _ee = " ", Yee = " ", Zee = " ", Xee = " ", qee = " ", Jee = " CAD ", Qee = "   ", ete = "  '", tte = " ", nte = " '", ote = " ", rte = "", ste = "", ite = "", ate = "", lte = "", dte = " ", cte = " ", pte = " ", ute = " ", hte = "", mte = " ", gte = "", fte = "", Ste = " ", bte = " ", Tte = " ", yte = " ", wte = " ", xte = "", kte = "", vte = "   ", Ite = "  ", Cte = "   ", Dte = "", Pte = "", Mte = "", Ete = "", Bte = "", Rte = "", Ate = "", Lte = "", Hte = "", zte = " ", Ote = "", Fte = "  ", jte = "   ", Gte = "", Vte = " ", $te = " ", Nte = "   ", Wte = " ", Ute = "   ", Kte = " ", _te = "", Yte = " ", Zte = "  ", Xte = " ", qte = " ", Jte = "", Qte = "  ", ene = " ", tne = "  ", nne = "", one = "", Ia = { "style.menu.color": Dee, "style.menu.fill": Pee, "style.menu.dash": Mee, "style.menu.size": Eee, "style.menu.keep.open": Bee, "style.menu.font": Ree, "style.menu.align": Aee, styles: Lee, "zoom.in": Hee, "zoom.out": zee, to: Oee, "menu.file": Fee, "menu.edit": jee, "menu.view": Gee, "menu.preferences": Vee, "menu.sign.in": $ee, "menu.sign.out": Nee, "become.a.sponsor": Wee, "zoom.to.selection": Uee, "zoom.to.fit": Kee, "zoom.to": _ee, "preferences.dark.mode": Yee, "preferences.focus.mode": Zee, "preferences.debug.mode": Xee, "preferences.show.grid": qee, "preferences.use.cad.selection": Jee, "preferences.keep.stylemenu.open": Qee, "preferences.always.show.snaps": ete, "preferences.rotate.handles": tte, "preferences.binding.handles": nte, "preferences.clone.handles": ote, undo: rte, redo: ste, cut: ite, copy: ate, paste: lte, "copy.as": dte, "export.as": cte, "select.all": pte, "select.none": ute, delete: hte, "new.project": mte, open: gte, save: fte, "save.as": Ste, "upload.media": bte, "create.page": Tte, "new.page": yte, "page.name": wte, duplicate: xte, cancel: kte, "copy.invite.link": vte, "create.multiplayer.project": Ite, "copy.multiplayer.project": Cte, select: Dte, eraser: Pte, draw: Mte, arrow: Ete, text: Bte, sticky: Rte, rectangle: Ate, ellipse: Lte, triangle: Hte, line: zte, rotate: Ote, "lock.aspect.ratio": Fte, "unlock.aspect.ratio": jte, group: Gte, ungroup: Vte, "move.to.back": $te, "move.backward": Nte, "move.forward": Wte, "move.to.front": Ute, "reset.angle": Kte, lock: _te, unlock: Yte, "move.to.page": Zte, "flip.horizontal": Xte, "flip.vertical": qte, move: Jte, "to.front": Qte, forward: ene, backward: tne, back: nne, language: one };
var rne = "", sne = "", ine = "", ane = "", lne = "", dne = "", cne = "", pne = "", une = "", hne = "", mne = "", gne = "", fne = "", Sne = "", bne = "", Tne = "", yne = "", wne = "", xne = "", kne = "", vne = "", Ine = "", Cne = "", Dne = "", Pne = "", Mne = "", Ene = "", Bne = "", Rne = "", Ane = " CAD ", Lne = "", Hne = "", zne = "", One = "", Fne = "", jne = "", Gne = "", Vne = "", $ne = "", Nne = "", Wne = "", Une = "", Kne = "", _ne = "", Yne = "", Zne = "", Xne = "", qne = "", Jne = "", Qne = "", eoe = "", toe = "", noe = "", ooe = "", roe = "", soe = "", ioe = "", aoe = "", loe = "", doe = "", coe = "", poe = "", uoe = "", hoe = "", moe = "", goe = "", foe = "", Soe = "", boe = "", Toe = "", yoe = "", woe = "", xoe = "", koe = "", voe = "", Ioe = "", Coe = "", Doe = "", Poe = "", Moe = "", Eoe = "", Boe = "", Roe = "", Aoe = "", Loe = "", Hoe = "", zoe = "", Ooe = "", Foe = "", joe = "", Goe = "", Voe = "", $oe = "", Noe = "", Woe = "", Uoe = "", Koe = "", _oe = "", Yoe = "", Zoe = "", Xoe = "", qoe = "", Joe = "", Qoe = "", ere = " / ", tre = "", nre = "", ore = "", rre = "", sre = "", Ca = { "style.menu.color": rne, "style.menu.fill": sne, "style.menu.dash": ine, "style.menu.size": ane, "style.menu.keep.open": lne, "style.menu.font": dne, "style.menu.align": cne, styles: pne, "zoom.in": une, "zoom.out": hne, to: mne, "menu.tools": gne, "menu.transform": fne, "menu.file": Sne, "menu.edit": bne, "menu.view": Tne, "menu.preferences": yne, "menu.sign.in": wne, "menu.sign.out": xne, search: kne, "become.a.sponsor": vne, "zoom.to.selection": Ine, "zoom.to.fit": Cne, "zoom.to": Dne, "zoom.to.content": Pne, "preferences.dark.mode": Mne, "preferences.focus.mode": Ene, "preferences.debug.mode": Bne, "preferences.show.grid": Rne, "preferences.use.cad.selection": Ane, "preferences.keep.stylemenu.open": Lne, "preferences.always.show.snaps": Hne, "preferences.rotate.handles": zne, "preferences.binding.handles": One, "preferences.clone.handles": Fne, undo: jne, redo: Gne, cut: Vne, copy: $ne, paste: Nne, "copy.as": Wne, "export.as": Une, "select.all": Kne, "select.none": _ne, delete: Yne, "new.project": Zne, open: Xne, save: qne, "save.as": Jne, "upload.media": Qne, "create.page": eoe, "new.page": toe, "page.name": noe, duplicate: ooe, cancel: roe, "copy.invite.link": soe, "create.multiplayer.project": ioe, "copy.multiplayer.project": aoe, select: loe, eraser: doe, draw: coe, arrow: poe, text: uoe, sticky: hoe, rectangle: moe, ellipse: goe, triangle: foe, line: Soe, rotate: boe, "lock.aspect.ratio": Toe, "unlock.aspect.ratio": yoe, group: woe, ungroup: xoe, "move.to.back": koe, "move.backward": voe, "move.forward": Ioe, "move.to.front": Coe, "reset.angle": Doe, lock: Poe, unlock: Moe, "move.to.page": Eoe, "flip.horizontal": Boe, "flip.vertical": Roe, move: Aoe, "to.front": Loe, forward: Hoe, backward: zoe, back: Ooe, language: Foe, "keyboard.shortcuts": joe, "translation.link": Goe, page: Voe, "dock.position": $oe, bottom: Noe, left: Woe, right: Uoe, top: Koe, "export.background": _oe, transparent: Yoe, auto: Zoe, light: Xoe, dark: qoe, "copy.readonly.link": Joe, image: Qoe, "align.distribute": ere, "dialog.save.firsttime": tre, "dialog.save.again": nre, "dialog.cancel": ore, "dialog.no": rre, "dialog.yes": sre };
var ire = "", are = "", lre = "", dre = "", cre = "", pre = "", ure = "", hre = "", mre = "", gre = "", fre = "", Sre = "", bre = "", Tre = "", yre = "", wre = "", xre = "", kre = "", vre = "", Ire = "", Cre = "", Dre = "", Pre = "", Mre = "", Ere = "", Bre = " CAD ", Rre = "", Are = "", Lre = "", Hre = "", zre = "", Ore = "", Fre = "", jre = "", Gre = "", Vre = "", $re = "", Nre = "", Wre = "", Ure = "", Kre = "", _re = "", Yre = "", Zre = "", Xre = "", qre = "", Jre = "", Qre = "", ese = "", tse = "", nse = "", ose = "", rse = "", sse = "", ise = "", ase = "", lse = "", dse = "", cse = "", pse = "", use = "", hse = "", mse = "", gse = "", fse = "", Sse = "", bse = "", Tse = "", yse = "", wse = "", xse = "", kse = "", vse = "", Ise = "", Cse = "", Dse = "", Pse = "", Mse = "", Ese = "", Bse = "", Rse = "", Ase = "", Lse = "", Hse = "", zse = "", Ose = "", Fse = "", jse = "", Gse = "", Vse = "", $se = "", Nse = "", Wse = "", Da = { "style.menu.color": ire, "style.menu.fill": are, "style.menu.dash": lre, "style.menu.size": dre, "style.menu.keep.open": cre, "style.menu.font": pre, "style.menu.align": ure, styles: hre, "zoom.in": mre, "zoom.out": gre, to: fre, "menu.file": Sre, "menu.edit": bre, "menu.view": Tre, "menu.preferences": yre, "menu.sign.in": wre, "menu.sign.out": xre, "become.a.sponsor": kre, "zoom.to.selection": vre, "zoom.to.fit": Ire, "zoom.to": Cre, "preferences.dark.mode": Dre, "preferences.focus.mode": Pre, "preferences.debug.mode": Mre, "preferences.show.grid": Ere, "preferences.use.cad.selection": Bre, "preferences.keep.stylemenu.open": Rre, "preferences.always.show.snaps": Are, "preferences.rotate.handles": Lre, "preferences.binding.handles": Hre, "preferences.clone.handles": zre, undo: Ore, redo: Fre, cut: jre, copy: Gre, paste: Vre, "copy.as": $re, "export.as": Nre, "select.all": Wre, "select.none": Ure, delete: Kre, "new.project": _re, open: Yre, save: Zre, "save.as": Xre, "upload.media": qre, "create.page": Jre, "new.page": Qre, "page.name": ese, duplicate: tse, cancel: nse, "copy.invite.link": ose, "copy.readonly.link": rse, "create.multiplayer.project": sse, "copy.multiplayer.project": ise, select: ase, eraser: lse, draw: dse, arrow: cse, text: pse, sticky: use, rectangle: hse, ellipse: mse, triangle: gse, line: fse, rotate: Sse, "lock.aspect.ratio": bse, "unlock.aspect.ratio": Tse, group: yse, ungroup: wse, "move.to.back": xse, "move.backward": kse, "move.forward": vse, "move.to.front": Ise, "reset.angle": Cse, lock: Dse, unlock: Pse, "move.to.page": Mse, "flip.horizontal": Ese, "flip.vertical": Bse, move: Rse, "to.front": Ase, forward: Lse, backward: Hse, back: zse, language: Ose, "translation.link": Fse, "dock.position": jse, bottom: Gse, left: Vse, right: $se, top: Nse, page: Wse };
var Ir = [{ locale: "ar", label: "", messages: Qi }, { locale: "da", label: "Danish", messages: ea }, { locale: "de", label: "Deutsch", messages: ta }, { locale: "en", label: "English", messages: na }, { locale: "es", label: "Espaol", messages: oa }, { locale: "fa", label: "", messages: ra }, { locale: "fr", label: "Franais", messages: sa }, { locale: "gl", label: "Galego", messages: ia }, { locale: "he", label: "", messages: aa }, { locale: "it", label: "Italiano", messages: la }, { locale: "ja", label: "", messages: da }, { locale: "ko-kr", label: "", messages: ca }, { locale: "my", label: "", messages: ha }, { locale: "nb-no", label: "Norwegian Bokml", messages: ma }, { locale: "ne", label: "", messages: ga }, { locale: "nn-no", label: "Norwegian Nynorsk", messages: fa }, { locale: "pl", label: "Polski", messages: Sa }, { locale: "pt", label: "Portugus - Europeu", messages: Ta }, { locale: "pt-br", label: "Portugus - Brasil", messages: ba }, { locale: "ru", label: "Russian", messages: ya }, { locale: "sv", label: "Svenska", messages: wa }, { locale: "te", label: "", messages: xa }, { locale: "tr", label: "Trke", messages: va }, { locale: "uk", label: "Ukrainian", messages: Ia }, { locale: "zh-ch", label: "", messages: Ca }, { locale: "zh-tw", label: " ()", messages: Da }, { locale: "th", label: "", messages: ka }, { locale: "ku", label: "", messages: pa }];
Ir.sort((r10, e10) => r10.locale < e10.locale ? -1 : 1);
function Pa(r10) {
  var t10;
  let e10 = Ir.find((n10) => n10.locale === r10);
  return { locale: r10, label: (t10 = e10 == null ? void 0 : e10.label) != null ? t10 : r10, messages: S(S({}, ua), e10 == null ? void 0 : e10.messages) };
}
function Ea(r10) {
  return reactExports.useMemo(() => Pa(r10 != null ? r10 : navigator.language.split(/[-_]/)[0]), [r10]);
}
var gs = reactExports.createContext({}), br = () => {
  let r10 = reactExports.useContext(gs);
  if (!r10) throw new Error("useCtx must be inside a Provider with a value");
  return r10;
};
var ke = reactExports.forwardRef((m10, p10) => {
  var h10 = m10, { onSelect: r10, onClick: e10, onDoubleClick: t10, variant: n10, children: o10, isToolLocked: s10 = false, disabled: a10 = false, isActive: d10 = false, onKeyDown: i10, id: c10 } = h10, u10 = Je(h10, ["onSelect", "onClick", "onDoubleClick", "variant", "children", "isToolLocked", "disabled", "isActive", "onKeyDown", "id"]);
  return reactExports.createElement(Use, S({ ref: p10, isActive: d10, variant: n10, onClick: e10, disabled: a10, onPointerDown: r10, onDoubleClick: t10, onKeyDown: i10, bp: Qe, id: c10 }, u10), reactExports.createElement(Yt, null, o10), s10 && reactExports.createElement(Kse, null));
});
function Xt(s10) {
  var a10 = s10, { label: r10, kbd: e10, variant: t10, isLocked: n10 } = a10, o10 = Je(a10, ["label", "kbd", "variant", "isLocked"]);
  let d10 = me(), i10 = reactExports.useCallback(() => {
    d10.toggleToolLock();
  }, []), c10 = reactExports.useCallback((u10) => {
    u10.key === " " && d10.isForcePanning && u10.preventDefault();
  }, []);
  return reactExports.createElement(Le, { label: r10[0].toUpperCase() + r10.slice(1), kbd: e10 }, reactExports.createElement(ke, x(S({}, o10), { variant: t10, isToolLocked: n10 && o10.isActive, onDoubleClick: i10, onKeyDown: c10, "aria-label": r10[0].toUpperCase() + r10.slice(1) })));
}
var Yt = H2("div", { position: "relative", height: "100%", width: "100%", backgroundColor: "$panel", borderRadius: "$2", margin: "0", display: "flex", alignItems: "center", justifyContent: "center", fontFamily: "$ui", color: "inherit", userSelect: "none", WebkitUserSelect: "none", boxSizing: "border-box", border: "1px solid transparent", "-webkit-tap-highlight-color": "transparent", "tap-highlight-color": "transparent" }), Use = H2("button", { position: "relative", color: "$text", fontSize: "$0", background: "none", margin: "0", padding: "$2", display: "flex", alignItems: "center", justifyContent: "center", outline: "none", cursor: "pointer", pointerEvents: "all", height: "40px", width: "40px", border: "1px solid $panel", "-webkit-tap-highlight-color": "transparent", "tap-highlight-color": "transparent", [`&:disabled ${Yt}`]: { opacity: 0.618 }, variants: { variant: { primary: { marginTop: "0" }, icon: { [`& ${Yt}`]: { display: "grid", "& > *": { gridRow: 1, gridColumn: 1 } } }, text: { width: "auto", [`& ${Yt}`]: { fontSize: "$1", padding: "0 $3", gap: "$3" } }, circle: { padding: 0, height: 32, width: 32, border: "none", [`& ${Yt}`]: { border: "1px solid $panelContrast", borderRadius: "100%", boxShadow: "$panel" }, [`& ${Yt} > svg`]: { width: 14, height: 14 } } }, isActive: { true: {}, false: {} }, bp: { mobile: { padding: 0 }, small: {} } }, compoundVariants: [{ variant: "primary", bp: "mobile", css: { height: 40, width: 36, [`& ${Yt} > svg`]: { width: 16, height: 16 } } }, { variant: "primary", bp: "small", css: { height: "40px", width: "40px", [`& ${Yt} > svg`]: { width: 20, height: 20 } } }, { isActive: true, css: { [`${Yt}`]: { backgroundColor: "$selected", color: "$selectedContrast" } } }, { isActive: false, bp: "small", css: { [`&:hover:not(:disabled) ${Yt}`]: { backgroundColor: "$hover" }, [`&:focus:not(:disabled) ${Yt}`]: { backgroundColor: "$hover" } } }] }), Kse = H2("div", { position: "absolute", width: 10, height: 10, backgroundColor: "$selected", borderRadius: "100%", bottom: -2, border: "2px solid $panel", zIndex: 100 });
var rie = (r10) => r10.document.pageStates[r10.appState.currentPageId].selectedIds.length, sie = (r10) => r10.settings.isDebugMode, iie = (r10) => r10.document.pageStates[r10.appState.currentPageId].selectedIds.some((e10) => r10.document.pages[r10.appState.currentPageId].shapes[e10].children !== void 0), aie = (r10) => r10.stopPropagation(), lie = ({ onBlur: r10, children: e10 }) => {
  let t10 = Lt();
  return reactExports.createElement($1b0217ee4a91d156$export$be92b6f5f03c0fe9, { dir: "ltr" }, reactExports.createElement($1b0217ee4a91d156$export$41fb9f06171c75f4, { dir: "ltr" }, e10), reactExports.createElement($1b0217ee4a91d156$export$602eac185826482c, { container: t10.current }, reactExports.createElement($1b0217ee4a91d156$export$7c6e2c02157bb7d2, { onEscapeKeyDown: aie, tabIndex: -1, onBlur: r10, asChild: true }, reactExports.createElement(Rt, { id: "TD-ContextMenu" }, reactExports.createElement(die, null)))));
}, die = reactExports.memo(function() {
  let e10 = me(), t10 = useIntl(), n10 = e10.useStore(rie), o10 = e10.useStore(sie), s10 = e10.useStore(iie), a10 = reactExports.useCallback(() => {
    e10.flipHorizontal();
  }, [e10]), d10 = reactExports.useCallback(() => {
    e10.flipVertical();
  }, [e10]), i10 = reactExports.useCallback(() => {
    e10.duplicate();
  }, [e10]), c10 = reactExports.useCallback(() => {
    e10.toggleLocked();
  }, [e10]), u10 = reactExports.useCallback(() => {
    e10.group();
  }, [e10]), p10 = reactExports.useCallback(() => {
    e10.moveToBack();
  }, [e10]), m10 = reactExports.useCallback(() => {
    e10.moveBackward();
  }, [e10]), h10 = reactExports.useCallback(() => {
    e10.moveForward();
  }, [e10]), g10 = reactExports.useCallback(() => {
    e10.moveToFront();
  }, [e10]), f10 = reactExports.useCallback(() => {
    e10.delete();
  }, [e10]), T10 = reactExports.useCallback(() => {
    e10.cut();
  }, [e10]), w10 = reactExports.useCallback(() => {
    e10.copy();
  }, [e10]), b10 = reactExports.useCallback(() => {
    e10.paste();
  }, [e10]), y10 = reactExports.useCallback(() => {
    e10.copyImage("svg", { scale: 1, quality: 1, transparentBackground: false });
  }, [e10]), R10 = reactExports.useCallback(() => {
    e10.copyImage("png", { scale: 2, quality: 1, transparentBackground: true });
  }, [e10]), U10 = reactExports.useCallback(() => {
    e10.undo();
  }, [e10]), L10 = reactExports.useCallback(() => {
    e10.redo();
  }, [e10]), k10 = reactExports.useCallback(() => pe(this, null, function* () {
    e10.exportImage("png", { scale: 2, quality: 1 });
  }), [e10]), I10 = reactExports.useCallback(() => pe(this, null, function* () {
    e10.exportImage("jpeg", { scale: 2, quality: 1 });
  }), [e10]), q10 = reactExports.useCallback(() => pe(this, null, function* () {
    e10.exportImage("webp", { scale: 2, quality: 1 });
  }), [e10]), de2 = reactExports.useCallback(() => pe(this, null, function* () {
    e10.exportImage("svg", { scale: 1, quality: 1 });
  }), [e10]), le2 = reactExports.useCallback(() => pe(this, null, function* () {
    e10.copyJson();
  }), [e10]), Ae = reactExports.useCallback(() => pe(this, null, function* () {
    e10.exportJson();
  }), [e10]), Ce2 = n10 > 0, De2 = n10 > 1, Ve = n10 > 2;
  return reactExports.createElement(reactExports.Fragment, null, Ce2 ? reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Ee, { onClick: i10, kbd: "#D", id: "TD-ContextMenu-Duplicate" }, reactExports.createElement(MemoizedFormattedMessage, { id: "duplicate" })), reactExports.createElement(Ee, { onClick: a10, kbd: "H", id: "TD-ContextMenu-Flip_Horizontal" }, reactExports.createElement(MemoizedFormattedMessage, { id: "flip.horizontal" })), reactExports.createElement(Ee, { onClick: d10, kbd: "V", id: "TD-ContextMenu-Flip_Vertical" }, reactExports.createElement(MemoizedFormattedMessage, { id: "flip.vertical" })), reactExports.createElement(Ee, { onClick: c10, kbd: "#L", id: "TD-ContextMenu- Lock_Unlock" }, reactExports.createElement(MemoizedFormattedMessage, { id: "lock" }), " / ", reactExports.createElement(MemoizedFormattedMessage, { id: "unlock" })), (De2 || s10) && reactExports.createElement(Pe, null), De2 && reactExports.createElement(Ee, { onClick: u10, kbd: "#G", id: "TD-ContextMenu-Group" }, reactExports.createElement(MemoizedFormattedMessage, { id: "group" })), s10 && reactExports.createElement(Ee, { onClick: u10, kbd: "#G", id: "TD-ContextMenu-Ungroup" }, reactExports.createElement(MemoizedFormattedMessage, { id: "ungroup" })), reactExports.createElement(Pe, null), reactExports.createElement(Dr, { label: t10.formatMessage({ id: "move" }), id: "TD-ContextMenu-Move" }, reactExports.createElement(Ee, { onClick: g10, kbd: "]", id: "TD-ContextMenu-Move-To_Front" }, reactExports.createElement(MemoizedFormattedMessage, { id: "to.front" })), reactExports.createElement(Ee, { onClick: h10, kbd: "]", id: "TD-ContextMenu-Move-Forward" }, reactExports.createElement(MemoizedFormattedMessage, { id: "forward" })), reactExports.createElement(Ee, { onClick: m10, kbd: "[", id: "TD-ContextMenu-Move-Backward" }, reactExports.createElement(MemoizedFormattedMessage, { id: "backward" })), reactExports.createElement(Ee, { onClick: p10, kbd: "[", id: "TD-ContextMenu-Move-To_Back" }, reactExports.createElement(MemoizedFormattedMessage, { id: "back" }))), reactExports.createElement(mie, null), De2 && reactExports.createElement(cie, { hasTwoOrMore: De2, hasThreeOrMore: Ve }), reactExports.createElement(Pe, null), reactExports.createElement(Ee, { onClick: T10, kbd: "#X", id: "TD-ContextMenu-Cut" }, reactExports.createElement(MemoizedFormattedMessage, { id: "cut" })), reactExports.createElement(Ee, { onClick: w10, kbd: "#C", id: "TD-ContextMenu-Copy" }, reactExports.createElement(MemoizedFormattedMessage, { id: "copy" })), reactExports.createElement(Ee, { onClick: b10, kbd: "#V", id: "TD-ContextMenu-Paste" }, reactExports.createElement(MemoizedFormattedMessage, { id: "paste" })), reactExports.createElement(Pe, null), reactExports.createElement(Dr, { label: `${t10.formatMessage({ id: "copy.as" })}...`, size: "small", id: "TD-ContextMenu-Copy-As" }, reactExports.createElement(Ee, { onClick: y10, id: "TD-ContextMenu-Copy-as-SVG" }, "SVG"), reactExports.createElement(Ee, { onClick: R10, id: "TD-ContextMenu-Copy-As-PNG" }, "PNG"), o10 && reactExports.createElement(Ee, { onClick: le2, id: "TD-ContextMenu-Copy_as_JSON" }, "JSON")), reactExports.createElement(Dr, { label: `${t10.formatMessage({ id: "export.as" })}...`, size: "small", id: "TD-ContextMenu-Export" }, reactExports.createElement(Ee, { onClick: de2, id: "TD-ContextMenu-Export-SVG" }, "SVG"), reactExports.createElement(Ee, { onClick: k10, id: "TD-ContextMenu-Export-PNG" }, "PNG"), reactExports.createElement(Ee, { onClick: I10, id: "TD-ContextMenu-Export-JPG" }, "JPG"), reactExports.createElement(Ee, { onClick: q10, id: "TD-ContextMenu-Export-WEBP" }, "WEBP"), o10 && reactExports.createElement(Ee, { onClick: Ae, id: "TD-ContextMenu-Export-JSON" }, "JSON")), reactExports.createElement(Pe, null), reactExports.createElement(Ee, { onClick: f10, kbd: "", id: "TD-ContextMenu-Delete" }, reactExports.createElement(MemoizedFormattedMessage, { id: "delete" }))) : reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Ee, { onClick: b10, kbd: "#V", id: "TD-ContextMenu-Paste" }, reactExports.createElement(MemoizedFormattedMessage, { id: "paste" })), reactExports.createElement(Ee, { onClick: U10, kbd: "#Z", id: "TD-ContextMenu-Undo" }, reactExports.createElement(MemoizedFormattedMessage, { id: "undo" })), reactExports.createElement(Ee, { onClick: L10, kbd: "#Z", id: "TD-ContextMenu-Redo" }, reactExports.createElement(MemoizedFormattedMessage, { id: "redo" })), reactExports.createElement(Dr, { label: `${t10.formatMessage({ id: "export.as" })}...`, size: "small", id: "TD-ContextMenu-Export" }, reactExports.createElement(Ee, { onClick: de2, id: "TD-ContextMenu-Export-SVG" }, "SVG"), reactExports.createElement(Ee, { onClick: k10, id: "TD-ContextMenu-Export-PNG" }, "PNG"), reactExports.createElement(Ee, { onClick: I10, id: "TD-ContextMenu-Export-JPG" }, "JPG"), reactExports.createElement(Ee, { onClick: q10, id: "TD-ContextMenu-Export-WEBP" }, "WEBP"), o10 && reactExports.createElement(Ee, { onClick: Ae, id: "TD-ContextMenu-Export-JSON" }, "JSON"))));
});
function cie({ hasThreeOrMore: r10 }) {
  let e10 = me(), t10 = reactExports.useCallback(() => {
    e10.align("top");
  }, [e10]), n10 = reactExports.useCallback(() => {
    e10.align("centerVertical");
  }, [e10]), o10 = reactExports.useCallback(() => {
    e10.align("bottom");
  }, [e10]), s10 = reactExports.useCallback(() => {
    e10.stretch("vertical");
  }, [e10]), a10 = reactExports.useCallback(() => {
    e10.distribute("vertical");
  }, [e10]), d10 = reactExports.useCallback(() => {
    e10.align("left");
  }, [e10]), i10 = reactExports.useCallback(() => {
    e10.align("centerHorizontal");
  }, [e10]), c10 = reactExports.useCallback(() => {
    e10.align("right");
  }, [e10]), u10 = reactExports.useCallback(() => {
    e10.stretch("horizontal");
  }, [e10]), p10 = reactExports.useCallback(() => {
    e10.distribute("horizontal");
  }, [e10]), m10 = Lt();
  return reactExports.createElement($1b0217ee4a91d156$export$d7a01e11500dfb6f, null, reactExports.createElement(Ss, { id: "TD-ContextMenu-Align-Distribute-Trigger" }, reactExports.createElement(MemoizedFormattedMessage, { id: "align.distribute" })), reactExports.createElement($1b0217ee4a91d156$export$602eac185826482c, { container: m10.current }, reactExports.createElement($1b0217ee4a91d156$export$6d4de93b380beddf, { asChild: true, sideOffset: 4, alignOffset: -2 }, reactExports.createElement(pie, { numberOfSelected: r10 ? "threeOrMore" : "twoOrMore" }, reactExports.createElement(an, { onClick: d10, id: "TD-ContextMenu-Align_Distribute-AlignLeft" }, reactExports.createElement(AlignLeftIcon, null)), reactExports.createElement(an, { onClick: i10, id: "TD-ContextMenu-Align_Distribute-AlignCenterHorizontal" }, reactExports.createElement(AlignCenterHorizontallyIcon, null)), reactExports.createElement(an, { onClick: c10, id: "TD-ContextMenu-Align_Distribute-AlignRight" }, reactExports.createElement(AlignRightIcon, null)), reactExports.createElement(an, { onClick: u10, id: "TD-ContextMenu-Align_Distribute-StretchHorizontal" }, reactExports.createElement(StretchHorizontallyIcon, null)), r10 && reactExports.createElement(an, { onClick: p10, id: "TD-ContextMenu-Align_Distribute-SpaceEvenlyHorizontal" }, reactExports.createElement(SpaceEvenlyHorizontallyIcon, null)), reactExports.createElement(an, { onClick: t10, id: "TD-ContextMenu-Align_Distribute-AlignTop" }, reactExports.createElement(AlignTopIcon, null)), reactExports.createElement(an, { onClick: n10, id: "TD-ContextMenu-Align_Distribute-AlignCenterVertical" }, reactExports.createElement(AlignCenterVerticallyIcon, null)), reactExports.createElement(an, { onClick: o10, id: "TD-ContextMenu-Align_Distribute-AlignBottom" }, reactExports.createElement(AlignBottomIcon, null)), reactExports.createElement(an, { onClick: s10, id: "TD-ContextMenu-Align_Distribute-StretchVertical" }, reactExports.createElement(StretchVerticallyIcon, null)), r10 && reactExports.createElement(an, { onClick: a10, id: "TD-ContextMenu-Align_Distribute-SpaceEvenlyVertical" }, reactExports.createElement(SpaceEvenlyVerticallyIcon, null)), reactExports.createElement(fs, { offset: 13 })))));
}
var pie = H2(Rt, { display: "grid", variants: { numberOfSelected: { threeOrMore: { gridTemplateColumns: "repeat(5, auto)" }, twoOrMore: { gridTemplateColumns: "repeat(4, auto)" } } } }), uie = (r10) => r10.appState.currentPageId, hie = (r10) => r10.document.pages;
function mie() {
  let r10 = me(), e10 = r10.useStore(uie), t10 = r10.useStore(hie), n10 = Object.values(t10).sort((s10, a10) => (s10.childIndex || 0) - (a10.childIndex || 0)).filter((s10) => s10.id !== e10), o10 = Lt();
  return n10.length === 0 ? null : reactExports.createElement($1b0217ee4a91d156$export$d7a01e11500dfb6f, null, reactExports.createElement(Ss, null, reactExports.createElement(MemoizedFormattedMessage, { id: "move.to.page" })), reactExports.createElement($1b0217ee4a91d156$export$602eac185826482c, { container: o10.current }, reactExports.createElement($1b0217ee4a91d156$export$6d4de93b380beddf, { sideOffset: 4, alignOffset: -2, asChild: true }, reactExports.createElement(Rt, null, n10.map(({ id: s10, name: a10 }, d10) => reactExports.createElement(Ee, { key: s10, disabled: s10 === e10, onClick: () => r10.moveToPage(s10) }, a10 || `Page ${d10}`)), reactExports.createElement(fs, { offset: 13 })))));
}
function Dr({ children: r10, label: e10, size: t10, id: n10 }) {
  let o10 = Lt();
  return reactExports.createElement($1b0217ee4a91d156$export$d7a01e11500dfb6f, null, reactExports.createElement(Ss, null, e10), reactExports.createElement($1b0217ee4a91d156$export$602eac185826482c, { container: o10.current }, reactExports.createElement($1b0217ee4a91d156$export$6d4de93b380beddf, { sideOffset: 4, alignOffset: -2, asChild: true }, reactExports.createElement(Rt, { size: t10 }, r10, reactExports.createElement(fs, { offset: 13 })))));
}
var fs = H2($1b0217ee4a91d156$export$f47d0a58228a61e2, { fill: "$panel" });
function an(t10) {
  var n10 = t10, { onSelect: r10 } = n10, e10 = Je(n10, ["onSelect"]);
  return reactExports.createElement($1b0217ee4a91d156$export$16a26dc176a49100, { dir: "ltr", onSelect: r10, asChild: true }, reactExports.createElement(ke, S({}, e10)));
}
var Ee = (t10) => {
  var n10 = t10, { id: r10 } = n10, e10 = Je(n10, ["id"]);
  return reactExports.createElement($1b0217ee4a91d156$export$16a26dc176a49100, { asChild: true, id: r10 }, reactExports.createElement(je, S({}, e10)));
}, Ss = (t10) => {
  var n10 = t10, { id: r10 } = n10, e10 = Je(n10, ["id"]);
  return reactExports.createElement($1b0217ee4a91d156$export$2ea8a7a591ac5eac, { asChild: true, id: r10 }, reactExports.createElement(je, S({ hasArrow: true }, e10)));
}, Ba = reactExports.memo(lie);
function Ra({ error: r10, resetErrorBoundary: e10 }) {
  let t10 = me(), n10 = () => {
    window.location.reload(), e10();
  }, o10 = () => {
    let d10 = document.createElement("textarea");
    d10.value = r10.message, document.body.appendChild(d10), d10.select(), document.execCommand("copy"), d10.remove();
  }, s10 = () => {
    t10.saveProjectAs();
  }, a10 = () => {
    t10.resetDocument(), e10();
  };
  return reactExports.createElement(gie, null, reactExports.createElement(fie, null, reactExports.createElement("div", null, "We've encountered an error!"), reactExports.createElement("pre", null, reactExports.createElement("code", null, r10.message)), reactExports.createElement(Sie, null, reactExports.createElement(je, { onClick: o10 }, "Copy Error"), reactExports.createElement(je, { onClick: n10 }, "Refresh Page")), reactExports.createElement(Pe, null), reactExports.createElement("p", null, "Keep getting this error?", " ", reactExports.createElement("a", { onClick: s10, title: "Download your project" }, "Download your project"), " ", "as a backup and then", " ", reactExports.createElement("a", { onClick: a10, title: "Reset the document" }, "reset the document"), ".")));
}
var gie = H2("div", { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", backgroundColor: "$canvas" }), fie = H2("div", { backgroundColor: "$panel", border: "1px solid $panelContrast", padding: "$5", borderRadius: 8, boxShadow: "$panel", maxWidth: 320, color: "$text", fontFamily: "$ui", fontSize: "$2", textAlign: "center", display: "flex", flexDirection: "column", gap: "$3", "& > pre": { marginTop: "$3", marginBottom: "$3", textAlign: "left", whiteSpace: "pre-wrap", backgroundColor: "$hover", padding: "$4", borderRadius: "$2", fontFamily: '"Menlo", "Monaco", monospace', fontWeight: 500 }, "& p": { fontFamily: "$body", lineHeight: 1.7, padding: "$5", margin: 0 }, "& a": { color: "$text", cursor: "pointer", textDecoration: "underline" }, "& hr": { marginLeft: "-$5", marginRight: "-$5" } }), Sie = H2("div", { display: "flex", "& > button > div": { justifyContent: "center", textAlign: "center" } });
var go = H2("button", { position: "relative", height: "32px", width: "32px", backgroundColor: "$panel", borderRadius: "4px", padding: "0", margin: "0", outline: "none", border: "none", pointerEvents: "all", fontSize: "$0", color: "$text", cursor: "pointer", display: "grid", alignItems: "center", justifyContent: "center", "& > *": { gridRow: 1, gridColumn: 1 }, "&:disabled": { opacity: "0.5" }, "& > span": { width: "100%", height: "100%", display: "flex", alignItems: "center" }, variants: { bp: { mobile: { backgroundColor: "transparent" }, small: { "&:hover:not(:disabled)": { backgroundColor: "$hover" } } }, size: { small: { height: 32, width: 32, "& svg:nth-of-type(1)": { height: "16px", width: "16px" } }, medium: { height: 44, width: 44, "& svg:nth-of-type(1)": { height: "18px", width: "18px" } }, large: { height: 44, width: 44, "& svg:nth-of-type(1)": { height: "20px", width: "20px" } } }, isActive: { true: { color: "$selected" } } } });
function Aa({ onSelect: r10 }) {
  return reactExports.createElement(Tie, null, reactExports.createElement(go, { onClick: r10 }, reactExports.createElement(DotFilledIcon, null)));
}
var Tie = H2("div", { opacity: 1, zIndex: 100, backgroundColor: "transparent", "& svg": { color: "$text" }, "&:hover svg": { color: "$text" } });
var wie = (r10) => r10.appState.isLoading;
function Ts() {
  let e10 = me().useStore(wie);
  return reactExports.createElement(xie, { hidden: !e10 }, reactExports.createElement(MemoizedFormattedMessage, { id: "loading", values: { dots: "..." } }));
}
var xie = H2("div", { position: "absolute", top: 0, left: "50%", transform: "translate(-50%, 0)", borderBottomLeftRadius: "12px", borderBottomRightRadius: "12px", padding: "8px 16px", fontFamily: "var(--fonts-ui)", fontSize: "var(--fontSizes-1)", boxShadow: "var(--shadows-panel)", backgroundColor: "white", zIndex: 200, pointerEvents: "none", "& > div > *": { pointerEvents: "all" }, variants: { transform: { hidden: { transform: "translate(-50%, 100%)" }, visible: { transform: "translate(-50%, 0%)" } } } });
function vie({ children: r10, onClose: e10, container: t10 }) {
  return reactExports.createElement(Portal2, { container: t10 }, reactExports.createElement(Eie, null), reactExports.createElement(Bie, { onKeyDown: (o10) => {
    switch (o10.key) {
      case "Escape":
        e10 == null || e10();
        break;
    }
  } }, r10));
}
var Iie = H2(Description2, { marginBottom: 20, color: "$text", fontSize: "$2", lineHeight: 1.5, textAlign: "center", maxWidth: "62%", minWidth: 0, alignSelf: "center" }), Cie = Root2$2, Die = vie, Pie = Iie, La = Action, Mie = Cancel, Ha = ({ container: r10 }) => {
  let { setDialogState: e10, dialogState: t10, onCancel: n10, onNo: o10, onYes: s10 } = br(), a10 = useIntl(), d10 = { saveFirstTime: a10.formatMessage({ id: "dialog.save.firsttime" }), saveAgain: a10.formatMessage({ id: "dialog.save.again" }) };
  return reactExports.createElement(Cie, { open: t10 !== null }, reactExports.createElement(Die, { onClose: () => e10(null), container: r10 }, t10 && reactExports.createElement(Pie, null, d10[t10]), reactExports.createElement("div", { style: { width: "100%", gap: "$6", display: "flex", justifyContent: "space-between" } }, n10 && reactExports.createElement(Mie, { asChild: true }, reactExports.createElement(fo, { css: { color: "$text" }, onClick: () => {
    n10(), e10(null);
  } }, reactExports.createElement(MemoizedFormattedMessage, { id: "dialog.cancel" }))), reactExports.createElement("div", { style: { flexShrink: 0 } }, o10 && reactExports.createElement(La, { asChild: true }, reactExports.createElement(fo, { onClick: () => {
    o10(), e10(null);
  } }, reactExports.createElement(MemoizedFormattedMessage, { id: "dialog.no" }))), s10 && reactExports.createElement(La, { asChild: true }, reactExports.createElement(fo, { css: { backgroundColor: "#2F80ED", color: "White" }, onClick: () => {
    s10(), e10(null);
  } }, reactExports.createElement(MemoizedFormattedMessage, { id: "dialog.yes" })))))));
}, Eie = H2(Overlay2, { position: "fixed", inset: 0, backgroundColor: "rgba(0, 0, 0, .15)", pointerEvents: "all" });
H2(Overlay2, { backgroundColor: "rgba(0, 0, 0, .15)", position: "absolute", pointerEvents: "all", inset: 0 });
var Bie = H2(Content2$1, { position: "fixed", font: "$ui", top: "50%", left: "50%", transform: "translate(-50%, -50%)", width: "max-content", padding: "$3", pointerEvents: "all", backgroundColor: "$panel", borderRadius: "$3", display: "flex", flexDirection: "column", justifyContent: "center", fontFamily: "$ui", border: "1px solid $panelContrast", boxShadow: "$panel" }), fo = H2("button", { all: "unset", display: "inline-flex", alignItems: "center", justifyContent: "center", borderRadius: "$2", padding: "0 15px", fontSize: "$1", lineHeight: 1, fontWeight: "normal", height: 36, color: "$text", cursor: "pointer", minWidth: 48 });
var Mr = reactExports.forwardRef((n10, t10) => {
  var o10 = n10, { icon: r10 } = o10, e10 = Je(o10, ["icon"]);
  return reactExports.createElement(Rie, null, reactExports.createElement(Aie, x(S({}, e10), { ref: t10 })), r10 ? reactExports.createElement(Lie, null, r10) : null);
}), Rie = H2("div", { position: "relative", width: "100%", height: "min-content" }), Aie = H2("input", { color: "$text", border: "none", textAlign: "left", width: "100%", paddingLeft: "$3", paddingRight: "$6", backgroundColor: "$background", height: "32px", outline: "none", fontFamily: "$ui", fontSize: "$1", "&:focus": { backgroundColor: "$hover" }, borderRadius: "$2" }), Lie = H2(ut, { top: 0, right: 0, position: "absolute", paddingLeft: "$3", paddingRight: "$3", pointerEvents: "none", color: "$text" });
var Oa = ({ isOpen: r10, onClose: e10 }) => {
  let t10 = me(), n10 = Lt(), o10 = useIntl(), [s10, a10] = reactExports.useState(t10.document.name), d10 = reactExports.useCallback((u10) => {
    let p10 = u10.target.value.trimStart();
    a10(p10);
  }, []);
  function i10(u10) {
    u10.stopPropagation();
  }
  let c10 = reactExports.useCallback((u10) => {
    switch (u10.key) {
      case "Enter": {
        t10.saveProjectAs(s10), e10();
        break;
      }
      case "Escape": {
        e10();
        break;
      }
    }
  }, []);
  return reactExports.createElement(Root2$2, { open: r10 }, reactExports.createElement(Portal2, { container: n10.current }, reactExports.createElement(Fie, { onPointerDown: e10 }), reactExports.createElement(Oie, { dir: "ltr", onKeyDown: i10, onKeyUp: i10 }, reactExports.createElement(Gie, { placeholder: o10.formatMessage({ id: "enter.file.name" }), value: s10, onChange: d10, onKeyDown: c10, icon: reactExports.createElement(Pencil1Icon, null) }), reactExports.createElement(jie, null, reactExports.createElement(Action, { asChild: true }, reactExports.createElement(fo, { onClick: e10 }, reactExports.createElement(MemoizedFormattedMessage, { id: "cancel" }))), reactExports.createElement(Action, { asChild: true }, reactExports.createElement(fo, { css: { backgroundColor: "#2F80ED", color: "White" }, onClick: () => {
    let u10 = s10.trim().replace(/\.tldr$/, "");
    t10.saveProjectAs(u10), e10();
  } }, reactExports.createElement(MemoizedFormattedMessage, { id: "save" })))))));
}, Oie = H2(Content2$1, { position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", minWidth: 300, maxWidth: "fit-content", maxHeight: "85vh", marginTop: "-5vh", pointerEvents: "all", backgroundColor: "$panel", padding: "$3", borderRadius: "$2", font: "$ui", zIndex: 999999, "&:focus": { outline: "none" } }), Fie = H2(Overlay2, { backgroundColor: "rgba(0, 0, 0, .15)", position: "absolute", pointerEvents: "all", inset: 0, zIndex: 999998 }), jie = H2("div", { width: "100%", display: "flex", alignItems: "center", gap: 8, justifyContent: "flex-end", marginTop: 10 }), Gie = H2(Mr, { background: "$hover" });
function xe(n10) {
  var o10 = n10, { onSelect: r10, id: e10 } = o10, t10 = Je(o10, ["onSelect", "id"]);
  return reactExports.createElement($d08ef79370b62062$export$6d08773d2e66f8f2, { dir: "ltr", asChild: true, onSelect: r10, id: e10 }, reactExports.createElement(je, S({}, t10)));
}
var He = (r10) => r10.preventDefault();
function Pt({ checked: r10, disabled: e10 = false, variant: t10, onCheckedChange: n10, kbd: o10, id: s10, ariaLabel: a10, children: d10 }) {
  return reactExports.createElement($d08ef79370b62062$export$16ce288f89fa631c, { dir: "ltr", onSelect: He, onCheckedChange: n10, checked: r10, disabled: e10, asChild: true, id: s10, "aria-label": a10 }, reactExports.createElement(je, { kbd: o10, variant: t10, hasIndicator: true }, d10));
}
var ft = (r10) => r10.stopPropagation();
function Mt({ sideOffset: r10 = 4, alignOffset: e10 = 0, children: t10, align: n10, variant: o10, id: s10, overflow: a10 = false, side: d10 = "bottom" }) {
  let i10 = Lt();
  return reactExports.createElement($d08ef79370b62062$export$602eac185826482c, { container: i10.current, dir: "ltr" }, reactExports.createElement($d08ef79370b62062$export$7c6e2c02157bb7d2, { align: n10, alignOffset: e10, sideOffset: r10, onEscapeKeyDown: ft, asChild: true, id: s10, side: d10 }, reactExports.createElement(Nie, { variant: o10, overflow: a10 }, t10)));
}
var Nie = H2(Rt, { width: "fit-content", height: "fit-content", minWidth: 0, maxHeight: "100vh", overflowY: "auto", overflowX: "hidden", "&::webkit-scrollbar": { display: "none" }, "-ms-overflow-style": "none", scrollbarWidth: "none", variants: { variant: { horizontal: { flexDirection: "row" }, menu: { minWidth: 128 } }, overflow: { true: { maxHeight: "60vh" } } } });
H2($d08ef79370b62062$export$1ff3c3f08ae963c0, { backgroundColor: "$hover", height: 1, marginTop: "$2", marginRight: "-$2", marginBottom: "$2", marginLeft: "-$2" });
var jo = H2($d08ef79370b62062$export$371ab307eab489c0, { height: "32px", width: "32px", backgroundColor: "$panel", borderRadius: "4px", padding: "0", margin: "0", display: "flex", alignItems: "center", justifyContent: "center", outline: "none", border: "none", pointerEvents: "all", cursor: "pointer", variants: { isActive: { true: { backgroundColor: "$selected", color: "white" }, false: {} }, bp: { mobile: {}, small: {} } }, compoundVariants: [{ isActive: false, bp: "small", css: { "&:focus": { backgroundColor: "$hover" }, "&:hover:not(:disabled)": { backgroundColor: "$hover" } } }] });
function ln({ children: r10, size: e10, overflow: t10 = false, disabled: n10 = false, label: o10, id: s10 }) {
  return reactExports.createElement($d08ef79370b62062$export$d7a01e11500dfb6f, { key: s10 }, reactExports.createElement($d08ef79370b62062$export$2ea8a7a591ac5eac, { dir: "ltr", asChild: true }, reactExports.createElement(je, { disabled: n10, hasArrow: true }, o10)), reactExports.createElement($d08ef79370b62062$export$6d4de93b380beddf, { asChild: true, sideOffset: 4, alignOffset: -4 }, reactExports.createElement(Rt, { size: e10, overflow: t10 }, r10, reactExports.createElement($d08ef79370b62062$export$21b07c8f274aebd5, { offset: 13 }))));
}
function Rr(n10) {
  var o10 = n10, { id: r10, children: e10 } = o10, t10 = Je(o10, ["id", "children"]);
  return reactExports.createElement($d08ef79370b62062$export$41fb9f06171c75f4, { asChild: true, id: r10 }, reactExports.createElement(ke, S({}, t10), e10));
}
var wae = (r10) => r10.settings.dockPosition, xae = (r10) => r10.document.pageStates[r10.appState.currentPageId].selectedIds.length, kae = (r10) => {
  let e10 = r10.document.pages[r10.appState.currentPageId], { selectedIds: t10 } = r10.document.pageStates[r10.appState.currentPageId];
  return t10.every((n10) => e10.shapes[n10].isLocked);
}, vae = (r10) => {
  let e10 = r10.document.pages[r10.appState.currentPageId], { selectedIds: t10 } = r10.document.pageStates[r10.appState.currentPageId];
  return t10.every((n10) => e10.shapes[n10].isAspectRatioLocked);
}, Iae = (r10) => {
  let e10 = r10.document.pages[r10.appState.currentPageId], t10 = r10.document.pageStates[r10.appState.currentPageId].selectedIds.map((n10) => e10.shapes[n10]);
  return t10.every((n10) => n10.children !== void 0 || n10.parentId === t10[0].parentId && t10[0].parentId !== r10.appState.currentPageId);
}, Cae = (r10) => {
  let { selectedIds: e10 } = r10.document.pageStates[r10.appState.currentPageId];
  return e10.length > 0;
}, Dae = (r10) => {
  let { selectedIds: e10 } = r10.document.pageStates[r10.appState.currentPageId];
  return e10.length > 1;
};
function Fa() {
  let r10 = me(), e10 = useIntl(), t10 = r10.useStore(kae), n10 = r10.useStore(vae), o10 = r10.useStore(Iae), s10 = r10.useStore(Cae), a10 = r10.useStore(Dae), d10 = r10.useStore(xae), i10 = r10.useStore(wae), c10 = d10 > 1, u10 = d10 > 2, p10 = reactExports.useCallback(() => {
    r10.rotate();
  }, [r10]), m10 = reactExports.useCallback(() => {
    r10.duplicate();
  }, [r10]), h10 = reactExports.useCallback(() => {
    r10.toggleLocked();
  }, [r10]), g10 = reactExports.useCallback(() => {
    r10.toggleAspectRatioLocked();
  }, [r10]), f10 = reactExports.useCallback(() => {
    r10.group();
  }, [r10]), T10 = reactExports.useCallback(() => {
    r10.moveToBack();
  }, [r10]), w10 = reactExports.useCallback(() => {
    r10.moveBackward();
  }, [r10]), b10 = reactExports.useCallback(() => {
    r10.moveForward();
  }, [r10]), y10 = reactExports.useCallback(() => {
    r10.moveToFront();
  }, [r10]), R10 = reactExports.useCallback(() => {
    r10.setShapeProps({ rotation: 0 });
  }, [r10]), U10 = reactExports.useCallback(() => {
    r10.align("top");
  }, [r10]), L10 = reactExports.useCallback(() => {
    r10.align("centerVertical");
  }, [r10]), k10 = reactExports.useCallback(() => {
    r10.align("bottom");
  }, [r10]), I10 = reactExports.useCallback(() => {
    r10.stretch("vertical");
  }, [r10]), q10 = reactExports.useCallback(() => {
    r10.distribute("vertical");
  }, [r10]), de2 = reactExports.useCallback(() => {
    r10.align("left");
  }, [r10]), le2 = reactExports.useCallback(() => {
    r10.align("centerHorizontal");
  }, [r10]), Ae = reactExports.useCallback(() => {
    r10.align("right");
  }, [r10]), Ce2 = reactExports.useCallback(() => {
    r10.stretch("horizontal");
  }, [r10]), De2 = reactExports.useCallback(() => {
    r10.distribute("horizontal");
  }, [r10]), Ve = reactExports.useCallback((jt) => {
    r10.setMenuOpen(jt);
  }, [r10]), $e = i10 === "bottom" || i10 === "top" ? "top" : i10;
  return reactExports.createElement($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr", onOpenChange: Ve }, reactExports.createElement($d08ef79370b62062$export$41fb9f06171c75f4, { dir: "ltr", asChild: true, id: "TD-Tools-Dots" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "shape.options" }), variant: "circle" }, reactExports.createElement(DotsHorizontalIcon, null))), reactExports.createElement(Mt, { sideOffset: 16, side: $e }, reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Ar, null, reactExports.createElement(Le, { label: e10.formatMessage({ id: "duplicate" }), kbd: "#D", id: "TD-Tools-Copy" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "duplicate" }), disabled: !s10, onClick: m10 }, reactExports.createElement(CopyIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: "rotate" }), id: "TD-Tools-Rotate" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "rotate" }), disabled: !s10, onClick: p10 }, reactExports.createElement(RotateCounterClockwiseIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: t10 ? "unlock" : "lock" }), kbd: "#L", id: "TD-Tools-Lock" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: t10 ? "unlock" : "lock" }), disabled: !s10, onClick: h10 }, t10 ? reactExports.createElement(LockClosedIcon, null) : reactExports.createElement(LockOpen1Icon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: n10 ? "unlock.aspect.ratio" : "lock.aspect.ratio" }), id: "TD-Tools-AspectRatio" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: n10 ? "unlock.aspect.ratio" : "lock.aspect.ratio" }), disabled: !s10, onClick: g10 }, n10 ? reactExports.createElement(AspectRatioIcon, null) : reactExports.createElement(BoxIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: "group" }), kbd: "#G", id: "TD-Tools-Group" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "group" }), disabled: !s10 || !o10 && !a10, onClick: f10 }, reactExports.createElement(GroupIcon, null)))), reactExports.createElement(Ar, null, reactExports.createElement(Le, { label: e10.formatMessage({ id: "move.to.back" }), kbd: "#[", id: "TD-Tools-PinBottom" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "move.to.back" }), disabled: !s10, onClick: T10 }, reactExports.createElement(PinBottomIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: "move.backward" }), kbd: "#[", id: "TD-Tools-ArrowDown" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "move.backward" }), disabled: !s10, onClick: w10 }, reactExports.createElement(ArrowDownIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: "move.forward" }), kbd: "#]", id: "TD-Tools-ArrowUp" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "move.forward" }), disabled: !s10, onClick: b10 }, reactExports.createElement(ArrowUpIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: "move.to.front" }), kbd: "#]", id: "TD-Tools-PinTop" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "move.to.front" }), disabled: !s10, onClick: y10 }, reactExports.createElement(PinTopIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: "reset.angle" }), id: "TD-Tools-ResetAngle" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "reset.angle" }), disabled: !s10, onClick: R10 }, reactExports.createElement(AngleIcon, null)))), reactExports.createElement(Pe, null), reactExports.createElement(Ar, null, reactExports.createElement(Le, { label: e10.formatMessage({ id: "align.left" }), id: "TD-Tools-AlignLeft" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "align.left" }), disabled: !c10, onClick: de2 }, reactExports.createElement(AlignLeftIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: "align.center.x" }), id: "TD-Tools-AlignCenterHorizontal" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "align.center.x" }), disabled: !c10, onClick: le2 }, reactExports.createElement(AlignCenterHorizontallyIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: "align.right" }), id: "TD-Tools-AlignRight" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "align.right" }), disabled: !c10, onClick: Ae }, reactExports.createElement(AlignRightIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: "stretch.x" }), id: "TD-Tools-StretchHorizontal" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "stretch.x" }), disabled: !c10, onClick: Ce2 }, reactExports.createElement(StretchHorizontallyIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: "distribute.x" }), id: "TD-Tools-SpaceEvenlyHorizontal" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "distribute.x" }), disabled: !u10, onClick: De2 }, reactExports.createElement(SpaceEvenlyHorizontallyIcon, null)))), reactExports.createElement(Ar, null, reactExports.createElement(Le, { label: e10.formatMessage({ id: "align.top" }), id: "TD-Tools-AlignTop" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "align.top" }), disabled: !c10, onClick: U10 }, reactExports.createElement(AlignTopIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: "align.center.y" }), id: "TD-Tools-AlignCenterVertical" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "align.center.y" }), disabled: !c10, onClick: L10 }, reactExports.createElement(AlignCenterVerticallyIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: "align.bottom" }), id: "TD-Tools-AlignBottom" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "align.bottom" }), disabled: !c10, onClick: k10 }, reactExports.createElement(AlignBottomIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: "stretch.y" }), id: "TD-Tools-StretchVertical" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "stretch.y" }), disabled: !c10, onClick: I10 }, reactExports.createElement(StretchVerticallyIcon, null))), reactExports.createElement(Le, { label: e10.formatMessage({ id: "distribute.y" }), id: "TD-Tools-SpaceEvenlyVertical" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "distribute.y" }), disabled: !u10, onClick: q10 }, reactExports.createElement(SpaceEvenlyVerticallyIcon, null)))))));
}
var Ar = H2("div", { position: "relative", display: "flex", width: "100%", background: "none", border: "none", cursor: "pointer", outline: "none", alignItems: "center", justifyContent: "flex-start", padding: 0 });
var Mae = (r10) => r10.appState.isEmptyCanvas && Object.keys(r10.document.pages[r10.appState.currentPageId].shapes).length > 0, Eae = (r10) => r10.settings.isDebugMode, Bae = (r10) => r10.settings.dockPosition, ja = reactExports.memo(function() {
  let e10 = me(), t10 = e10.useStore(Mae), n10 = e10.useStore(Bae), o10 = e10.useStore(Eae), s10 = { bottom: n10 === "bottom" && o10 ? 120 : n10 === "bottom" ? 80 : o10 ? 60 : 20, left: "50%", transform: "translate(-50%,0)" };
  return t10 ? reactExports.createElement(Rae, { id: "TD-Tools-Back_to_content", style: S({}, s10) }, reactExports.createElement(je, { onClick: e10.zoomToContent }, reactExports.createElement(MemoizedFormattedMessage, { id: "zoom.to.content" }))) : null;
}), Rae = H2(Rt, { pointerEvents: "all", width: "fit-content", minWidth: 0, position: "fixed", bottom: 0 });
function Is(r10) {
  let n10 = r10, { size: e10 = 16 } = n10, t10 = Je(n10, ["size"]);
  return reactExports.createElement("svg", S({ width: 24, height: 24 }, t10), reactExports.createElement("circle", { cx: 12, cy: 12, r: e10 / 2 }));
}
function Ga() {
  return reactExports.createElement("svg", { width: "24", height: "24", stroke: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, reactExports.createElement("circle", { cx: 12, cy: 12, r: 8, fill: "none", strokeWidth: 2.5, strokeLinecap: "round", strokeDasharray: 50.26548 * 0.1 }));
}
var Lae = `${50.26548 * 0.025} ${50.26548 * 0.1}`;
function Va() {
  return reactExports.createElement("svg", { width: "24", height: "24", stroke: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, reactExports.createElement("circle", { cx: 12, cy: 12, r: 8, fill: "none", strokeWidth: 2.5, strokeLinecap: "round", strokeDasharray: Lae }));
}
function $a() {
  return reactExports.createElement("svg", { width: "24", height: "24", viewBox: "1 1.5 21 22", fill: "currentColor", stroke: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, reactExports.createElement("path", { d: "M10.0162 19.2768C10.0162 19.2768 9.90679 19.2517 9.6879 19.2017C9.46275 19.1454 9.12816 19.0422 8.68413 18.8921C8.23384 18.7358 7.81482 18.545 7.42707 18.3199C7.03307 18.101 6.62343 17.7883 6.19816 17.3818C5.77289 16.9753 5.33511 16.3718 4.88482 15.5713C4.43453 14.7645 4.1531 13.8545 4.04053 12.8414C3.92795 11.822 4.04991 10.8464 4.40639 9.91451C4.76286 8.98266 5.39452 8.10084 6.30135 7.26906C7.21444 6.44353 8.29325 5.83377 9.5378 5.43976C10.7823 5.05202 11.833 4.92068 12.6898 5.04576C13.5466 5.16459 14.3878 5.43664 15.2133 5.86191C16.0388 6.28718 16.7768 6.8688 17.4272 7.60678C18.0714 8.34475 18.5404 9.21406 18.8344 10.2147C19.1283 11.2153 19.1721 12.2598 18.9657 13.348C18.7593 14.4299 18.2872 15.4337 17.5492 16.3593C16.8112 17.2849 15.9263 18.0072 14.8944 18.5263C13.8624 19.0391 12.9056 19.3174 12.0238 19.3612C11.142 19.405 10.2101 19.2705 9.22823 18.9578C8.24635 18.6451 7.35828 18.151 6.56402 17.4756C5.77601 16.8002 6.08871 16.8658 7.50212 17.6726C8.90927 18.4731 10.1444 18.8484 11.2076 18.7983C12.2645 18.7545 13.2965 18.4825 14.3034 17.9822C15.3102 17.4819 16.1264 16.8221 16.7518 16.0028C17.3772 15.1835 17.7681 14.3111 17.9244 13.3855C18.0808 12.4599 18.0401 11.5781 17.8025 10.74C17.5586 9.902 17.1739 9.15464 16.6486 8.49797C16.1233 7.8413 15.2289 7.27844 13.9656 6.80939C12.7086 6.34034 11.4203 6.20901 10.1007 6.41539C8.78732 6.61552 7.69599 7.06893 6.82669 7.77564C5.96363 8.48859 5.34761 9.26409 4.97863 10.1021C4.60964 10.9402 4.45329 11.8376 4.50958 12.7945C4.56586 13.7513 4.79101 14.6238 5.18501 15.4118C5.57276 16.1998 5.96363 16.8002 6.35764 17.2129C6.75164 17.6257 7.13313 17.9509 7.50212 18.1886C7.87736 18.4325 8.28074 18.642 8.71227 18.8171C9.15005 18.9922 9.47839 19.111 9.69728 19.1736C9.91617 19.2361 10.0256 19.2705 10.0256 19.2768H10.0162Z", strokeWidth: "2" }));
}
function Na() {
  return reactExports.createElement("svg", { width: "24", height: "24", stroke: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, reactExports.createElement("circle", { cx: 12, cy: 12, r: 8, fill: "none", strokeWidth: 2, strokeLinecap: "round" }));
}
function Wa(r10) {
  return reactExports.createElement("svg", S({ width: 18, height: 18, viewBox: "0 0 15 15", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, r10), reactExports.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2 4.656a.5.5 0 01.5-.5h9.7a.5.5 0 010 1H2.5a.5.5 0 01-.5-.5z" }), reactExports.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.272 3a.578.578 0 00-.578.578v.578h3.311v-.578A.578.578 0 008.428 3H6.272zm3.733 1.156v-.578A1.578 1.578 0 008.428 2H6.272a1.578 1.578 0 00-1.578 1.578v.578H3.578a.5.5 0 00-.5.5V12.2a1.578 1.578 0 001.577 1.578h5.39a1.578 1.578 0 001.577-1.578V4.656a.5.5 0 00-.5-.5h-1.117zm-5.927 1V12.2a.578.578 0 00.577.578h5.39a.578.578 0 00.577-.578V5.156H4.078z" }), reactExports.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.272 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5zM8.428 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5z" }));
}
function Bs(t10) {
  var n10 = t10, { flipHorizontal: r10 } = n10, e10 = Je(n10, ["flipHorizontal"]);
  return reactExports.createElement("svg", S({ width: 24, height: 24, viewBox: "0 0 15 15", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", style: { transform: r10 ? "scale(-1, 1)" : "scale(1, 1)" } }, e10), reactExports.createElement("path", { d: "M10.6707 8.5081C10.6707 10.1923 9.3004 11.5625 7.61631 11.5625H6.5351C6.35593 11.5625 6.21074 11.4173 6.21074 11.2382V11.13C6.21074 10.9508 6.35591 10.8057 6.5351 10.8057H7.61631C8.88313 10.8057 9.91387 9.77492 9.91387 8.5081C9.91387 7.24128 8.88313 6.21054 7.61631 6.21054H5.62155L6.99534 7.58433C7.14289 7.73183 7.14289 7.97195 6.99534 8.11944C6.85216 8.26251 6.60298 8.2623 6.46013 8.11944L4.44045 6.09971C4.36898 6.02824 4.32959 5.93321 4.32959 5.8321C4.32959 5.73106 4.36898 5.63598 4.44045 5.56454L6.46024 3.54472C6.60309 3.40176 6.85248 3.40176 6.99535 3.54472C7.14291 3.69218 7.14291 3.93234 6.99535 4.07979L5.62156 5.45368H7.61631C9.3004 5.45368 10.6707 6.82393 10.6707 8.5081Z" }));
}
function Ua(r10) {
  return reactExports.createElement("svg", S({ width: 24, height: 24, viewBox: "-2 -2 28 28", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, r10), reactExports.createElement("path", { d: "M12.4239 4.62C13.3572 4.62 14.1572 4.73333 14.8239 4.96C15.4906 5.17333 15.9772 5.43333 16.2839 5.74C16.3639 5.82 16.4039 5.94 16.4039 6.1V8.86H14.0639C13.9172 8.86 13.8439 8.78666 13.8439 8.64V7.26C13.4306 7.12666 12.9572 7.06 12.4239 7.06C11.6506 7.06 11.0639 7.18 10.6639 7.42C10.2639 7.66 10.0639 8.04666 10.0639 8.58V9C10.0639 9.38666 10.1639 9.69333 10.3639 9.92C10.5772 10.1333 11.0306 10.3467 11.7239 10.56L13.6439 11.14C14.4706 11.38 15.1172 11.66 15.5839 11.98C16.0506 12.3 16.3772 12.68 16.5639 13.12C16.7639 13.5467 16.8639 14.0733 16.8639 14.7V15.62C16.8639 16.7933 16.4039 17.7133 15.4839 18.38C14.5639 19.0467 13.2839 19.38 11.6439 19.38C10.6706 19.38 9.79723 19.2867 9.0239 19.1C8.2639 18.9133 7.71056 18.6533 7.3639 18.32C7.3239 18.28 7.29056 18.24 7.2639 18.2C7.25056 18.1467 7.2439 18.06 7.2439 17.94V15.74H7.6239C8.2239 16.1533 8.85056 16.4533 9.5039 16.64C10.1572 16.8267 10.9306 16.92 11.8239 16.92C12.6506 16.92 13.2506 16.7867 13.6239 16.52C14.0106 16.2533 14.2039 15.9333 14.2039 15.56V14.88C14.2039 14.6667 14.1639 14.48 14.0839 14.32C14.0172 14.16 13.8706 14.0133 13.6439 13.88C13.4172 13.7467 13.0572 13.6067 12.5639 13.46L10.6639 12.88C9.7839 12.6133 9.11056 12.3 8.6439 11.94C8.17723 11.58 7.85056 11.18 7.6639 10.74C7.49056 10.3 7.4039 9.83333 7.4039 9.34V8.38C7.4039 7.64666 7.61056 7 8.0239 6.44C8.43723 5.88 9.01723 5.44 9.7639 5.12C10.5239 4.78666 11.4106 4.62 12.4239 4.62Z" }));
}
function Ka(r10) {
  return reactExports.createElement("svg", S({ width: 24, height: 24, viewBox: "-2 -2 28 28", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, r10), reactExports.createElement("path", { d: "M8.16191 19H5.68191C5.53525 19 5.46191 18.9267 5.46191 18.78V5H8.76191C8.88191 5 8.97525 5.03333 9.04191 5.1C9.10858 5.15333 9.17525 5.27333 9.24191 5.46C9.72191 6.59333 10.1686 7.7 10.5819 8.78C11.0086 9.84667 11.4352 10.98 11.8619 12.18H12.1619C12.6019 10.9667 13.0352 9.79333 13.4619 8.66C13.8886 7.52667 14.3552 6.30667 14.8619 5H18.3219C18.4686 5 18.5419 5.07333 18.5419 5.22V19H16.0619C15.9152 19 15.8419 18.9267 15.8419 18.78V16.26C15.8419 15.5267 15.8486 14.8133 15.8619 14.12C15.8886 13.4267 15.9286 12.6867 15.9819 11.9C16.0486 11.1 16.1419 10.1933 16.2619 9.18H15.9019C15.4352 10.3533 14.9486 11.5667 14.4419 12.82C13.9486 14.06 13.4819 15.2333 13.0419 16.34H11.1019C11.0619 16.34 11.0152 16.3333 10.9619 16.32C10.9219 16.2933 10.8886 16.2467 10.8619 16.18C10.4619 15.18 10.0086 14.06 9.50191 12.82C9.00858 11.58 8.53525 10.3667 8.08191 9.18H7.70191C7.83525 10.18 7.93525 11.0733 8.00191 11.86C8.06858 12.6467 8.10858 13.3933 8.12191 14.1C8.14858 14.8067 8.16191 15.5267 8.16191 16.26V19Z" }));
}
function _a(r10) {
  return reactExports.createElement("svg", S({ width: 24, height: 24, viewBox: "-2 -2 28 28", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, r10), reactExports.createElement("path", { d: "M7.68191 19C7.53525 19 7.46191 18.9267 7.46191 18.78V5H10.1219C10.2686 5 10.3419 5.07333 10.3419 5.22V16.56H13.4419V15.02H15.7619C15.9086 15.02 15.9819 15.0933 15.9819 15.24V19H7.68191Z" }));
}
function Ya() {
  return reactExports.createElement("svg", { width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, reactExports.createElement("path", { d: "M1.72838 9.33987L8.84935 2.34732C9.23874 1.96494 9.86279 1.96539 10.2516 2.34831L13.5636 5.60975C13.9655 6.00555 13.9607 6.65526 13.553 7.04507L8.13212 12.2278C7.94604 12.4057 7.69851 12.505 7.44107 12.505L6.06722 12.505L3.83772 12.505C3.5673 12.505 3.30842 12.3954 3.12009 12.2014L1.7114 10.7498C1.32837 10.3551 1.33596 9.72521 1.72838 9.33987Z", stroke: "currentColor" }), reactExports.createElement("line", { x1: "6.01807", y1: "12.5", x2: "10.7959", y2: "12.5", stroke: "currentColor", strokeLinecap: "round" }), reactExports.createElement("line", { x1: "5.50834", y1: "5.74606", x2: "10.1984", y2: "10.4361", stroke: "currentColor" }));
}
function Za() {
  return reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", fill: "currentColor", viewBox: "0 0 16 16" }, reactExports.createElement("path", { d: "M13.545 2.907a13.227 13.227 0 0 0-3.257-1.011.05.05 0 0 0-.052.025c-.141.25-.297.577-.406.833a12.19 12.19 0 0 0-3.658 0 8.258 8.258 0 0 0-.412-.833.051.051 0 0 0-.052-.025c-1.125.194-2.22.534-3.257 1.011a.041.041 0 0 0-.021.018C.356 6.024-.213 9.047.066 12.032c.001.014.01.028.021.037a13.276 13.276 0 0 0 3.995 2.02.05.05 0 0 0 .056-.019c.308-.42.582-.863.818-1.329a.05.05 0 0 0-.01-.059.051.051 0 0 0-.018-.011 8.875 8.875 0 0 1-1.248-.595.05.05 0 0 1-.02-.066.051.051 0 0 1 .015-.019c.084-.063.168-.129.248-.195a.05.05 0 0 1 .051-.007c2.619 1.196 5.454 1.196 8.041 0a.052.052 0 0 1 .053.007c.08.066.164.132.248.195a.051.051 0 0 1-.004.085 8.254 8.254 0 0 1-1.249.594.05.05 0 0 0-.03.03.052.052 0 0 0 .003.041c.24.465.515.909.817 1.329a.05.05 0 0 0 .056.019 13.235 13.235 0 0 0 4.001-2.02.049.049 0 0 0 .021-.037c.334-3.451-.559-6.449-2.366-9.106a.034.034 0 0 0-.02-.019Zm-8.198 7.307c-.789 0-1.438-.724-1.438-1.612 0-.889.637-1.613 1.438-1.613.807 0 1.45.73 1.438 1.613 0 .888-.637 1.612-1.438 1.612Zm5.316 0c-.788 0-1.438-.724-1.438-1.612 0-.889.637-1.613 1.438-1.613.807 0 1.451.73 1.438 1.613 0 .888-.631 1.612-1.438 1.612Z" }));
}
function Xa() {
  return reactExports.createElement("svg", { width: "15", height: "15", viewBox: "0 0 15 15", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, reactExports.createElement("path", { d: "M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L11.1464 3.14645C11.3417 2.95118 11.6583 2.95118 11.8536 3.14645C12.0488 3.34171 12.0488 3.65829 11.8536 3.85355L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z" }));
}
function qa() {
  let r10 = me(), e10 = useIntl(), t10 = reactExports.useCallback(() => {
    r10.delete();
  }, [r10]), n10 = r10.useStore((o10) => o10.appState.status === "idle" && o10.document.pageStates[o10.appState.currentPageId].selectedIds.length > 0);
  return reactExports.createElement(Le, { label: e10.formatMessage({ id: "delete" }), kbd: "", id: "TD-Delete" }, reactExports.createElement(ke, { "aria-label": e10.formatMessage({ id: "delete" }), variant: "circle", disabled: !n10, onSelect: t10 }, reactExports.createElement(Wa, null)));
}
var Fae = (r10) => r10.settings.language, Ja = () => {
  let r10 = me(), e10 = r10.useStore(Fae), t10 = reactExports.useCallback((n10) => {
    r10.setSetting("language", n10);
  }, [r10]);
  return reactExports.createElement(Mt, { variant: "menu", overflow: true, id: "language-menu", side: "left", sideOffset: 8 }, Ir.map(({ locale: n10, label: o10 }) => reactExports.createElement(Pt, { key: n10, checked: e10 === n10, onCheckedChange: () => t10(n10), id: `TD-MenuItem-Language-${n10}` }, o10)), reactExports.createElement(Pe, null), reactExports.createElement("a", { href: "https://github.com/tldraw/tldraw/blob/main/guides/translation.md", target: "_blank", rel: "nofollow" }, reactExports.createElement(xe, { id: "TD-MenuItem-Translation-Link" }, reactExports.createElement(MemoizedFormattedMessage, { id: "translation.link" }), reactExports.createElement(ut, null, reactExports.createElement(ExternalLinkIcon, null)))));
};
function Qa({ onOpenChange: r10 }) {
  let e10 = useIntl(), t10 = Lt(), n10 = { Tools: [{ label: e10.formatMessage({ id: "select" }), kbd: "1" }, { label: e10.formatMessage({ id: "draw" }), kbd: "2" }, { label: e10.formatMessage({ id: "eraser" }), kbd: "3" }, { label: e10.formatMessage({ id: "rectangle" }), kbd: "4" }, { label: e10.formatMessage({ id: "ellipse" }), kbd: "5" }, { label: e10.formatMessage({ id: "triangle" }), kbd: "6" }, { label: e10.formatMessage({ id: "line" }), kbd: "7" }, { label: e10.formatMessage({ id: "arrow" }), kbd: "8" }, { label: e10.formatMessage({ id: "text" }), kbd: "9" }, { label: e10.formatMessage({ id: "sticky" }), kbd: "0" }], View: [{ label: e10.formatMessage({ id: "zoom.in" }), kbd: "#+" }, { label: e10.formatMessage({ id: "zoom.out" }), kbd: "#-" }, { label: `${e10.formatMessage({ id: "zoom.to" })} 100%`, kbd: "+0" }, { label: e10.formatMessage({ id: "zoom.to.fit" }), kbd: "+1" }, { label: e10.formatMessage({ id: "zoom.to.selection" }), kbd: "+2" }, { label: e10.formatMessage({ id: "preferences.dark.mode" }), kbd: "#D" }, { label: e10.formatMessage({ id: "preferences.focus.mode" }), kbd: "#." }, { label: e10.formatMessage({ id: "preferences.show.grid" }), kbd: "#G" }], Transform: [{ label: e10.formatMessage({ id: "flip.horizontal" }), kbd: "H" }, { label: e10.formatMessage({ id: "flip.vertical" }), kbd: "V" }, { label: `${e10.formatMessage({ id: "lock" })} / ${e10.formatMessage({ id: "unlock" })}`, kbd: "#L" }, { label: `${e10.formatMessage({ id: "move" })} ${e10.formatMessage({ id: "to.front" })}`, kbd: "]" }, { label: `${e10.formatMessage({ id: "move" })} ${e10.formatMessage({ id: "forward" })}`, kbd: "]" }, { label: `${e10.formatMessage({ id: "move" })} ${e10.formatMessage({ id: "backward" })}`, kbd: "[" }, { label: `${e10.formatMessage({ id: "move" })} ${e10.formatMessage({ id: "back" })}`, kbd: "[" }], File: [{ label: e10.formatMessage({ id: "new.project" }), kbd: "#N" }, { label: e10.formatMessage({ id: "open" }), kbd: "#O" }, { label: e10.formatMessage({ id: "save" }), kbd: "#S" }, { label: e10.formatMessage({ id: "save.as" }), kbd: "#S" }, { label: e10.formatMessage({ id: "upload.media" }), kbd: "#U" }], Edit: [{ label: e10.formatMessage({ id: "undo" }), kbd: "#Z" }, { label: e10.formatMessage({ id: "redo" }), kbd: "#Z" }, { label: e10.formatMessage({ id: "cut" }), kbd: "#X" }, { label: e10.formatMessage({ id: "copy" }), kbd: "#C" }, { label: e10.formatMessage({ id: "paste" }), kbd: "#V" }, { label: e10.formatMessage({ id: "select.all" }), kbd: "#A" }, { label: e10.formatMessage({ id: "delete" }), kbd: "" }, { label: e10.formatMessage({ id: "duplicate" }), kbd: "#D" }] };
  return reactExports.createElement(Root$1, { onOpenChange: r10 }, reactExports.createElement(Trigger$1, { asChild: true }, reactExports.createElement(je, { id: "TD-HelpItem-Keyboard", variant: "wide" }, reactExports.createElement(MemoizedFormattedMessage, { id: "keyboard.shortcuts" }))), reactExports.createElement(Portal, { container: t10.current }, reactExports.createElement(Kae, null), reactExports.createElement(Wae, null, reactExports.createElement(Yae, null, reactExports.createElement(MemoizedFormattedMessage, { id: "keyboard.shortcuts" }), reactExports.createElement(Close, { asChild: true }, reactExports.createElement(_ae, null, reactExports.createElement(Cross2Icon, null)))), reactExports.createElement(Uae, { bp: Qe }, Object.entries(n10).map(([o10, s10]) => reactExports.createElement(Fs, { key: o10 }, reactExports.createElement(Vae, null, reactExports.createElement(MemoizedFormattedMessage, { id: `menu.${o10.toLocaleLowerCase()}` })), reactExports.createElement($ae, null, s10.map((a10) => reactExports.createElement(Nae, { key: a10.label }, a10.label, reactExports.createElement(po, { variant: "menu" }, a10.kbd))))))))));
}
var Vae = H2("h3", { fontSize: "$2", color: "$text", fontFamily: "$ui", margin: 0, paddingBottom: "$5" }), Fs = H2("div", { breakInside: "avoid", paddingBottom: 24 }), $ae = H2("ul", { listStyleType: "none", width: "100%", padding: 0, margin: 0 }), Nae = H2("li", { display: "flex", alignItems: "center", justifyContent: "space-between", height: 32, minHeight: 32, width: "100%", outline: "none", color: "$text", fontFamily: "$ui", fontWeight: 400, fontSize: "$1", borderRadius: 4, userSelect: "none", WebkitUserSelect: "none", margin: 0, padding: "0 0" }), Wae = H2(Content$1, { borderRadius: 6, boxShadow: "hsl(206 22% 7% / 35%) 0px 10px 38px -10px, hsl(206 22% 7% / 20%) 0px 10px 20px -15px", position: "fixed", top: "50%", left: "50%", transform: "translate(-50%, -50%)", width: "fit-content", maxWidth: "90vw", maxHeight: "74vh", overflowY: "auto", padding: 25, zIndex: 9999, pointerEvents: "all", background: "$panel", "&:focus": { outline: "none" } }), Uae = H2("div", { maxWidth: "100%", width: "fit-content", height: "fit-content", overflowY: "auto", columnGap: 64, variants: { bp: { mobile: { columns: 1, [`& ${Fs}`]: { minWidth: "0px" } }, small: { columns: 2, [`& ${Fs}`]: { minWidth: "200px" } }, medium: { columns: 3 }, large: { columns: 3 } } } }), Kae = H2(Overlay, { backgroundColor: "$overlay", position: "fixed", inset: 0, zIndex: 9998 }), _ae = H2(go, { fontFamily: "inherit", borderRadius: "100%", height: 25, width: 25, display: "inline-flex", alignItems: "center", justifyContent: "center", color: "$text", cursor: "pointer", "&:hover": { backgroundColor: "$hover" } }), Yae = H2(Title, { fontFamily: "$body", fontSize: "$3", color: "$text", paddingBottom: 32, display: "flex", alignItems: "center", justifyContent: "space-between", margin: 0 });
var ele = (r10) => r10.settings.isDebugMode, tle = (r10) => r10.settings.dockPosition;
function tl() {
  let r10 = me(), e10 = r10.useStore(ele), t10 = r10.useStore(tle), [n10, o10] = reactExports.useState(false);
  return reactExports.createElement(Root2, null, reactExports.createElement(ale, { dir: "ltr", debug: e10, side: t10, bp: Qe }, reactExports.createElement(Trigger, { dir: "ltr", asChild: true }, reactExports.createElement(sle, null, reactExports.createElement(QuestionMarkIcon, null)))), reactExports.createElement(Content2, { dir: "ltr", align: "end", side: "top", alignOffset: 10, sideOffset: 8, asChild: true }, reactExports.createElement(ile, { style: { visibility: n10 ? "hidden" : "visible" } }, reactExports.createElement(nle, null), reactExports.createElement(Qa, { onOpenChange: o10 }), reactExports.createElement(Pe, null), reactExports.createElement(rle, null))));
}
var nle = () => reactExports.createElement($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr" }, reactExports.createElement($d08ef79370b62062$export$41fb9f06171c75f4, { asChild: true }, reactExports.createElement(je, { variant: "wide", hasArrow: true }, reactExports.createElement(MemoizedFormattedMessage, { id: "language" }))), reactExports.createElement(Ja, null)), ole = [{ id: "tldraw-beta", icon: ExternalLinkIcon, url: "https://beta.tldraw.com" }, { id: "github", icon: GitHubLogoIcon, url: "https://github.com/tldraw/tldraw" }, { id: "twitter", icon: TwitterLogoIcon, url: "https://twitter.com/tldraw" }, { id: "discord", icon: Za, url: "https://discord.gg/SBBEVCA4PG" }, { id: "become.a.sponsor", icon: HeartFilledIcon, url: "https://github.com/sponsors/steveruizok" }], rle = () => reactExports.createElement(reactExports.Fragment, null, ole.map((r10) => reactExports.createElement("a", { key: r10.id, href: r10.url, target: "_blank", rel: "nofollow" }, reactExports.createElement(je, { id: `TD-Link-${r10.id}`, variant: "wide" }, reactExports.createElement(MemoizedFormattedMessage, { id: r10.id }), reactExports.createElement(ut, null, reactExports.createElement(r10.icon, null)))))), sle = H2("button", { width: 32, height: 32, borderRadius: "100%", display: "flex", padding: 0, justifyContent: "center", alignItems: "center", outline: "none", backgroundColor: "$panel", cursor: "pointer", boxShadow: "$panel", border: "1px solid $panelContrast", color: "$text", "& svg": { height: 12, width: 12 } }), ile = H2(Rt, { width: "fit-content", height: "fit-content", minWidth: 200, maxHeight: 380, overflowY: "auto", "& *": { boxSizing: "border-box" }, "& a": { outline: "none" }, variants: { variant: { horizontal: { flexDirection: "row" }, menu: { minWidth: 128 } } } }), ale = H2(Anchor2, { position: "absolute", zIndex: 999, right: 10, bottom: 10, width: 32, height: 32, variants: { debug: { true: {}, false: {} }, bp: { mobile: { bottom: 64 }, small: { bottom: 20 }, medium: {}, large: {} }, side: { top: {}, left: {}, right: {}, bottom: {} } }, compoundVariants: [{ debug: true, css: { bottom: 50 } }, { bp: "mobile", side: "bottom", debug: true, css: { bottom: 104 } }, { bp: "small", side: "bottom", debug: true, css: { bottom: 60 } }, { bp: "small", side: "bottom", debug: true, css: { bottom: 60 } }] });
var no = H2("div", { backgroundColor: "$panel", display: "flex", alignItems: "center", flexDirection: "row", boxShadow: "$panel", padding: "$2", border: "1px solid $panelContrast", gap: 0, overflow: "hidden", variants: { side: { center: { borderRadius: 9 }, left: { padding: 0, borderTop: 0, borderLeft: 0, borderTopRightRadius: 0, borderBottomRightRadius: 9, borderBottomLeftRadius: 0 }, right: { padding: 0, borderTop: 0, borderRight: 0, borderTopLeftRadius: 0, borderBottomLeftRadius: 9, borderBottomRightRadius: 0 } } }, "& hr": { height: 10, width: "100%", backgroundColor: "red", border: "none" } });
var js = ["rectangle", "ellipse", "triangle", "line"], nl = { ["rectangle"]: reactExports.createElement(SquareIcon, null), ["ellipse"]: reactExports.createElement(CircleIcon, null), ["triangle"]: reactExports.createElement(VercelLogoIcon, null), ["line"]: reactExports.createElement(Xa, null) }, ule = (r10) => r10.settings.dockPosition, ol = reactExports.memo(function({ activeTool: e10, isToolLocked: t10 }) {
  let n10 = me(), o10 = useIntl(), s10 = n10.useStore(ule), [a10, d10] = reactExports.useState("rectangle");
  reactExports.useEffect(() => {
    js.includes(e10) && a10 !== e10 && d10(e10);
  }, [e10]);
  let i10 = reactExports.useCallback(() => {
    n10.selectTool(a10);
  }, [e10, n10]), c10 = reactExports.useCallback(() => {
    n10.toggleToolLock();
  }, [n10]), u10 = reactExports.useCallback((g10) => {
    g10.key === " " && n10.shiftKey && g10.preventDefault();
  }, []), p10 = js.includes(e10), m10 = s10 === "bottom" || s10 === "top" ? "top" : s10, h10 = s10 === "bottom" || s10 === "top" ? "row" : "column";
  return reactExports.createElement($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr", onOpenChange: i10 }, reactExports.createElement($d08ef79370b62062$export$41fb9f06171c75f4, { dir: "ltr", asChild: true, id: "TD-PrimaryTools-Shapes" }, reactExports.createElement(ke, { disabled: p10 && n10.shiftKey, variant: "primary", onDoubleClick: c10, isToolLocked: p10 && t10, isActive: p10, onKeyDown: u10, "aria-label": o10.formatMessage({ id: "shapes" }) }, nl[a10])), reactExports.createElement($d08ef79370b62062$export$7c6e2c02157bb7d2, { asChild: true, side: m10, sideOffset: 12 }, reactExports.createElement(no, { side: "center", style: { flexDirection: h10 } }, js.map((g10, f10) => reactExports.createElement(Le, { key: g10, label: o10.formatMessage({ id: g10 }), kbd: (4 + f10).toString(), id: `TD-PrimaryTools-Shapes-${g10}` }, reactExports.createElement($d08ef79370b62062$export$6d08773d2e66f8f2, { asChild: true }, reactExports.createElement(ke, { "aria-label": o10.formatMessage({ id: g10 }), variant: "primary", onClick: () => {
    n10.selectTool(g10), d10(g10);
  } }, nl[g10])))))));
});
var yle = (r10) => r10.appState.activeTool, wle = (r10) => r10.appState.isToolLocked, xle = (r10) => r10.settings.dockPosition, rl = reactExports.memo(function() {
  let e10 = me(), t10 = useIntl(), n10 = e10.useStore(yle), o10 = e10.useStore(wle), s10 = e10.useStore(xle), a10 = reactExports.useCallback(() => {
    e10.selectTool("select");
  }, [e10]), d10 = reactExports.useCallback(() => {
    e10.selectTool("erase");
  }, [e10]), i10 = reactExports.useCallback(() => {
    e10.selectTool("draw");
  }, [e10]), c10 = reactExports.useCallback(() => {
    e10.selectTool("arrow");
  }, [e10]), u10 = reactExports.useCallback(() => {
    e10.selectTool("text");
  }, [e10]), p10 = reactExports.useCallback(() => {
    e10.selectTool("sticky");
  }, [e10]), m10 = reactExports.useCallback(() => pe(this, null, function* () {
    e10.openAsset();
  }), [e10]);
  return reactExports.createElement(kle, { side: "center", id: "TD-PrimaryTools", style: { flexDirection: s10 === "bottom" || s10 === "top" ? "row" : "column" }, bp: Qe }, reactExports.createElement(Xt, { kbd: "1", label: t10.formatMessage({ id: "select" }), onClick: a10, isActive: n10 === "select", variant: "primary", id: "TD-PrimaryTools-CursorArrow" }, reactExports.createElement(CursorArrowIcon, null)), reactExports.createElement(Xt, { kbd: "2", label: t10.formatMessage({ id: "draw" }), onClick: i10, isActive: n10 === "draw", variant: "primary", id: "TD-PrimaryTools-Pencil" }, reactExports.createElement(Pencil1Icon, null)), reactExports.createElement(Xt, { kbd: "3", label: t10.formatMessage({ id: "eraser" }), onClick: d10, isActive: n10 === "erase", variant: "primary", id: "TD-PrimaryTools-Eraser" }, reactExports.createElement(Ya, null)), reactExports.createElement(ol, { activeTool: n10, isToolLocked: o10 }), reactExports.createElement(Xt, { kbd: "8", label: t10.formatMessage({ id: "arrow" }), onClick: c10, isLocked: o10, variant: "primary", isActive: n10 === "arrow", id: "TD-PrimaryTools-ArrowTopRight" }, reactExports.createElement(ArrowTopRightIcon, null)), reactExports.createElement(Xt, { kbd: "9", label: t10.formatMessage({ id: "text" }), onClick: u10, isLocked: o10, variant: "primary", isActive: n10 === "text", id: "TD-PrimaryTools-Text" }, reactExports.createElement(TextIcon, null)), reactExports.createElement(Xt, { kbd: "0", label: t10.formatMessage({ id: "sticky" }), onClick: p10, isActive: n10 === "sticky", variant: "primary", id: "TD-PrimaryTools-Pencil2" }, reactExports.createElement(Pencil2Icon, null)), reactExports.createElement(Xt, { label: t10.formatMessage({ id: "image" }), onClick: m10, id: "TD-PrimaryTools-Image", variant: "primary" }, reactExports.createElement(ImageIcon, null)));
}), kle = H2(no, { variants: { bp: { mobile: { padding: "$0", borderRadius: "10px" }, small: { padding: "$2" } } } });
var vle = (r10) => r10.appState.status, Ile = (r10) => r10.appState.activeTool;
function sl() {
  let r10 = me(), e10 = r10.useStore(vle), t10 = r10.useStore(Ile);
  return reactExports.createElement(Cle, { bp: Qe, id: "TD-StatusBar" }, reactExports.createElement(Dle, null, t10, " | ", e10));
}
var Cle = H2("div", { height: 40, userSelect: "none", WebkitUserSelect: "none", borderTop: "1px solid $panelContrast", gridArea: "status", display: "flex", color: "$text", justifyContent: "space-between", alignItems: "center", backgroundColor: "$panel", gap: 8, fontFamily: "$ui", fontSize: "$0", padding: "0 16px", variants: { bp: { small: { fontSize: "$1" } } } }), Dle = H2("div", { whiteSpace: "nowrap", overflow: "hidden" });
var Ple = (r10) => r10.settings.isDebugMode, Mle = (r10) => r10.settings.dockPosition, il = reactExports.memo(function({ onBlur: e10 }) {
  let t10 = me(), n10 = t10.useStore(Mle), o10 = t10.useStore(Ple);
  return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Ele, { side: n10, onBlur: e10, bp: Qe, debug: o10 }, reactExports.createElement(Ble, { id: "TD-Tools" }, reactExports.createElement(ja, null), reactExports.createElement(Ale, { orientation: n10 === "bottom" || n10 === "top" ? "horizontal" : "vertical" }, reactExports.createElement(Fa, null), reactExports.createElement(rl, null), reactExports.createElement(qa, null)))), reactExports.createElement(tl, null), o10 && reactExports.createElement(Rle, null, reactExports.createElement(sl, null)));
}), Ele = H2("div", { position: "absolute", width: "100%", minWidth: 0, maxWidth: "100%", height: 64, gap: "$4", display: "flex", justifyContent: "center", alignItems: "center", zIndex: 200, overflow: "hidden", pointerEvents: "none", "& > div > *": { pointerEvents: "all" }, variants: { debug: { true: {}, false: {} }, bp: { mobile: {}, small: {}, medium: {}, large: {} }, side: { top: { width: "100%", height: 64, left: 0, right: 0, top: 45 }, right: { width: 64, height: "100%", top: 0, right: 0 }, bottom: { width: "100%", left: 0, right: 0, bottom: 4 }, left: { width: 64, height: "100%", left: 0 } } }, compoundVariants: [{ side: "top", bp: "large", css: { top: 0 } }, { side: "bottom", debug: true, css: { bottom: 44 } }] }), Ble = H2("div", { display: "flex", width: "fit-content", height: "fit-content", alignItems: "center", justifyContent: "center", flexDirection: "column", gap: "$4" }), Rle = H2("div", { position: "absolute", bottom: "0px", left: "0px", right: "0px", height: "40px", width: "100%", maxWidth: "100%" }), Ale = H2("div", { position: "relative", display: "flex", alignItems: "center", height: "fit-content", gap: "$3", variants: { orientation: { horizontal: { flexDirection: "row" }, vertical: { flexDirection: "column" } } } });
var Hle = (r10) => r10.settings, zle = ["bottom", "left", "right", "top"];
function ll() {
  let r10 = me(), e10 = useIntl(), t10 = r10.useStore(Hle), n10 = reactExports.useCallback(() => {
    r10.setSetting("isDebugMode", (p10) => !p10);
  }, [r10]), o10 = reactExports.useCallback(() => {
    r10.setSetting("isDarkMode", (p10) => !p10);
  }, [r10]), s10 = reactExports.useCallback(() => {
    r10.setSetting("isFocusMode", (p10) => !p10);
  }, [r10]), a10 = reactExports.useCallback(() => {
    r10.setSetting("showGrid", (p10) => !p10);
  }, [r10]), d10 = reactExports.useCallback(() => {
    r10.setSetting("keepStyleMenuOpen", (p10) => !p10);
  }, [r10]), i10 = reactExports.useCallback(() => {
    r10.setSetting("isCadSelectMode", (p10) => !p10);
  }, [r10]), c10 = reactExports.useCallback((p10) => {
    r10.setSetting("dockPosition", p10);
  }, [r10]), u10 = reactExports.useCallback((p10) => {
    r10.setSetting("exportBackground", p10);
  }, [r10]);
  return reactExports.createElement(ln, { label: e10.formatMessage({ id: "menu.preferences" }), id: "TD-MenuItem-Preferences" }, reactExports.createElement(Pt, { checked: t10.isDarkMode, onCheckedChange: o10, kbd: "#D", id: "TD-MenuItem-Preferences-Dark_Mode", ariaLabel: e10.formatMessage({ id: "preferences.dark.mode" }) }, reactExports.createElement(MemoizedFormattedMessage, { id: "preferences.dark.mode" })), reactExports.createElement(Pt, { checked: t10.isFocusMode, onCheckedChange: s10, kbd: "#.", id: "TD-MenuItem-Preferences-Focus_Mode", ariaLabel: e10.formatMessage({ id: "preferences.focus.mode" }) }, reactExports.createElement(MemoizedFormattedMessage, { id: "preferences.focus.mode" })), reactExports.createElement(Pt, { checked: t10.isDebugMode, onCheckedChange: n10, id: "TD-MenuItem-Preferences-Debug_Mode", ariaLabel: e10.formatMessage({ id: "preferences.debug.mode" }) }, reactExports.createElement(MemoizedFormattedMessage, { id: "preferences.debug.mode" })), reactExports.createElement(Pe, null), reactExports.createElement(Pt, { checked: t10.showGrid, onCheckedChange: a10, kbd: "#G", id: "TD-MenuItem-Preferences-Grid", ariaLabel: e10.formatMessage({ id: "preferences.show.grid" }) }, reactExports.createElement(MemoizedFormattedMessage, { id: "preferences.show.grid" })), reactExports.createElement(Pt, { checked: t10.isCadSelectMode, onCheckedChange: i10, id: "TD-MenuItem-Preferences-Cad_Selection", ariaLabel: e10.formatMessage({ id: "preferences.use.cad.selection" }) }, reactExports.createElement(MemoizedFormattedMessage, { id: "preferences.use.cad.selection" })), reactExports.createElement(Pt, { checked: t10.keepStyleMenuOpen, onCheckedChange: d10, id: "TD-MenuItem-Preferences-Style_menu", ariaLabel: e10.formatMessage({ id: "preferences.keep.stylemenu.open" }) }, reactExports.createElement(MemoizedFormattedMessage, { id: "preferences.keep.stylemenu.open" })), reactExports.createElement(ln, { label: e10.formatMessage({ id: "dock.position" }) }, zle.map((p10) => reactExports.createElement(Pt, { key: p10, checked: t10.dockPosition === p10, onCheckedChange: () => c10(p10), id: `TD-MenuItem-DockPosition-${p10}`, ariaLabel: `DockPosition-${p10}` }, reactExports.createElement(al, null, reactExports.createElement(MemoizedFormattedMessage, { id: p10 }))))), reactExports.createElement(ln, { label: e10.formatMessage({ id: "export.background" }) }, Object.values(Fo).map((p10) => reactExports.createElement(Pt, { key: p10, checked: t10.exportBackground === p10, onCheckedChange: () => u10(p10), id: `TD-MenuItem-ExportBackground-${p10}`, ariaLabel: `ExportBackground-${p10}` }, reactExports.createElement(al, null, reactExports.createElement(MemoizedFormattedMessage, { id: p10 }))))));
}
var al = H2("span", { textTransform: "capitalize" });
var Gle = (r10) => r10.document.pageStates[r10.appState.currentPageId].selectedIds.length, Vle = (r10) => r10.appState.disableAssets, cl = reactExports.memo(function({ readOnly: e$12 }) {
  let t10 = me(), n10 = useIntl(), [o10, s10] = reactExports.useState(false), a10 = t10.useStore(Gle), d10 = t10.useStore(Vle), [i10, c10] = reactExports.useState(0);
  reactExports.useEffect(() => c10(1), []);
  let { onNewProject: u10, onOpenProject: p10, onSaveProject: m10 } = Sr(), g10 = reactExports.useCallback(() => {
    e ? t10.saveProjectAs() : s10(true);
  }, [t10]), f10 = reactExports.useCallback(() => {
    t10.delete();
  }, [t10]), T10 = reactExports.useCallback(() => {
    t10.copyImage("svg", { scale: 1, quality: 1, transparentBackground: false });
  }, [t10]), w10 = reactExports.useCallback(() => {
    t10.copyImage("png", { scale: 2, quality: 1, transparentBackground: true });
  }, [t10]), b10 = reactExports.useCallback(() => pe(this, null, function* () {
    t10.exportImage("png", { scale: 2, quality: 1 });
  }), [t10]), y10 = reactExports.useCallback(() => pe(this, null, function* () {
    t10.exportImage("jpeg", { scale: 2, quality: 1 });
  }), [t10]), R10 = reactExports.useCallback(() => pe(this, null, function* () {
    t10.exportImage("webp", { scale: 2, quality: 1 });
  }), [t10]), U10 = reactExports.useCallback(() => pe(this, null, function* () {
    t10.exportImage("svg", { scale: 2, quality: 1 });
  }), [t10]), L10 = reactExports.useCallback(() => pe(this, null, function* () {
    t10.copyJson();
  }), [t10]), k10 = reactExports.useCallback(() => pe(this, null, function* () {
    t10.exportJson();
  }), [t10]), I10 = reactExports.useCallback(() => {
    t10.cut();
  }, [t10]), q10 = reactExports.useCallback(() => {
    t10.copy();
  }, [t10]), de2 = reactExports.useCallback(() => {
    t10.paste();
  }, [t10]), le2 = reactExports.useCallback(() => {
    t10.selectAll();
  }, [t10]), Ae = reactExports.useCallback(() => {
    t10.selectNone();
  }, [t10]), Ce2 = reactExports.useCallback(() => {
    t10.openAsset();
  }, [t10]), De2 = reactExports.useCallback(() => {
    t10.zoomTo(1);
  }, [t10]), Ve = t10.callbacks.onNewProject || t10.callbacks.onOpenProject || t10.callbacks.onSaveProject || t10.callbacks.onSaveProjectAs || t10.callbacks.onExport, $e = a10 > 0;
  return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr" }, reactExports.createElement(Rr, { id: "TD-MenuIcon" }, reactExports.createElement(HamburgerMenuIcon, null)), reactExports.createElement(Mt, { variant: "menu", id: "TD-Menu", side: "bottom", align: "start", sideOffset: 4, alignOffset: 4 }, Ve && reactExports.createElement(ln, { label: `${n10.formatMessage({ id: "menu.file" })}...`, id: "TD-MenuItem-File" }, t10.callbacks.onNewProject && reactExports.createElement(xe, { onClick: u10, kbd: "#N", id: "TD-MenuItem-File-New_Project" }, reactExports.createElement(MemoizedFormattedMessage, { id: "new.project" })), t10.callbacks.onOpenProject && reactExports.createElement(xe, { onClick: p10, kbd: "#O", id: "TD-MenuItem-File-Open" }, reactExports.createElement(MemoizedFormattedMessage, { id: "open" }), "..."), t10.callbacks.onSaveProject && reactExports.createElement(xe, { onClick: m10, kbd: "#S", id: "TD-MenuItem-File-Save" }, reactExports.createElement(MemoizedFormattedMessage, { id: "save" })), t10.callbacks.onSaveProjectAs && reactExports.createElement(xe, { onClick: g10, kbd: "#S", id: "TD-MenuItem-File-Save_As" }, reactExports.createElement(MemoizedFormattedMessage, { id: "save.as" }), "..."), reactExports.createElement(ln, { label: `${n10.formatMessage({ id: "export.as" })}...`, size: "small", id: "TD-MenuItem-Export" }, reactExports.createElement(xe, { onClick: U10, id: "TD-MenuItem-Export-SVG" }, "SVG"), reactExports.createElement(xe, { onClick: b10, id: "TD-MenuItem-Export-PNG" }, "PNG"), reactExports.createElement(xe, { onClick: y10, id: "TD-MenuItem-Export-JPG" }, "JPG"), reactExports.createElement(xe, { onClick: R10, id: "TD-MenuItem-Export-WEBP" }, "WEBP"), reactExports.createElement(xe, { onClick: k10, id: "TD-MenuItem-Export-JSON" }, "JSON")), !d10 && reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Pe, null), reactExports.createElement(xe, { onClick: Ce2, kbd: "#U", id: "TD-MenuItem-File-Upload_Media" }, reactExports.createElement(MemoizedFormattedMessage, { id: "upload.media" })))), reactExports.createElement(ln, { label: `${n10.formatMessage({ id: "menu.edit" })}...`, id: "TD-MenuItem-Edit" }, reactExports.createElement(xe, { onSelect: He, onClick: t10.undo, disabled: e$12, kbd: "#Z", id: "TD-MenuItem-Edit-Undo" }, reactExports.createElement(MemoizedFormattedMessage, { id: "undo" })), reactExports.createElement(xe, { onSelect: He, onClick: t10.redo, disabled: e$12, kbd: "#Z", id: "TD-MenuItem-Edit-Redo" }, reactExports.createElement(MemoizedFormattedMessage, { id: "redo" })), reactExports.createElement(Pe, null), reactExports.createElement(xe, { onSelect: He, disabled: !$e || e$12, onClick: I10, kbd: "#X", id: "TD-MenuItem-Edit-Cut" }, reactExports.createElement(MemoizedFormattedMessage, { id: "cut" })), reactExports.createElement(xe, { onSelect: He, disabled: !$e, onClick: q10, kbd: "#C", id: "TD-MenuItem-Edit-Copy" }, reactExports.createElement(MemoizedFormattedMessage, { id: "copy" })), reactExports.createElement(xe, { onSelect: He, onClick: de2, kbd: "#V", id: "TD-MenuItem-Edit-Paste" }, reactExports.createElement(MemoizedFormattedMessage, { id: "paste" })), reactExports.createElement(Pe, null), reactExports.createElement(ln, { label: `${n10.formatMessage({ id: "copy.as" })}...`, size: "small", id: "TD-MenuItem-Copy-As" }, reactExports.createElement(xe, { onClick: T10, id: "TD-MenuItem-Copy-as-SVG" }, "SVG"), reactExports.createElement(xe, { onClick: w10, id: "TD-MenuItem-Copy-As-PNG" }, "PNG"), reactExports.createElement(xe, { onClick: L10, id: "TD-MenuItem-Copy_as_JSON" }, "JSON")), reactExports.createElement(Pe, null), reactExports.createElement(xe, { onSelect: He, onClick: le2, kbd: "#A", id: "TD-MenuItem-Select_All" }, reactExports.createElement(MemoizedFormattedMessage, { id: "select.all" })), reactExports.createElement(xe, { onSelect: He, disabled: !$e, onClick: Ae, id: "TD-MenuItem-Select_None" }, reactExports.createElement(MemoizedFormattedMessage, { id: "select.none" })), reactExports.createElement(Pe, null), reactExports.createElement(xe, { onSelect: f10, disabled: !$e, kbd: "", id: "TD-MenuItem-Delete" }, reactExports.createElement(MemoizedFormattedMessage, { id: "delete" }))), reactExports.createElement(ln, { label: n10.formatMessage({ id: "menu.view" }), id: "TD-MenuItem-Edit" }, reactExports.createElement(xe, { onSelect: He, onClick: t10.zoomIn, kbd: "#+", id: "TD-MenuItem-View-ZoomIn" }, reactExports.createElement(MemoizedFormattedMessage, { id: "zoom.in" })), reactExports.createElement(xe, { onSelect: He, onClick: t10.zoomOut, kbd: "#-", id: "TD-MenuItem-View-ZoomOut" }, reactExports.createElement(MemoizedFormattedMessage, { id: "zoom.out" })), reactExports.createElement(xe, { onSelect: He, onClick: De2, kbd: "+0", id: "TD-MenuItem-View-ZoomTo100" }, reactExports.createElement(MemoizedFormattedMessage, { id: "zoom.to" }), " 100%"), reactExports.createElement(xe, { onSelect: He, onClick: t10.zoomToFit, kbd: "+1", id: "TD-MenuItem-View-ZoomToFit" }, reactExports.createElement(MemoizedFormattedMessage, { id: "zoom.to.fit" })), reactExports.createElement(xe, { onSelect: He, onClick: t10.zoomToSelection, kbd: "+2", id: "TD-MenuItem-View-ZoomToSelection" }, reactExports.createElement(MemoizedFormattedMessage, { id: "zoom.to.selection" }))), reactExports.createElement(Pe, null), reactExports.createElement(ll, null))), reactExports.createElement(Oa, { isOpen: o10, onClose: () => s10(false) }));
});
function pl() {
  return reactExports.createElement("svg", { width: "15", height: "15", viewBox: "0 0 15 15", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", fillRule: "evenodd", clipRule: "evenodd" }, reactExports.createElement("path", { d: "M1.36482 4.71089C1.36482 3.21371 2.57853 2 4.07572 2C5.5729 2 6.78661 3.21371 6.78661 4.71089C6.78661 5.76842 6.18106 6.68452 5.29779 7.13136C5.80465 7.24611 6.26407 7.44186 6.66028 7.73182C7.18674 8.11711 7.57215 8.64722 7.81073 9.30983C7.81452 9.30606 7.81832 9.3023 7.82212 9.29855C8.30448 8.82317 8.91325 8.52463 9.60905 8.37275C8.68812 7.922 8.05394 6.97569 8.05394 5.88126C8.05394 4.35017 9.29513 3.10898 10.8262 3.10898C12.3573 3.10898 13.5985 4.35017 13.5985 5.88126C13.5985 6.97561 12.9644 7.92186 12.0436 8.37265C12.7396 8.52449 13.3486 8.82306 13.831 9.29854C14.5795 10.0361 14.9481 11.1249 14.9481 12.5176C14.9481 12.7799 14.7354 12.9926 14.473 12.9926C14.2107 12.9926 13.9981 12.7799 13.9981 12.5175C13.9981 11.2848 13.6738 10.4774 13.1642 9.97518C12.6532 9.4716 11.8802 9.20024 10.8266 9.20024C9.77294 9.20024 8.99993 9.4716 8.48896 9.97518C7.97939 10.4774 7.65513 11.2848 7.65513 12.5176C7.65513 12.7799 7.44247 12.9926 7.18013 12.9926C6.9178 12.9926 6.70513 12.7799 6.70513 12.5176C6.70513 11.6734 6.84053 10.941 7.11384 10.3307C7.0922 10.2895 7.0763 10.2444 7.06737 10.1962C6.91739 9.38749 6.57392 8.84586 6.09923 8.49845C5.61626 8.14499 4.94481 7.95427 4.07574 7.95427C3.05232 7.95427 2.30368 8.21784 1.80952 8.70485C1.31675 9.19047 1.00176 9.97257 1.00176 11.1702C1.00176 11.4326 0.789093 11.6452 0.526758 11.6452C0.264423 11.6452 0.0517578 11.4326 0.0517578 11.1702C0.0517578 9.81263 0.411052 8.74925 1.14268 8.02821C1.60624 7.57137 2.18892 7.28191 2.85378 7.13142C1.97043 6.68461 1.36482 5.76848 1.36482 4.71089ZM4.07572 2.95C3.1032 2.95 2.31482 3.73838 2.31482 4.71089C2.31482 5.68341 3.1032 6.47178 4.07572 6.47178C5.04823 6.47178 5.83661 5.68341 5.83661 4.71089C5.83661 3.73838 5.04823 2.95 4.07572 2.95ZM10.8262 4.05898C9.8198 4.05898 9.00394 4.87484 9.00394 5.88126C9.00394 6.88768 9.8198 7.70355 10.8262 7.70355C11.8326 7.70355 12.6485 6.88768 12.6485 5.88126C12.6485 4.87484 11.8326 4.05898 10.8262 4.05898Z" }));
}
var Vt = "-0.03em";
var yo = [0.5, 0.5], zr = ".tldr", oo = { linear: (r10) => r10, easeInQuad: (r10) => r10 * r10, easeOutQuad: (r10) => r10 * (2 - r10), easeInOutQuad: (r10) => r10 < 0.5 ? 2 * r10 * r10 : -1 + (4 - 2 * r10) * r10, easeInCubic: (r10) => r10 * r10 * r10, easeOutCubic: (r10) => --r10 * r10 * r10 + 1, easeInOutCubic: (r10) => r10 < 0.5 ? 4 * r10 * r10 * r10 : (r10 - 1) * (2 * r10 - 2) * (2 * r10 - 2) + 1, easeInQuart: (r10) => r10 * r10 * r10 * r10, easeOutQuart: (r10) => 1 - --r10 * r10 * r10 * r10, easeInOutQuart: (r10) => r10 < 0.5 ? 8 * r10 * r10 * r10 * r10 : 1 - 8 * --r10 * r10 * r10 * r10, easeInQuint: (r10) => r10 * r10 * r10 * r10 * r10, easeOutQuint: (r10) => 1 + --r10 * r10 * r10 * r10 * r10, easeInOutQuint: (r10) => r10 < 0.5 ? 16 * r10 * r10 * r10 * r10 * r10 : 1 + 16 * --r10 * r10 * r10 * r10 * r10, easeInSine: (r10) => 1 - Math.cos(r10 * Math.PI / 2), easeOutSine: (r10) => Math.sin(r10 * Math.PI / 2), easeInOutSine: (r10) => -(Math.cos(Math.PI * r10) - 1) / 2, easeInExpo: (r10) => r10 <= 0 ? 0 : Math.pow(2, 10 * r10 - 10), easeOutExpo: (r10) => r10 >= 1 ? 1 : 1 - Math.pow(2, -10 * r10), easeInOutExpo: (r10) => r10 <= 0 ? 0 : r10 >= 1 ? 1 : r10 < 0.5 ? Math.pow(2, 20 * r10 - 10) / 2 : (2 - Math.pow(2, -20 * r10 + 10)) / 2 };
var $s = ["#EC5E41", "#F2555A", "#F04F88", "#E34BA9", "#BD54C6", "#9D5BD2", "#7B66DC", "#02B1CC", "#11B3A3", "#39B178", "#55B467", "#FF802B"], $le = typeof Window == "undefined" ? false : /^((?!chrome|android).)*safari/i.test(navigator.userAgent), ul = typeof Window == "undefined" ? false : /linux/i.test(navigator.userAgent), Or = [".png", ".svg", ".jpg", ".jpeg", ".gif"], Fr = $le ? [] : [".mp4", ".webm"];
function St(r10) {
  if (r10 === null) return r10;
  if (r10 instanceof Date) return new Date(r10.getTime());
  if (typeof r10 == "object") if (typeof r10[Symbol.iterator] == "function") {
    let e10 = [];
    if (r10.length > 0) for (let t10 of r10) e10.push(St(t10));
    return e10;
  } else {
    let e10 = Object.keys(r10), t10 = {};
    if (e10.length > 0) for (let n10 of e10) t10[n10] = St(r10[n10]);
    return t10;
  }
  return r10;
}
function $t(r10, e10) {
  let t10 = C$2.getFromCache(e10, r10, () => {
    let [n10, o10] = r10.size;
    return { minX: 0, maxX: n10, minY: 0, maxY: o10, width: n10, height: o10 };
  });
  return C$2.translateBounds(t10, r10.point);
}
var Nle = { ["start"]: "left", ["middle"]: "center", ["end"]: "right", ["justify"]: "justify" };
function ml(r10 = "start") {
  return Nle[r10];
}
var jn;
function Wle() {
  var e10;
  (e10 = document.getElementById("__textLabelMeasure")) == null || e10.remove();
  let r10 = document.createElement("pre");
  return r10.id = "__textLabelMeasure", Object.assign(r10.style, { whiteSpace: "pre", width: "auto", border: "1px solid transparent", padding: "4px", margin: "0px", letterSpacing: Vt, opacity: "0", position: "absolute", top: "-500px", left: "0px", zIndex: "9999", pointerEvents: "none", userSelect: "none", "-webkit-user-select": "none", alignmentBaseline: "mathematical", dominantBaseline: "mathematical" }), r10.tabIndex = -1, document.body.appendChild(r10), r10;
}
typeof window != "undefined" && (jn = Wle());
var Ws = "", gl = "", Ns = [0, 0];
function fl() {
  Ws = "";
}
function Gn(r10, e10) {
  if (!r10) return [16, 32];
  if (!jn) return [10, 10];
  if (jn.parent || document.body.appendChild(jn), r10 === Ws && e10 === gl) return Ns;
  Ws = r10, gl = e10, jn.textContent = r10, jn.style.font = e10;
  let t10 = jn.offsetWidth || 1, n10 = jn.offsetHeight || 1;
  return Ns = [t10, n10], Ns;
}
var Ule = new RegExp(`${[32, 160, 4961, 65792, 65793, 4153, 4241].map((r10) => String.fromCodePoint(r10)).join("|")}`);
function Vn(r10, e10, t10, n10, o10, s10 = false) {
  let a10 = "normal", i10 = Vt, c10 = Kle({ text: r10, width: o10, fontSize: e10, fontWeight: a10, fontFamily: t10, textAlign: "left", letterSpacing: Vt, lineHeight: 1 }), u10 = document.createElementNS("http://www.w3.org/2000/svg", "text");
  u10.setAttribute("font-size", e10 + "px"), u10.setAttribute("font-family", t10), u10.setAttribute("font-weight", a10), u10.setAttribute("line-height", 1 * e10 + "px"), u10.setAttribute("letter-spacing", i10), u10.setAttribute("text-align", n10 != null ? n10 : "left"), u10.setAttribute("dominant-baseline", "mathematical"), u10.setAttribute("alignment-baseline", "mathematical");
  let p10 = c10.map((m10, h10) => {
    let g10 = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    return g10.textContent = m10 + `
`, g10.setAttribute("y", 1 * e10 * (h10 + 0.5) + "px"), u10.appendChild(g10), g10;
  });
  switch (n10) {
    case "middle": {
      u10.setAttribute("text-align", "center"), u10.setAttribute("text-anchor", "middle"), p10.forEach((m10) => m10.setAttribute("x", o10 / 2 + ""));
      break;
    }
    case "end": {
      u10.setAttribute("text-align", "right"), u10.setAttribute("text-anchor", "end"), p10.forEach((m10) => m10.setAttribute("x", -4 + o10 + ""));
      break;
    }
    default:
      u10.setAttribute("text-align", "left"), u10.setAttribute("text-anchor", "start"), p10.forEach((m10) => m10.setAttribute("x", "4"));
  }
  return u10;
}
function Kle(r10) {
  let e10 = document.createElement("div");
  e10.style.setProperty("position", "absolute"), e10.style.setProperty("top", "-9999px"), e10.style.setProperty("left", "-9999px"), e10.style.setProperty("width", r10.width + "px"), e10.style.setProperty("height", "min-content"), e10.style.setProperty("font-size", r10.fontSize + "px"), e10.style.setProperty("font-family", r10.fontFamily), e10.style.setProperty("font-weight", r10.fontWeight), e10.style.setProperty("line-height", r10.lineHeight * r10.fontSize + "px"), e10.style.setProperty("letter-spacing", r10.letterSpacing), e10.style.setProperty("text-align", r10.textAlign), document.body.appendChild(e10);
  let t10 = r10.text.split(Ule).flatMap((a10) => a10.replace(`
`, ` 
`)).join(" ").split(" ");
  e10.innerText = t10[0];
  let n10 = e10.offsetHeight, o10 = [t10[0]], s10 = [o10];
  for (let a10 = 1; a10 < t10.length; a10++) {
    let d10 = t10[a10];
    e10.innerText += " " + d10;
    let i10 = e10.offsetHeight;
    i10 > n10 && (n10 = i10, o10 = [], s10.push(o10)), o10.push(d10);
  }
  return e10.remove(), s10.map((a10) => a10.join(" "));
}
function Sl({ id: r10, bounds: e10, labelSize: t10, offset: n10, scale: o10 = 1 }) {
  return reactExports.createElement("defs", null, reactExports.createElement("mask", { id: r10 + "_clip" }, reactExports.createElement("rect", { x: -100, y: -100, width: e10.width + 200, height: e10.height + 200, fill: "white" }), reactExports.createElement("rect", { x: e10.width / 2 - t10[0] / 2 * o10 + ((n10 == null ? void 0 : n10[0]) || 0), y: e10.height / 2 - t10[1] / 2 * o10 + ((n10 == null ? void 0 : n10[1]) || 0), width: t10[0] * o10, height: t10[1] * o10, rx: 4 * o10, ry: 4 * o10, fill: "black", opacity: Math.max(o10, 0.8) })));
}
var jr = Math.PI * 2, zt = class {
  static inwardEdgeNormal(e10) {
    let t10 = p$4.sub(e10[1], e10[0]), n10 = p$4.len2(t10);
    return [-t10[0] / n10, t10[1] / n10];
  }
  static outwardEdgeNormal(e10) {
    return p$4.neg(zt.inwardEdgeNormal(e10));
  }
  static isReflexVertex(e10, t10) {
    let n10 = e10.length, o10 = e10[(t10 + n10 - 1) % n10], s10 = e10[t10], a10 = e10[(t10 + 1) % n10];
    return zt.leftSide(o10, a10, s10) < 0;
  }
  static getEdges(e10) {
    return e10.map((t10, n10) => [t10, e10[(n10 + 1) % e10.length]]);
  }
  static edgesIntersection([e10, t10], [n10, o10]) {
    let s10 = (o10[1] - n10[1]) * (t10[0] - e10[0]) - (o10[0] - n10[0]) * (t10[1] - e10[1]);
    if (s10 == 0) return null;
    let a10 = ((o10[0] - n10[0]) * (e10[1] - n10[1]) - (o10[1] - n10[1]) * (e10[0] - n10[0])) / s10, d10 = ((t10[0] - e10[0]) * (e10[1] - n10[1]) - (t10[1] - e10[1]) * (e10[0] - n10[0])) / s10;
    return a10 < 0 || d10 < 0 || a10 > 1 || d10 > 1 ? null : [e10[0] + a10 * (t10[0] - e10[0]), e10[1] + a10 * (t10[1] - e10[1])];
  }
  static appendArc(e10, t10, n10, o10, s10, a10 = false) {
    let d10 = [...e10], i10 = Math.atan2(o10[1] - t10[1], o10[0] - t10[0]), c10 = Math.atan2(s10[1] - t10[1], s10[0] - t10[0]);
    i10 < 0 && (i10 += jr), c10 < 0 && (c10 += jr);
    let u10 = 5, p10 = i10 > c10 ? i10 - c10 : i10 + jr - c10, m10 = (a10 ? -p10 : jr - p10) / u10;
    d10.push(o10);
    for (let h10 = 1; h10 < u10; ++h10) {
      let g10 = i10 + m10 * h10;
      d10.push([t10[0] + Math.cos(g10) * n10, t10[1] + Math.sin(g10) * n10]);
    }
    return d10.push(s10), d10;
  }
  static createOffsetEdge(e10, t10) {
    return e10.map((n10) => p$4.add(n10, t10));
  }
  static getOffsetPolygon(e10, t10 = 0) {
    let n10 = zt.getEdges(e10), o10 = n10.map((a10) => zt.createOffsetEdge(a10, p$4.mul(zt.outwardEdgeNormal(a10), t10))), s10 = [];
    for (let a10 = 0; a10 < o10.length; a10++) {
      let d10 = o10[a10], i10 = o10[(a10 + o10.length - 1) % o10.length], c10 = zt.edgesIntersection(i10, d10);
      c10 ? s10.push(c10) : zt.appendArc(s10, n10[a10][0], t10, i10[1], d10[0], false);
    }
    return s10;
  }
  static createPaddingPolygon(e10, t10 = 0) {
    let n10 = e10.map((s10) => zt.createOffsetEdge(s10, zt.inwardEdgeNormal(s10))), o10 = [];
    for (let s10 = 0; s10 < n10.length; s10++) {
      let a10 = n10[s10], d10 = n10[(s10 + n10.length - 1) % n10.length], i10 = zt.edgesIntersection(d10, a10);
      i10 ? o10.push(i10) : zt.appendArc(o10, e10[s10][0], t10, d10[1], a10[0], true);
    }
    return o10;
  }
}, bl = zt;
l(bl, "leftSide", p$4.isLeft);
function Tl(r10, e10) {
  if (r10.length < 3) throw Error("Polygon must have at least 3 points");
  let t10 = r10.length;
  return r10.map((n10, o10) => [n10, r10[(o10 + 1) % t10]]).map(([n10, o10]) => {
    let s10 = p$4.mul(p$4.per(p$4.uni(p$4.sub(o10, n10))), e10);
    return [p$4.add(n10, s10), p$4.add(o10, s10)];
  }).map((n10, o10, s10) => {
    let a10 = ie(n10, s10[(o10 + 1) % s10.length]);
    if (a10 === void 0) throw Error("Expected an intersection");
    return a10;
  });
}
var yl = "#fafafa", Us = "#343d45", xo = { ["white"]: "#f0f1f3", ["lightGray"]: "#c6cbd1", ["gray"]: "#788492", ["black"]: "#1d1d1d", ["green"]: "#36b24d", ["cyan"]: "#0e98ad", ["blue"]: "#1c7ed6", ["indigo"]: "#4263eb", ["violet"]: "#7746f1", ["red"]: "#ff2133", ["orange"]: "#ff9433", ["yellow"]: "#ffc936" }, Yle = { light: x(S({}, Object.fromEntries(Object.entries(xo).map(([r10, e10]) => [r10, C$2.lerpColor(e10, yl, 0.45)]))), { ["white"]: "#ffffff", ["black"]: "#3d3d3d" }), dark: x(S({}, Object.fromEntries(Object.entries(xo).map(([r10, e10]) => [r10, C$2.lerpColor(C$2.lerpColor(e10, "#999999", 0.3), Us, 0.4)]))), { ["white"]: "#1d1d1d", ["black"]: "#bbbbbb" }) }, ko = { light: x(S({}, xo), { ["white"]: "#1d1d1d" }), dark: x(S({}, Object.fromEntries(Object.entries(xo).map(([r10, e10]) => [r10, C$2.lerpColor(e10, Us, 0.1)]))), { ["white"]: "#cecece", ["black"]: "#cecece" }) }, Gr = { light: x(S({}, Object.fromEntries(Object.entries(xo).map(([r10, e10]) => [r10, C$2.lerpColor(e10, yl, 0.82)]))), { ["white"]: "#fefefe" }), dark: x(S({}, Object.fromEntries(Object.entries(xo).map(([r10, e10]) => [r10, C$2.lerpColor(e10, Us, 0.82)]))), { ["white"]: "rgb(30,33,37)", ["black"]: "#1e1e1f" }) }, Zle = { ["small"]: 2, ["medium"]: 3.5, ["large"]: 5 }, Xle = { ["small"]: 28, ["medium"]: 48, ["large"]: 96, auto: "auto" }, qle = { ["script"]: '"Caveat Brush"', ["sans"]: '"Source Sans Pro"', ["serif"]: '"Crimson Pro"', ["mono"]: '"Source Code Pro"' }, Jle = { ["script"]: 1, ["sans"]: 1, ["serif"]: 1, ["mono"]: 1 }, Qle = { ["small"]: 24, ["medium"]: 36, ["large"]: 48, auto: "auto" };
function ede(r10) {
  return Zle[r10];
}
function ro(r10, e10 = "script") {
  return Xle[r10] * Jle[e10];
}
function dn(r10 = "script") {
  return qle[r10];
}
function Ks(r10) {
  return Qle[r10];
}
function kt(r10) {
  let e10 = ro(r10.size, r10.font), t10 = dn(r10.font), { scale: n10 = 1 } = r10;
  return `${e10 * n10}px/1 ${t10}`;
}
function wl(r10) {
  let e10 = Ks(r10.size), t10 = dn(r10.font), { scale: n10 = 1 } = r10;
  return `${e10 * n10}px/1 ${t10}`;
}
function _s(r10, e10 = false) {
  let { color: t10 } = r10, n10 = e10 ? "dark" : "light", o10 = t10 === "white" || t10 === "black" ? "yellow" : t10;
  return { fill: Yle[n10][o10], stroke: ko[n10][o10], color: e10 ? "#1d1d1d" : "#0d0d0d" };
}
function be(r10, e10) {
  let { color: t10, size: n10, isFilled: o10 } = r10, s10 = ede(n10), a10 = e10 ? "dark" : "light";
  return { stroke: ko[a10][t10], fill: o10 ? Gr[a10][t10] : "none", strokeWidth: s10 };
}
var ct = { color: "black", size: "small", isFilled: false, dash: "draw", scale: 1 }, vo = x(S({}, ct), { font: "script", textAlign: "middle" });
var xl = "  ", st = class {
  static insertTextFirefox(e10, t10) {
    e10.setRangeText(t10, e10.selectionStart || 0, e10.selectionEnd || 0, "end"), e10.dispatchEvent(new InputEvent("input", { data: t10, inputType: "insertText", isComposing: false }));
  }
  static insert(e10, t10) {
    let n10 = e10.ownerDocument, o10 = n10.activeElement;
    o10 !== e10 && e10.focus(), n10.execCommand("insertText", false, t10) || st.insertTextFirefox(e10, t10), o10 === n10.body ? e10.blur() : o10 instanceof HTMLElement && o10 !== e10 && o10.focus();
  }
  static set(e10, t10) {
    e10.select(), st.insert(e10, t10);
  }
  static getSelection(e10) {
    let { selectionStart: t10, selectionEnd: n10 } = e10;
    return e10.value.slice(t10 || void 0, n10 || void 0);
  }
  static wrapSelection(e10, t10, n10) {
    let { selectionStart: o10, selectionEnd: s10 } = e10, a10 = st.getSelection(e10);
    st.insert(e10, t10 + a10 + (n10 != null ? n10 : t10)), e10.selectionStart = (o10 || 0) + t10.length, e10.selectionEnd = (s10 || 0) + t10.length;
  }
  static replace(e10, t10, n10) {
    let o10 = 0;
    e10.value.replace(t10, (...s10) => {
      let a10 = o10 + s10[s10.length - 2], d10 = s10[0].length;
      e10.selectionStart = a10, e10.selectionEnd = a10 + d10;
      let i10 = typeof n10 == "string" ? n10 : n10(...s10);
      return st.insert(e10, i10), e10.selectionStart = a10, o10 += i10.length - d10, i10;
    });
  }
  static findLineEnd(e10, t10) {
    let n10 = e10.lastIndexOf(`
`, t10 - 1) + 1;
    return e10.charAt(n10) !== "    " ? t10 : n10 + 1;
  }
  static indent(e10) {
    var d10;
    let { selectionStart: t10, selectionEnd: n10, value: o10 } = e10, s10 = o10.slice(t10, n10), a10 = (d10 = /\n/g.exec(s10)) == null ? void 0 : d10.length;
    if (a10 && a10 > 0) {
      let i10 = o10.lastIndexOf(`
`, t10 - 1) + 1, c10 = e10.value.slice(i10, n10 - 1), u10 = c10.replace(/^|\n/g, `$&${xl}`), p10 = u10.length - c10.length;
      e10.setSelectionRange(i10, n10 - 1), st.insert(e10, u10), e10.setSelectionRange(t10 + 1, n10 + p10);
    } else st.insert(e10, xl);
  }
  static unindent(e10) {
    let { selectionStart: t10, selectionEnd: n10, value: o10 } = e10, s10 = o10.lastIndexOf(`
`, t10 - 1) + 1, a10 = st.findLineEnd(o10, n10), d10 = e10.value.slice(s10, a10), i10 = d10.replace(/(^|\n)(\t| {1,2})/g, "$1"), c10 = d10.length - i10.length;
    e10.setSelectionRange(s10, a10), st.insert(e10, i10);
    let u10 = /\t| {1,2}/.exec(o10.slice(s10, t10)), p10 = u10 ? u10[0].length : 0, m10 = t10 - p10;
    e10.setSelectionRange(t10 - p10, Math.max(m10, n10 - c10));
  }
};
var $n = reactExports.memo(function({ font: e10, text: t10, color: n10, offsetX: o10 = 0, offsetY: s10 = 0, scale: a10 = 1, isEditing: d10 = false, onBlur: i10, onChange: c10 }) {
  let u10 = reactExports.useRef(null), p10 = reactExports.useRef(false), m10 = reactExports.useCallback((y10) => {
    c10(v.normalizeText(y10.currentTarget.value));
  }, [c10]), h10 = reactExports.useCallback((y10) => {
    if (y10.key === "Escape") {
      y10.preventDefault(), y10.stopPropagation(), i10 == null || i10();
      return;
    }
    if (y10.key === "Tab" && t10.length === 0) {
      y10.preventDefault();
      return;
    }
    if (!(y10.key === "Meta" || y10.metaKey)) y10.stopPropagation();
    else if (y10.key === "z" && y10.metaKey) {
      y10.shiftKey ? document.execCommand("redo", false) : document.execCommand("undo", false), y10.stopPropagation(), y10.preventDefault();
      return;
    }
    (y10.metaKey || y10.ctrlKey) && y10.key === "=" && y10.preventDefault(), y10.key === "Tab" && (y10.preventDefault(), y10.shiftKey ? st.unindent(y10.currentTarget) : st.indent(y10.currentTarget), c10 == null || c10(v.normalizeText(y10.currentTarget.value)));
  }, [c10]), g10 = reactExports.useCallback((y10) => {
    y10.currentTarget.setSelectionRange(0, 0), i10 == null || i10();
  }, [i10]), f10 = reactExports.useCallback((y10) => {
    !d10 || !p10.current || document.activeElement === y10.currentTarget && y10.currentTarget.select();
  }, [d10]), T10 = reactExports.useCallback((y10) => {
    d10 && y10.stopPropagation();
  }, [d10]), w10 = reactExports.useRef(d10);
  reactExports.useEffect(() => {
    d10 ? (w10.current = true, requestAnimationFrame(() => {
      p10.current = true;
      let y10 = u10.current;
      y10 && (y10.focus(), y10.select());
    })) : w10.current && (i10 == null || i10(), w10.current = false);
  }, [d10, i10]);
  let b10 = reactExports.useRef(null);
  return reactExports.useLayoutEffect(() => {
    let y10 = b10.current;
    if (!y10) return;
    let R10 = Gn(t10, e10);
    y10.style.transform = `scale(${a10}, ${a10}) translate(${o10}px, ${s10}px)`, y10.style.width = R10[0] + 1 + "px", y10.style.height = R10[1] + 1 + "px";
  }, [t10, e10, s10, o10, a10]), reactExports.createElement(tde, null, reactExports.createElement(nde, { ref: b10, hasText: !!t10, isEditing: d10, style: { font: e10, color: n10 } }, d10 ? reactExports.createElement(ode, { ref: u10, style: { font: e10, color: n10 }, name: "text", tabIndex: -1, autoComplete: "false", autoCapitalize: "false", autoCorrect: "false", autoSave: "false", autoFocus: true, placeholder: "", spellCheck: "true", wrap: "off", dir: "auto", datatype: "wysiwyg", defaultValue: t10, color: n10, onFocus: f10, onChange: m10, onKeyDown: h10, onBlur: g10, onPointerDown: T10, onContextMenu: ft, onCopy: ft, onPaste: ft, onCut: ft }) : t10, ""));
}), tde = H2("div", { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", pointerEvents: "none", userSelect: "none", variants: { isGhost: { false: { opacity: 1 }, true: { transition: "opacity .2s", opacity: 0.3 } } } }), kl = { whiteSpace: "pre-wrap", overflowWrap: "break-word", letterSpacing: Vt }, nde = H2("div", S({ position: "absolute", padding: "4px", zIndex: 1, minHeight: 1, minWidth: 1, lineHeight: 1, outline: 0, fontWeight: "500", textAlign: "center", backfaceVisibility: "hidden", userSelect: "none", WebkitUserSelect: "none", WebkitTouchCallout: "none", variants: { hasText: { false: { pointerEvents: "none" }, true: { pointerEvents: "all" } }, isEditing: { false: { userSelect: "none" }, true: { background: "$boundsBg", userSelect: "text", WebkitUserSelect: "text" } } } }, kl)), ode = H2("textarea", x(S({ position: "absolute", top: 0, left: 0, zIndex: 1, width: "100%", height: "100%", border: "none", padding: "4px", resize: "none", textAlign: "inherit", minHeight: "inherit", minWidth: "inherit", lineHeight: "inherit", outline: 0, fontWeight: "inherit", overflow: "hidden", backfaceVisibility: "hidden", display: "inline-block", pointerEvents: "all", background: "$boundsBg", userSelect: "text", WebkitUserSelect: "text", fontSmooth: "always", WebkitFontSmoothing: "subpixel-antialiased", MozOsxFontSmoothing: "auto" }, kl), { "&:focus": { outline: "none", border: "none" } }));
function Nn(r10, e10, { initialShape: t10, transformOrigin: n10, scaleX: o10, scaleY: s10 }) {
  if (r10.rotation || t10.isAspectRatioLocked) {
    let a10 = p$4.toFixed(p$4.mul(t10.size, Math.min(Math.abs(o10), Math.abs(s10)))), d10 = p$4.toFixed([e10.minX + (e10.width - r10.size[0]) * (o10 < 0 ? 1 - n10[0] : n10[0]), e10.minY + (e10.height - r10.size[1]) * (s10 < 0 ? 1 - n10[1] : n10[1])]), i10 = o10 < 0 && s10 >= 0 || s10 < 0 && o10 >= 0 ? t10.rotation ? -t10.rotation : 0 : t10.rotation;
    return { size: a10, point: d10, rotation: i10 };
  } else return { point: p$4.toFixed([e10.minX, e10.minY]), size: p$4.toFixed([e10.width, e10.height]) };
}
function Wn(r10, e10) {
  return { size: p$4.toFixed([e10.width, e10.height]), point: p$4.toFixed([e10.minX, e10.minY]) };
}
var ye = class extends _e {
  constructor() {
    super(...arguments);
    l(this, "canBind", false);
    l(this, "canEdit", false);
    l(this, "canClone", false);
    l(this, "isAspectRatioLocked", false);
    l(this, "hideResizeHandles", false);
    l(this, "bindingDistance", 16);
    l(this, "hitTestPoint", (e10, t10) => C$2.pointInBounds(t10, this.getRotatedBounds(e10)));
    l(this, "hitTestLineSegment", (e10, t10, n10) => {
      let o10 = C$2.getBoundsFromPoints([t10, n10]), s10 = this.getBounds(e10);
      return C$2.boundsContain(s10, o10) || e10.rotation ? S$3(t10, n10, C$2.getRotatedCorners(this.getBounds(e10))).didIntersect : ce(t10, n10, this.getBounds(e10)).length > 0;
    });
    l(this, "create", (e10) => (this.refMap.set(e10.id, reactExports.createRef()), this.getShape(e10)));
    l(this, "getCenter", (e10) => C$2.getBoundsCenter(this.getBounds(e10)));
    l(this, "getExpandedBounds", (e10) => C$2.expandBounds(this.getBounds(e10), this.bindingDistance));
    l(this, "getBindingPoint", (e10, t10, n10, o10, s10, a10) => {
      let d10 = this.getBounds(e10), i10 = this.getExpandedBounds(e10);
      if (!C$2.pointInBounds(n10, i10)) return;
      let c10 = se(o10, s10, i10).filter((T10) => T10.didIntersect).map((T10) => T10.points[0]);
      if (!c10.length) return;
      let u10 = this.getCenter(e10), p10 = c10.sort((T10, w10) => e$3.dist(w10, o10) - e$3.dist(T10, o10))[0], m10 = e$3.med(n10, p10), h10, g10;
      a10 ? (h10 = e$3.dist(n10, u10) < 16 / 2 ? u10 : n10, g10 = 0) : (e$3.distanceToLineSegment(n10, m10, u10) < 16 / 2 ? h10 = u10 : h10 = m10, C$2.pointInBounds(n10, d10) ? g10 = this.bindingDistance : g10 = Math.max(this.bindingDistance, C$2.getBoundsSides(d10).map((T10) => e$3.distanceToLineSegment(T10[1][0], T10[1][1], n10)).sort((T10, w10) => T10 - w10)[0]));
      let f10 = e$3.divV(e$3.sub(h10, [i10.minX, i10.minY]), [i10.width, i10.height]);
      return { point: e$3.clampV(f10, 0, 1), distance: g10 };
    });
    l(this, "mutate", (e10, t10) => t10);
    l(this, "transform", (e10, t10, n10) => x(S({}, e10), { point: [t10.minX, t10.minY] }));
    l(this, "transformSingle", (e10, t10, n10) => this.transform(e10, t10, n10));
    l(this, "updateChildren");
    l(this, "onChildrenChange");
    l(this, "onHandleChange");
    l(this, "onRightPointHandle");
    l(this, "onDoubleClickHandle");
    l(this, "onDoubleClickBoundsHandle");
    l(this, "onSessionComplete");
    l(this, "getSvgElement", (e10, t10) => {
      var s10, a10, d10, i10, c10;
      let n10 = (s10 = document.getElementById(e10.id + "_svg")) == null ? void 0 : s10.cloneNode(true);
      if (!n10) return;
      if ((i10 = (d10 = (a10 = e10.label) == null ? void 0 : a10.trim()) == null ? void 0 : d10.length) != null ? i10 : 0 > 0) {
        let u10 = e10, p10 = document.createElementNS("http://www.w3.org/2000/svg", "g"), m10 = kt(e10.style), h10 = Gn(e10.label, m10), g10 = ro(e10.style.size, e10.style.font) * ((c10 = e10.style.scale) != null ? c10 : 1), f10 = dn(e10.style.font).slice(1, -1), T10 = Vn(u10.label, g10, f10, "middle", h10[0], false), w10 = this.getBounds(e10);
        return T10.setAttribute("transform", `translate(${w10.width / 2 - h10[0] / 2}, ${w10.height / 2 - h10[1] / 2})`), T10.setAttribute("fill", be(e10.style, t10).stroke), T10.setAttribute("transform-origin", "center center"), p10.setAttribute("text-align", "center"), p10.setAttribute("text-anchor", "middle"), p10.appendChild(n10), p10.appendChild(T10), p10;
      }
      return n10;
    });
  }
};
function Ml(r10, e10, t10, n10) {
  return ["M", r10[0], r10[1], "A", t10[2], t10[2], 0, 0, n10 < 0 ? 0 : 1, e10[0], e10[1]].join(" ");
}
function Wo(r10, e10) {
  let { start: t10, end: n10 } = r10, o10 = p$4.dist(t10.point, n10.point), s10 = p$4.med(t10.point, n10.point), a10 = o10 / 2 * e10, d10 = p$4.uni(p$4.vec(t10.point, n10.point));
  return p$4.toFixed(Math.abs(a10) < 10 ? s10 : p$4.add(s10, p$4.mul(p$4.per(d10), a10)));
}
function El(r10, e10, t10, n10, o10, s10) {
  let a10 = C$2.rng(r10), d10 = be(e10).strokeWidth, i10 = o10 ? p$4.nudge(t10, n10, d10) : t10, c10 = s10 ? p$4.nudge(n10, t10, d10) : n10, u10 = _e$1([i10, c10], { size: d10, thinning: 0.618 + a10() * 0.2, easing: oo.easeOutQuad, simulatePressure: true, streamline: 0, last: true });
  return C$2.getSvgPathFromStroke(u10);
}
function Bl(r10, e10, t10, n10, o10, s10, a10, d10, i10, c10) {
  let u10 = C$2.rng(r10), p10 = be(e10).strokeWidth, m10 = o10 ? p$4.rotWith(t10, a10, p10 / i10) : t10, h10 = s10 ? p$4.rotWith(n10, a10, -(p10 / i10)) : n10, g10 = p$4.angle(a10, m10), f10 = p$4.angle(a10, h10), T10 = [], w10 = 8 + Math.floor(Math.abs(i10) / 20 * 1 + u10() / 2);
  for (let y10 = 0; y10 < w10; y10++) {
    let R10 = c10(y10 / w10), U10 = C$2.lerpAngles(g10, f10, R10);
    T10.push(p$4.toFixed(p$4.nudgeAtAngle(a10, U10, d10)));
  }
  let b10 = _e$1([m10, ...T10, h10], { size: 1 + p10, thinning: 0.618 + u10() * 0.2, easing: oo.easeOutQuad, simulatePressure: false, streamline: 0, last: true });
  return C$2.getSvgPathFromStroke(b10);
}
function kn(r10, e10, t10) {
  return C$2.circleFromThreePoints(r10, t10, e10);
}
function Vr(r10, e10, t10, n10, o10) {
  let s10 = le(r10, e10 * 0.618, t10, n10).points;
  if (!s10) return v.warn("Could not find an intersection for the arrow head."), { left: r10, right: r10 };
  let a10 = o10 ? s10[0] : s10[1], d10 = a10 ? p$4.nudge(p$4.rotWith(a10, r10, Math.PI / 6), r10, e10 * -0.382) : r10, i10 = a10 ? p$4.nudge(p$4.rotWith(a10, r10, -Math.PI / 6), r10, e10 * -0.382) : r10;
  return { left: d10, right: i10 };
}
function $r(r10, e10, t10) {
  let n10 = de(r10, t10, r10, e10).points;
  if (!n10) return v.warn("Could not find an intersection for the arrow head."), { left: r10, right: r10 };
  let o10 = n10[0], s10 = o10 ? p$4.rotWith(o10, r10, Math.PI / 6) : r10, a10 = o10 ? p$4.rotWith(o10, r10, -Math.PI / 6) : r10;
  return { left: s10, right: a10 };
}
function Cl(r10, e10, t10, n10, o10) {
  let { left: s10, right: a10 } = Vr(r10, e10, t10, n10, o10);
  return `M ${s10} L ${r10} ${a10}`;
}
function Dl(r10, e10, t10) {
  let { left: n10, right: o10 } = $r(r10, e10, t10);
  return `M ${n10} L ${r10} ${o10}`;
}
function Rl(r10, e10, t10, n10, o10, s10) {
  let { strokeWidth: a10 } = be(r10, false), d10 = p$4.dist(e10, n10), i10 = Math.min(d10 / 3, a10 * 8), c10 = [];
  if (p$4.dist(t10, p$4.toFixed(p$4.med(e10, n10))) < 1) c10.push(`M ${e10} L ${n10}`), o10 && c10.push(Dl(e10, n10, i10)), s10 && c10.push(Dl(n10, e10, i10));
  else {
    let p10 = kn(e10, t10, n10), m10 = [p10[0], p10[1]], h10 = p10[2], g10 = so(m10, h10, e10, n10);
    c10.push(`M ${e10} A ${h10} ${h10} 0 0 ${g10 > 0 ? "1" : "0"} ${n10}`), o10 && c10.push(Cl(e10, i10, m10, h10, g10 < 0)), s10 && c10.push(Cl(n10, i10, m10, h10, g10 >= 0));
  }
  return c10.join(" ");
}
function Uo(r10, e10, t10) {
  if (p$4.dist2(e10, p$4.med(r10, t10)) <= 4) return [r10, t10];
  let n10 = [], o10 = kn(r10, e10, t10), s10 = [o10[0], o10[1]], a10 = o10[2], d10 = p$4.angle(s10, r10), i10 = p$4.angle(s10, t10);
  for (let c10 = 0; c10 < 20; c10++) {
    let u10 = c10 / 19, p10 = C$2.lerpAngles(d10, i10, u10);
    n10.push(p$4.nudgeAtAngle(s10, p10, a10));
  }
  return n10;
}
function Al(r10, e10, t10) {
  if (t10 === r10 || t10 === e10) return true;
  let n10 = Math.PI * 2, o10 = (e10 - r10 + n10) % n10, s10 = (t10 - r10 + n10) % n10;
  return o10 <= Math.PI != s10 > o10;
}
function so(r10, e10, t10, n10) {
  let o10 = C$2.getSweep(r10, t10, n10);
  return e10 * (2 * Math.PI) * (o10 / (2 * Math.PI));
}
function Io({ left: r10, middle: e10, right: t10, stroke: n10, strokeWidth: o10 }) {
  return reactExports.createElement("g", null, reactExports.createElement("path", { className: "tl-stroke-hitarea", d: `M ${r10} L ${e10} ${t10}` }), reactExports.createElement("path", { d: `M ${r10} L ${e10} ${t10}`, fill: "none", stroke: n10, strokeWidth: o10, strokeLinecap: "round", strokeLinejoin: "round", pointerEvents: "none" }));
}
var Hl = reactExports.memo(function({ id: e10, style: t10, start: n10, bend: o10, end: s10, arrowBend: a10, decorationStart: d10, decorationEnd: i10, isDraw: c10, isDarkMode: u10 }) {
  let p10 = p$4.dist(n10, s10);
  if (p10 < 2) return null;
  let m10 = be(t10, u10), { strokeWidth: h10 } = m10, g10 = 1 + h10 * 1.618, f10 = kn(n10, o10, s10), T10 = [f10[0], f10[1]], w10 = f10[2], b10 = so(T10, w10, n10, s10), y10 = C$2.rng(e10), R10 = oo[y10() > 0 ? "easeInOutSine" : "easeInOutCubic"], U10 = c10 ? Bl(e10, t10, n10, s10, d10, i10, T10, w10, b10, R10) : Ml(n10, s10, f10, a10), { strokeDasharray: L10, strokeDashoffset: k10 } = C$2.getPerfectDashProps(Math.abs(b10), g10, t10.dash, 2, false), I10 = Math.min(p10 / 3, h10 * 8), q10 = d10 ? Vr(n10, I10, T10, w10, b10 < 0) : null, de2 = i10 ? Vr(s10, I10, T10, w10, b10 >= 0) : null;
  return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("path", { className: "tl-stroke-hitarea", d: U10 }), reactExports.createElement("path", { d: U10, fill: c10 ? m10.stroke : "none", stroke: m10.stroke, strokeWidth: c10 ? 0 : g10, strokeDasharray: L10, strokeDashoffset: k10, strokeLinecap: "round", strokeLinejoin: "round", pointerEvents: "none" }), q10 && reactExports.createElement(Io, { left: q10.left, middle: n10, right: q10.right, stroke: m10.stroke, strokeWidth: g10 }), de2 && reactExports.createElement(Io, { left: de2.left, middle: s10, right: de2.right, stroke: m10.stroke, strokeWidth: g10 }));
});
var zl = reactExports.memo(function({ id: e10, style: t10, start: n10, end: o10, decorationStart: s10, decorationEnd: a10, isDraw: d10, isDarkMode: i10 }) {
  let c10 = p$4.dist(n10, o10);
  if (c10 < 2) return null;
  let u10 = be(t10, i10), { strokeWidth: p10 } = u10, m10 = 1 + p10 * 1.618, h10 = d10 ? El(e10, t10, n10, o10, s10, a10) : "M" + p$4.toFixed(n10) + "L" + p$4.toFixed(o10), { strokeDasharray: g10, strokeDashoffset: f10 } = C$2.getPerfectDashProps(c10, p10 * 1.618, t10.dash, 2, false), T10 = Math.min(c10 / 3, p10 * 8), w10 = s10 ? $r(n10, o10, T10) : null, b10 = a10 ? $r(o10, n10, T10) : null;
  return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("path", { className: "tl-stroke-hitarea", d: h10 }), reactExports.createElement("path", { d: h10, fill: u10.stroke, stroke: u10.stroke, strokeWidth: d10 ? m10 / 2 : m10, strokeDasharray: g10, strokeDashoffset: f10, strokeLinecap: "round", strokeLinejoin: "round", pointerEvents: "stroke" }), w10 && reactExports.createElement(Io, { left: w10.left, middle: n10, right: w10.right, stroke: u10.stroke, strokeWidth: m10 }), b10 && reactExports.createElement(Io, { left: b10.left, middle: o10, right: b10.right, stroke: u10.stroke, strokeWidth: m10 }));
});
var Zs = class extends ye {
  constructor() {
    super(...arguments);
    l(this, "type", "arrow");
    l(this, "hideBounds", true);
    l(this, "canEdit", true);
    l(this, "pathCache", /* @__PURE__ */ new WeakMap());
    l(this, "getShape", (e10) => {
      var t10, n10, o10, s10;
      return S({ id: "id", type: "arrow", name: "Arrow", parentId: "page", childIndex: 1, point: [0, 0], rotation: 0, bend: 0, handles: { start: S({ id: "start", index: 0, point: [0, 0], canBind: true }, (t10 = e10.handles) == null ? void 0 : t10.start), end: S({ id: "end", index: 1, point: [1, 1], canBind: true }, (n10 = e10.handles) == null ? void 0 : n10.end), bend: S({ id: "bend", index: 2, point: [0.5, 0.5] }, (o10 = e10.handles) == null ? void 0 : o10.bend) }, decorations: (s10 = e10.decorations) != null ? s10 : { end: "arrow" }, style: S(x(S({}, ct), { isFilled: false }), e10.style), label: "", labelPoint: [0.5, 0.5] }, e10);
    });
    l(this, "Component", ye.Component(({ shape: e10, isEditing: t10, isGhost: n10, meta: o10, events: s10, onShapeChange: a10, onShapeBlur: d10 }, i10) => {
      var le2, Ae;
      let { id: c10, label: u10 = "", handles: { start: p10, bend: m10, end: h10 }, decorations: g10 = {}, style: f10 } = e10, T10 = (Ae = (le2 = u10 == null ? void 0 : u10.trim()) == null ? void 0 : le2.length) != null ? Ae : 0 > 0, w10 = e$3.dist(m10.point, e$3.toFixed(e$3.med(p10.point, h10.point))) < 1, b10 = kt(f10), y10 = be(f10, o10.isDarkMode), R10 = T10 || t10 ? Gn(u10, b10) : [0, 0], U10 = this.getBounds(e10), L10 = reactExports.useMemo(() => {
        let { start: Ce2, bend: De2, end: Ve } = e10.handles;
        if (w10) return e$3.dist(Ce2.point, Ve.point);
        let $e = kn(Ce2.point, De2.point, Ve.point), jt = $e.slice(0, 2), on2 = $e[2], Lo = so(jt, on2, Ce2.point, Ve.point);
        return Math.abs(Lo);
      }, [e10.handles]), k10 = Math.max(0.5, Math.min(1, Math.max(L10 / (R10[1] + 128), L10 / (R10[0] + 128)))), I10 = reactExports.useMemo(() => {
        let Ce2 = this.getBounds(e10);
        return e$3.sub(e10.handles.bend.point, e$3.toFixed([Ce2.width / 2, Ce2.height / 2]));
      }, [e10, k10]), q10 = reactExports.useCallback((Ce2) => {
        a10 == null || a10({ id: c10, label: Ce2 });
      }, [a10]), de2 = w10 ? zl : Hl;
      return reactExports.createElement(fde, S({ ref: i10 }, s10), reactExports.createElement($n, { font: b10, text: u10, color: y10.stroke, offsetX: I10[0], offsetY: I10[1], scale: k10, isEditing: t10, onChange: q10, onBlur: d10 }), reactExports.createElement(te, { id: e10.id + "_svg" }, reactExports.createElement("defs", null, reactExports.createElement("mask", { id: e10.id + "_clip" }, reactExports.createElement("rect", { x: -100, y: -100, width: U10.width + 200, height: U10.height + 200, fill: "white" }), reactExports.createElement("rect", { x: U10.width / 2 - R10[0] / 2 * k10 + I10[0], y: U10.height / 2 - R10[1] / 2 * k10 + I10[1], width: R10[0] * k10, height: R10[1] * k10, rx: 4 * k10, ry: 4 * k10, fill: "black", opacity: 1 }))), reactExports.createElement("g", { pointerEvents: "none", opacity: n10 ? 0.3 : 1, mask: T10 || t10 ? `url(#${e10.id}_clip)` : "" }, reactExports.createElement(de2, { id: c10, style: f10, start: p10.point, end: h10.point, bend: m10.point, arrowBend: e10.bend, decorationStart: g10 == null ? void 0 : g10.start, decorationEnd: g10 == null ? void 0 : g10.end, isDraw: f10.dash === "draw", isDarkMode: o10.isDarkMode }))));
    }));
    l(this, "Indicator", ye.Indicator(({ shape: e10, bounds: t10 }) => {
      var T10, w10;
      let { style: n10, decorations: o10, label: s10, handles: { start: a10, bend: d10, end: i10 } } = e10, c10 = (w10 = (T10 = s10 == null ? void 0 : s10.trim()) == null ? void 0 : T10.length) != null ? w10 : 0 > 0, u10 = kt(n10), p10 = c10 ? Gn(s10, u10) : [0, 0], m10 = e$3.dist(d10.point, e$3.toFixed(e$3.med(a10.point, i10.point))) < 1, h10 = reactExports.useMemo(() => {
        let { start: b10, bend: y10, end: R10 } = e10.handles;
        if (m10) return e$3.dist(b10.point, R10.point);
        let U10 = kn(b10.point, y10.point, R10.point), L10 = U10.slice(0, 2), k10 = U10[2], I10 = so(L10, k10, b10.point, R10.point);
        return Math.abs(I10);
      }, [e10.handles]), g10 = Math.max(0.5, Math.min(1, Math.max(h10 / (p10[1] + 128), h10 / (p10[0] + 128)))), f10 = reactExports.useMemo(() => {
        let b10 = this.getBounds(e10);
        return e$3.sub(e10.handles.bend.point, [b10.width / 2, b10.height / 2]);
      }, [e10, g10]);
      return reactExports.createElement(reactExports.Fragment, null, c10 && reactExports.createElement(Sl, { id: e10.id, scale: g10, offset: f10, bounds: t10, labelSize: p10 }), reactExports.createElement("path", { d: Rl(n10, a10.point, d10.point, i10.point, o10 == null ? void 0 : o10.start, o10 == null ? void 0 : o10.end), mask: c10 ? `url(#${e10.id}_clip)` : "" }), c10 && reactExports.createElement("rect", { x: t10.width / 2 - p10[0] / 2 * g10 + f10[0], y: t10.height / 2 - p10[1] / 2 * g10 + f10[1], width: p10[0] * g10, height: p10[1] * g10, rx: 4 * g10, ry: 4 * g10, fill: "transparent" }));
    }));
    l(this, "getBounds", (e10) => {
      let t10 = C$2.getFromCache(this.boundsCache, e10, () => {
        let { handles: { start: n10, bend: o10, end: s10 } } = e10;
        return C$2.getBoundsFromPoints(Uo(n10.point, o10.point, s10.point));
      });
      return C$2.translateBounds(t10, e10.point);
    });
    l(this, "getRotatedBounds", (e10) => {
      let { handles: { start: t10, bend: n10, end: o10 } } = e10, s10 = Uo(t10.point, n10.point, o10.point), { minX: a10, minY: d10, maxX: i10, maxY: c10 } = C$2.getBoundsFromPoints(s10);
      return e10.rotation !== 0 && (s10 = s10.map((u10) => e$3.rotWith(u10, [(a10 + i10) / 2, (d10 + c10) / 2], e10.rotation || 0))), C$2.translateBounds(C$2.getBoundsFromPoints(s10), e10.point);
    });
    l(this, "getCenter", (e10) => {
      let { start: t10, end: n10 } = e10.handles;
      return e$3.add(e10.point, e$3.med(t10.point, n10.point));
    });
    l(this, "shouldRender", (e10, t10) => t10.decorations !== e10.decorations || t10.handles !== e10.handles || t10.style !== e10.style || t10.label !== e10.label);
    l(this, "hitTestPoint", (e10, t10) => {
      let { handles: { start: n10, bend: o10, end: s10 } } = e10, a10 = e$3.sub(t10, e10.point), d10 = Uo(n10.point, o10.point, s10.point);
      for (let i10 = 1; i10 < d10.length; i10++) if (e$3.distanceToLineSegment(d10[i10 - 1], d10[i10], a10) < 1) return true;
      return false;
    });
    l(this, "hitTestLineSegment", (e10, t10, n10) => {
      let { handles: { start: o10, bend: s10, end: a10 } } = e10, d10 = e$3.sub(t10, e10.point), i10 = e$3.sub(n10, e10.point), c10 = Uo(o10.point, s10.point, a10.point);
      for (let u10 = 1; u10 < c10.length; u10++) if (B$1(c10[u10 - 1], c10[u10], d10, i10).didIntersect) return true;
      return false;
    });
    l(this, "hitTestBounds", (e10, t10) => {
      let { start: n10, end: o10, bend: s10 } = e10.handles, a10 = e$3.add(e10.point, n10.point), d10 = e$3.add(e10.point, o10.point);
      if (C$2.pointInBounds(a10, t10) || C$2.pointInBounds(d10, t10)) return true;
      if (e$3.isEqual(e$3.med(n10.point, o10.point), s10.point)) return ce(a10, d10, t10).length > 0;
      {
        let [i10, c10, u10] = kn(n10.point, s10.point, o10.point), p10 = e$3.add(e10.point, [i10, c10]);
        return be$2(p10, u10, a10, d10, t10).length > 0;
      }
    });
    l(this, "transform", (e10, t10, { initialShape: n10, scaleX: o10, scaleY: s10 }) => {
      let a10 = this.getBounds(n10), d10 = ["start", "end"], i10 = S({}, n10.handles);
      d10.forEach((p10) => {
        if (p10 === "bend") return;
        let [m10, h10] = i10[p10].point, g10 = m10 / a10.width, f10 = h10 / a10.height;
        i10[p10] = x(S({}, i10[p10]), { point: [t10.width * (o10 < 0 ? 1 - g10 : g10), t10.height * (s10 < 0 ? 1 - f10 : f10)] });
      });
      let c10 = o10 > 0 && s10 < 0 || o10 < 0 && s10 > 0 ? -n10.bend : n10.bend, u10 = Wo(i10, c10);
      return i10.bend.point = u10, { point: e$3.toFixed([t10.minX, t10.minY]), handles: i10, bend: c10 };
    });
    l(this, "onDoubleClickHandle", (e10, t10) => {
      var n10, o10;
      switch (t10) {
        case "bend":
          return { bend: 0, handles: x(S({}, e10.handles), { bend: x(S({}, e10.handles.bend), { point: Wo(e10.handles, e10.bend) }) }) };
        case "start":
          return { decorations: x(S({}, e10.decorations), { start: ((n10 = e10.decorations) == null ? void 0 : n10.start) ? void 0 : "arrow" }) };
        case "end":
          return { decorations: x(S({}, e10.decorations), { end: ((o10 = e10.decorations) == null ? void 0 : o10.end) ? void 0 : "arrow" }) };
      }
      return this;
    });
    l(this, "onHandleChange", (e10, t10) => {
      let n10 = C$2.deepMerge(e10.handles, t10), o10 = e10.bend;
      if (n10 = C$2.deepMerge(n10, { start: { point: e$3.toFixed(n10.start.point) }, end: { point: e$3.toFixed(n10.end.point) } }), e$3.isEqual(n10.start.point, n10.end.point)) return;
      if ("bend" in t10) {
        let { start: c10, end: u10, bend: p10 } = n10, m10 = e$3.dist(c10.point, u10.point), h10 = e$3.med(c10.point, u10.point), g10 = e$3.angle(c10.point, u10.point), f10 = e$3.uni(e$3.vec(c10.point, u10.point)), T10 = e$3.add(h10, e$3.mul(e$3.per(f10), m10)), w10 = e$3.sub(h10, e$3.mul(e$3.per(f10), m10)), b10 = e$3.nearestPointOnLineSegment(T10, w10, p10.point, true), R10 = e$3.dist(h10, b10) / (m10 / 2);
        o10 = C$2.clamp(R10, -0.99, 0.99);
        let U10 = e$3.angle(c10.point, b10);
        e$3.isEqual(h10, Wo(n10, o10)) ? o10 = 0 : Al(g10, g10 + Math.PI, U10) && (o10 *= -1);
      }
      let s10 = { point: e10.point, bend: o10, handles: x(S({}, n10), { bend: x(S({}, n10.bend), { point: Wo(n10, o10) }) }) }, a10 = e10.point, d10 = this.getBounds(S({}, s10)), i10 = e$3.sub([d10.minX, d10.minY], a10);
      return e$3.isEqual(i10, [0, 0]) || (Object.values(s10.handles).forEach((c10) => {
        c10.point = e$3.toFixed(e$3.sub(c10.point, i10));
      }), s10.point = e$3.toFixed(e$3.add(s10.point, i10))), s10;
    });
    l(this, "getSvgElement", (e10, t10) => {
      var s10, a10, d10, i10, c10;
      let n10 = (s10 = document.getElementById(e10.id + "_svg")) == null ? void 0 : s10.cloneNode(true);
      if (!n10) return;
      if ((i10 = (d10 = (a10 = e10.label) == null ? void 0 : a10.trim()) == null ? void 0 : d10.length) != null ? i10 : 0 > 0) {
        let u10 = e10, p10 = document.createElementNS("http://www.w3.org/2000/svg", "g"), m10 = kt(e10.style), h10 = Gn(e10.label, m10), g10 = ro(e10.style.size, e10.style.font) * ((c10 = e10.style.scale) != null ? c10 : 1), f10 = dn(e10.style.font).slice(1, -1), T10 = Vn(u10.label, g10, f10, "start", h10[0], false), w10, { start: b10, bend: y10, end: R10 } = e10.handles;
        if (e$3.dist(y10.point, e$3.toFixed(e$3.med(b10.point, R10.point))) < 1) w10 = e$3.dist(b10.point, R10.point);
        else {
          let le2 = kn(b10.point, y10.point, R10.point), Ae = le2.slice(0, 2), Ce2 = le2[2], De2 = so(Ae, Ce2, b10.point, R10.point);
          w10 = Math.abs(De2);
        }
        let L10 = Math.max(0.5, Math.min(1, Math.max(w10 / (h10[1] + 128), w10 / (h10[0] + 128)))), k10 = this.getBounds(e10), I10 = e$3.sub(e10.handles.bend.point, [k10.width / 2, k10.height / 2]), q10 = k10.width / 2 - h10[0] / 2 * L10 + I10[0], de2 = k10.height / 2 - h10[1] / 2 * L10 + I10[1];
        return T10.setAttribute("transform", `translate(${q10}, ${de2})`), T10.setAttribute("fill", be(e10.style, t10).stroke), T10.setAttribute("transform-origin", "center center"), p10.setAttribute("text-align", "center"), p10.setAttribute("text-anchor", "middle"), p10.appendChild(n10), p10.appendChild(T10), p10;
      }
      return n10;
    });
  }
}, fde = H2("div", { width: "100%", height: "100%" });
var Tde = { easing: (r10) => Math.sin(r10 * Math.PI / 2), simulatePressure: true }, yde = { easing: (r10) => r10 * r10, simulatePressure: false };
function qs(r10) {
  let e10 = be(r10.style);
  return x(S({ size: 1 + e10.strokeWidth * 1.5, thinning: 0.65, streamline: 0.65, smoothing: 0.65 }, r10.points[1][2] === 0.5 ? Tde : yde), { last: r10.isComplete });
}
function Fl(r10) {
  return r10.points.length < 2 ? "" : C$2.getSvgPathFromStroke(me$1(r10.points, qs(r10)).map((e10) => e10.point));
}
function jl(r10, e10) {
  return me$1(r10.points, e10);
}
function Gl(r10) {
  if (r10.points.length < 2) return "";
  let e10 = qs(r10), t10 = jl(r10, e10);
  return C$2.getSvgPathFromStroke(ce$1(t10, e10));
}
function Js(r10) {
  let { points: e10 } = r10;
  if (e10.length < 2) return "M 0 0 L 0 0";
  let t10 = qs(r10), n10 = jl(r10, t10), o10 = e10[e10.length - 1];
  return p$4.isEqual(n10[0].point, o10) || n10.push({ point: o10 }), C$2.getSvgPathFromStrokePoints(n10);
}
var ei = class extends ye {
  constructor() {
    super(...arguments);
    l(this, "type", "draw");
    l(this, "pointsBoundsCache", /* @__PURE__ */ new WeakMap([]));
    l(this, "shapeBoundsCache", /* @__PURE__ */ new Map());
    l(this, "rotatedCache", /* @__PURE__ */ new WeakMap([]));
    l(this, "pointCache", {});
    l(this, "canClone", true);
    l(this, "getShape", (e10) => C$2.deepMerge({ id: "id", type: "draw", name: "Draw", parentId: "page", childIndex: 1, point: [0, 0], rotation: 0, style: ct, points: [], isComplete: false }, e10));
    l(this, "Component", ye.Component(({ shape: e10, meta: t10, isSelected: n10, isGhost: o10, events: s10 }, a10) => {
      let { points: d10, style: i10, isComplete: c10 } = e10, u10 = reactExports.useMemo(() => Fl(e10), [d10, i10.size]), p10 = reactExports.useMemo(() => i10.dash === "draw" ? Gl(e10) : Js(e10), [d10, i10.size, i10.dash, c10]), m10 = be(i10, t10.isDarkMode), { stroke: h10, fill: g10, strokeWidth: f10 } = m10, T10 = this.getBounds(e10);
      if (T10.width <= f10 / 2 && T10.height <= f10 / 2) {
        let L10 = 1 + f10;
        return reactExports.createElement(te, S({ ref: a10, id: e10.id + "_svg" }, s10), reactExports.createElement("circle", { r: L10, fill: h10, stroke: h10, pointerEvents: "all", opacity: o10 ? 0.3 : 1 }));
      }
      let b10 = i10.isFilled && d10.length > 3 && e$3.dist(d10[0], d10[d10.length - 1]) < f10 * 2;
      if (e10.style.dash === "draw") return reactExports.createElement(te, S({ ref: a10, id: e10.id + "_svg" }, s10), reactExports.createElement("g", { opacity: o10 ? 0.3 : 1 }, reactExports.createElement("path", { className: b10 || n10 ? "tl-fill-hitarea" : "tl-stroke-hitarea", d: p10 }), b10 && reactExports.createElement("path", { d: u10, stroke: "none", fill: g10, strokeLinejoin: "round", strokeLinecap: "round", pointerEvents: "none" }), reactExports.createElement("path", { d: p10, fill: h10, stroke: h10, strokeWidth: f10 / 2, strokeLinejoin: "round", strokeLinecap: "round", pointerEvents: "none" })));
      let y10 = { ["draw"]: "none", ["solid"]: "none", ["dotted"]: `0.1 ${f10 * 4}`, ["dashed"]: `${f10 * 4} ${f10 * 4}` }[i10.dash], R10 = { ["draw"]: "none", ["solid"]: "none", ["dotted"]: "0", ["dashed"]: "0" }[i10.dash], U10 = 1 + f10 * 1.5;
      return reactExports.createElement(te, S({ ref: a10, id: e10.id + "_svg" }, s10), reactExports.createElement("g", { opacity: o10 ? 0.3 : 1 }, reactExports.createElement("path", { className: b10 && n10 ? "tl-fill-hitarea" : "tl-stroke-hitarea", d: p10 }), reactExports.createElement("path", { d: p10, fill: b10 ? g10 : "none", stroke: "none", strokeWidth: Math.min(4, f10 * 2), strokeLinejoin: "round", strokeLinecap: "round", pointerEvents: "none" }), reactExports.createElement("path", { d: p10, fill: "none", stroke: h10, strokeWidth: U10, strokeDasharray: y10, strokeDashoffset: R10, strokeLinejoin: "round", strokeLinecap: "round", pointerEvents: "none" })));
    }));
    l(this, "Indicator", ye.Indicator(({ shape: e10 }) => {
      let { points: t10 } = e10, n10 = reactExports.useMemo(() => Js(e10), [t10]), o10 = this.getBounds(e10);
      return o10.width < 4 && o10.height < 4 ? reactExports.createElement("circle", { x: o10.width / 2, y: o10.height / 2, r: 1 }) : reactExports.createElement("path", { d: n10 });
    }));
    l(this, "transform", (e10, t10, { initialShape: n10, scaleX: o10, scaleY: s10 }) => {
      let a10 = C$2.getFromCache(this.boundsCache, n10, () => C$2.getBoundsFromPoints(n10.points)), d10 = n10.points.map(([u10, p10, m10]) => [t10.width * (o10 < 0 ? 1 - u10 / a10.width : u10 / a10.width), t10.height * (s10 < 0 ? 1 - p10 / a10.height : p10 / a10.height), m10]), i10 = C$2.getBoundsFromPoints(e10.points), c10 = e$3.sub([t10.minX, t10.minY], [i10.minX, i10.minY]);
      return { points: d10, point: c10 };
    });
    l(this, "getBounds", (e10) => {
      let t10 = !this.pointsBoundsCache.has(e10.points), n10 = this.pointCache[e10.id] !== e10.point;
      if (t10) {
        let o10 = C$2.getBoundsFromPoints(e10.points);
        this.pointsBoundsCache.set(e10.points, o10), this.shapeBoundsCache.set(e10.id, C$2.translateBounds(o10, e10.point)), this.pointCache[e10.id] = e10.point;
      } else n10 && !t10 && (this.pointCache[e10.id] = e10.point, this.shapeBoundsCache.set(e10.id, C$2.translateBounds(this.pointsBoundsCache.get(e10.points), e10.point)));
      return this.shapeBoundsCache.get(e10.id);
    });
    l(this, "shouldRender", (e10, t10) => t10.points !== e10.points || t10.style !== e10.style || t10.isComplete !== e10.isComplete);
    l(this, "hitTestPoint", (e10, t10) => {
      let n10 = e$3.sub(t10, e10.point);
      return C$2.pointInPolyline(n10, e10.points);
    });
    l(this, "hitTestLineSegment", (e10, t10, n10) => {
      let { points: o10, point: s10 } = e10, a10 = e$3.sub(t10, s10), d10 = e$3.sub(n10, s10), i10 = this.getBounds(e10);
      if (i10.width < 8 && i10.height < 8) return e$3.distanceToLineSegment(t10, n10, C$2.getBoundsCenter(i10)) < 5;
      if (ce(a10, d10, i10)) {
        for (let c10 = 1; c10 < o10.length; c10++) if (B$1(o10[c10 - 1], o10[c10], a10, d10).didIntersect) return true;
      }
      return false;
    });
    l(this, "hitTestBounds", (e10, t10) => {
      if (!e10.rotation) {
        let s10 = this.getBounds(e10);
        return C$2.boundsContain(t10, s10) || (C$2.boundsContain(s10, t10) || Te(s10, t10).length > 0) && ye$1(C$2.translateBounds(t10, e$3.neg(e10.point)), e10.points).length > 0;
      }
      let n10 = this.getRotatedBounds(e10), o10 = C$2.getFromCache(this.rotatedCache, e10, () => {
        let s10 = C$2.getBoundsCenter(C$2.getBoundsFromPoints(e10.points));
        return e10.points.map((a10) => e$3.rotWith(a10, s10, e10.rotation || 0));
      });
      return C$2.boundsContain(t10, n10) || ye$1(C$2.translateBounds(t10, e$3.neg(e10.point)), o10).length > 0;
    });
  }
};
var Nl = reactExports.memo(function({ radius: e10, style: t10, isSelected: n10, isDarkMode: o10 }) {
  let { stroke: s10, strokeWidth: a10, fill: d10 } = be(t10, o10), i10 = 1 + a10 * 1.618, c10 = Math.max(0, e10[0] - i10 / 2), u10 = Math.max(0, e10[1] - i10 / 2), p10 = C$2.perimeterOfEllipse(c10, u10), { strokeDasharray: m10, strokeDashoffset: h10 } = C$2.getPerfectDashProps(p10 < 64 ? p10 * 2 : p10, a10 * 1.618, t10.dash, 4);
  return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("ellipse", { className: t10.isFilled || n10 ? "tl-fill-hitarea" : "tl-stroke-hitarea", cx: e10[0], cy: e10[1], rx: e10[0], ry: e10[1] }), reactExports.createElement("ellipse", { cx: e10[0], cy: e10[1], rx: c10, ry: u10, fill: d10, stroke: s10, strokeWidth: i10, strokeDasharray: m10, strokeDashoffset: h10, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round" }));
});
function Wl(r10, e10, t10) {
  let { strokeWidth: n10 } = be(t10), o10 = C$2.rng(r10), s10 = e10[0] + o10() * n10 * 2, a10 = e10[1] + o10() * n10 * 2, d10 = C$2.perimeterOfEllipse(s10, a10), i10 = [], c10 = Math.PI + Math.PI * o10(), u10 = Math.abs(o10()), p10 = Math.max(16, d10 / 10);
  for (let m10 = 0; m10 < p10; m10++) {
    let h10 = oo.easeInOutSine(m10 / (p10 + 1)), g10 = c10 * 2 + Math.PI * (2 + u10) * h10, f10 = Math.cos(g10), T10 = Math.sin(g10);
    i10.push([s10 * f10 + e10[0], a10 * T10 + e10[1], h10 + 0.5 + o10() / 2]);
  }
  return me$1(i10, { size: 1 + n10 * 2, streamline: 0 });
}
function Ul(r10, e10, t10) {
  let { strokeWidth: n10 } = be(t10), o10 = C$2.rng(r10), s10 = e10[0] + o10() * n10 * 2, a10 = e10[1] + o10() * n10 * 2, d10 = C$2.perimeterOfEllipse(s10, a10);
  return C$2.getSvgPathFromStroke(ce$1(Wl(r10, e10, t10), { size: 2 + n10 * 2, thinning: 0.618, end: { taper: d10 / 8 }, start: { taper: d10 / 12 }, simulatePressure: true }));
}
function Wr(r10, e10, t10) {
  return C$2.getSvgPathFromStrokePoints(Wl(r10, e10, t10));
}
var Kl = reactExports.memo(function({ id: e10, radius: t10, style: n10, isSelected: o10, isDarkMode: s10 }) {
  let { stroke: a10, strokeWidth: d10, fill: i10 } = be(n10, s10), c10 = Ul(e10, t10, n10);
  return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("ellipse", { className: n10.isFilled || o10 ? "tl-fill-hitarea" : "tl-stroke-hitarea", cx: t10[0], cy: t10[1], rx: t10[0], ry: t10[1] }), n10.isFilled && reactExports.createElement("path", { d: Wr(e10, t10, n10), stroke: "none", fill: i10, pointerEvents: "none" }), reactExports.createElement("path", { d: c10, fill: a10, stroke: a10, strokeWidth: d10, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round" }));
});
var ni = class extends ye {
  constructor() {
    super(...arguments);
    l(this, "type", "ellipse");
    l(this, "canBind", true);
    l(this, "canClone", true);
    l(this, "canEdit", true);
    l(this, "getShape", (e10) => C$2.deepMerge({ id: "id", type: "ellipse", name: "Ellipse", parentId: "page", childIndex: 1, point: [0, 0], radius: [1, 1], rotation: 0, style: ct, label: "", labelPoint: [0.5, 0.5] }, e10));
    l(this, "Component", ye.Component(({ shape: e10, isGhost: t10, isSelected: n10, isBinding: o10, isEditing: s10, meta: a10, bounds: d10, events: i10, onShapeChange: c10, onShapeBlur: u10 }, p10) => {
      let { id: m10, radius: h10, style: g10, label: f10 = "", labelPoint: T10 = yo } = e10, w10 = kt(e10.style), b10 = be(g10, a10.isDarkMode), y10 = b10.strokeWidth, R10 = 1 + y10 * 1.618, U10 = Math.max(0, h10[0] - R10 / 2), L10 = Math.max(0, h10[1] - R10 / 2), k10 = g10.dash === "draw" ? Kl : Nl, I10 = reactExports.useCallback((q10) => c10 == null ? void 0 : c10({ id: m10, label: q10 }), [c10]);
      return reactExports.createElement(Mde, S({ ref: p10 }, i10), reactExports.createElement($n, { isEditing: s10, onChange: I10, onBlur: u10, font: w10, text: f10, color: b10.stroke, offsetX: (T10[0] - 0.5) * d10.width, offsetY: (T10[1] - 0.5) * d10.height }), reactExports.createElement(te, { id: e10.id + "_svg", opacity: t10 ? 0.3 : 1 }, o10 && reactExports.createElement("ellipse", { className: "tl-binding-indicator", cx: h10[0], cy: h10[1], rx: U10, ry: L10, strokeWidth: this.bindingDistance }), reactExports.createElement(k10, { id: m10, radius: h10, style: g10, isSelected: n10, isDarkMode: a10.isDarkMode })));
    }));
    l(this, "Indicator", ye.Indicator(({ shape: e10 }) => {
      let { id: t10, radius: n10, style: o10 } = e10, a10 = be(o10).strokeWidth, d10 = 1 + a10 * 1.618, i10 = Math.max(0, n10[0] - d10 / 2), c10 = Math.max(0, n10[1] - d10 / 2);
      return o10.dash === "draw" ? reactExports.createElement("path", { d: Wr(t10, n10, o10) }) : reactExports.createElement("ellipse", { cx: n10[0], cy: n10[1], rx: i10, ry: c10 });
    }));
    l(this, "hitTestPoint", (e10, t10) => C$2.pointInBounds(t10, this.getRotatedBounds(e10)) && C$2.pointInEllipse(t10, this.getCenter(e10), e10.radius[0], e10.radius[1], e10.rotation || 0));
    l(this, "hitTestLineSegment", (e10, t10, n10) => y$4(t10, n10, this.getCenter(e10), e10.radius[0], e10.radius[1], e10.rotation || 0).didIntersect);
    l(this, "getBounds", (e10) => C$2.getFromCache(this.boundsCache, e10, () => C$2.getRotatedEllipseBounds(e10.point[0], e10.point[1], e10.radius[0], e10.radius[1], 0)));
    l(this, "getRotatedBounds", (e10) => C$2.getRotatedEllipseBounds(e10.point[0], e10.point[1], e10.radius[0], e10.radius[1], e10.rotation));
    l(this, "hitTestBounds", (e10, t10) => {
      let n10 = this.getBounds(e10);
      return C$2.boundsContained(n10, t10) || pe$1(this.getCenter(e10), e10.radius[0], e10.radius[1], e10.rotation || 0, t10).length > 0;
    });
    l(this, "shouldRender", (e10, t10) => t10.radius !== e10.radius || t10.style !== e10.style || t10.label !== e10.label);
    l(this, "getCenter", (e10) => e$3.add(e10.point, e10.radius));
    l(this, "getBindingPoint", (e10, t10, n10, o10, s10, a10) => {
      {
        let d10 = this.getExpandedBounds(e10), i10 = this.getCenter(e10), c10, u10;
        if (!C$2.pointInEllipse(n10, i10, e10.radius[0] + this.bindingDistance, e10.radius[1] + this.bindingDistance)) return;
        if (a10) e$3.dist(n10, this.getCenter(e10)) < 12 ? c10 = [0.5, 0.5] : c10 = e$3.divV(e$3.sub(n10, [d10.minX, d10.minY]), [d10.width, d10.height]), u10 = 0;
        else {
          let p10 = F$1(o10, s10, i10, e10.radius[0], e10.radius[1], e10.rotation || 0).points.sort((h10, g10) => e$3.dist(h10, o10) - e$3.dist(g10, o10))[0];
          if (p10 || (p10 = y$4(n10, i10, i10, e10.radius[0], e10.radius[1], e10.rotation || 0).points.sort((h10, g10) => e$3.dist(h10, n10) - e$3.dist(g10, n10))[0]), !p10) return;
          let m10 = e$3.med(n10, p10);
          if (e$3.distanceToLineSegment(n10, m10, this.getCenter(e10)) < 12 ? c10 = [0.5, 0.5] : c10 = e$3.divV(e$3.sub(m10, [d10.minX, d10.minY]), [d10.width, d10.height]), C$2.pointInEllipse(n10, i10, e10.radius[0], e10.radius[1], e10.rotation || 0)) u10 = this.bindingDistance / 2;
          else {
            let h10 = y$4(n10, i10, i10, e10.radius[0], e10.radius[1], e10.rotation || 0).points[0];
            if (!h10) return;
            u10 = Math.max(this.bindingDistance / 2, e$3.dist(n10, h10));
          }
        }
        return { point: c10, distance: u10 };
      }
    });
    l(this, "transform", (e10, t10, { scaleX: n10, scaleY: o10, initialShape: s10 }) => {
      let { rotation: a10 = 0 } = s10;
      return { point: [t10.minX, t10.minY], radius: [t10.width / 2, t10.height / 2], rotation: n10 < 0 && o10 >= 0 || o10 < 0 && n10 >= 0 ? -(a10 || 0) : a10 || 0 };
    });
    l(this, "transformSingle", (e10, t10) => ({ point: e$3.toFixed([t10.minX, t10.minY]), radius: e$3.div([t10.width, t10.height], 2) }));
  }
}, Mde = H2("div", { width: "100%", height: "100%" });
var oi = class extends ye {
  constructor() {
    super(...arguments);
    l(this, "type", "group");
    l(this, "canBind", true);
    l(this, "getShape", (e10) => C$2.deepMerge({ id: "id", type: "group", name: "Group", parentId: "page", childIndex: 1, point: [0, 0], size: [100, 100], rotation: 0, children: [], style: ct }, e10));
    l(this, "Component", ye.Component(({ shape: e10, isBinding: t10, isGhost: n10, isHovered: o10, isSelected: s10, events: a10 }, d10) => {
      let { id: i10, size: c10 } = e10, u10 = 2, p10 = Math.max(0, c10[0] - u10 / 2), m10 = Math.max(0, c10[1] - u10 / 2), g10 = [[[u10 / 2, u10 / 2], [p10, u10 / 2], p10 - u10 / 2], [[p10, u10 / 2], [p10, m10], m10 - u10 / 2], [[p10, m10], [u10 / 2, m10], p10 - u10 / 2], [[u10 / 2, m10], [u10 / 2, u10 / 2], m10 - u10 / 2]].map(([f10, T10], w10) => reactExports.createElement("line", { key: i10 + "_" + w10, x1: f10[0], y1: f10[1], x2: T10[0], y2: T10[1] }));
      return reactExports.createElement(te, S({ ref: d10 }, a10), t10 && reactExports.createElement("rect", { className: "tl-binding-indicator", strokeWidth: this.bindingDistance }), reactExports.createElement("g", { opacity: n10 ? 0.3 : 1 }, reactExports.createElement("rect", { x: 0, y: 0, width: c10[0], height: c10[1], fill: "transparent", pointerEvents: "all" }), reactExports.createElement(_l, { stroke: "black", opacity: o10 || s10 ? 1 : 0, strokeLinecap: "round", pointerEvents: "stroke" }, g10)));
    }));
    l(this, "Indicator", ye.Indicator(({ shape: e10 }) => {
      let { id: t10, size: n10 } = e10, o10 = 2, s10 = Math.max(0, n10[0] - o10 / 2), a10 = Math.max(0, n10[1] - o10 / 2), i10 = [[[o10 / 2, o10 / 2], [s10, o10 / 2], s10 - o10 / 2], [[s10, o10 / 2], [s10, a10], a10 - o10 / 2], [[s10, a10], [o10 / 2, a10], s10 - o10 / 2], [[o10 / 2, a10], [o10 / 2, o10 / 2], a10 - o10 / 2]].map(([c10, u10], p10) => reactExports.createElement("line", { key: t10 + "_" + p10, x1: c10[0], y1: c10[1], x2: u10[0], y2: u10[1] }));
      return reactExports.createElement(_l, { strokeLinecap: "round", pointerEvents: "stroke" }, i10);
    }));
    l(this, "getBounds", (e10) => $t(e10, this.boundsCache));
    l(this, "shouldRender", (e10, t10) => t10.size !== e10.size || t10.style !== e10.style);
  }
}, _l = H2("g", { strokeWidth: "calc(1.5px * var(--tl-scale))", strokeDasharray: "calc(1px * var(--tl-scale)), calc(3px * var(--tl-scale))" });
var ri = class extends ye {
  constructor() {
    super(...arguments);
    l(this, "type", "image");
    l(this, "canBind", true);
    l(this, "canClone", true);
    l(this, "isAspectRatioLocked", true);
    l(this, "showCloneHandles", false);
    l(this, "getShape", (e10) => C$2.deepMerge({ id: "image", type: "image", name: "Image", parentId: "page", childIndex: 1, point: [0, 0], size: [1, 1], rotation: 0, style: x(S({}, ct), { isFilled: true }), assetId: "assetId" }, e10));
    l(this, "Component", ye.Component(({ shape: e10, asset: t10 = { src: "" }, isBinding: n10, isGhost: o10, meta: s10, events: a10, onShapeChange: d10 }, i10) => {
      let { size: c10, style: u10 } = e10, { bindingDistance: p10 } = this, m10 = reactExports.useRef(null), h10 = reactExports.useRef(null);
      return reactExports.useLayoutEffect(() => {
        let g10 = h10.current;
        if (!g10) return;
        let [f10, T10] = c10;
        g10.style.width = `${f10}px`, g10.style.height = `${T10}px`;
      }, [c10]), reactExports.createElement(Xs, S({ ref: i10 }, a10), n10 && reactExports.createElement("div", { className: "tl-binding-indicator", style: { position: "absolute", top: `calc(${-p10}px * var(--tl-zoom))`, left: `calc(${-p10}px * var(--tl-zoom))`, width: `calc(100% + ${p10 * 2}px * var(--tl-zoom))`, height: `calc(100% + ${p10 * 2}px * var(--tl-zoom))`, backgroundColor: "var(--tl-selectFill)" } }), reactExports.createElement(Lde, { ref: h10, isDarkMode: s10.isDarkMode, isFilled: u10.isFilled, isGhost: o10 }, reactExports.createElement(Hde, { id: e10.id + "_image", ref: m10, src: t10.src, alt: "tl_image_asset", draggable: false })));
    }));
    l(this, "Indicator", ye.Indicator(({ shape: e10 }) => {
      let { size: [t10, n10] } = e10;
      return reactExports.createElement("rect", { x: 0, y: 0, rx: 2, ry: 2, width: Math.max(1, t10), height: Math.max(1, n10) });
    }));
    l(this, "getBounds", (e10) => $t(e10, this.boundsCache));
    l(this, "shouldRender", (e10, t10) => t10.size !== e10.size || t10.style !== e10.style);
    l(this, "transform", Nn);
    l(this, "transformSingle", Wn);
    l(this, "getSvgElement", (e10) => {
      let t10 = this.getBounds(e10), n10 = document.createElementNS("http://www.w3.org/2000/svg", "image");
      return n10.setAttribute("width", `${t10.width}`), n10.setAttribute("height", `${t10.height}`), n10.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), n10;
    });
  }
}, Lde = re("div", { pointerEvents: "all", position: "relative", fontFamily: "sans-serif", fontSize: "2em", height: "100%", width: "100%", borderRadius: "3px", perspective: "800px", overflow: "hidden", p: { userSelect: "none" }, img: { userSelect: "none" }, variants: { isGhost: { false: { opacity: 1 }, true: { transition: "opacity .2s", opacity: 0.3 } }, isFilled: { true: {}, false: {} }, isDarkMode: { true: {}, false: {} } }, compoundVariants: [{ isFilled: true, isDarkMode: true, css: { boxShadow: "2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)" } }, { isFilled: true, isDarkMode: false, css: { boxShadow: "2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)" } }] }), Hde = re("img", { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", maxWidth: "100%", minWidth: "100%", pointerEvents: "none", objectFit: "cover", userSelect: "none", borderRadius: 2 });
function Xl({ strokeWidth: r10, size: e10 }) {
  return reactExports.createElement("rect", { className: "tl-binding-indicator", x: r10, y: r10, width: Math.max(0, e10[0] - r10 / 2), height: Math.max(0, e10[1] - r10 / 2), strokeWidth: 16 * 2 });
}
var ql = reactExports.memo(function({ id: e10, style: t10, size: n10, isSelected: o10, isDarkMode: s10 }) {
  let { stroke: a10, strokeWidth: d10, fill: i10 } = be(t10, s10), c10 = 1 + d10 * 1.618, u10 = Math.max(0, n10[0] - c10 / 2), p10 = Math.max(0, n10[1] - c10 / 2), h10 = [[[c10 / 2, c10 / 2], [u10, c10 / 2], u10 - c10 / 2], [[u10, c10 / 2], [u10, p10], p10 - c10 / 2], [[u10, p10], [c10 / 2, p10], u10 - c10 / 2], [[c10 / 2, p10], [c10 / 2, c10 / 2], p10 - c10 / 2]].map(([g10, f10, T10], w10) => {
    let { strokeDasharray: b10, strokeDashoffset: y10 } = C$2.getPerfectDashProps(T10, d10 * 1.618, t10.dash);
    return reactExports.createElement("line", { key: e10 + "_" + w10, x1: g10[0], y1: g10[1], x2: f10[0], y2: f10[1], strokeDasharray: b10, strokeDashoffset: y10 });
  });
  return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("rect", { className: o10 || t10.isFilled ? "tl-fill-hitarea" : "tl-stroke-hitarea", x: c10 / 2, y: c10 / 2, width: u10, height: p10, strokeWidth: 16 }), t10.isFilled && reactExports.createElement("rect", { x: c10 / 2, y: c10 / 2, width: u10, height: p10, fill: i10, pointerEvents: "none" }), reactExports.createElement("g", { pointerEvents: "none", stroke: a10, strokeWidth: c10, strokeLinecap: "round" }, h10));
});
function jde(r10, e10, t10) {
  let n10 = be(e10), o10 = C$2.rng(r10), s10 = n10.strokeWidth, a10 = Math.max(0, t10[0]), d10 = Math.max(0, t10[1]), i10 = Array.from(Array(4)).map(() => [o10() * s10 * 0.75, o10() * s10 * 0.75]), c10 = p$4.add([s10 / 2, s10 / 2], i10[0]), u10 = p$4.add([a10 - s10 / 2, s10 / 2], i10[1]), p10 = p$4.add([a10 - s10 / 2, d10 - s10 / 2], i10[2]), m10 = p$4.add([s10 / 2, d10 - s10 / 2], i10[3]), h10 = Math.round(Math.abs(o10() * 2 * 4)), g10 = Math.min(a10 / 4, s10 * 2), f10 = Math.min(d10 / 4, s10 * 2), T10 = Math.max(8, Math.floor(a10 / 16)), w10 = Math.max(8, Math.floor(d10 / 16)), b10 = C$2.rotateArray([p$4.pointsBetween(p$4.add(c10, [g10, 0]), p$4.sub(u10, [g10, 0]), T10), p$4.pointsBetween(p$4.add(u10, [0, f10]), p$4.sub(p10, [0, f10]), w10), p$4.pointsBetween(p$4.sub(p10, [g10, 0]), p$4.add(m10, [g10, 0]), T10), p$4.pointsBetween(p$4.sub(m10, [0, f10]), p$4.add(c10, [0, f10]), w10)], h10);
  return { points: [...b10.flat(), ...b10[0]].slice(5, Math.floor((h10 % 2 === 0 ? T10 : w10) / -2) + 3) };
}
function Jl(r10, e10, t10) {
  let { points: n10 } = jde(r10, e10, t10), { strokeWidth: o10 } = be(e10);
  return { points: n10, options: { size: o10, thinning: 0.65, streamline: 0.3, smoothing: 1, simulatePressure: false, last: true } };
}
function Ql(r10, e10, t10) {
  let { points: n10, options: o10 } = Jl(r10, e10, t10), s10 = _e$1(n10, o10);
  return C$2.getSvgPathFromStroke(s10);
}
function Kr(r10, e10, t10) {
  let { points: n10, options: o10 } = Jl(r10, e10, t10);
  return C$2.getSvgPathFromStrokePoints(me$1(n10, o10));
}
var ed = reactExports.memo(function({ id: e10, style: t10, size: n10, isSelected: o10, isDarkMode: s10 }) {
  let { isFilled: a10 } = t10, { stroke: d10, strokeWidth: i10, fill: c10 } = be(t10, s10), u10 = Ql(e10, t10, n10), p10 = Kr(e10, t10, n10);
  return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("path", { className: t10.isFilled || o10 ? "tl-fill-hitarea" : "tl-stroke-hitarea", d: p10 }), a10 && reactExports.createElement("path", { d: p10, fill: c10, pointerEvents: "none" }), reactExports.createElement("path", { d: u10, fill: d10, stroke: d10, strokeWidth: i10, pointerEvents: "none" }));
});
var si = class extends ye {
  constructor() {
    super(...arguments);
    l(this, "type", "rectangle");
    l(this, "canBind", true);
    l(this, "canClone", true);
    l(this, "canEdit", true);
    l(this, "getShape", (e10) => C$2.deepMerge({ id: "id", type: "rectangle", name: "Rectangle", parentId: "page", childIndex: 1, point: [0, 0], size: [1, 1], rotation: 0, style: ct, label: "", labelPoint: [0.5, 0.5] }, e10));
    l(this, "Component", ye.Component(({ shape: e10, isEditing: t10, isBinding: n10, isSelected: o10, isGhost: s10, meta: a10, bounds: d10, events: i10, onShapeBlur: c10, onShapeChange: u10 }, p10) => {
      let { id: m10, size: h10, style: g10, label: f10 = "", labelPoint: T10 = yo } = e10, w10 = kt(g10), b10 = be(g10, a10.isDarkMode), y10 = g10.dash === "draw" ? ed : ql, R10 = reactExports.useCallback((U10) => u10 == null ? void 0 : u10({ id: m10, label: U10 }), [u10]);
      return reactExports.createElement($de, S({ ref: p10 }, i10), reactExports.createElement($n, { isEditing: t10, onChange: R10, onBlur: c10, font: w10, text: f10, color: b10.stroke, offsetX: (T10[0] - 0.5) * d10.width, offsetY: (T10[1] - 0.5) * d10.height }), reactExports.createElement(te, { id: e10.id + "_svg", opacity: s10 ? 0.3 : 1 }, n10 && reactExports.createElement(Xl, { strokeWidth: b10.strokeWidth, size: h10 }), reactExports.createElement(y10, { id: m10, style: g10, size: h10, isSelected: o10, isDarkMode: a10.isDarkMode })));
    }));
    l(this, "Indicator", ye.Indicator(({ shape: e10 }) => {
      let { id: t10, style: n10, size: o10 } = e10, a10 = be(n10, false).strokeWidth;
      return n10.dash === "draw" ? reactExports.createElement("path", { d: Kr(t10, n10, o10) }) : reactExports.createElement("rect", { x: a10, y: a10, rx: 1, ry: 1, width: Math.max(1, o10[0] - a10 * 2), height: Math.max(1, o10[1] - a10 * 2) });
    }));
    l(this, "getBounds", (e10) => $t(e10, this.boundsCache));
    l(this, "shouldRender", (e10, t10) => t10.size !== e10.size || t10.style !== e10.style || t10.label !== e10.label);
    l(this, "transform", Nn);
    l(this, "transformSingle", Wn);
  }
}, $de = H2("div", { width: "100%", height: "100%" });
var ai = class extends ye {
  constructor() {
    super(...arguments);
    l(this, "type", "sticky");
    l(this, "canBind", true);
    l(this, "canEdit", true);
    l(this, "canClone", true);
    l(this, "hideResizeHandles", true);
    l(this, "showCloneHandles", true);
    l(this, "getShape", (e10) => C$2.deepMerge({ id: "id", type: "sticky", name: "Sticky", parentId: "page", childIndex: 1, point: [0, 0], size: [200, 200], text: "", rotation: 0, style: vo }, e10));
    l(this, "Component", ye.Component(({ shape: e10, meta: t10, events: n10, isGhost: o10, isBinding: s10, isEditing: a10, onShapeBlur: d10, onShapeChange: i10 }, c10) => {
      let u10 = wl(e10.style), { color: p10, fill: m10 } = _s(e10.style, t10.isDarkMode), h10 = reactExports.useRef(null), g10 = reactExports.useRef(null), f10 = reactExports.useRef(null), T10 = reactExports.useRef(false), w10 = reactExports.useCallback((I10) => {
        I10.stopPropagation();
      }, []), b10 = reactExports.useCallback((I10) => {
        i10 == null || i10({ id: e10.id, type: e10.type, text: v.normalizeText(I10) });
      }, [e10.id]), y10 = reactExports.useCallback((I10) => {
        b10(I10.currentTarget.value);
      }, [i10, b10]), R10 = reactExports.useCallback((I10) => {
        if (I10.key === "Escape") {
          I10.preventDefault(), I10.stopPropagation(), d10 == null || d10();
          return;
        }
        if (I10.key === "Tab" && e10.text.length === 0) {
          I10.preventDefault();
          return;
        }
        if (!(I10.key === "Meta" || I10.metaKey)) I10.stopPropagation();
        else if (I10.key === "z" && I10.metaKey) {
          I10.shiftKey ? document.execCommand("redo", false) : document.execCommand("undo", false), I10.stopPropagation(), I10.preventDefault();
          return;
        }
        (I10.metaKey || I10.ctrlKey) && I10.key === "=" && I10.preventDefault(), I10.key === "Tab" && (I10.preventDefault(), I10.shiftKey ? st.unindent(I10.currentTarget) : st.indent(I10.currentTarget), i10 == null || i10(x(S({}, e10), { text: v.normalizeText(I10.currentTarget.value) })));
      }, [e10, i10]), U10 = reactExports.useCallback((I10) => {
        I10.currentTarget.setSelectionRange(0, 0), d10 == null || d10();
      }, []), L10 = reactExports.useCallback((I10) => {
        !a10 || !T10.current || I10.currentTarget.select();
      }, [a10]);
      reactExports.useEffect(() => {
        if (a10) {
          T10.current = true;
          let I10 = g10.current;
          I10.focus(), I10.select();
        }
      }, [a10]), reactExports.useEffect(() => {
        let I10 = f10.current, { size: q10 } = e10, { offsetHeight: de2 } = I10, le2 = ii - gn * 2, Ae = q10[1] - gn * 2;
        if (de2 === Ae) return;
        if (de2 > le2) {
          i10 == null || i10({ id: e10.id, size: [q10[0], de2 + gn * 2] });
          return;
        }
        if (de2 < le2 && q10[1] > ii) {
          i10 == null || i10({ id: e10.id, size: [q10[0], ii] });
          return;
        }
        let Ce2 = g10.current;
        Ce2 == null || Ce2.focus();
      }, [e10.text, e10.size[1], e10.style]);
      let k10 = { font: u10, color: p10, textShadow: t10.isDarkMode ? "0.5px 0.5px 2px rgba(255, 255, 255,.25)" : "0.5px 0.5px 2px rgba(255, 255, 255,.5)" };
      return reactExports.createElement(Xs, S({ ref: c10 }, n10), reactExports.createElement(Kde, { ref: h10, isDarkMode: t10.isDarkMode, isGhost: o10, style: S({ backgroundColor: m10 }, k10) }, s10 && reactExports.createElement("div", { className: "tl-binding-indicator", style: { position: "absolute", top: -this.bindingDistance, left: -this.bindingDistance, width: `calc(100% + ${this.bindingDistance * 2}px)`, height: `calc(100% + ${this.bindingDistance * 2}px)`, backgroundColor: "var(--tl-selectFill)" } }), reactExports.createElement(_de, { ref: f10, isEditing: a10, alignment: e10.style.textAlign }, e10.text, ""), a10 && reactExports.createElement(Yde, { ref: g10, onPointerDown: w10, value: e10.text, onChange: y10, onKeyDown: R10, onFocus: L10, onBlur: U10, tabIndex: -1, autoComplete: "false", autoCapitalize: "false", autoCorrect: "false", autoSave: "false", autoFocus: true, spellCheck: true, alignment: e10.style.textAlign, onContextMenu: ft, onCopy: ft, onPaste: ft, onCut: ft })));
    }));
    l(this, "Indicator", ye.Indicator(({ shape: e10 }) => {
      let { size: [t10, n10] } = e10;
      return reactExports.createElement("rect", { x: 0, y: 0, rx: 3, ry: 3, width: Math.max(1, t10), height: Math.max(1, n10) });
    }));
    l(this, "getBounds", (e10) => $t(e10, this.boundsCache));
    l(this, "shouldRender", (e10, t10) => t10.size !== e10.size || t10.style !== e10.style || t10.text !== e10.text);
    l(this, "transform", (e10, t10, { scaleX: n10, scaleY: o10, transformOrigin: s10 }) => ({ point: e$3.toFixed([t10.minX + (t10.width - e10.size[0]) * (n10 < 0 ? 1 - s10[0] : s10[0]), t10.minY + (t10.height - e10.size[1]) * (o10 < 0 ? 1 - s10[1] : s10[1])]) }));
    l(this, "transformSingle", (e10) => e10);
    l(this, "getSvgElement", (e10, t10) => {
      var p10, m10;
      let n10 = this.getBounds(e10), o10 = _s(e10.style, t10), s10 = Ks(e10.style.size) * ((p10 = e10.style.scale) != null ? p10 : 1), a10 = dn(e10.style.font).slice(1, -1), d10 = (m10 = e10.style.textAlign) != null ? m10 : "start", i10 = Vn(e10.text, s10, a10, d10, n10.width - gn * 2, true);
      i10.setAttribute("fill", o10.color), i10.setAttribute("transform", `translate(${gn}, ${gn})`);
      let c10 = document.createElementNS("http://www.w3.org/2000/svg", "g"), u10 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      return u10.setAttribute("width", n10.width + ""), u10.setAttribute("height", n10.height + ""), u10.setAttribute("fill", o10.fill), u10.setAttribute("rx", "3"), u10.setAttribute("ry", "3"), c10.appendChild(u10), c10.appendChild(i10), c10;
    });
  }
}, gn = 16, ii = 200, Kde = H2("div", { pointerEvents: "all", position: "relative", backgroundColor: "rgba(255, 220, 100)", fontFamily: "sans-serif", height: "100%", width: "100%", padding: gn + "px", borderRadius: "3px", perspective: "800px", variants: { isGhost: { false: { opacity: 1 }, true: { transition: "opacity .2s", opacity: 0.3 } }, isDarkMode: { true: { boxShadow: "2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)" }, false: { boxShadow: "2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)" } } } }), td = { whiteSpace: "pre-wrap", overflowWrap: "break-word", letterSpacing: Vt }, _de = H2("div", S({ position: "absolute", top: gn, left: gn, width: `calc(100% - ${gn * 2}px)`, height: "fit-content", font: "inherit", pointerEvents: "none", userSelect: "none", variants: { isEditing: { true: { opacity: 1 }, false: { opacity: 1 } }, alignment: { ["start"]: { textAlign: "left" }, ["middle"]: { textAlign: "center" }, ["end"]: { textAlign: "right" }, ["justify"]: { textAlign: "justify" } } } }, td)), Yde = H2("textarea", x(S({ width: "100%", height: "100%", border: "none", overflow: "hidden", background: "none", outline: "none", textAlign: "left", font: "inherit", padding: 0, color: "transparent", verticalAlign: "top", resize: "none", caretColor: "black" }, td), { variants: { alignment: { ["start"]: { textAlign: "left" }, ["middle"]: { textAlign: "center" }, ["end"]: { textAlign: "right" }, ["justify"]: { textAlign: "justify" } } }, "&:focus": { outline: "none", border: "none" } }));
var di = class extends ye {
  constructor() {
    super(...arguments);
    l(this, "type", "text");
    l(this, "isAspectRatioLocked", true);
    l(this, "canEdit", true);
    l(this, "canBind", true);
    l(this, "canClone", true);
    l(this, "bindingDistance", 16 / 2);
    l(this, "getShape", (e10) => C$2.deepMerge({ id: "id", type: "text", name: "Text", parentId: "page", childIndex: 1, point: [0, 0], rotation: 0, text: " ", style: vo }, e10));
    l(this, "texts", /* @__PURE__ */ new Map());
    l(this, "Component", ye.Component(({ shape: e10, isBinding: t10, isGhost: n10, isEditing: o10, onShapeBlur: s10, onShapeChange: a10, meta: d10, events: i10 }, c10) => {
      let { text: u10, style: p10 } = e10, m10 = be(p10, d10.isDarkMode), h10 = kt(e10.style), g10 = reactExports.useRef(null), f10 = reactExports.useRef(false), T10 = reactExports.useRef(u10);
      reactExports.useLayoutEffect(() => {
        if (u10 !== T10.current) {
          let k10 = [0, 0];
          this.texts.set(e10.id, u10);
          let I10 = this.getBounds(e10), q10 = this.getBounds(e10);
          switch (e10.style.textAlign) {
            case "start":
              break;
            case "middle": {
              k10 = e$3.div([q10.width - I10.width, 0], 2);
              break;
            }
            case "end": {
              k10 = [q10.width - I10.width, 0];
              break;
            }
          }
          T10.current = u10, a10 == null || a10(x(S({}, e10), { id: e10.id, point: e$3.sub(e10.point, k10), text: u10 }));
        }
      }, [u10]);
      let w10 = reactExports.useCallback((k10) => {
        let I10 = [0, 0], q10 = v.normalizeText(k10.currentTarget.value), de2 = this.getBounds(e10);
        this.texts.set(e10.id, q10);
        let le2 = this.getBounds(x(S({}, e10), { text: q10 }));
        switch (e10.style.textAlign) {
          case "start":
            break;
          case "middle": {
            I10 = e$3.div([le2.width - de2.width, 0], 2);
            break;
          }
          case "end": {
            I10 = [le2.width - de2.width, 0];
            break;
          }
        }
        T10.current = q10, a10 == null || a10(x(S({}, e10), { id: e10.id, point: e$3.sub(e10.point, I10), text: q10 }));
      }, [e10.id, e10.point]), b10 = reactExports.useCallback((k10) => {
        if (k10.key === "Escape") {
          k10.preventDefault(), k10.stopPropagation(), s10 == null || s10();
          return;
        }
        if (k10.key === "Tab" && e10.text.length === 0) {
          k10.preventDefault();
          return;
        }
        if (k10.key === "Enter" && (k10.metaKey || k10.ctrlKey)) {
          k10.preventDefault(), k10.stopPropagation(), g10.current.blur();
          return;
        }
        if (!(k10.key === "Meta" || k10.metaKey)) k10.stopPropagation();
        else if (k10.key === "z" && k10.metaKey) {
          k10.shiftKey ? document.execCommand("redo", false) : document.execCommand("undo", false), k10.stopPropagation(), k10.preventDefault();
          return;
        }
        (k10.metaKey || k10.ctrlKey) && k10.key === "=" && k10.preventDefault(), k10.key === "Tab" && (k10.preventDefault(), k10.shiftKey ? st.unindent(k10.currentTarget) : st.indent(k10.currentTarget), a10 == null || a10(x(S({}, e10), { text: v.normalizeText(k10.currentTarget.value) })));
      }, [e10, a10]), y10 = reactExports.useCallback((k10) => {
        k10.currentTarget.setSelectionRange(0, 0), s10 == null || s10();
      }, []), R10 = reactExports.useCallback((k10) => {
        !o10 || !f10.current || document.activeElement === k10.currentTarget && k10.currentTarget.select();
      }, [o10]), U10 = reactExports.useCallback((k10) => {
        o10 && k10.stopPropagation();
      }, [o10]), L10 = reactExports.useRef(o10);
      return reactExports.useEffect(() => {
        o10 ? (L10.current = true, this.texts.set(e10.id, u10), requestAnimationFrame(() => {
          f10.current = true;
          let k10 = g10.current;
          k10 && (k10.focus(), k10.select());
        })) : L10.current && (L10.current = false, s10 == null || s10());
      }, [o10]), reactExports.createElement(Xs, S({ ref: c10 }, i10), reactExports.createElement(qde, { isGhost: n10, isEditing: o10, onPointerDown: U10 }, reactExports.createElement(Jde, { style: { font: h10, color: m10.stroke, textAlign: ml(p10.textAlign) } }, t10 && reactExports.createElement("div", { className: "tl-binding-indicator", style: { position: "absolute", top: -this.bindingDistance, left: -this.bindingDistance, width: `calc(100% + ${this.bindingDistance * 2}px)`, height: `calc(100% + ${this.bindingDistance * 2}px)`, backgroundColor: "var(--tl-selectFill)" } }), o10 ? reactExports.createElement(Qde, { ref: g10, style: { font: h10, color: m10.stroke }, name: "text", tabIndex: -1, autoComplete: "false", autoCapitalize: "false", autoCorrect: "false", autoSave: "false", autoFocus: true, placeholder: "", spellCheck: "true", wrap: "off", dir: "auto", datatype: "wysiwyg", defaultValue: u10, color: m10.stroke, onFocus: R10, onChange: w10, onKeyDown: b10, onBlur: y10, onPointerDown: U10, onContextMenu: ft, onCopy: ft, onPaste: ft, onCut: ft }) : u10, "")));
    }));
    l(this, "Indicator", ye.Indicator(({ shape: e10 }) => {
      let { width: t10, height: n10 } = this.getBounds(e10);
      return reactExports.createElement("rect", { x: 0, y: 0, width: t10, height: n10 });
    }));
    l(this, "getBounds", (e10) => {
      let t10 = C$2.getFromCache(this.boundsCache, e10, () => {
        var s10;
        if (!Yn) return { minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10 };
        Yn.parentNode || document.body.appendChild(Yn), Yn.style.font = kt(e10.style), Yn.textContent = (s10 = this.texts.get(e10.id)) != null ? s10 : e10.text;
        let n10 = Yn.offsetWidth || 1, o10 = Yn.offsetHeight || 1;
        return { minX: 0, maxX: n10, minY: 0, maxY: o10, width: n10, height: o10 };
      });
      return C$2.translateBounds(t10, e10.point);
    });
    l(this, "shouldRender", (e10, t10) => t10.text !== e10.text || t10.style.scale !== e10.style.scale || t10.style !== e10.style);
    l(this, "transform", (e10, t10, { initialShape: n10, scaleX: o10, scaleY: s10 }) => {
      let { rotation: a10 = 0, style: { scale: d10 = 1 } } = n10, i10 = d10 * Math.abs(Math.min(o10, s10));
      return { point: [t10.minX, t10.minY], rotation: o10 < 0 && s10 >= 0 || s10 < 0 && o10 >= 0 ? -(a10 || 0) : a10, style: x(S({}, n10.style), { scale: i10 }) };
    });
    l(this, "transformSingle", (e10, t10, { initialShape: n10, scaleX: o10, scaleY: s10 }) => {
      let { style: { scale: a10 = 1 } } = n10;
      return { point: e$3.toFixed([t10.minX, t10.minY]), style: x(S({}, n10.style), { scale: a10 * Math.max(Math.abs(s10), Math.abs(o10)) }) };
    });
    l(this, "onDoubleClickBoundsHandle", (e10) => {
      let t10 = this.getCenter(e10), n10 = this.getCenter(x(S({}, e10), { style: x(S({}, e10.style), { scale: 1 }) }));
      return { style: x(S({}, e10.style), { scale: 1 }), point: e$3.toFixed(e$3.add(e10.point, e$3.sub(t10, n10))) };
    });
    l(this, "getSvgElement", (e10, t10) => {
      var c10, u10;
      let n10 = this.getBounds(e10), o10 = be(e10.style, t10), s10 = ro(e10.style.size, e10.style.font) * ((c10 = e10.style.scale) != null ? c10 : 1), a10 = dn(e10.style.font).slice(1, -1), d10 = (u10 = e10.style.textAlign) != null ? u10 : "middle", i10 = Vn(e10.text, s10, a10, d10, n10.width, false);
      return i10.setAttribute("fill", o10.stroke), i10;
    });
  }
}, Yn;
function Xde() {
  var e10;
  (e10 = document.getElementById("__textMeasure")) == null || e10.remove();
  let r10 = document.createElement("pre");
  return r10.id = "__textMeasure", Object.assign(r10.style, { whiteSpace: "pre", width: "auto", border: "1px solid transparent", padding: "4px", margin: "0px", letterSpacing: Vt, opacity: "0", position: "absolute", top: "-500px", left: "0px", zIndex: "9999", pointerEvents: "none", userSelect: "none", alignmentBaseline: "mathematical", dominantBaseline: "mathematical" }), r10.tabIndex = -1, document.body.appendChild(r10), r10;
}
typeof window != "undefined" && (Yn = Xde());
var qde = H2("div", { width: "100%", height: "100%", variants: { isGhost: { false: { opacity: 1 }, true: { transition: "opacity .2s", opacity: 0.3 } }, isEditing: { false: { pointerEvents: "all", userSelect: "all" }, true: { pointerEvents: "none", userSelect: "none" } } } }), nd = { whiteSpace: "pre-wrap", overflowWrap: "break-word" }, Jde = H2("div", S({ position: "absolute", width: "100%", height: "100%", padding: "4px", zIndex: 1, minHeight: 1, minWidth: 1, lineHeight: 1, letterSpacing: Vt, outline: 0, fontWeight: "500", backfaceVisibility: "hidden", userSelect: "none", pointerEvents: "none", WebkitUserSelect: "none", WebkitTouchCallout: "none", isEditing: { false: {}, true: { pointerEvents: "all", background: "$boundsBg", userSelect: "text", WebkitUserSelect: "text" } } }, nd)), Qde = H2("textarea", x(S({ position: "absolute", top: 0, left: 0, zIndex: 1, width: "100%", height: "100%", border: "none", padding: "4px", resize: "none", textAlign: "inherit", minHeight: "inherit", minWidth: "inherit", lineHeight: "inherit", letterSpacing: "inherit", outline: 0, fontWeight: "inherit", overflow: "hidden", backfaceVisibility: "hidden", display: "inline-block", pointerEvents: "all", background: "$boundsBg", userSelect: "text", WebkitUserSelect: "text" }, nd), { "&:focus": { outline: "none", border: "none" } }));
function tn(r10, e10 = 0, t10 = 0) {
  let [n10, o10] = r10, s10 = [[n10 / 2, 0], [n10, o10], [0, o10]];
  return e10 && (s10 = Tl(s10, e10)), t10 && (s10 = s10.map((a10) => p$4.rotWith(a10, [n10 / 2, o10 / 2], t10))), s10;
}
function ci(r10) {
  let [e10, t10] = r10, n10 = [[e10 / 2, 0], [e10, t10], [0, t10]];
  return [(n10[0][0] + n10[1][0] + n10[2][0]) / 3, (n10[0][1] + n10[1][1] + n10[2][1]) / 3];
}
function nce(r10, e10, t10) {
  let [n10, o10] = e10, s10 = C$2.rng(r10), a10 = Array.from(Array(3)).map(() => [s10() * t10 * 0.75, s10() * t10 * 0.75]), d10 = [p$4.add([n10 / 2, 0], a10[0]), p$4.add([n10, o10], a10[1]), p$4.add([0, o10], a10[2])], i10 = Math.round(Math.abs(s10() * 2 * 3)), c10 = C$2.rotateArray([p$4.pointsBetween(d10[0], d10[1], 32), p$4.pointsBetween(d10[1], d10[2], 32), p$4.pointsBetween(d10[2], d10[0], 32)], i10);
  return { points: [...c10.flat(), ...c10[0]] };
}
function od(r10, e10, t10) {
  let { strokeWidth: n10 } = be(t10), { points: o10 } = nce(r10, e10, n10);
  return { points: o10, options: { size: n10, thinning: 0.65, streamline: 0.3, smoothing: 1, simulatePressure: false, last: true } };
}
function rd(r10, e10, t10) {
  let { points: n10, options: o10 } = od(r10, e10, t10), s10 = _e$1(n10, o10);
  return C$2.getSvgPathFromStroke(s10);
}
function sd(r10, e10, t10) {
  let { points: n10, options: o10 } = od(r10, e10, t10);
  return C$2.getSvgPathFromStrokePoints(me$1(n10, o10));
}
var ad = reactExports.memo(function({ id: e10, size: t10, style: n10, isSelected: o10, isDarkMode: s10 }) {
  let { stroke: a10, strokeWidth: d10, fill: i10 } = be(n10, s10), c10 = 1 + d10 * 1.618, u10 = tn(t10), m10 = C$2.pointsToLineSegments(u10, true).map(([g10, f10], T10) => {
    let { strokeDasharray: w10, strokeDashoffset: b10 } = C$2.getPerfectDashProps(p$4.dist(g10, f10), d10 * 1.618, n10.dash);
    return reactExports.createElement("line", { key: e10 + "_" + T10, x1: g10[0], y1: g10[1], x2: f10[0], y2: f10[1], stroke: a10, strokeWidth: c10, strokeLinecap: "round", strokeDasharray: w10, strokeDashoffset: b10 });
  }), h10 = u10.join();
  return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("polygon", { className: n10.isFilled || o10 ? "tl-fill-hitarea" : "tl-stroke-hitarea", points: h10 }), n10.isFilled && reactExports.createElement("polygon", { fill: i10, points: h10, pointerEvents: "none" }), reactExports.createElement("g", { pointerEvents: "stroke" }, m10));
});
var ld = reactExports.memo(function({ id: e10, size: t10, style: n10, isSelected: o10, isDarkMode: s10 }) {
  let { stroke: a10, strokeWidth: d10, fill: i10 } = be(n10, s10), c10 = rd(e10, t10, n10), u10 = sd(e10, t10, n10);
  return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("path", { className: n10.isFilled || o10 ? "tl-fill-hitarea" : "tl-stroke-hitarea", d: u10 }), n10.isFilled && reactExports.createElement("path", { d: u10, fill: i10, pointerEvents: "none" }), reactExports.createElement("path", { d: c10, fill: a10, stroke: a10, strokeWidth: d10, pointerEvents: "none" }));
});
function cd({ size: r10 }) {
  let e10 = tn(r10).join();
  return reactExports.createElement("polygon", { className: "tl-binding-indicator", points: e10, strokeWidth: 16 * 2 });
}
var pi = class extends ye {
  constructor() {
    super(...arguments);
    l(this, "type", "triangle");
    l(this, "canBind", true);
    l(this, "canClone", true);
    l(this, "canEdit", true);
    l(this, "getShape", (e10) => C$2.deepMerge({ id: "id", type: "triangle", name: "Triangle", parentId: "page", childIndex: 1, point: [0, 0], size: [1, 1], rotation: 0, style: ct, label: "", labelPoint: [0.5, 0.5] }, e10));
    l(this, "Component", ye.Component(({ shape: e10, bounds: t10, isBinding: n10, isEditing: o10, isSelected: s10, isGhost: a10, meta: d10, events: i10, onShapeChange: c10, onShapeBlur: u10 }, p10) => {
      let { id: m10, label: h10 = "", size: g10, style: f10, labelPoint: T10 = yo } = e10, w10 = kt(f10), b10 = be(f10, d10.isDarkMode), y10 = f10.dash === "draw" ? ld : ad, R10 = reactExports.useCallback((L10) => c10 == null ? void 0 : c10({ id: m10, label: L10 }), [c10]), U10 = reactExports.useMemo(() => {
        let L10 = p$4.div(g10, 2);
        return (ci(g10)[1] - L10[1]) * 0.72;
      }, [g10]);
      return reactExports.createElement(lce, S({ ref: p10 }, i10), reactExports.createElement($n, { font: w10, text: h10, color: b10.stroke, offsetX: (T10[0] - 0.5) * t10.width, offsetY: U10 + (T10[1] - 0.5) * t10.height, isEditing: o10, onChange: R10, onBlur: u10 }), reactExports.createElement(te, { id: e10.id + "_svg", opacity: a10 ? 0.3 : 1 }, n10 && reactExports.createElement(cd, { size: g10 }), reactExports.createElement(y10, { id: m10, style: f10, size: g10, isSelected: s10, isDarkMode: d10.isDarkMode })));
    }));
    l(this, "Indicator", ye.Indicator(({ shape: e10 }) => {
      let { size: t10 } = e10;
      return reactExports.createElement("polygon", { points: tn(t10).join() });
    }));
    l(this, "shouldRender", (e10, t10) => t10.size !== e10.size || t10.style !== e10.style || t10.label !== e10.label);
    l(this, "getBounds", (e10) => $t(e10, this.boundsCache));
    l(this, "getExpandedBounds", (e10) => C$2.getBoundsFromPoints(tn(e10.size, this.bindingDistance).map((t10) => p$4.add(t10, e10.point))));
    l(this, "hitTestLineSegment", (e10, t10, n10) => S$3(t10, n10, this.getPoints(e10)).didIntersect);
    l(this, "hitTestBounds", (e10, t10) => C$2.boundsContained(this.getBounds(e10), t10) || Se(t10, this.getPoints(e10)).length > 0);
    l(this, "getBindingPoint", (e10, t10, n10, o10, s10, a10) => {
      let d10 = this.getExpandedBounds(e10);
      if (!C$2.pointInBounds(n10, d10)) return;
      let i10 = tn(e10.size).map((b10) => p$4.add(b10, e10.point)), c10 = tn(e10.size, this.bindingDistance).map((b10) => p$4.add(b10, e10.point)), u10 = C$2.pointsToLineSegments(i10, true).map(([b10, y10]) => p$4.distanceToLineSegment(b10, y10, n10)).sort((b10, y10) => b10 - y10)[0];
      if (!(C$2.pointInPolygon(n10, c10) || u10 < this.bindingDistance)) return;
      let p10 = C$2.pointsToLineSegments(c10.concat([c10[0]])).map((b10) => x$4(o10, s10, b10[0], b10[1])).filter((b10) => b10.didIntersect).flatMap((b10) => b10.points);
      if (!p10.length) return;
      let m10 = p$4.add(ci(e10.size), e10.point), h10 = p10.sort((b10, y10) => p$4.dist(y10, o10) - p$4.dist(b10, o10))[0], g10 = p$4.med(n10, h10), f10, T10;
      a10 ? (f10 = p$4.dist(n10, m10) < 16 / 2 ? m10 : n10, T10 = 0) : (p$4.distanceToLineSegment(n10, g10, m10) < 16 / 2 ? f10 = m10 : f10 = g10, C$2.pointInPolygon(n10, i10) ? T10 = this.bindingDistance : T10 = Math.max(this.bindingDistance, u10));
      let w10 = p$4.divV(p$4.sub(f10, [d10.minX, d10.minY]), [d10.width, d10.height]);
      return { point: p$4.clampV(w10, 0, 1), distance: T10 };
    });
    l(this, "transform", Nn);
    l(this, "transformSingle", Wn);
  }
  getPoints(e10) {
    let { rotation: t10 = 0, point: [n10, o10], size: [s10, a10] } = e10;
    return [[n10 + s10 / 2, o10], [n10, o10 + a10], [n10 + s10, o10 + a10]].map((d10) => p$4.rotWith(d10, this.getCenter(e10), t10));
  }
}, lce = H2("div", { width: "100%", height: "100%" });
var ui = class extends ye {
  constructor() {
    super(...arguments);
    l(this, "type", "video");
    l(this, "canBind", true);
    l(this, "canEdit", true);
    l(this, "canClone", true);
    l(this, "isAspectRatioLocked", true);
    l(this, "showCloneHandles", false);
    l(this, "isStateful", true);
    l(this, "getShape", (e10) => C$2.deepMerge({ id: "video", type: "video", name: "Video", parentId: "page", childIndex: 1, point: [0, 0], size: [1, 1], rotation: 0, style: ct, assetId: "assetId", isPlaying: true, currentTime: 0 }, e10));
    l(this, "Component", ye.Component(({ shape: e10, asset: t10 = { src: "" }, isBinding: n10, isEditing: o10, isGhost: s10, meta: a10, events: d10, onShapeChange: i10 }, c10) => {
      let u10 = reactExports.useRef(null), p10 = reactExports.useRef(null), { currentTime: m10 = 0, size: h10, isPlaying: g10, style: f10 } = e10;
      reactExports.useLayoutEffect(() => {
        let y10 = p10.current;
        if (!y10) return;
        let [R10, U10] = h10;
        y10.style.width = `${R10}px`, y10.style.height = `${U10}px`;
      }, [h10]), reactExports.useLayoutEffect(() => {
        let y10 = u10.current;
        !y10 || (g10 ? y10.play() : y10.pause());
      }, [g10]), reactExports.useLayoutEffect(() => {
        let y10 = u10.current;
        !y10 || m10 !== y10.currentTime && (y10.currentTime = m10);
      }, [m10]);
      let T10 = reactExports.useCallback(() => {
        i10 == null || i10({ id: e10.id, isPlaying: true });
      }, []), w10 = reactExports.useCallback(() => {
        i10 == null || i10({ id: e10.id, isPlaying: false });
      }, []), b10 = reactExports.useCallback(() => {
        let y10 = u10.current;
        !y10 || !o10 || i10 == null || i10({ id: e10.id, currentTime: y10.currentTime });
      }, [o10]);
      return reactExports.createElement(Xs, S({ ref: c10 }, d10), n10 && reactExports.createElement("div", { className: "tl-binding-indicator", style: { position: "absolute", top: -this.bindingDistance, left: -this.bindingDistance, width: `calc(100% + ${this.bindingDistance * 2}px)`, height: `calc(100% + ${this.bindingDistance * 2}px)`, backgroundColor: "var(--tl-selectFill)" } }), reactExports.createElement(pce, { ref: p10, isDarkMode: a10.isDarkMode, isGhost: s10, isFilled: f10.isFilled }, reactExports.createElement(uce, { ref: u10, id: e10.id + "_video", muted: true, loop: true, playsInline: true, disableRemotePlayback: true, disablePictureInPicture: true, controls: o10, autoPlay: g10, onPlay: T10, onPause: w10, onTimeUpdate: b10 }, reactExports.createElement("source", { src: t10.src }))));
    }));
    l(this, "Indicator", ye.Indicator(({ shape: e10 }) => {
      let { size: [t10, n10] } = e10;
      return reactExports.createElement("rect", { x: 0, y: 0, rx: 2, ry: 2, width: Math.max(1, t10), height: Math.max(1, n10) });
    }));
    l(this, "getBounds", (e10) => $t(e10, this.boundsCache));
    l(this, "shouldRender", (e10, t10) => t10.size !== e10.size || t10.style !== e10.style || t10.isPlaying !== e10.isPlaying);
    l(this, "getSvgElement", (e10) => {
      let t10 = this.getBounds(e10), n10 = document.createElementNS("http://www.w3.org/2000/svg", "image");
      return n10.setAttribute("width", `${t10.width}`), n10.setAttribute("height", `${t10.height}`), n10.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), n10;
    });
    l(this, "transform", Nn);
    l(this, "transformSingle", Wn);
  }
}, pce = re("div", { pointerEvents: "all", position: "relative", fontFamily: "sans-serif", fontSize: "2em", height: "100%", width: "100%", borderRadius: "3px", perspective: "800px", overflow: "hidden", p: { userSelect: "none" }, img: { userSelect: "none" }, variants: { isGhost: { false: { opacity: 1 }, true: { transition: "opacity .2s", opacity: 0.3 } }, isFilled: { true: {}, false: {} }, isDarkMode: { true: {}, false: {} } }, compoundVariants: [{ isFilled: true, isDarkMode: true, css: { boxShadow: "2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)" } }, { isFilled: true, isDarkMode: false, css: { boxShadow: "2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)" } }] }), uce = re("video", { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", maxWidth: "100%", minWidth: "100%", pointerEvents: "none", objectFit: "cover", userSelect: "none", borderRadius: 2 });
var hi = new si(), mi = new pi(), gi = new ni(), fi = new ei(), Ko = new Zs(), hce = new di(), mce = new oi(), Yr = new ai(), gce = new ri(), fce = new ui(), En = { ["rectangle"]: hi, ["triangle"]: mi, ["ellipse"]: gi, ["draw"]: fi, ["arrow"]: Ko, ["text"]: hce, ["group"]: mce, ["sticky"]: Yr, ["image"]: gce, ["video"]: fce }, ud = (r10) => typeof r10 == "string" ? En[r10] : En[r10.type];
var he = class {
  static getShapeUtil(e10) {
    return ud(e10);
  }
  static getSelectedShapes(e10, t10) {
    let n10 = he.getPage(e10, t10);
    return he.getSelectedIds(e10, t10).map((s10) => n10.shapes[s10]);
  }
  static screenToWorld(e10, t10) {
    let n10 = he.getPageState(e10, e10.appState.currentPageId).camera;
    return e$3.sub(e$3.div(t10, n10.zoom), n10.point);
  }
  static getCameraZoom(e10) {
    return C$2.clamp(e10, 0.1, 5);
  }
  static getPage(e10, t10) {
    return e10.document.pages[t10];
  }
  static getPageState(e10, t10) {
    return e10.document.pageStates[t10];
  }
  static getSelectedIds(e10, t10) {
    return he.getPageState(e10, t10).selectedIds;
  }
  static getShapes(e10, t10) {
    return Object.values(he.getPage(e10, t10).shapes);
  }
  static getCamera(e10, t10) {
    return he.getPageState(e10, t10).camera;
  }
  static getShape(e10, t10, n10) {
    return he.getPage(e10, n10).shapes[t10];
  }
  static getCenter(e10) {
    return he.getShapeUtil(e10).getCenter(e10);
  }
  static getBounds(e10) {
    return he.getShapeUtil(e10).getBounds(e10);
  }
  static getRotatedBounds(e10) {
    return he.getShapeUtil(e10).getRotatedBounds(e10);
  }
  static getSelectedBounds(e10) {
    return C$2.getCommonBounds(he.getSelectedShapes(e10, e10.appState.currentPageId).map((t10) => he.getShapeUtil(t10).getBounds(t10)));
  }
  static getParentId(e10, t10, n10) {
    return he.getShape(e10, t10, n10).parentId;
  }
  static getDocumentBranch(e10, t10, n10) {
    let o10 = he.getShape(e10, t10, n10);
    return o10.children === void 0 ? [t10] : [t10, ...o10.children.flatMap((s10) => he.getDocumentBranch(e10, s10, n10))];
  }
  static getSelectedBranchSnapshot(e10, t10, n10) {
    let o10 = he.getPage(e10, t10), s10 = he.getSelectedIds(e10, t10).flatMap((a10) => he.getDocumentBranch(e10, a10, t10).map((d10) => o10.shapes[d10])).filter((a10) => !a10.isLocked).map(C$2.deepClone);
    return n10 !== void 0 ? s10.map((a10) => S({ id: a10.id }, n10(a10))) : s10;
  }
  static getSelectedShapeSnapshot(e10, t10, n10) {
    let o10 = he.getSelectedShapes(e10, t10).filter((s10) => !s10.isLocked).map(C$2.deepClone);
    return n10 !== void 0 ? o10.map((s10) => S({ id: s10.id }, n10(s10))) : o10;
  }
  static getAllEffectedShapeIds(e10, t10, n10) {
    let o10 = he.getPage(e10, n10), s10 = new Set(t10);
    return t10.forEach((a10) => {
      let d10 = o10.shapes[a10];
      function i10(u10) {
        u10.children !== void 0 && u10.children.filter((p10) => !s10.has(p10)).forEach((p10) => {
          s10.add(p10), i10(o10.shapes[p10]);
        });
      }
      i10(d10);
      function c10(u10) {
        let p10 = u10.parentId;
        p10 !== o10.id && (s10.has(p10) || (s10.add(p10), c10(o10.shapes[p10])));
      }
      c10(d10), s10.forEach((u10) => {
        Object.values(o10.bindings).filter((p10) => p10.fromId === u10 || p10.toId === u10).forEach((p10) => s10.add(p10.fromId === u10 ? p10.toId : p10.fromId));
      });
    }), Array.from(s10.values());
  }
  static getLinkedShapeIds(e10, t10, n10, o10 = true) {
    let s10 = he.getSelectedIds(e10, t10), a10 = he.getPage(e10, t10), d10 = new Set(s10), i10 = /* @__PURE__ */ new Set(), c10 = [...s10], u10 = new Set(Object.values(a10.shapes).filter((p10) => {
      var m10;
      return p10.type === "arrow" && (p10.handles.start.bindingId || ((m10 = p10.handles) == null ? void 0 : m10.end.bindingId));
    }));
    for (; c10.length; ) {
      let p10 = c10.pop();
      if (!(p10 && u10.size)) break;
      i10.has(p10) || (i10.add(p10), u10.forEach((m10) => {
        var b10, y10;
        let { handles: { start: { bindingId: h10 }, end: { bindingId: g10 } } } = m10, f10 = h10 ? a10.bindings[h10] : null, T10 = g10 ? a10.bindings[g10] : null, w10 = false;
        f10 && f10.toId === p10 ? (n10 === "center" ? w10 = true : ((b10 = m10.decorations) == null ? void 0 : b10.start) && T10 ? w10 = n10 === "left" : w10 = n10 === "right", w10 && (o10 && d10.add(m10.id), d10.add(p10), T10 && (d10.add(T10.toId), c10.push(T10.toId)))) : T10 && T10.toId === p10 && (n10 === "center" ? w10 = true : ((y10 = m10.decorations) == null ? void 0 : y10.end) && f10 ? w10 = n10 === "left" : w10 = n10 === "right", w10 && (o10 && d10.add(m10.id), d10.add(p10), f10 && (d10.add(f10.toId), c10.push(f10.toId)))), (!f10 || d10.has(f10.toId)) && (!T10 || d10.has(T10.toId)) && u10.delete(m10);
      }));
    }
    return Array.from(d10.values());
  }
  static getChildIndexAbove(e10, t10, n10) {
    let o10 = e10.document.pages[n10], s10 = o10.shapes[t10], a10;
    if (s10.parentId === o10.id) a10 = Object.values(o10.shapes).filter((c10) => c10.parentId === o10.id).sort((c10, u10) => c10.childIndex - u10.childIndex);
    else {
      let c10 = o10.shapes[s10.parentId];
      if (!c10.children) throw Error("No children in parent!");
      a10 = c10.children.map((u10) => o10.shapes[u10]).sort((u10, p10) => u10.childIndex - p10.childIndex);
    }
    let d10 = a10.indexOf(s10), i10 = a10[d10 + 1];
    return i10 ? i10.childIndex : s10.childIndex + 1;
  }
  static getBeforeShape(e10, t10) {
    return Object.fromEntries(Object.keys(t10).map((n10) => [n10, e10[n10]]));
  }
  static mutateShapes(e10, t10, n10, o10, s10 = false) {
    let a10 = {}, d10 = {};
    t10.forEach((c10, u10) => {
      let p10 = he.getShape(e10, c10, o10);
      if (p10.isLocked) return;
      (p10 == null ? void 0 : p10.type) === "group" && (t10.length === 1 || s10) && p10.children.forEach((h10, g10) => {
        let f10 = he.getShape(e10, h10, o10);
        if (f10.isLocked) return;
        let T10 = n10(f10, g10);
        T10 && (a10[h10] = he.getBeforeShape(f10, T10), d10[h10] = T10);
      });
      let m10 = n10(p10, u10);
      m10 && (a10[c10] = he.getBeforeShape(p10, m10), d10[c10] = m10);
    });
    let i10 = C$2.deepMerge(e10, { document: { pages: { [e10.appState.currentPageId]: { shapes: d10 } } } });
    return { before: a10, after: d10, data: i10 };
  }
  static createShapes(e10, t10, n10) {
    let o10 = { document: { pages: { [n10]: { shapes: S({}, Object.fromEntries(t10.flatMap((a10) => {
      let d10 = [[a10.id, void 0]];
      if (a10.parentId !== n10) {
        let i10 = he.getShape(e10, a10.parentId, n10);
        if (!i10.children) throw Error("No children in parent!");
        d10.push([i10.id, { children: i10.children }]);
      }
      return d10;
    }))) } } } }, s10 = { document: { pages: { [n10]: { shapes: { shapes: S({}, Object.fromEntries(t10.flatMap((a10) => {
      let d10 = [[a10.id, a10]];
      if (a10.parentId !== n10) {
        let i10 = he.getShape(e10, a10.parentId, n10);
        if (!i10.children) throw Error("No children in parent!");
        d10.push([i10.id, { children: [...i10.children, a10.id] }]);
      }
      return d10;
    }))) } } } } };
    return { before: o10, after: s10 };
  }
  static deleteShapes(e10, t10, n10) {
    n10 = n10 || e10.appState.currentPageId;
    let o10 = he.getPage(e10, n10), s10 = typeof t10[0] == "string" ? t10 : t10.map((i10) => i10.id), a10 = { document: { pages: { [n10]: { shapes: S({}, Object.fromEntries(s10.flatMap((i10) => {
      let c10 = o10.shapes[i10], u10 = [[c10.id, c10]];
      if (c10.parentId !== n10) {
        let p10 = o10.shapes[c10.parentId];
        if (!p10.children) throw Error("No children in parent!");
        u10.push([p10.id, { children: p10.children }]);
      }
      return u10;
    }))), bindings: S({}, Object.fromEntries(Object.values(o10.bindings).filter((i10) => s10.includes(i10.fromId) || s10.includes(i10.toId)).map((i10) => [i10.id, i10]))) } } } }, d10 = { document: { pages: { [n10]: { shapes: S({}, Object.fromEntries(s10.flatMap((i10) => {
      let c10 = o10.shapes[i10], u10 = [[c10.id, void 0]];
      if (c10.parentId !== o10.id) {
        let p10 = o10.shapes[c10.parentId];
        if (!p10.children) throw Error("No children in parent!");
        u10.push([p10.id, { children: p10.children.filter((m10) => m10 !== c10.id) }]);
      }
      return u10;
    }))) } } } };
    return { before: a10, after: d10 };
  }
  static onSessionComplete(e10) {
    var n10, o10;
    let t10 = (o10 = (n10 = he.getShapeUtil(e10)).onSessionComplete) == null ? void 0 : o10.call(n10, e10);
    return t10 ? S(S({}, e10), t10) : e10;
  }
  static onChildrenChange(e10, t10, n10) {
    var s10, a10;
    if (!t10.children) return;
    let o10 = (a10 = (s10 = he.getShapeUtil(t10)).onChildrenChange) == null ? void 0 : a10.call(s10, t10, t10.children.map((d10) => he.getShape(e10, d10, n10)));
    return o10 ? S(S({}, t10), o10) : t10;
  }
  static updateArrowBindings(e10, t10) {
    var a10, d10, i10, c10, u10, p10;
    let n10 = { start: St(t10.handles.start), end: St(t10.handles.end) }, o10 = { isBound: false, handle: t10.handles.start, point: e$3.add(t10.handles.start.point, t10.point) }, s10 = { isBound: false, handle: t10.handles.end, point: e$3.add(t10.handles.end.point, t10.point) };
    if (t10.handles.start.bindingId) {
      let m10 = ((a10 = t10.decorations) == null ? void 0 : a10.start) !== void 0, h10 = t10.handles.start, g10 = e10.bindings[t10.handles.start.bindingId];
      if (!g10) throw Error("Could not find a binding to match the start handle's bindingId: " + t10.handles.start.bindingId);
      let f10 = e10.shapes[g10.toId], T10 = he.getShapeUtil(f10), w10 = T10.getBounds(f10), b10 = T10.getExpandedBounds(f10), y10 = m10 ? C$2.expandBounds(w10, g10.distance) : w10, { minX: R10, minY: U10, width: L10, height: k10 } = b10, I10 = e$3.add([R10, U10], e$3.mulV([L10, k10], e$3.rotWith(g10.point, [0.5, 0.5], f10.rotation || 0)));
      o10 = { isBound: true, hasDecoration: m10, binding: g10, handle: h10, point: I10, util: T10, target: f10, bounds: w10, expandedBounds: b10, intersectBounds: y10, center: T10.getCenter(f10) };
    }
    if (t10.handles.end.bindingId) {
      let m10 = ((d10 = t10.decorations) == null ? void 0 : d10.end) !== void 0, h10 = t10.handles.end, g10 = e10.bindings[t10.handles.end.bindingId];
      if (!g10) throw Error("Could not find a binding to match the end handle's bindingId");
      let f10 = e10.shapes[g10.toId], T10 = he.getShapeUtil(f10), w10 = T10.getBounds(f10), b10 = T10.getExpandedBounds(f10), y10 = m10 ? C$2.expandBounds(w10, g10.distance) : w10, { minX: R10, minY: U10, width: L10, height: k10 } = b10, I10 = e$3.add([R10, U10], e$3.mulV([L10, k10], e$3.rotWith(g10.point, [0.5, 0.5], f10.rotation || 0)));
      s10 = { isBound: true, hasDecoration: m10, binding: g10, handle: h10, point: I10, util: T10, target: f10, bounds: w10, expandedBounds: b10, intersectBounds: y10, center: T10.getCenter(f10) };
    }
    for (let m10 of ["end", "start"]) {
      let h10 = m10 === "start" ? o10 : s10, g10 = m10 === "start" ? s10 : o10;
      if (h10.isBound) if (!h10.binding.distance) n10[m10].point = e$3.sub(h10.point, t10.point);
      else {
        let f10 = e$3.uni(e$3.sub(h10.point, g10.point));
        switch (h10.target.type) {
          case "ellipse": {
            let T10 = F$1(g10.point, f10, h10.center, h10.target.radius[0] + (h10.hasDecoration ? h10.binding.distance : 0), h10.target.radius[1] + (h10.hasDecoration ? h10.binding.distance : 0), h10.target.rotation || 0).points.sort((w10, b10) => e$3.dist(w10, g10.point) - e$3.dist(b10, g10.point));
            T10[0] !== void 0 && (n10[m10].point = e$3.toFixed(e$3.sub(T10[0], t10.point)));
            break;
          }
          case "triangle": {
            let T10 = h10.target.point, w10 = tn(h10.target.size, h10.hasDecoration ? 16 : 0, h10.target.rotation).map((y10) => e$3.add(y10, T10)), b10 = C$2.pointsToLineSegments(w10, true).map(([y10, R10]) => x$4(g10.point, f10, y10, R10)).filter((y10) => y10.didIntersect).flatMap((y10) => y10.points).sort((y10, R10) => e$3.dist(y10, g10.point) - e$3.dist(R10, g10.point));
            b10[0] !== void 0 && (n10[m10].point = e$3.toFixed(e$3.sub(b10[0], t10.point)));
            break;
          }
          default: {
            let T10 = se(g10.point, f10, h10.intersectBounds, h10.target.rotation).filter((b10) => b10.didIntersect).map((b10) => b10.points[0]).sort((b10, y10) => e$3.dist(b10, g10.point) - e$3.dist(y10, g10.point));
            if (!T10[0]) continue;
            let w10;
            if (g10.isBound && (w10 = se(g10.point, f10, g10.intersectBounds, g10.target.rotation).filter((y10) => y10.didIntersect).map((y10) => y10.points[0]).sort((y10, R10) => e$3.dist(y10, g10.point) - e$3.dist(R10, g10.point))[0]), g10.isBound && (T10.length < 2 || w10 && T10[0] && Math.ceil(e$3.dist(T10[0], w10)) < 16 * 2.5 || C$2.boundsContain(h10.expandedBounds, g10.expandedBounds) || C$2.boundsCollide(h10.expandedBounds, g10.expandedBounds))) {
              let b10 = e$3.uni(e$3.sub(g10.point, h10.point)), y10 = se(h10.point, b10, h10.bounds, h10.target.rotation).filter((R10) => R10.didIntersect).map((R10) => R10.points[0]);
              if (!y10[0]) continue;
              n10[m10].point = e$3.toFixed(e$3.sub(y10[0], t10.point)), n10[m10 === "start" ? "end" : "start"].point = e$3.toFixed(e$3.add(e$3.sub(y10[0], t10.point), e$3.mul(b10, Math.min(e$3.dist(y10[0], g10.point), 16 * 2.5 * (C$2.boundsContain(g10.bounds, h10.intersectBounds) ? -1 : 1)))));
            } else if (!g10.isBound && (T10[0] && e$3.dist(T10[0], g10.point) < 16 * 2.5 || C$2.pointInBounds(g10.point, h10.intersectBounds))) {
              let b10 = e$3.uni(e$3.sub(h10.center, g10.point));
              return (c10 = (i10 = he.getShapeUtil(t10)).onHandleChange) == null ? void 0 : c10.call(i10, t10, { [m10]: x(S({}, t10.handles[m10]), { point: e$3.toFixed(e$3.add(e$3.sub(g10.point, t10.point), e$3.mul(b10, 16 * 2.5))) }) });
            } else T10[0] && (n10[m10].point = e$3.toFixed(e$3.sub(T10[0], t10.point)));
          }
        }
      }
    }
    return (p10 = (u10 = he.getShapeUtil(t10)).onHandleChange) == null ? void 0 : p10.call(u10, t10, n10);
  }
  static transform(e10, t10, n10) {
    let o10 = he.getShapeUtil(e10).transform(e10, t10, n10);
    return o10 ? S(S({}, e10), o10) : e10;
  }
  static transformSingle(e10, t10, n10) {
    let o10 = he.getShapeUtil(e10).transformSingle(e10, t10, n10);
    return o10 ? S(S({}, e10), o10) : e10;
  }
  static getRotatedShapeMutation(e10, t10, n10, o10) {
    var c10, u10;
    let s10 = e$3.sub(t10, e10.point), a10 = e$3.rotWith(t10, n10, o10), d10 = e$3.toFixed(e$3.sub(a10, s10));
    if (e10.handles !== void 0) return (u10 = (c10 = this.getShapeUtil(e10)).onHandleChange) == null ? void 0 : u10.call(c10, x(S({}, e10), { point: d10 }), Object.fromEntries(Object.entries(e10.handles).map(([m10, h10]) => {
      let g10 = e$3.toFixed(e$3.rotWith(h10.point, s10, o10));
      return [m10, x(S({}, h10), { point: g10 })];
    })));
    let i10 = C$2.clampRadians((e10.rotation || 0) + o10);
    return { point: d10, rotation: i10 };
  }
  static updateParents(e10, t10, n10) {
    let o10 = he.getPage(e10, t10);
    if (n10.length === 0) return;
    let { shapes: s10 } = he.getPage(e10, t10), a10 = Array.from(new Set(n10.map((d10) => s10[d10].parentId).values())).filter((d10) => d10 !== o10.id);
    for (let d10 of a10) {
      let i10 = s10[d10];
      if (!i10.children) throw Error("A shape is parented to a shape without a children array.");
      he.onChildrenChange(e10, i10, t10);
    }
    he.updateParents(e10, t10, a10);
  }
  static getBinding(e10, t10, n10) {
    return he.getPage(e10, n10).bindings[t10];
  }
  static getBindings(e10, t10) {
    let n10 = he.getPage(e10, t10);
    return Object.values(n10.bindings);
  }
  static getBindableShapeIds(e10) {
    return he.getShapes(e10, e10.appState.currentPageId).filter((t10) => he.getShapeUtil(t10).canBind).sort((t10, n10) => n10.childIndex - t10.childIndex).map((t10) => t10.id);
  }
  static getBindingsWithShapeIds(e10, t10, n10) {
    return Array.from(new Set(he.getBindings(e10, n10).filter((o10) => t10.includes(o10.toId) || t10.includes(o10.fromId))).values());
  }
  static getRelatedBindings(e10, t10, n10) {
    let o10 = new Set(t10), s10 = he.getPage(e10, n10), a10 = Object.values(s10.bindings), d10 = new Set(a10.filter((u10) => o10.has(u10.toId) || o10.has(u10.fromId))), i10 = d10.size, c10 = -1;
    for (; c10 !== 0; ) d10.forEach((u10) => {
      let p10 = u10.fromId;
      for (let m10 of a10) m10.fromId === p10 && d10.add(m10), m10.toId === p10 && d10.add(m10);
    }), c10 = d10.size - i10, i10 = d10.size;
    return Array.from(d10.values());
  }
  static normalizeText(e10) {
    return e10.replace(he.fixNewLines, `
`).split(`
`).map((t10) => t10 || " ").join(`
`);
  }
  static assertShapeHasProperty(e10, t10) {
    if (e10[t10] === void 0) throw new Error();
  }
  static warn(e10) {
  }
  static error(e10) {
  }
  static getSvgString(e10, t10 = 1) {
    let n10 = e10.cloneNode(true);
    return e10.setAttribute("width", +e10.getAttribute("width") * t10 + ""), e10.setAttribute("height", +e10.getAttribute("height") * t10 + ""), new XMLSerializer().serializeToString(n10).replaceAll("&#10;      ", "").replaceAll(/((\s|")[0-9]*\.[0-9]{2})([0-9]*)(\b|"|\))/g, "$1");
  }
  static getSvgAsDataUrl(e10, t10 = 1) {
    let n10 = he.getSvgString(e10, t10);
    return `data:image/svg+xml;base64,${window.btoa(unescape(n10))}`;
  }
  static getImageForSvg(o10) {
    return pe(this, arguments, function* (e10, t10 = "png", n10 = {}) {
      let { scale: s10 = 2, quality: a10 = 1 } = n10, d10 = he.getSvgString(e10, s10);
      if (!d10) return;
      let i10 = yield new Promise((u10) => {
        let p10 = new Image();
        p10.crossOrigin = "anonymous";
        let h10 = `data:image/svg+xml;base64,${window.btoa(unescape(encodeURIComponent(d10)))}`;
        p10.onload = () => {
          let g10 = document.createElement("canvas"), f10 = g10.getContext("2d"), T10 = p10.width, w10 = p10.height;
          g10.width = T10, g10.height = w10, f10.drawImage(p10, 0, 0, T10, w10), URL.revokeObjectURL(h10), u10(g10);
        }, p10.onerror = () => {
          console.warn("Could not convert that SVG to an image.");
        }, p10.src = h10;
      });
      return yield new Promise((u10) => i10.toBlob((p10) => u10(p10), "image/" + t10, a10));
    });
  }
}, v = he;
l(v, "copyStringToClipboard", (e10) => {
  try {
    navigator.clipboard && navigator.clipboard.write([new ClipboardItem({ "text/plain": new Blob([e10], { type: "text/plain" }) })]);
  } catch (t10) {
    let n10 = document.createElement("textarea");
    n10.setAttribute("position", "fixed"), n10.setAttribute("top", "0"), n10.setAttribute("readonly", "true"), n10.setAttribute("contenteditable", "true"), n10.style.position = "fixed", n10.value = e10, document.body.appendChild(n10), n10.focus(), n10.select();
    try {
      let o10 = document.createRange();
      o10.selectNodeContents(n10);
      let s10 = window.getSelection();
      s10 && (s10.removeAllRanges(), s10.addRange(o10), n10.setSelectionRange(0, n10.value.length)), document.execCommand("copy");
    } catch (o10) {
    } finally {
      document.body.removeChild(n10);
    }
  }
}), l(v, "flattenShape", (e10, t10) => {
  var n10;
  return [t10, ...((n10 = t10.children) != null ? n10 : []).map((o10) => he.getShape(e10, o10, e10.appState.currentPageId)).sort((o10, s10) => o10.childIndex - s10.childIndex).flatMap((o10) => he.flattenShape(e10, o10))];
}), l(v, "flattenPage", (e10, t10) => Object.values(e10.document.pages[t10].shapes).sort((n10, o10) => n10.childIndex - o10.childIndex).reduce((n10, o10) => [...n10, ...he.flattenShape(e10, o10)], [])), l(v, "getTopChildIndex", (e10, t10) => {
  let n10 = he.getShapes(e10, t10);
  return n10.length === 0 ? 1 : n10.filter((o10) => o10.parentId === t10).sort((o10, s10) => s10.childIndex - o10.childIndex)[0].childIndex + 1;
}), l(v, "fixNewLines", /\r?\n|\r/g);
var Tce = (r10) => r10.room, Sd = function() {
  let e10 = me(), t10 = e10.useStore(Tce), [n10, o10] = reactExports.useState(false), s10 = reactExports.useRef(0), a10 = reactExports.useCallback(() => {
    o10(true), v.copyStringToClipboard(window.location.href), clearTimeout(s10.current), s10.current = setTimeout(() => o10(false), 1200);
  }, []), d10 = reactExports.useCallback(() => {
    o10(true);
    let u10 = window.location.href.split("/");
    u10[u10.length - 2] = "v", u10[u10.length - 1] = C$2.lns(u10[u10.length - 1]), v.copyStringToClipboard(u10.join("/")), clearTimeout(s10.current), s10.current = setTimeout(() => o10(false), 1200);
  }, []), i10 = reactExports.useCallback(() => pe(this, null, function* () {
    e10.isDirty ? e10.fileSystemHandle ? window.confirm("Do you want to save changes to your current project?") && (yield e10.saveProject()) : window.confirm("Do you want to save your current project?") && (yield e10.saveProject()) : e10.fileSystemHandle || window.confirm("Do you want to save your current project?") && (yield e10.saveProject());
  }), []), c10 = reactExports.useCallback(() => pe(this, null, function* () {
    var p10;
    let u10 = C$2.deepClone(e10.document);
    e10.setIsLoading(true);
    try {
      if (e10.callbacks.onAssetUpload) for (let h10 in u10.assets) {
        let g10 = u10.assets[h10];
        if (g10.src.includes("base64")) {
          let f10 = yce(g10.src, ((p10 = g10.fileName) != null ? p10 : g10.type === "video") ? "image.png" : "image.mp4"), T10 = yield e10.callbacks.onAssetUpload(e10, f10, h10);
          T10 ? g10.src = T10 : g10.src = "";
        }
      }
      let m10 = yield fetch("/api/create", { method: "POST", mode: "no-cors", headers: { "Access-Control-Allow-Origin": "*", "Content-Type": "application/json" }, body: JSON.stringify({ roomId: C$2.uniqueId(), pageId: e10.currentPageId, document: u10 }) }).then((h10) => h10.json());
      (m10 == null ? void 0 : m10.url) ? window.location.href = m10.url : v.warn(m10 == null ? void 0 : m10.message);
    } catch (m10) {
      v.warn(m10.message);
    }
    e10.setIsLoading(false);
  }), []);
  return reactExports.createElement($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr" }, reactExports.createElement(Rr, { id: "TD-MultiplayerMenuIcon", isActive: !!t10 }, reactExports.createElement(pl, null)), reactExports.createElement(Mt, { variant: "menu", id: "TD-MultiplayerMenu", side: "bottom", align: "start", sideOffset: 4 }, reactExports.createElement(xe, { id: "TD-Multiplayer-CopyInviteLink", onClick: a10, disabled: !t10 }, reactExports.createElement(MemoizedFormattedMessage, { id: "copy.invite.link" }), reactExports.createElement(ut, null, n10 ? reactExports.createElement(CheckIcon, null) : reactExports.createElement(ClipboardIcon, null))), reactExports.createElement(xe, { id: "TD-Multiplayer-CopyReadOnlyLink", onClick: d10, disabled: !t10 }, reactExports.createElement(MemoizedFormattedMessage, { id: "copy.readonly.link" }), reactExports.createElement(ut, null, n10 ? reactExports.createElement(CheckIcon, null) : reactExports.createElement(ClipboardIcon, null))), reactExports.createElement(Pe, null), reactExports.createElement(xe, { id: "TD-Multiplayer-CreateMultiplayerProject", onClick: i10 }, reactExports.createElement("a", { href: `${window.location.origin}/r` }, reactExports.createElement(MemoizedFormattedMessage, { id: "create.multiplayer.project" }))), reactExports.createElement(xe, { id: "TD-Multiplayer-CopyToMultiplayerProject", onClick: c10 }, reactExports.createElement(MemoizedFormattedMessage, { id: "copy.multiplayer.project" }))));
};
function yce(r10, e10) {
  var d10, i10;
  let t10 = r10.split(","), n10 = (i10 = (d10 = t10[0]) == null ? void 0 : d10.match(/:(.*?);/)) == null ? void 0 : i10[1], o10 = window.atob(t10[1]), s10 = o10.length, a10 = new Uint8Array(s10);
  for (; s10--; ) a10[s10] = o10.charCodeAt(s10);
  return new File([a10], e10, { type: n10 });
}
var vce = (r10) => Object.keys(r10.document.pages).length > 1;
function Td({ page: r10, onOpen: e10, onClose: t10 }) {
  let n10 = me(), o10 = useIntl(), [s10, a10] = reactExports.useState(false), [d10, i10] = reactExports.useState(r10.name || "Page"), c10 = n10.useStore(vce), u10 = reactExports.useRef(null), p10 = reactExports.useCallback(() => {
    a10(false);
  }, []), m10 = reactExports.useCallback(() => {
    n10.duplicatePage(r10.id);
  }, [n10]), h10 = reactExports.useCallback(() => {
    window.confirm("Are you sure you want to delete this page?") && n10.deletePage(r10.id);
  }, [n10]), g10 = reactExports.useCallback((L10) => {
    if (a10(L10), L10) {
      e10 == null || e10();
      return;
    }
  }, [n10]);
  function f10(L10) {
    L10.stopPropagation();
  }
  let T10 = reactExports.useRef(r10.name || "Page"), w10 = reactExports.useRef(T10.current), b10 = reactExports.useCallback((L10) => {
    let k10 = L10.target.value.trimStart();
    w10.current = k10, i10(k10);
  }, []), y10 = reactExports.useCallback((L10) => {
    switch (L10.key) {
      case "Enter": {
        w10.current === T10.current || (T10.current = w10.current, n10.renamePage(r10.id, w10.current.trim())), a10(false);
        break;
      }
      case "Escape": {
        if (w10.current === T10.current) {
          a10(false);
          return;
        }
        w10.current = T10.current, i10(T10.current), requestAnimationFrame(() => {
          let k10 = u10.current;
          k10 && (k10.focus(), k10.setSelectionRange(0, k10.value.length));
        });
        break;
      }
    }
  }, []), R10 = reactExports.useRef(false);
  reactExports.useEffect(() => (s10 ? (R10.current = true, T10.current = r10.name || "Page", w10.current = T10.current, requestAnimationFrame(() => {
    let L10 = u10.current;
    L10 && (L10.focus(), L10.setSelectionRange(0, L10.value.length));
  })) : R10.current && (t10 == null || t10()), () => {
    w10.current !== T10.current && (T10.current = w10.current, n10.renamePage(r10.id, w10.current));
  }), [s10]);
  let U10 = Lt();
  return reactExports.createElement(Root2$2, { open: s10, onOpenChange: g10 }, reactExports.createElement(Trigger2, { asChild: true, "data-shy": "true" }, reactExports.createElement(go, { bp: Qe }, reactExports.createElement(ut, null, reactExports.createElement(MixerVerticalIcon, null)))), reactExports.createElement(Portal2, { container: U10.current }, reactExports.createElement(Cce, { onPointerDown: p10 }), reactExports.createElement(Ice, { dir: "ltr", onKeyDown: f10, onKeyUp: f10 }, reactExports.createElement(Mr, { ref: u10, placeholder: o10.formatMessage({ id: "page.name" }), value: d10, onChange: b10, onKeyDown: y10, icon: reactExports.createElement(Pencil1Icon, null) }), reactExports.createElement(Pe, null), reactExports.createElement(bd, { onSelect: m10 }, reactExports.createElement(MemoizedFormattedMessage, { id: "duplicate" })), reactExports.createElement(bd, { disabled: !c10, onSelect: h10 }, reactExports.createElement(MemoizedFormattedMessage, { id: "delete" })), reactExports.createElement(Pe, null), reactExports.createElement(Cancel, { asChild: true }, reactExports.createElement(je, null, reactExports.createElement(MemoizedFormattedMessage, { id: "cancel" }))))));
}
var Ice = H2(Content2$1, { position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", minWidth: 240, maxWidth: "fit-content", maxHeight: "85vh", marginTop: "-5vh", pointerEvents: "all", backgroundColor: "$panel", padding: "$1", borderRadius: "$2", font: "$ui", zIndex: 999999, "&:focus": { outline: "none" } }), Cce = H2(Overlay2, { backgroundColor: "rgba(0, 0, 0, .15)", position: "absolute", pointerEvents: "all", inset: 0, zIndex: 999998 });
function bd(t10) {
  var n10 = t10, { onSelect: r10 } = n10, e10 = Je(n10, ["onSelect"]);
  return reactExports.createElement(Action, { asChild: true, onClick: r10, onSelect: r10 }, reactExports.createElement(je, S({}, e10)));
}
var Ece = (r10) => Object.values(r10.document.pages).sort((e10, t10) => (e10.childIndex || 0) - (t10.childIndex || 0)), Bce = (r10) => r10.document.pages[r10.appState.currentPageId].name, Rce = (r10) => r10.document.pages[r10.appState.currentPageId].id;
function wd() {
  let r10 = me(), e10 = useIntl(), t10 = reactExports.useRef(false), [n10, o10] = reactExports.useState(false);
  reactExports.useEffect(() => {
    t10.current !== n10 && (t10.current = n10);
  }, [n10]);
  let s10 = reactExports.useCallback(() => {
    o10(false);
  }, [o10]), a10 = reactExports.useCallback((i10) => {
    t10.current !== i10 && o10(i10);
  }, [o10]), d10 = r10.useStore(Bce);
  return reactExports.createElement($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr", open: n10, onOpenChange: a10 }, reactExports.createElement($d08ef79370b62062$export$41fb9f06171c75f4, { dir: "ltr", asChild: true, id: "TD-Page" }, reactExports.createElement(ke, { variant: "text" }, d10 || e10.formatMessage({ id: "page" }))), reactExports.createElement(Mt, { variant: "menu", align: "start", sideOffset: 4 }, n10 && reactExports.createElement(Ace, { onClose: s10 })));
}
function Ace({ onClose: r10 }) {
  let e10 = me(), t10 = useIntl(), n10 = e10.useStore(Ece), o10 = e10.useStore(Rce), s10 = t10.formatMessage({ id: "page" }), a10 = reactExports.useCallback(() => {
    let f10 = s10 + " " + (Object.keys(e10.document.pages).length + 1);
    e10.createPage(void 0, f10);
  }, [e10]), d10 = reactExports.useCallback((f10) => {
    r10(), e10.changePage(f10);
  }, [e10]), [i10, c10] = reactExports.useState(null), [u10, p10] = reactExports.useState(null), m10 = reactExports.useCallback((f10) => {
    c10(f10.currentTarget.id), p10(n10.findIndex((T10) => T10.id === f10.currentTarget.id)), f10.dataTransfer.effectAllowed = "move";
  }, []), h10 = reactExports.useCallback((f10) => {
    f10.preventDefault();
    let T10 = n10.findIndex((y10) => y10.id === f10.currentTarget.id), w10 = f10.currentTarget.getBoundingClientRect();
    T10 = (f10.clientY - w10.top) / w10.height < 0.5 ? T10 : T10 + 1, p10(T10);
  }, [i10, n10]), g10 = reactExports.useCallback(() => {
    i10 !== null && u10 !== null && e10.movePage(i10, u10), c10(null), p10(null);
  }, [i10, u10]);
  return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement($d08ef79370b62062$export$a98f0dcb43a68a25, { dir: "ltr", value: o10, onValueChange: d10 }, n10.map((f10, T10) => reactExports.createElement(Lce, { key: f10.id, isDropAbove: T10 === u10 && T10 === 0, isDropBelow: u10 !== null && T10 === u10 - 1 }, reactExports.createElement($d08ef79370b62062$export$371ab307eab489c0, { title: f10.name || s10, value: f10.id, key: f10.id, id: f10.id, asChild: true, onDragOver: h10, onDragStart: m10, onDrop: g10, draggable: true }, reactExports.createElement(Hce, null, reactExports.createElement("span", { id: f10.id }, f10.name || s10), reactExports.createElement($d08ef79370b62062$export$c3468e2714d175fa, null, reactExports.createElement(ut, null, reactExports.createElement(CheckIcon, null))))), reactExports.createElement(Td, { page: f10, onClose: r10 })))), reactExports.createElement(Pe, null), reactExports.createElement($d08ef79370b62062$export$6d08773d2e66f8f2, { onSelect: a10, asChild: true }, reactExports.createElement(je, null, reactExports.createElement("span", null, reactExports.createElement(MemoizedFormattedMessage, { id: "create.page" })), reactExports.createElement(ut, null, reactExports.createElement(PlusIcon, null)))));
}
var Lce = H2("div", { position: "relative", display: "grid", gridTemplateColumns: "1fr auto", gridAutoFlow: "column", margin: 0, '& > *[data-shy="true"]': { opacity: 0 }, '&:hover > *[data-shy="true"]': { opacity: 1 }, variants: { isDropAbove: { true: { "&::after": { content: "", display: "block", position: "absolute", top: 0, width: "100%", height: "1px", backgroundColor: "$selected", zIndex: 999, pointerEvents: "none" } } }, isDropBelow: { true: { "&::after": { content: "", display: "block", position: "absolute", width: "100%", height: "1px", top: "100%", backgroundColor: "$selected", zIndex: 999, pointerEvents: "none" } } } } }), Hce = H2(je, { minWidth: 128 });
var Vce = (r10) => r10.appState.currentStyle, $ce = (r10) => r10.document.pageStates[r10.appState.currentPageId].selectedIds, Nce = Object.keys(vo), xd = { ["draw"]: reactExports.createElement($a, null), ["solid"]: reactExports.createElement(Na, null), ["dashed"]: reactExports.createElement(Ga, null), ["dotted"]: reactExports.createElement(Va, null) }, Wce = { ["small"]: reactExports.createElement(Ua, null), ["medium"]: reactExports.createElement(Ka, null), ["large"]: reactExports.createElement(_a, null) }, Uce = { ["start"]: reactExports.createElement(TextAlignLeftIcon, null), ["middle"]: reactExports.createElement(TextAlignCenterIcon, null), ["end"]: reactExports.createElement(TextAlignRightIcon, null), ["justify"]: reactExports.createElement(TextAlignJustifyIcon, null) }, Kce = (r10) => r10.settings.isDarkMode ? "dark" : "light", _ce = (r10) => r10.settings.keepStyleMenuOpen, Yce = (r10) => {
  let { activeTool: e10, currentPageId: t10 } = r10.appState;
  switch (e10) {
    case "select": {
      let n10 = r10.document.pages[t10], o10 = false, s10 = false;
      for (let a10 of r10.document.pageStates[t10].selectedIds) "text" in n10.shapes[a10] && (o10 = true), "label" in n10.shapes[a10] && (s10 = true);
      return o10 ? "text" : s10 ? "label" : "";
    }
    case "text":
      return "text";
    case "rectangle":
      return "label";
    case "ellipse":
      return "label";
    case "triangle":
      return "label";
    case "arrow":
      return "label";
    case "line":
      return "label";
  }
  return false;
}, kd = reactExports.memo(function() {
  let e10 = me(), t10 = useIntl(), n10 = e10.useStore(Kce), o10 = e10.useStore(_ce), s10 = e10.useStore(Yce), a10 = e10.useStore(Vce), d10 = e10.useStore($ce), [i10, c10] = reactExports.useState(a10), u10 = reactExports.useRef(a10);
  reactExports.useEffect(() => {
    let { appState: { currentStyle: b10 }, page: y10, selectedIds: R10 } = e10, U10 = {};
    if (R10.length <= 0) U10 = b10;
    else {
      let L10 = /* @__PURE__ */ new Set([]);
      e10.selectedIds.map((k10) => y10.shapes[k10]).forEach((k10) => {
        Nce.forEach((I10) => {
          if (!L10.has(I10)) if (U10[I10] === void 0) U10[I10] = k10.style[I10];
          else {
            if (U10[I10] === k10.style[I10]) return;
            U10[I10] = k10.style[I10], L10.add(I10);
          }
        });
      });
    }
    JSON.stringify(U10) !== JSON.stringify(u10.current) && (u10.current = U10, c10(U10));
  }, [a10, d10]);
  let p10 = reactExports.useCallback((b10) => {
    e10.setSetting("keepStyleMenuOpen", b10);
  }, []), m10 = reactExports.useCallback((b10) => {
    e10.style({ isFilled: b10 });
  }, []), h10 = reactExports.useCallback((b10) => {
    e10.style({ dash: b10 });
  }, []), g10 = reactExports.useCallback((b10) => {
    e10.style({ size: b10 });
  }, []), f10 = reactExports.useCallback((b10) => {
    e10.style({ font: b10 });
  }, []), T10 = reactExports.useCallback((b10) => {
    e10.style({ textAlign: b10 });
  }, []), w10 = reactExports.useCallback((b10) => {
    e10.setMenuOpen(b10);
  }, [e10]);
  return reactExports.createElement($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr", onOpenChange: w10, open: o10 ? true : void 0, modal: false }, reactExports.createElement($d08ef79370b62062$export$41fb9f06171c75f4, { asChild: true, id: "TD-Styles" }, reactExports.createElement(ke, { "aria-label": t10.formatMessage({ id: "styles" }), variant: "text" }, reactExports.createElement(MemoizedFormattedMessage, { id: "styles" }), reactExports.createElement(Xce, { style: { color: ko[n10][i10.color] } }, i10.isFilled && reactExports.createElement(Is, { size: 16, stroke: "none", fill: Gr[n10][i10.color] }), xd[i10.dash]))), reactExports.createElement(Mt, { id: "TD-StylesMenu", side: "bottom", align: "end", sideOffset: 4, alignOffset: 4 }, reactExports.createElement(_o, { variant: "tall", id: "TD-Styles-Color-Container" }, reactExports.createElement("span", null, reactExports.createElement(MemoizedFormattedMessage, { id: "style.menu.color" })), reactExports.createElement(Zce, null, Object.keys(ko.light).map((b10) => reactExports.createElement($d08ef79370b62062$export$6d08773d2e66f8f2, { key: b10, onSelect: He, asChild: true, id: `TD-Styles-Color-Swatch-${b10}` }, reactExports.createElement(ke, { variant: "icon", isActive: i10.color === b10, onClick: () => e10.style({ color: b10 }), "aria-label": t10.formatMessage({ id: b10 }) }, reactExports.createElement(Is, { size: 18, strokeWidth: 2.5, fill: i10.isFilled ? Gr[n10][b10] : "transparent", stroke: ko.light[b10] })))))), reactExports.createElement(Pt, { variant: "styleMenu", checked: !!i10.isFilled, onCheckedChange: m10, id: "TD-Styles-Fill" }, reactExports.createElement(MemoizedFormattedMessage, { id: "style.menu.fill" })), reactExports.createElement(_o, { id: "TD-Styles-Dash-Container" }, reactExports.createElement(MemoizedFormattedMessage, { id: "style.menu.dash" }), reactExports.createElement(Xr, { dir: "ltr", value: i10.dash, onValueChange: h10 }, Object.values(yn).map((b10) => reactExports.createElement(jo, { key: b10, isActive: b10 === i10.dash, value: b10, onSelect: He, bp: Qe, id: `TD-Styles-Dash-${b10}`, "aria-label": t10.formatMessage({ id: b10 }) }, xd[b10])))), reactExports.createElement(_o, { id: "TD-Styles-Size-Container" }, reactExports.createElement(MemoizedFormattedMessage, { id: "style.menu.size" }), reactExports.createElement(Xr, { dir: "ltr", value: i10.size, onValueChange: g10 }, Object.values(kr).map((b10) => reactExports.createElement(jo, { key: b10, isActive: b10 === i10.size, value: b10, onSelect: He, bp: Qe, id: `TD-Styles-Dash-${b10}`, "aria-label": t10.formatMessage({ id: b10 }) }, Wce[b10])))), (s10 === "text" || s10 === "label") && reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Pe, null), reactExports.createElement(_o, { id: "TD-Styles-Font-Container" }, reactExports.createElement(MemoizedFormattedMessage, { id: "style.menu.font" }), reactExports.createElement(Xr, { dir: "ltr", value: i10.font, onValueChange: f10 }, Object.values(Oo).map((b10) => reactExports.createElement(jo, { key: b10, isActive: b10 === i10.font, value: b10, onSelect: He, bp: Qe, id: `TD-Styles-Font-${b10}` }, reactExports.createElement(qce, { fontStyle: b10 }, "Aa"))))), s10 === "text" && reactExports.createElement(_o, { id: "TD-Styles-Align-Container" }, reactExports.createElement(MemoizedFormattedMessage, { id: "style.menu.align" }), reactExports.createElement(Xr, { dir: "ltr", value: i10.textAlign, onValueChange: T10 }, Object.values(Gt).map((b10) => reactExports.createElement(jo, { key: b10, isActive: b10 === i10.textAlign, value: b10, onSelect: He, bp: Qe, id: `TD-Styles-Align-${b10}` }, Uce[b10]))))), reactExports.createElement(Pe, null), reactExports.createElement(Pt, { variant: "styleMenu", checked: o10, onCheckedChange: p10, id: "TD-Styles-Keep-Open" }, reactExports.createElement(MemoizedFormattedMessage, { id: "style.menu.keep.open" }))));
}), Zce = H2("div", { display: "grid", gridTemplateColumns: "repeat(4, auto)", gap: 0 }), _o = H2("div", { position: "relative", width: "100%", background: "none", border: "none", cursor: "pointer", minHeight: "32px", outline: "none", color: "$text", fontFamily: "$ui", fontWeight: 400, fontSize: "$1", padding: "$2 0 $2 $3", borderRadius: 4, userSelect: "none", WebkitUserSelect: "none", margin: 0, display: "flex", gap: "$3", flexDirection: "row", alignItems: "center", justifyContent: "space-between", variants: { variant: { tall: { alignItems: "flex-start", padding: "0 0 0 $3", "& > span": { paddingTop: "$4" } } } } }), Xr = H2($d08ef79370b62062$export$3323ad73d55f587e, { display: "flex", flexDirection: "row", gap: "$1" }), Xce = H2("div", { display: "grid", "& > *": { gridColumn: 1, gridRow: 1 } }), qce = H2("div", { width: 32, height: 32, display: "flex", alignItems: "center", justifyContent: "center", fontSize: "$3", variants: { fontStyle: { ["script"]: { fontFamily: "Caveat Brush" }, ["sans"]: { fontFamily: "Recursive" }, ["serif"]: { fontFamily: "Georgia" }, ["mono"]: { fontFamily: "Recursive Mono" } } } });
var Jce = (r10) => r10.document.pageStates[r10.appState.currentPageId].camera.zoom, vd = function() {
  let e10 = me(), t10 = e10.useStore(Jce);
  return reactExports.createElement($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr" }, reactExports.createElement($d08ef79370b62062$export$41fb9f06171c75f4, { dir: "ltr", asChild: true, id: "TD-Zoom" }, reactExports.createElement(Qce, { onDoubleClick: e10.resetZoom, variant: "text" }, Math.round(t10 * 100), "%")), reactExports.createElement(Mt, { align: "end" }, reactExports.createElement(xe, { onSelect: He, onClick: e10.zoomIn, kbd: "#+", id: "TD-Zoom-Zoom_In" }, reactExports.createElement(MemoizedFormattedMessage, { id: "zoom.in" })), reactExports.createElement(xe, { onSelect: He, onClick: e10.zoomOut, kbd: "#", id: "TD-Zoom-Zoom_Out" }, reactExports.createElement(MemoizedFormattedMessage, { id: "zoom.out" })), reactExports.createElement(xe, { onSelect: He, onClick: e10.resetZoom, kbd: "0", id: "TD-Zoom-Zoom_To_100%" }, reactExports.createElement(MemoizedFormattedMessage, { id: "zoom.to" }), " 100%"), reactExports.createElement(xe, { onSelect: He, onClick: e10.zoomToFit, kbd: "1", id: "TD-Zoom-To_Fit" }, reactExports.createElement(MemoizedFormattedMessage, { id: "zoom.to.fit" })), reactExports.createElement(xe, { onSelect: He, onClick: e10.zoomToSelection, kbd: "2", id: "TD-Zoom-To_Selection" }, reactExports.createElement(MemoizedFormattedMessage, { id: "zoom.to.selection" }))));
}, Qce = H2(ke, { minWidth: 56 });
function tpe({ readOnly: r10, showPages: e10, showMenu: t10, showStyles: n10, showZoom: o10, showMultiplayerMenu: s10 }) {
  let a10 = me(), d10 = useIntl();
  return reactExports.createElement(npe, null, (t10 || e10) && reactExports.createElement(no, { side: "left", id: "TD-MenuPanel" }, t10 && reactExports.createElement(cl, { readOnly: r10 }), s10 && reactExports.createElement(Sd, null), e10 && reactExports.createElement(wd, null)), reactExports.createElement(ope, null), (n10 || o10) && reactExports.createElement(no, { side: "right" }, a10.readOnly ? reactExports.createElement(rpe, null, "Read Only") : reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Xt, { kbd: "#Z", label: d10.formatMessage({ id: "undo" }), onClick: a10.undo, id: "TD-TopPanel-Undo", "aria-label": d10.formatMessage({ id: "undo" }) }, reactExports.createElement(Bs, null)), reactExports.createElement(Xt, { kbd: "#Z", label: d10.formatMessage({ id: "redo" }), onClick: a10.redo, id: "TD-TopPanel-Redo", "aria-label": d10.formatMessage({ id: "redo" }) }, reactExports.createElement(Bs, { flipHorizontal: true }))), o10 && reactExports.createElement(vd, null), n10 && !r10 && reactExports.createElement(kd, null)));
}
var npe = H2("div", { width: "100%", position: "absolute", top: 0, left: 0, right: 0, display: "flex", flexDirection: "row", pointerEvents: "none", "& > *": { pointerEvents: "all" } }), ope = H2("div", { flexGrow: 2, pointerEvents: "none" }), rpe = H2("div", { width: "100%", display: "flex", alignItems: "center", justifyContent: "center", fontFamily: "$ui", fontSize: "$1", paddingLeft: "$4", paddingRight: "$1", userSelect: "none", WebkitUserSelect: "none" }), Id = reactExports.memo(tpe);
function Cd(r10) {
  spe.useEffect(() => {
    let e10 = false, t10 = false, n10 = r10.current;
    if (!n10) return;
    let o10 = (i10) => {
      i10.key === " " && !t10 && (t10 = true, e10 ? n10.setAttribute("style", "cursor: grabbing !important") : n10.setAttribute("style", "cursor: grab !important"));
    }, s10 = (i10) => {
      i10.key === " " && (t10 = false, n10.setAttribute("style", "cursor: initial"));
    }, a10 = (i10) => {
      e10 = true, i10.button === 1 && n10.setAttribute("style", "cursor: grabbing !important"), i10.button === 0 && t10 && n10.setAttribute("style", "cursor: grabbing !important");
    }, d10 = () => {
      e10 = false, t10 ? n10.setAttribute("style", "cursor: grab !important") : n10.setAttribute("style", "cursor: initial");
    };
    return n10.addEventListener("keydown", o10), n10.addEventListener("keyup", s10), n10.addEventListener("pointerdown", a10), n10.addEventListener("pointerup", d10), () => {
      n10.removeEventListener("keydown", o10), n10.removeEventListener("keyup", s10), n10.removeEventListener("pointerdown", a10), n10.removeEventListener("pointerup", d10);
    };
  }, [r10.current]);
}
var Dd = "tldraw_clipboard";
function Pd() {
  return pe(this, null, function* () {
    return get(Dd);
  });
}
function Md(r10) {
  return pe(this, null, function* () {
    return set(Dd, r10);
  });
}
var yi = class {
  constructor(e10, t10, n10, o10) {
    l(this, "_idbId");
    l(this, "initialState");
    l(this, "store");
    l(this, "pointer", -1);
    l(this, "_state");
    l(this, "_status", "loading");
    l(this, "stack", []);
    l(this, "_snapshot");
    l(this, "useStore");
    l(this, "ready");
    l(this, "isPaused", false);
    l(this, "persist", (e11, t11) => {
      if (this._status === "ready" && (this.onPersist && this.onPersist(this._state, e11, t11), this._idbId)) return set(this._idbId, this._state).catch((n11) => console.error(n11));
    });
    l(this, "applyPatch", (e11, t11) => {
      let n11 = this._state, o11 = C$2.deepMerge(this._state, e11), s10 = this.cleanup(o11, n11, e11, t11);
      return this.onStateWillChange && this.onStateWillChange(s10, t11), this._state = s10, this.store.setState(this._state, true), this.onStateDidChange && this.onStateDidChange(this._state, t11), this;
    });
    l(this, "migrate", (e11) => e11);
    l(this, "cleanup", (e11, t11, n11, o11) => e11);
    l(this, "onStateWillChange");
    l(this, "onStateDidChange");
    l(this, "patchState", (e11, t11) => (this.applyPatch(e11, t11), this.onPatch && this.onPatch(this._state, e11, t11), this));
    l(this, "replaceState", (e11, t11) => {
      let n11 = this.cleanup(e11, this._state, e11, t11);
      return this.onStateWillChange && this.onStateWillChange(n11, "replace"), this._state = n11, this.store.setState(this._state, true), this.onStateDidChange && this.onStateDidChange(this._state, "replace"), this;
    });
    l(this, "setState", (e11, t11 = e11.id) => (this.pointer < this.stack.length - 1 && (this.stack = this.stack.slice(0, this.pointer + 1)), this.stack.push(x(S({}, e11), { id: t11 })), this.pointer = this.stack.length - 1, this.applyPatch(e11.after, t11), this.onCommand && this.onCommand(this._state, e11, t11), this.persist(e11.after, t11), this));
    l(this, "onReady");
    l(this, "onPatch");
    l(this, "onCommand");
    l(this, "onPersist");
    l(this, "onReplace");
    l(this, "onReset");
    l(this, "onResetHistory");
    l(this, "onUndo");
    l(this, "onRedo");
    l(this, "reset", () => (this.onStateWillChange && this.onStateWillChange(this.initialState, "reset"), this._state = this.initialState, this.store.setState(this._state, true), this.resetHistory(), this.persist({}, "reset"), this.onStateDidChange && this.onStateDidChange(this._state, "reset"), this.onReset && this.onReset(this._state), this));
    l(this, "replaceHistory", (e11, t11 = e11.length - 1) => (this.stack = e11, this.pointer = t11, this.onReplace && this.onReplace(this._state), this));
    l(this, "resetHistory", () => (this.stack = [], this.pointer = -1, this.onResetHistory && this.onResetHistory(this._state), this));
    l(this, "undo", () => {
      if (!this.isPaused) {
        if (!this.canUndo) return this;
        let e11 = this.stack[this.pointer];
        this.pointer--, this.applyPatch(e11.before, "undo"), this.persist(e11.before, "undo");
      }
      return this.onUndo && this.onUndo(this._state), this;
    });
    l(this, "redo", () => {
      if (!this.isPaused) {
        if (!this.canRedo) return this;
        this.pointer++;
        let e11 = this.stack[this.pointer];
        this.applyPatch(e11.after, "redo"), this.persist(e11.after, "undo");
      }
      return this.onRedo && this.onRedo(this._state), this;
    });
    l(this, "setSnapshot", () => (this._snapshot = S({}, this._state), this));
    l(this, "forceUpdate", () => {
      this.store.setState(this._state, true);
    });
    this._idbId = t10, this._state = St(e10), this._snapshot = St(e10), this.initialState = St(e10), this.store = vanilla(() => this._state), this.useStore = react(this.store), this.ready = new Promise((s10) => {
      let a10 = "none";
      this._idbId ? (a10 = "restored", get(this._idbId).then((d10) => pe(this, null, function* () {
        if (d10) {
          let i10 = d10;
          if (n10) {
            let u10 = yield get(t10 + "_version");
            u10 && u10 < n10 && (i10 = o10 ? o10(d10, e10, u10) : e10, a10 = "migrated");
          }
          yield set(t10 + "_version", n10 || -1);
          let c10 = this._state.appState.isEmptyCanvas;
          i10 = this.migrate(i10), this._state = St(i10), this._snapshot = St(i10), this._state.appState.isEmptyCanvas = c10, this.store.setState(this._state, true);
        } else yield set(t10 + "_version", n10 || -1);
        this._status = "ready", s10(a10);
      })).catch((d10) => console.error(d10))) : (this._status = "ready", s10(a10));
    }).then((s10) => (this.onReady && this.onReady(s10), s10));
  }
  pause() {
    this.isPaused = true;
  }
  resume() {
    this.isPaused = false;
  }
  get canUndo() {
    return this.pointer > -1;
  }
  get canRedo() {
    return this.pointer < this.stack.length - 1;
  }
  get state() {
    return this._state;
  }
  get status() {
    return this._status;
  }
  get snapshot() {
    return this._snapshot;
  }
};
function Bd(r10, e10, t10) {
  let { currentPageId: n10 } = r10, o10 = e10.map((m10) => r10.getShape(m10)), s10 = o10.map((m10) => ({ id: m10.id, point: [...m10.point], bounds: v.getBounds(m10) })), a10 = C$2.getCommonBounds(s10.map(({ bounds: m10 }) => m10)), d10 = a10.minX + a10.width / 2, i10 = a10.minY + a10.height / 2, c10 = Object.fromEntries(s10.map(({ id: m10, point: h10, bounds: g10 }) => [m10, { prev: h10, next: { ["top"]: [h10[0], a10.minY], ["centerVertical"]: [h10[0], i10 - g10.height / 2], ["bottom"]: [h10[0], a10.maxY - g10.height], ["left"]: [a10.minX, h10[1]], ["centerHorizontal"]: [d10 - g10.width / 2, h10[1]], ["right"]: [a10.maxX - g10.width, h10[1]] }[t10] }])), { before: u10, after: p10 } = v.mutateShapes(r10.state, e10, (m10) => c10[m10.id] ? { point: c10[m10.id].next } : m10, n10, false);
  return o10.forEach((m10) => {
    if (m10.type === "group") {
      let h10 = e$3.sub(p10[m10.id].point, u10[m10.id].point);
      m10.children.forEach((g10) => {
        let f10 = r10.getShape(g10);
        u10[f10.id] = { point: f10.point }, p10[f10.id] = { point: e$3.add(f10.point, h10) };
      }), delete u10[m10.id], delete p10[m10.id];
    }
  }), { id: "align", before: { document: { pages: { [n10]: { shapes: u10 } }, pageStates: { [n10]: { selectedIds: e10 } } } }, after: { document: { pages: { [n10]: { shapes: p10 } }, pageStates: { [n10]: { selectedIds: e10 } } } } };
}
function Rd(r10, e10) {
  return { id: "change_page", before: { appState: { currentPageId: r10.currentPageId } }, after: { appState: { currentPageId: e10 } } };
}
function Ad(r10, e10) {
  var o10;
  let t10 = r10, n10 = new Set(e10);
  for (; n10.has(t10); ) t10 = ((o10 = /^.*(\d+)$/.exec(t10)) == null ? void 0 : o10[1]) ? t10.replace(/(\d+)(?=\D?)$/, (s10) => (+s10 + 1).toString()) : `${t10} 1`;
  return t10;
}
function Ld(r10, e10, t10) {
  let n10 = { shapes: {}, bindings: {} }, o10 = { shapes: {}, bindings: {} }, s10 = [], a10 = /* @__PURE__ */ new Set(), d10 = /* @__PURE__ */ new Set();
  e10.filter((c10) => !v.getShape(r10, c10, t10).isLocked).forEach((c10) => {
    a10.add(c10);
    let u10 = v.getShape(r10, c10, t10);
    n10.shapes[c10] = u10, o10.shapes[c10] = void 0, u10.children !== void 0 && u10.children.forEach((p10) => {
      a10.add(p10);
      let m10 = v.getShape(r10, p10, t10);
      n10.shapes[p10] = m10, o10.shapes[p10] = void 0;
    }), u10.parentId !== t10 && s10.push(v.getShape(r10, u10.parentId, t10)), u10.assetId && d10.add(u10.assetId);
  }), s10.forEach((c10) => {
    var u10;
    e10.includes(c10.id) || (a10.add(c10.id), n10.shapes[c10.id] = { children: c10.children }, o10.shapes[c10.id] = { children: c10.children.filter((p10) => !e10.includes(p10)) }, ((u10 = o10.shapes[c10.id]) == null ? void 0 : u10.children.length) === 0 && (o10.shapes[c10.id] = void 0, n10.shapes[c10.id] = v.getShape(r10, c10.id, t10)));
  });
  let i10 = v.getPage(r10, t10);
  return Object.values(i10.bindings).filter((c10) => a10.has(c10.fromId) || a10.has(c10.toId)).forEach((c10) => {
    for (let u10 of [c10.toId, c10.fromId]) if (o10.shapes[u10] === void 0) {
      n10.bindings[c10.id] = c10, o10.bindings[c10.id] = void 0;
      let p10 = i10.shapes[u10];
      p10 && p10.handles && Object.values(p10.handles).filter((m10) => m10.bindingId === c10.id).forEach((m10) => {
        var h10, g10, f10, T10, w10, b10;
        n10.shapes[u10] = x(S({}, n10.shapes[u10]), { handles: x(S({}, (h10 = n10.shapes[u10]) == null ? void 0 : h10.handles), { [m10.id]: x(S({}, (f10 = (g10 = n10.shapes[u10]) == null ? void 0 : g10.handles) == null ? void 0 : f10[m10.id]), { bindingId: c10.id }) }) }), a10.has(u10) || (o10.shapes[u10] = x(S({}, o10.shapes[u10]), { handles: x(S({}, (T10 = o10.shapes[u10]) == null ? void 0 : T10.handles), { [m10.id]: x(S({}, (b10 = (w10 = o10.shapes[u10]) == null ? void 0 : w10.handles) == null ? void 0 : b10[m10.id]), { bindingId: void 0 }) }) }));
      });
    }
  }), Object.values(r10.document.pages).flatMap((c10) => Object.values(c10.shapes)).forEach((c10) => {
    "assetId" in c10 && c10.assetId && !a10.has(c10.id) && d10.delete(c10.assetId);
  }), { before: n10, after: o10, assetsToRemove: Array.from(d10) };
}
function Hd(r10, e10, t10 = C$2.uniqueId(), n10 = "Page") {
  let { currentPageId: o10 } = r10, s10 = Object.values(r10.state.document.pages).sort((u10, p10) => {
    var m10, h10;
    return ((m10 = u10.childIndex) != null ? m10 : 0) - ((h10 = p10.childIndex) != null ? h10 : 0);
  }), a10 = s10[s10.length - 1], d10 = (a10 == null ? void 0 : a10.childIndex) ? (a10 == null ? void 0 : a10.childIndex) + 1 : 1, i10 = { id: t10, name: Ad(n10, s10.map((u10) => {
    var p10;
    return (p10 = u10.name) != null ? p10 : "";
  })), childIndex: d10, shapes: {}, bindings: {} }, c10 = { id: t10, selectedIds: [], camera: { point: e10, zoom: 1 }, editingId: void 0, bindingId: void 0, hoveredId: void 0, pointedId: void 0 };
  return { id: "create_page", before: { appState: { currentPageId: o10 }, document: { pages: { [t10]: void 0 }, pageStates: { [t10]: void 0 } } }, after: { appState: { currentPageId: i10.id }, document: { pages: { [t10]: i10 }, pageStates: { [t10]: c10 } } } };
}
function wi(r10, e10, t10 = []) {
  let { currentPageId: n10 } = r10, o10 = {}, s10 = {};
  e10.forEach((i10) => {
    o10[i10.id] = void 0, s10[i10.id] = i10;
  });
  let a10 = {}, d10 = {};
  return t10.forEach((i10) => {
    a10[i10.id] = void 0, d10[i10.id] = i10;
  }), { id: "create", before: { document: { pages: { [n10]: { shapes: o10, bindings: a10 } }, pageStates: { [n10]: { selectedIds: [...r10.selectedIds] } } } }, after: { document: { pages: { [n10]: { shapes: s10, bindings: d10 } }, pageStates: { [n10]: { selectedIds: e10.map((i10) => i10.id) } } } } };
}
function zd(r10, e10) {
  let { currentPageId: t10, document: { pages: n10, pageStates: o10 } } = r10, s10 = Object.values(n10).sort((i10, c10) => (i10.childIndex || 0) - (c10.childIndex || 0)), a10 = s10.findIndex((i10) => i10.id === e10), d10;
  return e10 === t10 ? a10 === s10.length - 1 ? d10 = s10[s10.length - 2].id : d10 = s10[a10 + 1].id : d10 = t10, { id: "delete_page", before: { appState: { currentPageId: e10 }, document: { pages: { [e10]: S({}, n10[e10]) }, pageStates: { [e10]: S({}, o10[e10]) } } }, after: { appState: { currentPageId: d10 }, document: { pages: { [e10]: void 0 }, pageStates: { [e10]: void 0 } } } };
}
var hpe = (r10, e10) => {
  let t10 = S({}, r10);
  return e10.forEach((n10) => t10[n10] = void 0), t10;
};
function xi(r10, e10, t10 = r10.currentPageId) {
  let { pageState: n10, selectedIds: o10, document: { assets: s10 } } = r10, { before: a10, after: d10, assetsToRemove: i10 } = Ld(r10.state, e10, t10), c10 = hpe(s10, i10);
  return { id: "delete", before: { document: { assets: s10, pages: { [t10]: a10 }, pageStates: { [t10]: { selectedIds: [...r10.selectedIds] } } } }, after: { document: { assets: c10, pages: { [t10]: d10 }, pageStates: { [t10]: { selectedIds: o10.filter((u10) => !e10.includes(u10)), hoveredId: n10.hoveredId && e10.includes(n10.hoveredId) ? void 0 : n10.hoveredId } } } } };
}
function Fd(r10, e10, t10) {
  let { currentPageId: n10 } = r10, o10 = e10.map((i10) => r10.getShape(i10)), s10 = Object.fromEntries(gpe(o10, t10).map((i10) => [i10.id, i10])), { before: a10, after: d10 } = v.mutateShapes(r10.state, e10.filter((i10) => s10[i10] !== void 0), (i10) => {
    var c10;
    return { point: (c10 = s10[i10.id]) == null ? void 0 : c10.next };
  }, n10);
  return o10.forEach((i10) => {
    if (i10.type === "group") {
      let c10 = p$4.sub(d10[i10.id].point, a10[i10.id].point);
      i10.children.forEach((u10) => {
        let p10 = r10.getShape(u10);
        a10[p10.id] = { point: p10.point }, d10[p10.id] = { point: p$4.add(p10.point, c10) };
      }), delete a10[i10.id], delete d10[i10.id];
    }
  }), { id: "distribute", before: { document: { pages: { [n10]: { shapes: a10 } }, pageStates: { [n10]: { selectedIds: e10 } } } }, after: { document: { pages: { [n10]: { shapes: d10 } }, pageStates: { [n10]: { selectedIds: e10 } } } } };
}
function gpe(r10, e10) {
  let t10 = r10.map((a10) => {
    let d10 = v.getShapeUtil(a10);
    return { id: a10.id, point: [...a10.point], bounds: d10.getBounds(a10), center: d10.getCenter(a10) };
  }), n10 = t10.length, o10 = C$2.getCommonBounds(t10.map(({ bounds: a10 }) => a10)), s10 = [];
  switch (e10) {
    case "horizontal": {
      let a10 = t10.reduce((d10, i10) => d10 + i10.bounds.width, 0);
      if (a10 > o10.width) {
        let d10 = t10.sort((m10, h10) => m10.bounds.minX - h10.bounds.minX)[0], i10 = t10.sort((m10, h10) => h10.bounds.maxX - m10.bounds.maxX)[0], c10 = t10.filter((m10) => m10 !== d10 && m10 !== i10).sort((m10, h10) => m10.center[0] - h10.center[0]), u10 = (i10.center[0] - d10.center[0]) / (n10 - 1), p10 = d10.center[0] + u10;
        c10.forEach(({ id: m10, point: h10, bounds: g10 }, f10) => {
          s10.push({ id: m10, prev: h10, next: [p10 + u10 * f10 - g10.width / 2, g10.minY] });
        });
      } else {
        let d10 = t10.sort((u10, p10) => u10.center[0] - p10.center[0]), i10 = o10.minX, c10 = (o10.width - a10) / (n10 - 1);
        d10.forEach(({ id: u10, point: p10, bounds: m10 }) => {
          s10.push({ id: u10, prev: p10, next: [i10, m10.minY] }), i10 += m10.width + c10;
        });
      }
      break;
    }
    case "vertical": {
      let a10 = t10.reduce((d10, i10) => d10 + i10.bounds.height, 0);
      if (a10 > o10.height) {
        let d10 = t10.sort((m10, h10) => m10.bounds.minY - h10.bounds.minY)[0], i10 = t10.sort((m10, h10) => h10.bounds.maxY - m10.bounds.maxY)[0], c10 = t10.filter((m10) => m10 !== d10 && m10 !== i10).sort((m10, h10) => m10.center[1] - h10.center[1]), u10 = (i10.center[1] - d10.center[1]) / (n10 - 1), p10 = d10.center[1] + u10;
        c10.forEach(({ id: m10, point: h10, bounds: g10 }, f10) => {
          s10.push({ id: m10, prev: h10, next: [g10.minX, p10 + u10 * f10 - g10.height / 2] });
        });
      } else {
        let d10 = t10.sort((u10, p10) => u10.center[1] - p10.center[1]), i10 = o10.minY, c10 = (o10.height - a10) / (n10 - 1);
        d10.forEach(({ id: u10, point: p10, bounds: m10 }) => {
          s10.push({ id: u10, prev: p10, next: [m10.minX, i10] }), i10 += m10.height + c10;
        });
      }
      break;
    }
  }
  return s10;
}
function jd(r10, e10) {
  let { currentPageId: t10, pageState: { camera: n10 } } = r10, o10 = r10.document.pages[e10], s10 = C$2.uniqueId(), a10 = Object.fromEntries([[o10.id, s10], ...Object.keys(o10.shapes).map((u10) => [u10, C$2.uniqueId()]), ...Object.keys(o10.bindings).map((u10) => [u10, C$2.uniqueId()])]), d10 = Object.fromEntries(Object.entries(o10.shapes).map(([u10, p10]) => [a10[u10], x(S({}, C$2.deepClone(p10)), { id: a10[u10], parentId: a10[p10.parentId] })])), i10 = Object.fromEntries(Object.entries(o10.bindings).map(([u10, p10]) => [a10[u10], x(S({}, C$2.deepClone(p10)), { id: a10[p10.id], fromId: a10[p10.fromId], toId: a10[p10.toId] })]));
  Object.values(o10.bindings).forEach((u10) => {
    let p10 = a10[u10.fromId], m10 = d10[p10].handles;
    m10 && Object.values(m10).forEach((f10) => {
      f10.bindingId === u10.id && (f10.bindingId = a10[u10.id]);
    });
    let h10 = a10[u10.toId], g10 = d10[h10].handles;
    g10 && Object.values(g10).forEach((f10) => {
      f10.bindingId === u10.id && (f10.bindingId = a10[u10.id]);
    });
  });
  let c10 = x(S({}, o10), { id: a10[o10.id], name: o10.name + " Copy", shapes: d10, bindings: i10 });
  return { id: "duplicate_page", before: { appState: { currentPageId: t10 }, document: { pages: { [s10]: void 0 }, pageStates: { [s10]: void 0 } } }, after: { appState: { currentPageId: s10 }, document: { pages: { [s10]: c10 }, pageStates: { [s10]: x(S({}, o10), { id: s10, selectedIds: [], camera: S({}, n10), editingId: void 0, bindingId: void 0, hoveredId: void 0, pointedId: void 0 }) } } } };
}
function Gd(r10, e10, t10) {
  let { selectedIds: n10, currentPageId: o10, page: s10, shapes: a10 } = r10, d10 = { shapes: {}, bindings: {} }, i10 = { shapes: {}, bindings: {} }, c10 = {}, u10 = e10.map((h10) => r10.getShape(h10)).filter((h10) => !e10.includes(h10.parentId));
  u10.forEach((h10) => {
    let g10 = C$2.uniqueId();
    if (d10.shapes[g10] = void 0, i10.shapes[g10] = x(S({}, C$2.deepClone(h10)), { id: g10, childIndex: v.getChildIndexAbove(r10.state, h10.id, o10) }), h10.children && (i10.shapes[g10].children = []), h10.parentId !== o10) {
      let f10 = r10.getShape(h10.parentId);
      d10.shapes[f10.id] = x(S({}, d10.shapes[f10.id]), { children: f10.children }), i10.shapes[f10.id] = x(S({}, i10.shapes[f10.id]), { children: [...(i10.shapes[f10.id] || f10).children, g10] });
    }
    c10[h10.id] = g10;
  }), u10.forEach((h10) => {
    h10.children && h10.children.forEach((g10) => {
      var b10, y10;
      let f10 = r10.getShape(g10), T10 = C$2.uniqueId(), w10 = c10[h10.id];
      d10.shapes[T10] = void 0, i10.shapes[T10] = x(S({}, C$2.deepClone(f10)), { id: T10, parentId: w10, childIndex: v.getChildIndexAbove(r10.state, f10.id, o10) }), c10[g10] = T10, (y10 = (b10 = i10.shapes[c10[h10.id]]) == null ? void 0 : b10.children) == null || y10.push(T10);
    });
  });
  let p10 = new Set(Object.keys(c10));
  Object.values(s10.bindings).filter((h10) => p10.has(h10.fromId) || p10.has(h10.toId)).forEach((h10) => {
    if (p10.has(h10.fromId)) if (p10.has(h10.toId)) {
      let g10 = C$2.uniqueId(), f10 = x(S({}, C$2.deepClone(h10)), { id: g10, fromId: c10[h10.fromId], toId: c10[h10.toId] });
      d10.bindings[g10] = void 0, i10.bindings[g10] = f10;
      let T10 = i10.shapes[f10.fromId];
      Object.values(T10.handles).forEach((w10) => {
        w10.bindingId === h10.id && (w10.bindingId = g10);
      });
    } else {
      let g10 = i10.shapes[c10[h10.fromId]];
      Object.values(g10.handles).forEach((f10) => {
        f10.bindingId === h10.id && (f10.bindingId = void 0);
      });
    }
  });
  let m10 = Object.values(i10.shapes);
  if (t10) {
    let h10 = C$2.getCommonBounds(m10.map((f10) => v.getBounds(f10))), g10 = C$2.getBoundsCenter(h10);
    m10.forEach((f10) => {
      !f10.point || (f10.point = e$3.sub(t10, e$3.sub(g10, f10.point)));
    });
  } else {
    let h10 = [16, 16];
    m10.forEach((g10) => {
      !g10.point || (g10.point = e$3.add(g10.point, h10));
    });
  }
  return m10.forEach((h10) => {
    h10.isLocked && (h10.isLocked = false);
  }), { id: "duplicate", before: { document: { pages: { [o10]: d10 }, pageStates: { [o10]: { selectedIds: n10 } } } }, after: { document: { pages: { [o10]: i10 }, pageStates: { [o10]: { selectedIds: Array.from(p10.values()).map((h10) => c10[h10]) } } } } };
}
function vi(r10, e10, t10) {
  let { selectedIds: n10, currentPageId: o10, page: { shapes: s10 } } = r10, a10 = e10.map((p10) => v.getBounds(s10[p10])), d10 = e10.length === 1 && s10[e10[0]].type === "group", i10 = C$2.getCommonBounds(a10), { before: c10, after: u10 } = v.mutateShapes(r10.state, e10, (p10) => {
    let m10 = v.getBounds(p10), h10 = p10.parentId !== o10;
    switch (t10) {
      case "horizontal": {
        if (h10 && !d10) {
          let f10 = v.getBounds(s10[p10.parentId]), w10 = C$2.getRelativeTransformedBoundingBox(i10, i10, f10, true, false).minX - f10.minX;
          return v.getShapeUtil(p10).transform(p10, x(S({}, m10), { minX: m10.minX + w10, maxX: m10.maxX + w10 }), { type: He$1.TopLeft, scaleX: 1, scaleY: 1, initialShape: p10, transformOrigin: [0.5, 0.5] });
        }
        let g10 = C$2.getRelativeTransformedBoundingBox(i10, i10, m10, true, false);
        return v.getShapeUtil(p10).transform(p10, g10, { type: He$1.TopLeft, scaleX: -1, scaleY: 1, initialShape: p10, transformOrigin: [0.5, 0.5] });
      }
      case "vertical": {
        if (h10 && !d10) {
          let f10 = v.getBounds(s10[p10.parentId]), w10 = C$2.getRelativeTransformedBoundingBox(i10, i10, f10, false, true).minY - f10.minY;
          return v.getShapeUtil(p10).transform(p10, x(S({}, m10), { minY: m10.minY + w10, maxY: m10.maxY + w10 }), { type: He$1.TopLeft, scaleX: 1, scaleY: 1, initialShape: p10, transformOrigin: [0.5, 0.5] });
        }
        let g10 = C$2.getRelativeTransformedBoundingBox(i10, i10, m10, false, true);
        return v.getShapeUtil(p10).transform(p10, g10, { type: He$1.TopLeft, scaleX: 1, scaleY: -1, initialShape: p10, transformOrigin: [0.5, 0.5] });
      }
    }
  }, o10, true);
  return { id: "flip", before: { document: { pages: { [o10]: { shapes: c10 } }, pageStates: { [o10]: { selectedIds: n10 } } } }, after: { document: { pages: { [o10]: { shapes: u10 } }, pageStates: { [o10]: { selectedIds: e10 } } } } };
}
function Vd(r10, e10, t10, n10) {
  var R10, U10;
  if (e10.length < 2) return;
  let o10 = {}, s10 = {}, a10 = {}, d10 = {}, i10 = [...e10], c10 = [], u10 = [], p10 = [];
  for (let L10 of e10) {
    let k10 = r10.getShape(L10);
    if (!k10.isLocked) if (k10.children === void 0) c10.push(k10);
    else {
      let I10 = k10.children.filter((q10) => !r10.getShape(q10).isLocked);
      p10.push(k10), i10.push(...I10), c10.push(...I10.map((q10) => r10.getShape(q10)).filter(Boolean));
    }
  }
  if (c10.every((L10) => L10.parentId === c10[0].parentId) && c10[0].parentId !== n10 && ((R10 = r10.getShape(c10[0].parentId).children) == null ? void 0 : R10.length) === i10.length) return;
  let m10 = v.flattenPage(r10.state, n10), h10 = Object.fromEntries(c10.map((L10) => [L10.id, m10.indexOf(L10)])), g10 = c10.sort((L10, k10) => h10[L10.id] - h10[k10.id]), f10 = n10, T10 = (g10.filter((L10) => L10.parentId === n10)[0] || g10[0]).childIndex, w10 = C$2.getCommonBounds(c10.map((L10) => v.getBounds(L10)));
  for (o10[t10] = void 0, s10[t10] = v.getShapeUtil("group").create({ id: t10, childIndex: T10, parentId: f10, point: [w10.minX, w10.minY], size: [w10.width, w10.height], children: g10.map((L10) => L10.id) }), g10.forEach((L10, k10) => {
    if (L10.parentId !== n10) {
      let I10 = r10.getShape(L10.parentId);
      p10.push(I10);
    }
    o10[L10.id] = x(S({}, o10[L10.id]), { parentId: L10.parentId, childIndex: L10.childIndex }), s10[L10.id] = x(S({}, s10[L10.id]), { parentId: t10, childIndex: k10 + 1 });
  }); p10.length > 0; ) {
    let L10 = p10.pop();
    if (!L10) break;
    let k10 = (((U10 = o10[L10.id]) == null ? void 0 : U10.children) || L10.children).filter((I10) => I10 && !(i10.includes(I10) || u10.includes(I10)));
    k10.length === 0 ? (o10[L10.id] = L10, s10[L10.id] = void 0, L10.parentId !== n10 && (u10.push(L10.id), p10.push(r10.getShape(L10.parentId)))) : (o10[L10.id] = x(S({}, o10[L10.id]), { children: L10.children }), s10[L10.id] = x(S({}, s10[L10.id]), { children: k10 }));
  }
  let { bindings: b10 } = r10, y10 = new Set(u10);
  return b10.forEach((L10) => {
    for (let k10 of [L10.toId, L10.fromId]) if (y10.has(k10)) {
      a10[L10.id] = L10, d10[L10.id] = void 0;
      let I10 = r10.getShape(k10);
      I10.handles && Object.values(I10.handles).filter((q10) => q10.bindingId === L10.id).forEach((q10) => {
        var de2, le2;
        o10[k10] = x(S({}, o10[k10]), { handles: x(S({}, (de2 = o10[k10]) == null ? void 0 : de2.handles), { [q10.id]: { bindingId: L10.id } }) }), u10.includes(k10) || (s10[k10] = x(S({}, s10[k10]), { handles: x(S({}, (le2 = s10[k10]) == null ? void 0 : le2.handles), { [q10.id]: { bindingId: void 0 } }) }));
      });
    }
  }), { id: "group", before: { document: { pages: { [n10]: { shapes: o10, bindings: a10 } }, pageStates: { [n10]: { selectedIds: e10 } } } }, after: { document: { pages: { [n10]: { shapes: s10, bindings: a10 } }, pageStates: { [n10]: { selectedIds: [t10] } } } } };
}
function Nd(r10, e10, t10, n10, o10) {
  let { page: s10 } = r10, a10 = { before: { shapes: {}, bindings: {} }, after: { shapes: {}, bindings: {} } }, d10 = { before: { shapes: {}, bindings: {} }, after: { shapes: {}, bindings: {} } }, i10 = /* @__PURE__ */ new Set(), c10 = /* @__PURE__ */ new Set();
  e10.map((b10) => r10.getShape(b10, n10)).filter((b10) => !b10.isLocked).forEach((b10) => {
    i10.add(b10.id), c10.add(b10), b10.children !== void 0 && b10.children.forEach((y10) => {
      i10.add(y10), c10.add(r10.getShape(y10, n10));
    });
  });
  let u10 = v.getTopChildIndex(r10.state, o10), p10 = Array.from(c10.values());
  p10.forEach((b10, y10) => {
    if (a10.before.shapes[b10.id] = b10, a10.after.shapes[b10.id] = void 0, d10.before.shapes[b10.id] = void 0, d10.after.shapes[b10.id] = b10, !i10.has(b10.parentId) && (d10.after.shapes[b10.id] = x(S({}, b10), { parentId: o10, childIndex: u10 + y10 }), b10.parentId !== n10)) {
      let R10 = r10.getShape(b10.parentId, n10);
      a10.before.shapes[R10.id] = { children: R10.children }, a10.after.shapes[R10.id] = { children: R10.children.filter((U10) => U10 !== b10.id) };
    }
  }), Object.values(s10.bindings).filter((b10) => i10.has(b10.fromId) || i10.has(b10.toId)).forEach((b10) => {
    a10.before.bindings[b10.id] = b10, a10.after.bindings[b10.id] = void 0;
    let y10 = r10.getShape(b10.fromId, n10);
    if (i10.has(b10.fromId) && i10.has(b10.toId)) d10.before.bindings[b10.id] = void 0, d10.after.bindings[b10.id] = b10;
    else if (i10.has(b10.fromId)) {
      let U10 = r10.getShape(b10.fromId, n10), k10 = Object.values(y10.handles).find((q10) => q10.bindingId === b10.id).id, I10 = d10.after.shapes[U10.id];
      I10.handles = x(S({}, I10.handles), { [k10]: x(S({}, I10.handles[k10]), { bindingId: void 0 }) });
    } else {
      let U10 = r10.getShape(b10.fromId, n10), L10 = Object.values(y10.handles).find((k10) => k10.bindingId === b10.id);
      a10.before.shapes[U10.id] = { handles: { [L10.id]: { bindingId: b10.id } } }, a10.after.shapes[U10.id] = { handles: { [L10.id]: { bindingId: void 0 } } };
    }
  });
  let m10 = r10.state.document.pageStates[o10], h10 = C$2.getCommonBounds(p10.map((b10) => v.getBounds(b10))), g10 = v.getCameraZoom(t10.width < t10.height ? (t10.width - 128) / h10.width : (t10.height - 128) / h10.height), f10 = (t10.width - h10.width * g10) / 2 / g10, T10 = (t10.height - h10.height * g10) / 2 / g10, w10 = e$3.toFixed(e$3.add([-h10.minX, -h10.minY], [f10, T10]));
  return { id: "move_to_page", before: { appState: { currentPageId: n10 }, document: { pages: { [n10]: a10.before, [o10]: d10.before }, pageStates: { [n10]: { selectedIds: e10 }, [o10]: { selectedIds: m10.selectedIds, camera: m10.camera } } } }, after: { appState: { currentPageId: o10 }, document: { pages: { [n10]: a10.after, [o10]: d10.after }, pageStates: { [n10]: { selectedIds: [] }, [o10]: { selectedIds: e10, camera: { zoom: g10, point: w10 } } } } } };
}
function Wd(r10, e10, t10) {
  let { pages: n10 } = r10.document, o10 = n10[e10], s10 = Object.values(n10).sort((i10, c10) => {
    var u10, p10;
    return ((u10 = i10.childIndex) != null ? u10 : 0) - ((p10 = c10.childIndex) != null ? p10 : 0);
  }), a10 = s10.indexOf(o10), d10 = [...s10];
  return d10.splice(a10, 1), d10.splice(t10 > a10 ? t10 - 1 : t10, 0, o10), { id: "move_page", before: { document: { pages: Object.fromEntries(s10.map((i10) => [i10.id, { childIndex: i10.childIndex }])) } }, after: { document: { pages: Object.fromEntries(d10.map((i10, c10) => [i10.id, { childIndex: c10 }])) } } };
}
function qo(r10, e10, t10) {
  let { currentPageId: n10, page: o10 } = r10, s10 = new Set(e10.map((u10) => r10.getShape(u10).parentId)), a10 = { before: {}, after: {} }, d10, i10, c10;
  return Array.from(s10.values()).forEach((u10) => {
    let p10 = [];
    if (u10 === o10.id) p10 = Object.values(o10.shapes).sort((g10, f10) => g10.childIndex - f10.childIndex);
    else {
      let g10 = r10.getShape(u10);
      if (!g10.children) throw Error("No children in parent!");
      p10 = g10.children.map((f10) => r10.getShape(f10)).sort((f10, T10) => f10.childIndex - T10.childIndex);
    }
    let m10 = p10.map((g10) => g10.id), h10 = e10.filter((g10) => m10.includes(g10)).map((g10) => m10.indexOf(g10)).sort((g10, f10) => g10 - f10);
    if (h10.length !== m10.length) switch (t10) {
      case "toBack": {
        for (let g10 = 0; g10 < m10.length; g10++) if (!h10.includes(g10)) {
          d10 = g10;
          break;
        }
        i10 = p10[d10].childIndex, c10 = i10 / (h10.length + 1), a10 = v.mutateShapes(r10.state, h10.map((g10) => p10[g10].id).reverse(), (g10, f10) => ({ childIndex: i10 - (f10 + 1) * c10 }), n10);
        break;
      }
      case "toFront": {
        for (let g10 = m10.length - 1; g10 >= 0; g10--) if (!h10.includes(g10)) {
          d10 = g10;
          break;
        }
        i10 = p10[d10].childIndex, c10 = 1, a10 = v.mutateShapes(r10.state, h10.map((g10) => p10[g10].id), (g10, f10) => ({ childIndex: i10 + (f10 + 1) }), n10);
        break;
      }
      case "backward": {
        let g10 = {};
        for (let f10 = m10.length - 1; f10 >= 0; f10--) if (h10.includes(f10)) {
          for (let T10 = f10; T10 >= 0; T10--) if (!h10.includes(T10)) {
            let w10 = p10[T10].childIndex, b10, y10;
            T10 === 0 ? (b10 = w10 / 2, y10 = w10 / 2 / (f10 - T10 + 1)) : (b10 = p10[T10 - 1].childIndex, y10 = (w10 - b10) / (f10 - T10 + 1), b10 += y10);
            for (let R10 = 0; R10 < f10 - T10; R10++) g10[p10[T10 + R10 + 1].id] = b10 + y10 * R10;
            break;
          }
        }
        Object.values(g10).length > 0 && (a10 = v.mutateShapes(r10.state, h10.map((f10) => p10[f10].id), (f10) => ({ childIndex: g10[f10.id] }), n10));
        break;
      }
      case "forward": {
        let g10 = {};
        for (let f10 = 0; f10 < m10.length; f10++) if (h10.includes(f10)) {
          for (let T10 = f10; T10 < m10.length; T10++) if (!h10.includes(T10)) {
            i10 = p10[T10].childIndex;
            let w10 = T10 === m10.length - 1 ? 1 : (p10[T10 + 1].childIndex - i10) / (T10 - f10 + 1);
            for (let b10 = 0; b10 < T10 - f10; b10++) g10[p10[f10 + b10].id] = i10 + w10 * (b10 + 1);
            break;
          }
        }
        Object.values(g10).length > 0 && (a10 = v.mutateShapes(r10.state, h10.map((f10) => p10[f10].id), (f10) => ({ childIndex: g10[f10.id] }), n10));
        break;
      }
    }
  }), { id: "move", before: { document: { pages: { [n10]: { shapes: a10.before } }, pageStates: { [n10]: { selectedIds: e10 } } } }, after: { document: { pages: { [n10]: { shapes: a10.after } }, pageStates: { [n10]: { selectedIds: e10 } } } } };
}
function Ud(r10, e10, t10) {
  let { page: n10 } = r10;
  return { id: "rename_page", before: { document: { pages: { [e10]: { name: n10.name } } } }, after: { document: { pages: { [e10]: { name: t10 } } } } };
}
function Ii(r10, e10, t10) {
  let { currentPageId: n10 } = r10, { before: o10, after: s10 } = v.mutateShapes(r10.state, e10, (a10) => {
    var d10, i10;
    return (i10 = (d10 = r10.getShapeUtil(a10)).onDoubleClickBoundsHandle) == null ? void 0 : i10.call(d10, a10);
  }, t10);
  return { id: "reset_bounds", before: { document: { pages: { [n10]: { shapes: o10 } }, pageStates: { [n10]: { selectedIds: e10 } } } }, after: { document: { pages: { [n10]: { shapes: s10 } }, pageStates: { [n10]: { selectedIds: e10 } } } } };
}
var bpe = Math.PI * 2;
function _d(r10, e10, t10 = -bpe / 4) {
  let { currentPageId: n10 } = r10, o10 = {}, s10 = {}, a10 = e10.flatMap((i10) => {
    let c10 = r10.getShape(i10);
    return c10.children ? c10.children.map((u10) => r10.getShape(u10)) : c10;
  }).filter((i10) => !i10.isLocked), d10 = C$2.getBoundsCenter(C$2.getCommonBounds(a10.map((i10) => v.getBounds(i10))));
  return a10.forEach((i10) => {
    let c10 = v.getRotatedShapeMutation(i10, v.getCenter(i10), d10, t10);
    !c10 || (o10[i10.id] = v.getBeforeShape(i10, c10), s10[i10.id] = c10);
  }), { id: "rotate", before: { document: { pages: { [n10]: { shapes: o10 } }, pageStates: { [n10]: { selectedIds: e10 } } } }, after: { document: { pages: { [n10]: { shapes: s10 } }, pageStates: { [n10]: { selectedIds: e10 } } } } };
}
function Zd(r10, e10, t10) {
  let { currentPageId: n10, selectedIds: o10 } = r10, s10 = e10.map((p10) => r10.getShape(p10)), a10 = s10.map((p10) => v.getBounds(p10)), d10 = C$2.getCommonBounds(a10), i10 = e10.flatMap((p10) => {
    let m10 = r10.getShape(p10);
    return m10.children ? m10.children : m10.id;
  }).filter((p10) => !r10.getShape(p10).isLocked), { before: c10, after: u10 } = v.mutateShapes(r10.state, i10, (p10) => {
    let m10 = v.getBounds(p10);
    switch (t10) {
      case "horizontal": {
        let h10 = x(S({}, m10), { minX: d10.minX, maxX: d10.maxX, width: d10.width });
        return v.getShapeUtil(p10).transformSingle(p10, h10, { type: He$1.TopLeft, scaleX: h10.width / m10.width, scaleY: 1, initialShape: p10, transformOrigin: [0.5, 0.5] });
      }
      case "vertical": {
        let h10 = x(S({}, m10), { minY: d10.minY, maxY: d10.maxY, height: d10.height });
        return v.getShapeUtil(p10).transformSingle(p10, h10, { type: He$1.TopLeft, scaleX: 1, scaleY: h10.height / m10.height, initialShape: p10, transformOrigin: [0.5, 0.5] });
      }
    }
  }, n10);
  return s10.forEach((p10) => {
    p10.type === "group" && (delete c10[p10.id], delete u10[p10.id]);
  }), { id: "stretch", before: { document: { pages: { [n10]: { shapes: c10 } }, pageStates: { [n10]: { selectedIds: o10 } } } }, after: { document: { pages: { [n10]: { shapes: u10 } }, pageStates: { [n10]: { selectedIds: e10 } } } } };
}
function Xd(r10, e10, t10) {
  let { currentPageId: n10, selectedIds: o10 } = r10, s10 = e10.flatMap((i10) => v.getDocumentBranch(r10.state, i10, n10)).filter((i10) => !r10.getShape(i10).isLocked), a10 = {}, d10 = {};
  return s10.map((i10) => r10.getShape(i10)).filter((i10) => !i10.isLocked).forEach((i10) => {
    a10[i10.id] = { style: S({}, Object.fromEntries(Object.keys(t10).map((c10) => [c10, i10.style[c10]]))) }, d10[i10.id] = { style: t10 }, i10.type === "text" && (a10[i10.id].point = i10.point, d10[i10.id].point = e$3.toFixed(e$3.add(i10.point, e$3.sub(r10.getShapeUtil(i10).getCenter(i10), r10.getShapeUtil(i10).getCenter(x(S({}, i10), { style: S(S({}, i10.style), t10) }))))));
  }), { id: "style", before: { document: { pages: { [n10]: { shapes: a10 } }, pageStates: { [n10]: { selectedIds: o10 } } }, appState: { currentStyle: S({}, r10.appState.currentStyle) } }, after: { document: { pages: { [n10]: { shapes: d10 } }, pageStates: { [n10]: { selectedIds: e10 } } }, appState: { currentStyle: t10 } } };
}
function qd(r10, e10, t10) {
  let { currentPageId: n10, selectedIds: o10 } = r10, s10 = Object.fromEntries(e10.map((d10) => {
    var i10;
    return [d10, { decorations: { [t10]: (i10 = r10.getShape(d10).decorations) == null ? void 0 : i10[t10] } }];
  })), a10 = Object.fromEntries(e10.filter((d10) => !r10.getShape(d10).isLocked).map((d10) => {
    var i10;
    return [d10, { decorations: { [t10]: ((i10 = r10.getShape(d10).decorations) == null ? void 0 : i10[t10]) ? void 0 : "arrow" } }];
  }));
  return { id: "toggle_decorations", before: { document: { pages: { [n10]: { shapes: s10 } }, pageStates: { [n10]: { selectedIds: o10 } } } }, after: { document: { pages: { [n10]: { shapes: a10 } }, pageStates: { [n10]: { selectedIds: e10 } } } } };
}
function Qr(r10, e10, t10) {
  let { currentPageId: n10 } = r10, o10 = e10.map((i10) => r10.getShape(i10)).filter((i10) => t10 === "isLocked" ? true : !i10.isLocked), s10 = o10.every((i10) => i10[t10]), a10 = {}, d10 = {};
  return o10.forEach((i10) => {
    a10[i10.id] = { [t10]: i10[t10] }, d10[i10.id] = { [t10]: !s10 };
  }), { id: "toggle", before: { document: { pages: { [n10]: { shapes: a10 } }, pageStates: { [n10]: { selectedIds: e10 } } } }, after: { document: { pages: { [n10]: { shapes: d10 } }, pageStates: { [n10]: { selectedIds: e10 } } } } };
}
function Qd(r10, e10, t10) {
  let { currentPageId: n10, selectedIds: o10 } = r10;
  r10.rotationInfo.selectedIds = [...o10];
  let s10 = { shapes: {}, bindings: {} }, a10 = { shapes: {}, bindings: {} }, d10 = e10.flatMap((u10) => {
    let p10 = r10.getShape(u10);
    return p10.children ? p10.children : p10.id;
  }).filter((u10) => !r10.getShape(u10).isLocked), i10 = v.mutateShapes(r10.state, d10, (u10) => ({ point: e$3.toFixed(e$3.add(u10.point, t10)) }), n10);
  return s10.shapes = i10.before, a10.shapes = i10.after, v.getBindings(r10.state, n10).filter((u10) => e10.includes(u10.fromId) && !e10.includes(u10.toId)).forEach((u10) => {
    s10.bindings[u10.id] = u10, a10.bindings[u10.id] = void 0;
    for (let p10 of [u10.toId, u10.fromId]) {
      let m10 = r10.getShape(p10);
      !m10.handles || Object.values(m10.handles).filter((h10) => h10.bindingId === u10.id).forEach((h10) => {
        var g10, f10;
        s10.shapes[p10] = x(S({}, s10.shapes[p10]), { handles: x(S({}, (g10 = s10.shapes[p10]) == null ? void 0 : g10.handles), { [h10.id]: { bindingId: u10.id } }) }), a10.shapes[p10] = x(S({}, a10.shapes[p10]), { handles: x(S({}, (f10 = a10.shapes[p10]) == null ? void 0 : f10.handles), { [h10.id]: { bindingId: void 0 } }) });
      });
    }
  }), { id: "translate", before: { document: { pages: { [n10]: s10 }, pageStates: { [n10]: { selectedIds: e10 } } } }, after: { document: { pages: { [n10]: a10 }, pageStates: { [n10]: { selectedIds: e10 } } } } };
}
function ec(r10, e10, t10, n10) {
  let { bindings: o10 } = r10, s10 = {}, a10 = {}, d10 = {}, i10 = {}, c10 = e10, u10 = e10.filter((p10) => !t10.find((m10) => m10.id === p10));
  return t10.filter((p10) => !p10.isLocked).forEach((p10) => {
    let m10 = [], h10 = [];
    s10[p10.id] = p10, a10[p10.id] = void 0, p10.children.forEach((b10) => {
      u10.push(b10);
      let y10 = r10.getShape(b10, n10);
      m10.push(y10);
    });
    let g10 = p10.childIndex, T10 = (v.getChildIndexAbove(r10.state, p10.id, n10) - g10) / m10.length;
    m10.sort((b10, y10) => b10.childIndex - y10.childIndex).forEach((b10, y10) => {
      s10[b10.id] = { parentId: b10.parentId, childIndex: b10.childIndex }, a10[b10.id] = { parentId: n10, childIndex: g10 + T10 * y10 };
    }), o10.filter((b10) => b10.toId === p10.id || b10.fromId === p10.id).forEach((b10) => {
      for (let y10 of [b10.toId, b10.fromId]) if (a10[y10] === void 0) {
        d10[b10.id] = b10, i10[b10.id] = void 0;
        let R10 = r10.getShape(y10, n10);
        R10.handles && Object.values(R10.handles).filter((U10) => U10.bindingId === b10.id).forEach((U10) => {
          var L10, k10;
          s10[y10] = x(S({}, s10[y10]), { handles: x(S({}, (L10 = s10[y10]) == null ? void 0 : L10.handles), { [U10.id]: { bindingId: b10.id } }) }), h10.includes(y10) || (a10[y10] = x(S({}, a10[y10]), { handles: x(S({}, (k10 = a10[y10]) == null ? void 0 : k10.handles), { [U10.id]: { bindingId: void 0 } }) }));
        });
      }
    });
  }), { id: "ungroup", before: { document: { pages: { [n10]: { shapes: s10, bindings: d10 } }, pageStates: { [n10]: { selectedIds: c10 } } } }, after: { document: { pages: { [n10]: { shapes: a10, bindings: d10 } }, pageStates: { [n10]: { selectedIds: u10 } } } } };
}
function Di(r10, e10, t10) {
  let n10 = e10.map((s10) => s10.id), o10 = v.mutateShapes(r10.state, n10.filter((s10) => !r10.getShape(s10, t10).isLocked), (s10, a10) => e10[a10], t10);
  return { id: "update", before: { document: { pages: { [t10]: { shapes: o10.before } } } }, after: { document: { pages: { [t10]: { shapes: o10.after } } } } };
}
function tc(r10, e10, t10) {
  let { currentPageId: n10, selectedIds: o10 } = r10, s10 = e10.map((c10) => r10.getShape(c10)).filter((c10) => t10.isLocked ? true : !c10.isLocked), a10 = {}, d10 = {}, i10 = Object.keys(t10);
  return s10.forEach((c10) => {
    a10[c10.id] = Object.fromEntries(i10.map((u10) => [u10, c10[u10]])), d10[c10.id] = t10;
  }), { id: "set_props", before: { document: { pages: { [n10]: { shapes: a10 } }, pageStates: { [n10]: { selectedIds: o10 } } } }, after: { document: { pages: { [n10]: { shapes: d10 } }, pageStates: { [n10]: { selectedIds: o10 } } } } };
}
function nc(r10, e10, t10 = {}) {
  let { currentPageId: n10 } = r10, { point: o10, select: s10, overwrite: a10 } = t10, d10 = r10.document.pages[n10], i10 = { shapes: {}, bindings: {} }, c10 = {}, u10 = { shapes: {}, bindings: {} };
  if (a10) {
    for (let m10 of e10.shapes) i10.shapes[m10.id] = d10.shapes[m10.id], u10.shapes[m10.id] = m10;
    if (e10.bindings) for (let m10 of e10.bindings) i10.bindings[m10.id] = d10.bindings[m10.id], u10.bindings[m10.id] = m10;
    if (e10.assets) for (let m10 of e10.assets) c10[m10.id] = m10;
  } else {
    let m10 = {}, h10 = v.getTopChildIndex(r10.state, n10), g10 = e10.shapes.sort((w10, b10) => w10.childIndex - b10.childIndex).map((w10) => {
      let b10 = C$2.uniqueId();
      return m10[w10.id] = b10, x(S({}, C$2.deepClone(w10)), { id: b10 });
    }), f10 = /* @__PURE__ */ new Set();
    for (; g10.length > 0; ) {
      let w10 = g10.shift();
      if (!w10) break;
      if (f10.add(w10.id), w10.parentId === "currentPageId") w10.parentId = n10, w10.childIndex = h10++;
      else {
        w10.parentId = m10[w10.parentId];
        let b10 = u10.shapes[w10.parentId];
        if (!b10) {
          f10.has(w10.id) && (w10.parentId = "currentPageId"), g10.push(w10);
          continue;
        }
        b10.children.push(w10.id);
      }
      w10.children && (w10.children = []), i10.shapes[w10.id] = void 0, u10.shapes[w10.id] = w10;
    }
    Object.values(u10.shapes).forEach((w10) => {
      w10.children && w10.children.length === 0 && (delete i10.shapes[w10.id], delete u10.shapes[w10.id]);
    }), e10.bindings && e10.bindings.forEach((w10) => {
      let b10 = C$2.uniqueId();
      m10[w10.id] = b10;
      let y10 = m10[w10.toId], R10 = m10[w10.fromId];
      if (!y10 || !R10) {
        if (R10) {
          let I10 = u10.shapes[R10].handles;
          I10 && Object.values(I10).forEach((q10) => {
            q10.bindingId === w10.id && (q10.bindingId = void 0);
          });
        }
        if (y10) {
          let I10 = u10.shapes[y10].handles;
          I10 && Object.values(I10).forEach((q10) => {
            q10.bindingId === w10.id && (q10.bindingId = void 0);
          });
        }
        return;
      }
      let U10 = u10.shapes[R10].handles;
      U10 && Object.values(U10).forEach((I10) => {
        I10.bindingId === w10.id && (I10.bindingId = b10);
      }), u10.shapes[y10].handles && Object.values(u10.shapes[y10].handles).forEach((I10) => {
        I10.bindingId === w10.id && (I10.bindingId = b10);
      });
      let k10 = x(S({}, C$2.deepClone(w10)), { id: b10, toId: y10, fromId: R10 });
      i10.bindings[k10.id] = void 0, u10.bindings[k10.id] = k10;
    });
    let T10 = Object.values(u10.shapes);
    if (T10.length > 0) if (o10) {
      let w10 = C$2.getCommonBounds(T10.map((y10) => v.getBounds(y10))), b10 = C$2.getBoundsCenter(w10);
      T10.forEach((y10) => {
        !y10.point || (y10.point = e$3.sub(o10, e$3.sub(b10, y10.point)));
      });
    } else {
      let w10 = C$2.getCommonBounds(T10.map(v.getBounds));
      if (!(C$2.boundsContain(r10.viewport, w10) || C$2.boundsCollide(r10.viewport, w10))) {
        let b10 = e$3.toFixed(r10.getPagePoint(r10.centerPoint)), y10 = C$2.centerBounds(w10, b10), R10 = e$3.sub(C$2.getBoundsCenter(y10), C$2.getBoundsCenter(w10));
        T10.forEach((U10) => {
          U10.point = e$3.toFixed(e$3.add(U10.point, R10));
        });
      }
    }
    if (e10.assets) for (let w10 of e10.assets) c10[w10.id] = w10;
  }
  let p10 = document.createElement("textarea");
  return Object.values(u10.shapes).forEach((m10) => {
    "text" in m10 && (p10.innerHTML = m10.text, m10.text = p10.value), "label" in m10 && (p10.innerHTML = m10.label, m10.label = p10.value);
  }), p10.remove(), { id: "insert", before: { document: { pages: { [n10]: i10 }, pageStates: { [n10]: { selectedIds: [...r10.selectedIds] } } } }, after: { document: { pages: { [n10]: u10 }, assets: c10, pageStates: { [n10]: { selectedIds: s10 ? Object.keys(u10.shapes) : [...r10.selectedIds] } } } } };
}
var Po = {};
yc(Po, { fileToBase64: () => Ri, fileToText: () => Ai, getImageSizeFromSrc: () => Li, getVideoSizeFromSrc: () => Hi, loadFileHandle: () => Pi, migrate: () => Sn, openAssetsFromFileSystem: () => Bi, openFromFileSystem: () => Ei, saveFileHandle: () => Mi, saveToFileSystem: () => es });
function Sn(r10, e10) {
  let { document: t10, settings: n10 } = r10, { version: o10 = 0 } = t10;
  "assets" in t10 || (t10.assets = {});
  let s10 = /* @__PURE__ */ new Set();
  return Object.values(t10.pages).forEach((a10) => Object.values(a10.shapes).forEach((d10) => {
    let { parentId: i10, children: c10, assetId: u10 } = d10;
    u10 && s10.add(u10), i10 !== a10.id && !a10.shapes[i10] && (console.warn("Encountered a shape with a missing parent!"), d10.parentId = a10.id), d10.type === "group" && c10 && c10.forEach((p10) => {
      a10.shapes[p10] || (console.warn("Encountered a parent with a missing child!", d10.id, p10), c10 == null || c10.splice(c10.indexOf(p10), 1));
    });
  })), Object.keys(t10.assets).forEach((a10) => {
    s10.has(a10) || delete t10.assets[a10];
  }), o10 !== e10 && (o10 < 14 && Object.values(t10.pages).forEach((a10) => {
    Object.values(a10.shapes).filter((d10) => d10.type === "text").forEach((d10) => d10.style.font === "script");
  }), o10 <= 13 && Object.values(t10.pages).forEach((a10) => {
    Object.values(a10.bindings).forEach((d10) => {
      Object.assign(d10, d10.meta);
    }), Object.values(a10.shapes).forEach((d10) => {
      Object.entries(d10.style).forEach(([i10, c10]) => {
        typeof c10 == "string" && (d10.style[i10] = c10.toLowerCase());
      }), d10.type === "arrow" && d10.decorations && Object.entries(d10.decorations).forEach(([i10, c10]) => {
        c10 === "Arrow" && (d10.decorations = x(S({}, d10.decorations), { [i10]: "arrow" }));
      });
    });
  }), o10 <= 13.1 && (t10.name = "New Document"), o10 < 15 && (t10.assets = {}), Object.values(t10.pages).forEach((a10) => {
    Object.values(a10.shapes).forEach((d10) => {
      o10 < 15.2 && (d10.type === "image" || d10.type === "video") && (d10.style.isFilled = true), o10 < 15.3 && (d10.type === "rectangle" || d10.type === "triangle" || d10.type === "ellipse" || d10.type === "arrow") && (d10.label = d10.text || "", d10.labelPoint = [0.5, 0.5]);
    });
  }), o10 < 15.4 && (n10.dockPosition = "bottom"), o10 < 15.5 && (n10.exportBackground = "transparent")), Object.values(t10.pageStates).forEach((a10) => {
    a10.selectedIds = a10.selectedIds.filter((d10) => t10.pages[a10.id].shapes[d10] !== void 0), a10.bindingId = void 0, a10.editingId = void 0, a10.hoveredId = void 0, a10.pointedId = void 0;
  }), t10.version = e10, r10;
}
var oc = { mode: "readwrite" }, Ipe = (r10) => pe(void 0, null, function* () {
  return (yield r10.queryPermission(oc)) === "granted" || (yield r10.requestPermission(oc)) === "granted";
});
function Pi() {
  return pe(this, null, function* () {
    if (typeof Window == "undefined" || !("_location" in Window)) return;
    let r10 = yield get(`Tldraw_file_handle_${window.location.origin}`);
    return r10 || null;
  });
}
function Mi(r10) {
  return pe(this, null, function* () {
    return set(`Tldraw_file_handle_${window.location.origin}`, r10);
  });
}
function es(r10, e$12, t10) {
  return pe(this, null, function* () {
    let n10 = { name: r10.name || "New Document", fileHandle: e$12 != null ? e$12 : null, document: r10 }, o$12 = JSON.stringify(n10), s10 = new Blob([o$12], { type: "application/vnd.Tldraw+json" });
    if (e$12 && !(yield Ipe(e$12))) return null;
    let a10 = !e && (t10 == null ? void 0 : t10.length) ? t10 : `${n10.name}`, d10 = yield o(s10, { fileName: `${a10}${zr}`, description: "Tldraw File", extensions: [`${zr}`] }, e$12);
    return yield Mi(d10), d10;
  });
}
function Ei() {
  return pe(this, null, function* () {
    var o10;
    let r10 = yield n({ description: "Tldraw File", extensions: [`${zr}`], multiple: false });
    if (!r10) return null;
    let e10 = yield new Promise((s10) => {
      let a10 = new FileReader();
      a10.onloadend = () => {
        a10.readyState === FileReader.DONE && s10(a10.result);
      }, a10.readAsText(r10, "utf8");
    }), t10 = JSON.parse(e10);
    if ("tldrawFileFormatVersion" in t10) return alert("This file was created in a newer version of tldraw. Please visit beta.tldraw.com to open it."), null;
    let n$12 = (o10 = r10.handle) != null ? o10 : null;
    return yield Mi(n$12), { fileHandle: n$12, document: t10.document };
  });
}
function Bi() {
  return pe(this, null, function* () {
    return n({ description: "Image or Video", extensions: [...Or, ...Fr], multiple: true });
  });
}
function Ri(r10) {
  return new Promise((e10, t10) => {
    if (r10) {
      let n10 = new FileReader();
      n10.readAsDataURL(r10), n10.onload = () => e10(n10.result), n10.onerror = (o10) => t10(o10), n10.onabort = (o10) => t10(o10);
    }
  });
}
function Ai(r10) {
  return new Promise((e10, t10) => {
    if (r10) {
      let n10 = new FileReader();
      n10.readAsText(r10), n10.onload = () => e10(n10.result), n10.onerror = (o10) => t10(o10), n10.onabort = (o10) => t10(o10);
    }
  });
}
function Li(r10) {
  return new Promise((e10, t10) => {
    let n10 = new Image();
    n10.onload = () => e10([n10.width, n10.height]), n10.onerror = () => t10(new Error("Could not get image size")), n10.src = r10;
  });
}
function Hi(r10) {
  return new Promise((e10, t10) => {
    let n10 = document.createElement("video");
    n10.onloadedmetadata = () => e10([n10.videoWidth, n10.videoHeight]), n10.onerror = () => t10(new Error("Could not get video size")), n10.src = r10;
  });
}
fr(Po, QDe);
var Ye = class {
  constructor(e10) {
    this.app = e10;
  }
};
var zi = class extends Ye {
  constructor(e10, t10, n10, o10 = false) {
    super(e10);
    l(this, "type", "arrow");
    l(this, "performanceMode");
    l(this, "status", "translatingHandle");
    l(this, "newStartBindingId", C$2.uniqueId());
    l(this, "draggedBindingId", C$2.uniqueId());
    l(this, "didBind", false);
    l(this, "initialShape");
    l(this, "handleId");
    l(this, "bindableShapeIds");
    l(this, "initialBinding");
    l(this, "startBindingShapeId");
    l(this, "isCreate");
    l(this, "start", () => {
    });
    l(this, "update", () => {
      var U10, L10, k10;
      let { initialShape: e11 } = this, { currentPoint: t11, shiftKey: n11, altKey: o11, metaKey: s11, currentGrid: a11, settings: { showGrid: d11 } } = this.app, i11 = this.app.getShape(e11.id);
      if (i11.isLocked) return;
      let { handles: c11 } = e11, u11 = this.handleId;
      if (!c11[u11].canBind) return;
      let p11 = e$3.sub(t11, e$3.add(c11[u11].point, e11.point));
      if (n11) {
        let I10 = o11 ? e$3.med(c11.start.point, c11.end.point) : c11[u11 === "start" ? "end" : "start"].point, q10 = c11[u11].point, de2 = e$3.add(q10, p11), le2 = e$3.angle(I10, de2), Ae = e$3.rotWith(de2, I10, C$2.snapAngleToSegments(le2, 24) - le2);
        p11 = e$3.add(p11, e$3.sub(Ae, de2));
      }
      let m10 = e$3.add(c11[u11].point, p11), h10 = { [u11]: x(S({}, c11[u11]), { point: d11 ? e$3.snap(m10, a11) : e$3.toFixed(m10), bindingId: void 0 }) }, g10 = En["arrow"], f10 = (U10 = g10.onHandleChange) == null ? void 0 : U10.call(g10, e11, h10);
      if (!f10) return;
      let T10 = { shape: C$2.deepMerge(i11, f10), bindings: {} }, w10, b10 = T10.shape.handles[this.handleId], y10 = T10.shape.handles[this.handleId === "start" ? "end" : "start"];
      if (this.startBindingShapeId) {
        let I10, q10 = this.app.page.shapes[this.startBindingShapeId], de2 = v.getShapeUtil(q10), le2 = de2.getCenter(q10), Ae = T10.shape.handles.start, Ce2 = T10.shape.handles.end, De2 = e$3.add(Ae.point, T10.shape.point);
        e$3.isEqual(De2, le2) && De2[1]++;
        let Ve = le2, $e = de2.hitTestPoint(q10, t11), jt = e$3.uni(e$3.sub(De2, Ve)), on2 = this.app.getBinding(this.newStartBindingId) !== void 0;
        !s11 && !de2.hitTestPoint(q10, e$3.add(T10.shape.point, Ce2.point)) && (I10 = this.findBindingPoint(i11, q10, "start", this.newStartBindingId, le2, Ve, jt, $e)), I10 && !on2 ? (this.didBind = true, T10.bindings[this.newStartBindingId] = I10, T10.shape = C$2.deepMerge(T10.shape, { handles: { start: { bindingId: I10.id } } })) : !I10 && on2 && (this.didBind = false, T10.bindings[this.newStartBindingId] = void 0, T10.shape = C$2.deepMerge(e11, { handles: { start: { bindingId: void 0 } } }));
      }
      if (!s11) {
        let I10 = e$3.add(y10.point, T10.shape.point), q10 = e$3.add(b10.point, T10.shape.point), de2 = e$3.uni(e$3.sub(q10, I10)), le2 = e$3.add(T10.shape.point, T10.shape.handles.start.point), Ae = e$3.add(T10.shape.point, T10.shape.handles.end.point), Ce2 = this.bindableShapeIds.map((De2) => this.app.page.shapes[De2]).sort((De2, Ve) => Ve.childIndex - De2.childIndex).filter((De2) => {
          if (De2.isLocked) return false;
          let Ve = v.getShapeUtil(De2);
          return ![le2, Ae].every(($e) => Ve.hitTestPoint(De2, $e));
        });
        for (let De2 of Ce2) if (w10 = this.findBindingPoint(i11, De2, this.handleId, this.draggedBindingId, q10, I10, de2, o11), w10) break;
      }
      if (w10) this.didBind = true, T10.bindings[this.draggedBindingId] = w10, T10.shape = C$2.deepMerge(T10.shape, { handles: { [this.handleId]: { bindingId: this.draggedBindingId } } });
      else {
        this.didBind = this.didBind || false;
        let I10 = i11.handles[this.handleId].bindingId;
        I10 !== void 0 && (T10.bindings[I10] = void 0, T10.shape = C$2.deepMerge(T10.shape, { handles: { [this.handleId]: { bindingId: void 0 } } }));
      }
      let R10 = (k10 = (L10 = v.getShapeUtil(T10.shape)).onHandleChange) == null ? void 0 : k10.call(L10, T10.shape, T10.shape.handles);
      return { document: { pages: { [this.app.currentPageId]: { shapes: { [i11.id]: S(S({}, T10.shape), R10 != null ? R10 : {}) }, bindings: T10.bindings } }, pageStates: { [this.app.currentPageId]: { bindingId: T10.shape.handles[u11].bindingId } } } };
    });
    l(this, "cancel", () => {
      let { initialShape: e11, initialBinding: t11, newStartBindingId: n11, draggedBindingId: o11 } = this, s11 = v.onSessionComplete(this.app.page.shapes[e11.id]), a11 = this.isCreate || e$3.dist(s11.handles.start.point, s11.handles.end.point) < 4, d11 = {};
      return d11[o11] = void 0, t11 && (d11[t11.id] = a11 ? void 0 : t11), n11 && (d11[n11] = void 0), { document: { pages: { [this.app.currentPageId]: { shapes: { [e11.id]: a11 ? void 0 : e11 }, bindings: d11 } }, pageStates: { [this.app.currentPageId]: { selectedIds: a11 ? [] : [e11.id], bindingId: void 0, hoveredId: void 0, editingId: void 0 } } } };
    });
    l(this, "complete", () => {
      let { initialShape: e11, initialBinding: t11, newStartBindingId: n11, startBindingShapeId: o11, handleId: s11 } = this, a11 = v.onSessionComplete(this.app.page.shapes[e11.id]), d11 = a11.handles[s11].bindingId, i11 = e$3.dist(a11.handles.start.point, a11.handles.end.point);
      if (!(d11 || t11) && i11 < 4) return this.cancel();
      let c11 = {}, u11 = {};
      return t11 && (c11[t11.id] = this.isCreate ? void 0 : t11, u11[t11.id] = void 0), d11 && (c11[d11] = void 0, u11[d11] = this.app.page.bindings[d11]), o11 && (c11[n11] = void 0, u11[n11] = this.app.page.bindings[n11]), { id: "arrow", before: { document: { pages: { [this.app.currentPageId]: { shapes: { [e11.id]: this.isCreate ? void 0 : e11 }, bindings: c11 } }, pageStates: { [this.app.currentPageId]: { selectedIds: this.isCreate ? [] : [e11.id], bindingId: void 0, hoveredId: void 0, editingId: void 0 } } } }, after: { document: { pages: { [this.app.currentPageId]: { shapes: { [e11.id]: a11 }, bindings: u11 } }, pageStates: { [this.app.currentPageId]: { selectedIds: [e11.id], bindingId: void 0, hoveredId: void 0, editingId: void 0 } } } } };
    });
    l(this, "findBindingPoint", (e11, t11, n11, o11, s11, a11, d11, i11) => {
      let u11 = v.getShapeUtil(t11.type).getBindingPoint(t11, e11, s11, a11, d11, i11);
      if (!!u11) return { id: o11, type: "arrow", fromId: e11.id, toId: t11.id, handleId: n11, point: e$3.toFixed(u11.point), distance: u11.distance };
    });
    var c10, u10, p10;
    this.isCreate = o10;
    let { currentPageId: s10 } = e10.state.appState, a10 = e10.state.document.pages[s10];
    this.handleId = n10, this.initialShape = St(a10.shapes[t10]), this.bindableShapeIds = v.getBindableShapeIds(e10.state).filter((m10) => !(m10 === this.initialShape.id || m10 === this.initialShape.parentId));
    let d10 = (c10 = this.initialShape.handles[n10 === "start" ? "end" : "start"]) == null ? void 0 : c10.bindingId;
    if (d10) {
      let m10 = (u10 = a10.bindings[d10]) == null ? void 0 : u10.toId;
      m10 && (this.bindableShapeIds = this.bindableShapeIds.filter((h10) => h10 !== m10));
    }
    let { originPoint: i10 } = this.app;
    if (this.isCreate) this.startBindingShapeId = (p10 = this.bindableShapeIds.map((m10) => a10.shapes[m10]).filter((m10) => !m10.isLocked && C$2.pointInBounds(i10, v.getShapeUtil(m10).getBounds(m10))).sort((m10, h10) => h10.childIndex - m10.childIndex)[0]) == null ? void 0 : p10.id, this.startBindingShapeId && this.bindableShapeIds.splice(this.bindableShapeIds.indexOf(this.startBindingShapeId), 1);
    else {
      let m10 = this.initialShape.handles[this.handleId].bindingId;
      m10 ? this.initialBinding = a10.bindings[m10] : this.initialShape.handles[this.handleId].bindingId = void 0;
    }
  }
};
var Oi = class extends Ye {
  constructor(e10) {
    super(e10);
    l(this, "type", "brush");
    l(this, "performanceMode");
    l(this, "status", "brushing");
    l(this, "initialSelectedIds");
    l(this, "shapesToTest");
    l(this, "start", () => {
    });
    l(this, "update", () => {
      let { initialSelectedIds: e11, shapesToTest: t11, app: { metaKey: n10, settings: o10, originPoint: s10, currentPoint: a10 } } = this, d10 = C$2.getBoundsFromPoints([s10, a10]), i10 = o10.isCadSelectMode ? !n10 && s10[0] < a10[0] : n10, c10 = /* @__PURE__ */ new Set(), u10 = new Set(e11);
      t11.forEach(({ id: g10, selectId: f10 }) => {
        let T10 = this.app.getShape(g10);
        if (!c10.has(f10)) {
          let w10 = this.app.getShapeUtil(T10);
          (i10 ? C$2.boundsContain(d10, w10.getBounds(T10)) : w10.hitTestBounds(T10, d10)) ? (c10.add(f10), u10.has(f10) || u10.add(f10)) : u10.has(f10) && u10.delete(f10);
        }
      });
      let p10 = this.app.selectedIds, m10 = u10.size !== p10.length || p10.some((g10) => !u10.has(g10)), h10 = m10 ? Array.from(u10.values()) : p10;
      return m10 ? { appState: { selectByContain: i10 }, document: { pageStates: { [this.app.currentPageId]: { brush: d10, selectedIds: h10 } } } } : { appState: { selectByContain: i10 }, document: { pageStates: { [this.app.currentPageId]: { brush: d10 } } } };
    });
    l(this, "cancel", () => ({ appState: { selectByContain: false }, document: { pageStates: { [this.app.currentPageId]: { brush: null, selectedIds: Array.from(this.initialSelectedIds.values()) } } } }));
    l(this, "complete", () => ({ appState: { selectByContain: false }, document: { pageStates: { [this.app.currentPageId]: { brush: null, selectedIds: [...this.app.selectedIds] } } } }));
    let { currentPageId: t10 } = e10;
    this.initialSelectedIds = new Set(this.app.selectedIds), this.shapesToTest = this.app.shapes.filter((n10) => !(n10.isLocked || n10.isHidden || n10.parentId !== t10 || this.initialSelectedIds.has(n10.id) || this.initialSelectedIds.has(n10.parentId))).map((n10) => ({ id: n10.id, bounds: this.app.getShapeUtil(n10).getBounds(n10), selectId: n10.id })), this.update();
  }
};
var Fi = class extends Ye {
  constructor(e10, t10) {
    super(e10);
    l(this, "type", "draw");
    l(this, "performanceMode");
    l(this, "status", "creating");
    l(this, "topLeft");
    l(this, "points");
    l(this, "initialShape");
    l(this, "lastAdjustedPoint");
    l(this, "shiftedPoints", []);
    l(this, "shapeId");
    l(this, "isLocked");
    l(this, "isExtending");
    l(this, "lockedDirection");
    l(this, "start", () => {
      var s11;
      let e11 = this.app.originPoint, t11 = [0, 0, (s11 = e11[2]) != null ? s11 : 0.5];
      this.points.push(t11);
      let n11 = [Math.min(this.topLeft[0], e11[0]), Math.min(this.topLeft[1], e11[1])], o11 = e$3.sub(n11, e11);
      return this.topLeft = n11, this.shiftedPoints = this.points.map((a11) => e$3.toFixed(e$3.sub(a11, o11)).concat(a11[2])), { document: { pages: { [this.app.currentPageId]: { shapes: { [this.shapeId]: { point: this.topLeft, points: this.shiftedPoints } } } }, pageStates: { [this.app.currentPageId]: { selectedIds: [this.shapeId] } } } };
    });
    l(this, "update", () => {
      let { shapeId: e11 } = this, { currentPoint: t11, originPoint: n11, shiftKey: o11, zoom: s11 } = this.app;
      if (!this.lockedDirection && this.points.length > 1) {
        let d11 = e$3.sub(t11, n11);
        e$3.len(d11) > 3 / s11 && (this.lockedDirection = Math.abs(d11[0]) > Math.abs(d11[1]) ? "horizontal" : "vertical");
      }
      if (o11) {
        if (!this.isLocked && this.points.length > 2) {
          if (!this.lockedDirection) {
            let i11 = e$3.sub(t11, n11);
            e$3.len(i11) > 3 / s11 && (this.lockedDirection = Math.abs(i11[0]) > Math.abs(i11[1]) ? "horizontal" : "vertical");
          }
          this.isLocked = true;
          let d11 = [...this.lastAdjustedPoint];
          this.lockedDirection === "vertical" ? d11[0] = 0 : d11[1] = 0, this.points.push(d11.concat(t11[2]));
        }
      } else this.isLocked && (this.isLocked = false);
      this.isLocked && (this.lockedDirection === "vertical" ? t11[0] = n11[0] : t11[1] = n11[1]);
      let a11 = this.addPoint(t11);
      if (!!a11) return { document: { pages: { [this.app.currentPageId]: { shapes: { [e11]: a11 } } }, pageStates: { [this.app.currentPageId]: { selectedIds: [e11] } } } };
    });
    l(this, "cancel", () => {
      let { shapeId: e11 } = this, t11 = this.app.currentPageId;
      return { document: { pages: { [t11]: { shapes: { [e11]: this.isExtending ? this.initialShape : void 0 } } }, pageStates: { [t11]: { selectedIds: [] } } } };
    });
    l(this, "complete", () => {
      let { shapeId: e11 } = this, t11 = this.app.currentPageId, n11 = this.app.getShape(e11);
      return { id: "create_draw", before: { document: { pages: { [t11]: { shapes: { [e11]: this.isExtending ? this.initialShape : void 0 } } }, pageStates: { [t11]: { selectedIds: [] } } } }, after: { document: { pages: { [t11]: { shapes: { [e11]: x(S({}, n11), { point: e$3.toFixed(n11.point), points: n11.points.map((o11) => e$3.toFixed(o11)), isComplete: true }) } } }, pageStates: { [this.app.currentPageId]: { selectedIds: [] } } } } };
    });
    l(this, "addPoint", (e11) => {
      let { originPoint: t11 } = this.app, n11 = e$3.toFixed(e$3.sub(e11, t11)).concat(e11[2]);
      if (e$3.isEqual(this.lastAdjustedPoint, n11)) return;
      this.points.push(n11), this.lastAdjustedPoint = n11;
      let o11 = [...this.topLeft], s11 = [Math.min(this.topLeft[0], e11[0]), Math.min(this.topLeft[1], e11[1])], a11 = e$3.sub(s11, t11), d11;
      return o11[0] !== s11[0] || o11[1] !== s11[1] ? (this.topLeft = s11, d11 = this.points.map((i11) => e$3.toFixed(e$3.sub(i11, a11)).concat(i11[2]))) : d11 = [...this.shiftedPoints, e$3.sub(n11, a11).concat(n11[2])], this.shiftedPoints = d11, { point: this.topLeft, points: d11 };
    });
    var i10;
    let { originPoint: n10 } = this.app;
    this.shapeId = t10, this.initialShape = this.app.getShape(t10), this.topLeft = [...this.initialShape.point];
    let o10 = [0, 0, (i10 = n10[2]) != null ? i10 : 0.5], s10 = e$3.sub(n10, this.topLeft), a10 = this.initialShape.points.map((c10) => e$3.sub(c10, s10).concat(c10[2]));
    this.isExtending = a10.length > 0;
    let d10 = [];
    if (this.isExtending) {
      let c10 = a10[a10.length - 1];
      if (c10) {
        d10.push(c10, c10);
        let u10 = Math.floor(e$3.dist(c10, o10) / 16);
        if (u10 > 1) for (let p10 = 0; p10 < u10; p10++) {
          let m10 = p10 / (u10 - 1);
          d10.push(e$3.lrp(c10, o10, m10).concat(c10[2]));
        }
        else d10.push(o10, o10);
      }
    } else d10.push(o10);
    this.points = [...a10, ...d10], this.shiftedPoints = this.points.map((c10) => e$3.add(c10, s10).concat(c10[2])), this.lastAdjustedPoint = this.points[this.points.length - 1];
  }
};
var ji = class extends Ye {
  constructor(e10, t10, n10) {
    super(e10);
    l(this, "type", "edit");
    l(this, "performanceMode");
    l(this, "initialShape");
    l(this, "initialSelectedIds");
    l(this, "currentPageId");
    l(this, "isCreating");
    l(this, "start", () => {
    });
    l(this, "update", () => {
    });
    l(this, "cancel", () => ({ document: { pages: { [this.currentPageId]: { shapes: { [this.initialShape.id]: this.isCreating ? void 0 : this.initialShape } } }, pageStates: { [this.currentPageId]: { selectedIds: this.isCreating ? [] : this.initialSelectedIds, editingId: void 0 } } } }));
    l(this, "complete", () => {
      let e11 = this.app.getShape(this.initialShape.id);
      return { id: "edit", before: { document: { pages: { [this.currentPageId]: { shapes: { [this.initialShape.id]: this.isCreating ? void 0 : this.initialShape } } }, pageStates: { [this.currentPageId]: { selectedIds: this.isCreating ? [] : this.initialSelectedIds, editingId: void 0 } } } }, after: { document: { pages: { [this.currentPageId]: { shapes: { [this.initialShape.id]: e11 } } }, pageStates: { [this.currentPageId]: { selectedIds: [e11.id], editingId: void 0 } } } } };
    });
    this.initialShape = e10.getShape(t10, e10.currentPageId), this.currentPageId = e10.currentPageId, this.isCreating = n10, this.initialSelectedIds = [...e10.selectedIds];
  }
};
var Gi = class extends Ye {
  constructor(e10) {
    super(e10);
    l(this, "type", "draw");
    l(this, "performanceMode");
    l(this, "status", "creating");
    l(this, "isLocked");
    l(this, "lockedDirection");
    l(this, "erasedShapes", /* @__PURE__ */ new Set());
    l(this, "erasedBindings", /* @__PURE__ */ new Set());
    l(this, "initialSelectedShapes");
    l(this, "erasableShapes");
    l(this, "prevPoint");
    l(this, "prevEraseShapesSize", 0);
    l(this, "interval");
    l(this, "timestamp1", 0);
    l(this, "timestamp2", 0);
    l(this, "prevErasePoint", []);
    l(this, "loop", () => {
      let e11 = Date.now(), t10 = e11 - this.timestamp1, n10 = e11 - this.timestamp2, { eraseLine: o10 } = this.app.appState, s10 = [...o10], a10 = false;
      t10 > 16 && this.prevErasePoint !== this.prevPoint && (a10 = true, s10 = [...o10, this.prevPoint], this.prevErasePoint = this.prevPoint), n10 > 32 && s10.length > 1 && (a10 = true, s10.splice(0, Math.ceil(s10.length * 0.1)), this.timestamp2 = e11), a10 && this.app.patchState({ appState: { eraseLine: s10 } }, "eraseline"), this.interval = requestAnimationFrame(this.loop);
    });
    l(this, "start", () => {
    });
    l(this, "update", () => {
      let { page: e11, shiftKey: t10, originPoint: n10, currentPoint: o10, zoom: s10 } = this.app;
      if (t10) {
        let c10 = e$3.sub(o10, n10);
        if (!this.isLocked && e$3.len(c10) > 3 / s10) {
          if (!this.lockedDirection) {
            let u10 = e$3.sub(o10, n10);
            this.lockedDirection = Math.abs(u10[0]) > Math.abs(u10[1]) ? "horizontal" : "vertical";
          }
          this.isLocked = true;
        }
      } else this.isLocked && (this.isLocked = false);
      this.isLocked && (this.lockedDirection === "vertical" ? o10[0] = n10[0] : o10[1] = n10[1]);
      let a10 = e$3.toFixed(e$3.add(n10, e$3.sub(o10, n10))), d10 = /* @__PURE__ */ new Set([]);
      this.erasableShapes.forEach((c10) => {
        if (!this.erasedShapes.has(c10) && this.app.getShapeUtil(c10).hitTestLineSegment(c10, this.prevPoint, a10) && (this.erasedShapes.add(c10), d10.add(c10.id), c10.children !== void 0)) for (let u10 of c10.children) this.erasedShapes.add(this.app.getShape(u10)), d10.add(u10);
      }), Object.values(e11.bindings).forEach((c10) => {
        for (let u10 of [c10.toId, c10.fromId]) d10.has(u10) && this.erasedBindings.add(c10);
      }), this.erasedShapes.forEach((c10) => {
        this.app.getShape(c10.id) || (this.erasedShapes.delete(c10), this.erasableShapes.delete(c10), d10.delete(c10.id));
      });
      let i10 = Array.from(this.erasedShapes.values());
      if (this.prevPoint = a10, i10.length !== this.prevEraseShapesSize) return this.prevEraseShapesSize = i10.length, { document: { pages: { [e11.id]: { shapes: Object.fromEntries(i10.map((c10) => [c10.id, { isGhost: true }])) } } } };
    });
    l(this, "cancel", () => {
      let { page: e11 } = this.app;
      cancelAnimationFrame(this.interval), this.erasedShapes.forEach((n10) => {
        this.app.getShape(n10.id) || (this.erasedShapes.delete(n10), this.erasableShapes.delete(n10));
      });
      let t10 = Array.from(this.erasedShapes.values());
      return { document: { pages: { [e11.id]: { shapes: Object.fromEntries(t10.map((n10) => [n10.id, { isGhost: false }])) } }, pageStates: { [e11.id]: { selectedIds: this.initialSelectedShapes.map((n10) => n10.id) } } }, appState: { eraseLine: [] } };
    });
    l(this, "complete", () => {
      let { page: e11 } = this.app;
      cancelAnimationFrame(this.interval), this.erasedShapes.forEach((i10) => {
        this.app.getShape(i10.id) || (this.erasedShapes.delete(i10), this.erasableShapes.delete(i10));
      }), this.erasedBindings.forEach((i10) => {
        this.app.getBinding(i10.id) || this.erasedBindings.delete(i10);
      });
      let t10 = Array.from(this.erasedShapes.values()), n10 = Array.from(this.erasedBindings.values()), o10 = t10.map((i10) => i10.id), s10 = n10.map((i10) => i10.id), a10 = { shapes: Object.fromEntries(t10.map((i10) => [i10.id, i10])), bindings: Object.fromEntries(n10.map((i10) => [i10.id, i10])) }, d10 = { shapes: Object.fromEntries(t10.map((i10) => [i10.id, void 0])), bindings: Object.fromEntries(n10.map((i10) => [i10.id, void 0])) };
      return this.app.shapes.forEach((i10) => {
        i10.handles && !d10.shapes[i10.id] && Object.values(i10.handles).forEach((c10) => {
          var u10, p10;
          c10.bindingId && s10.includes(c10.bindingId) && (a10.shapes[i10.id] = x(S({}, a10.shapes[i10.id]), { handles: x(S({}, (u10 = a10.shapes[i10.id]) == null ? void 0 : u10.handles), { [c10.id]: c10 }) }), o10.includes(i10.id) || (d10.shapes[i10.id] = x(S({}, d10.shapes[i10.id]), { handles: x(S({}, (p10 = d10.shapes[i10.id]) == null ? void 0 : p10.handles), { [c10.id]: x(S({}, c10), { bindingId: void 0 }) }) })));
        });
      }), { id: "erase", before: { document: { pages: { [e11.id]: a10 }, pageStates: { [e11.id]: { selectedIds: this.initialSelectedShapes.filter((i10) => !!this.app.getShape(i10.id)).map((i10) => i10.id) } } }, appState: { eraseLine: [] } }, after: { document: { pages: { [e11.id]: d10 }, pageStates: { [e11.id]: { selectedIds: this.initialSelectedShapes.filter((i10) => !!this.app.getShape(i10.id)).filter((i10) => !o10.includes(i10.id)).map((i10) => i10.id) } } }, appState: { eraseLine: [] } } };
    });
    this.prevPoint = [...e10.originPoint], this.initialSelectedShapes = this.app.selectedIds.map((t10) => this.app.getShape(t10)), this.erasableShapes = new Set(this.app.shapes.filter((t10) => !t10.isLocked)), this.interval = this.loop();
  }
};
var Vi = class extends Ye {
  constructor(e10, t10) {
    super(e10);
    l(this, "type", "grid");
    l(this, "performanceMode");
    l(this, "status", "translating");
    l(this, "shape");
    l(this, "bounds");
    l(this, "initialSelectedIds");
    l(this, "initialSiblings");
    l(this, "grid", {});
    l(this, "columns", 1);
    l(this, "rows", 1);
    l(this, "isCopying", false);
    l(this, "start", () => {
    });
    l(this, "update", () => {
      let { currentPageId: e11, altKey: t11, shiftKey: n11, currentPoint: o10 } = this.app, s10 = {}, a10 = {}, d10 = C$2.getBoundsCenter(this.bounds), i10 = e$3.sub(o10, d10);
      n11 && (Math.abs(i10[0]) < Math.abs(i10[1]) ? i10[0] = 0 : i10[1] = 0);
      let c10 = this.bounds.width + 32, u10 = this.bounds.height + 32, p10 = Math.ceil(i10[0] / c10), m10 = Math.ceil(i10[1] / u10), h10 = Math.min(p10, 0), g10 = Math.min(m10, 0), f10 = Math.max(p10, 1), T10 = Math.max(m10, 1), w10 = /* @__PURE__ */ new Set(), b10 = t11;
      b10 !== this.isCopying && (Object.values(this.grid).filter((y10) => y10 !== this.shape.id).forEach((y10) => s10[y10] = void 0), this.grid = { "0_0": this.shape.id }, this.isCopying = b10);
      for (let y10 = h10; y10 < f10; y10++) for (let R10 = g10; R10 < T10; R10++) {
        let U10 = `${y10}_${R10}`;
        if (w10.add(U10), this.grid[U10] || y10 === 0 && R10 === 0) continue;
        let L10 = this.getClone(e$3.add(this.shape.point, [y10 * c10, R10 * u10]), b10);
        s10[L10.id] = L10, this.grid[U10] = L10.id;
      }
      if (Object.entries(this.grid).forEach(([y10, R10]) => {
        w10.has(y10) || (s10[R10] = void 0, delete this.grid[y10]);
      }), Object.values(s10).length !== 0) return this.initialSiblings && (s10[this.shape.parentId] = { children: [...this.initialSiblings, ...Object.values(this.grid)] }), { document: { pages: { [e11]: { shapes: s10 } }, pageStates: { [e11]: a10 } } };
    });
    l(this, "cancel", () => {
      let { currentPageId: e11 } = this.app, t11 = {};
      return Object.values(this.grid).forEach((n11) => {
        t11[n11] = void 0;
      }), t11[this.shape.id] = x(S({}, t11[this.shape.id]), { point: this.shape.point }), this.initialSiblings && (t11[this.shape.parentId] = { children: [...this.initialSiblings, this.shape.id] }), { document: { pages: { [e11]: { shapes: t11 } }, pageStates: { [e11]: { selectedIds: [this.shape.id] } } } };
    });
    l(this, "complete", () => {
      let { currentPageId: e11 } = this.app, t11 = {}, n11 = {}, o10 = [];
      if (Object.values(this.grid).forEach((s10) => {
        t11[s10] = void 0, n11[s10] = this.app.getShape(s10), o10.push(s10);
      }), t11[this.shape.id] = this.shape, this.initialSiblings && (t11[this.shape.parentId] = { children: [...this.initialSiblings, this.shape.id] }, n11[this.shape.parentId] = { children: [...this.initialSiblings, ...Object.values(this.grid)] }), o10.length !== 1) return { id: "grid", before: { document: { pages: { [e11]: { shapes: t11 } }, pageStates: { [e11]: { selectedIds: [], hoveredId: void 0 } } } }, after: { document: { pages: { [e11]: { shapes: n11 } }, pageStates: { [e11]: { selectedIds: o10, hoveredId: void 0 } } } } };
    });
    l(this, "getClone", (e11, t11) => {
      let n11 = x(S({}, this.shape), { id: C$2.uniqueId(), point: e11 });
      return t11 || n11.type === "sticky" && (n11.text = ""), n11;
    });
    var n10;
    this.shape = this.app.getShape(t10), this.grid["0_0"] = this.shape.id, this.bounds = this.app.getShapeBounds(t10), this.initialSelectedIds = [...this.app.selectedIds], this.shape.parentId !== this.app.currentPageId && (this.initialSiblings = (n10 = this.app.getShape(this.shape.parentId).children) == null ? void 0 : n10.filter((o10) => o10 !== this.shape.id));
  }
};
var Ni = class extends Ye {
  constructor(e10, t10, n10, o10 = "move_handle") {
    super(e10);
    l(this, "type", "handle");
    l(this, "performanceMode");
    l(this, "status", "translatingHandle");
    l(this, "commandId");
    l(this, "topLeft");
    l(this, "shiftKey", false);
    l(this, "initialShape");
    l(this, "handleId");
    l(this, "start", () => {
    });
    l(this, "update", () => {
      var u10, p10;
      let { initialShape: e11, app: { currentPageId: t11, currentPoint: n11 } } = this, o11 = this.app.getShape(e11.id);
      if (o11.isLocked) return;
      let s11 = o11.handles, a10 = this.handleId, d10 = e$3.sub(n11, s11[a10].point), i10 = { [a10]: x(S({}, s11[a10]), { point: e$3.sub(e$3.add(s11[a10].point, d10), o11.point) }) }, c10 = (p10 = (u10 = v.getShapeUtil(o11)).onHandleChange) == null ? void 0 : p10.call(u10, o11, i10);
      if (!!c10) return { document: { pages: { [t11]: { shapes: { [o11.id]: c10 } } } } };
    });
    l(this, "cancel", () => {
      let { initialShape: e11, app: { currentPageId: t11 } } = this;
      return { document: { pages: { [t11]: { shapes: { [e11.id]: e11 } } } } };
    });
    l(this, "complete", () => {
      let { initialShape: e11, app: { currentPageId: t11 } } = this;
      return { id: this.commandId, before: { document: { pages: { [t11]: { shapes: { [e11.id]: e11 } } } } }, after: { document: { pages: { [t11]: { shapes: { [e11.id]: v.onSessionComplete(this.app.getShape(this.initialShape.id)) } } } } } };
    });
    let { originPoint: s10 } = e10;
    this.topLeft = [...s10], this.handleId = n10, this.initialShape = this.app.getShape(t10), this.commandId = o10;
  }
};
var Wi = class extends Ye {
  constructor(e10) {
    super(e10);
    l(this, "type", "rotate");
    l(this, "status", "transforming");
    l(this, "performanceMode");
    l(this, "delta", [0, 0]);
    l(this, "commonBoundsCenter");
    l(this, "initialAngle");
    l(this, "initialShapes");
    l(this, "changes", {});
    l(this, "start", () => {
    });
    l(this, "update", () => {
      let { commonBoundsCenter: e11, initialShapes: t11, app: { currentPageId: n11, currentPoint: o11, shiftKey: s11 } } = this, a10 = {}, d10 = e$3.angle(e11, o11) - this.initialAngle;
      return s11 && (d10 = C$2.snapAngleToSegments(d10, 24)), t11.forEach(({ center: i10, shape: c10 }) => {
        let { rotation: u10 = 0 } = c10, p10 = 0;
        s11 && (p10 = C$2.snapAngleToSegments(u10, 24) - u10);
        let m10 = v.getRotatedShapeMutation(c10, i10, e11, s11 ? d10 + p10 : d10);
        m10 && (a10[c10.id] = m10);
      }), this.changes = a10, { document: { pages: { [n11]: { shapes: a10 } } } };
    });
    l(this, "cancel", () => {
      let { initialShapes: e11, app: { currentPageId: t11 } } = this, n11 = {};
      return e11.forEach(({ shape: o11 }) => n11[o11.id] = o11), { document: { pages: { [t11]: { shapes: n11 } } } };
    });
    l(this, "complete", () => {
      let { initialShapes: e11, app: { currentPageId: t11 } } = this, n11 = {}, o11 = this.changes;
      return e11.forEach(({ shape: { id: s11, point: a10, rotation: d10, handles: i10 } }) => {
        n11[s11] = { point: a10, rotation: d10, handles: i10 };
      }), { id: "rotate", before: { document: { pages: { [t11]: { shapes: n11 } } } }, after: { document: { pages: { [t11]: { shapes: o11 } } } } };
    });
    let { app: { currentPageId: t10, pageState: n10, originPoint: o10 } } = this, s10 = v.getSelectedBranchSnapshot(e10.state, t10).filter((a10) => !a10.isLocked);
    if (s10.length === 0) throw Error("No selected shapes!");
    if (e10.rotationInfo.selectedIds === n10.selectedIds) {
      if (e10.rotationInfo.center === void 0) throw Error("We should have a center for rotation!");
      this.commonBoundsCenter = e10.rotationInfo.center;
    } else this.commonBoundsCenter = C$2.getBoundsCenter(C$2.getCommonBounds(s10.map(v.getBounds))), e10.rotationInfo.selectedIds = n10.selectedIds, e10.rotationInfo.center = this.commonBoundsCenter;
    this.initialShapes = s10.filter((a10) => a10.children === void 0).map((a10) => ({ shape: a10, center: this.app.getShapeUtil(a10).getCenter(a10) })), this.initialAngle = e$3.angle(this.commonBoundsCenter, o10);
  }
};
var Ui = class extends Ye {
  constructor(e10, t10 = He$1.BottomRight, n10 = false) {
    super(e10);
    this.transformType = t10;
    this.isCreate = n10;
    l(this, "type", "transform");
    l(this, "performanceMode");
    l(this, "status", "transforming");
    l(this, "scaleX", 1);
    l(this, "scaleY", 1);
    l(this, "initialShapes");
    l(this, "initialShapeIds");
    l(this, "initialSelectedIds");
    l(this, "shapeBounds");
    l(this, "hasUnlockedShapes");
    l(this, "isAllAspectRatioLocked");
    l(this, "initialCommonBounds");
    l(this, "snapInfo", { state: "empty" });
    l(this, "prevPoint", [0, 0]);
    l(this, "speed", 1);
    l(this, "start", () => {
      this.snapInfo = { state: "ready", bounds: this.app.shapes.filter((e11) => !this.initialShapeIds.includes(e11.id)).map((e11) => C$2.getBoundsWithCenter(v.getRotatedBounds(e11))) };
    });
    l(this, "update", () => {
      let { transformType: e11, shapeBounds: t11, initialCommonBounds: n11, isAllAspectRatioLocked: o11, app: { currentPageId: s11, pageState: { camera: a11 }, viewport: d10, currentPoint: i10, previousPoint: c10, originPoint: u10, shiftKey: p10, altKey: m10, metaKey: h10, currentGrid: g10, settings: { isSnapping: f10, showGrid: T10 } } } = this, w10 = {}, b10 = m10 ? e$3.mul(e$3.sub(i10, u10), 2) : e$3.sub(i10, u10), y10 = C$2.getTransformedBoundingBox(n11, e11, b10, 0, p10 || o11);
      m10 && (y10 = S(S({}, y10), C$2.centerBounds(y10, C$2.getBoundsCenter(n11)))), T10 && (y10 = S(S({}, y10), C$2.snapBoundsToGrid(y10, g10)));
      let U10 = e$3.dist(i10, c10) - this.speed;
      this.speed = this.speed + U10 * (U10 > 1 ? 0.5 : 0.15);
      let L10 = [];
      if ((f10 && !h10 || !f10 && h10) && this.speed * a11.zoom < 10 && this.snapInfo.state === "ready") {
        let k10 = C$2.getSnapPoints(C$2.getBoundsWithCenter(y10), this.snapInfo.bounds.filter((I10) => C$2.boundsContain(d10, I10) || C$2.boundsCollide(d10, I10)), 5 / a11.zoom);
        k10 && (L10 = k10.snapLines, y10 = C$2.getTransformedBoundingBox(n11, e11, e$3.sub(b10, k10.offset), 0, p10 || o11));
      }
      return this.scaleX = y10.scaleX, this.scaleY = y10.scaleY, t11.forEach(({ initialShape: k10, initialShapeBounds: I10, transformOrigin: q10 }) => {
        let de2 = C$2.getRelativeTransformedBoundingBox(y10, n11, I10, this.scaleX < 0, this.scaleY < 0);
        T10 && (de2 = C$2.snapBoundsToGrid(de2, g10));
        let le2 = v.transform(this.app.getShape(k10.id), de2, { type: this.transformType, initialShape: k10, scaleX: this.scaleX, scaleY: this.scaleY, transformOrigin: q10 });
        w10[k10.id] = le2;
      }), { appState: { snapLines: L10 }, document: { pages: { [s11]: { shapes: w10 } } } };
    });
    l(this, "cancel", () => {
      let { shapeBounds: e11, app: { currentPageId: t11 } } = this, n11 = {};
      return this.isCreate ? e11.forEach((o11) => n11[o11.initialShape.id] = void 0) : e11.forEach((o11) => n11[o11.initialShape.id] = o11.initialShape), { appState: { snapLines: [] }, document: { pages: { [t11]: { shapes: n11 } }, pageStates: { [t11]: { selectedIds: this.isCreate ? [] : e11.map((o11) => o11.initialShape.id) } } } };
    });
    l(this, "complete", () => {
      let { isCreate: e11, shapeBounds: t11, hasUnlockedShapes: n11, app: { currentPageId: o11 } } = this;
      if (!n11) return;
      if (this.isCreate && e$3.dist(this.app.originPoint, this.app.currentPoint) < 2) return this.cancel();
      let s11 = {}, a11 = {}, d10, i10;
      return e11 ? (d10 = [], i10 = [], t11.forEach(({ initialShape: c10 }) => {
        s11[c10.id] = void 0, a11[c10.id] = this.app.getShape(c10.id);
      })) : (d10 = this.initialSelectedIds, i10 = this.initialSelectedIds, t11.forEach(({ initialShape: c10 }) => {
        s11[c10.id] = c10, a11[c10.id] = this.app.getShape(c10.id);
      })), { id: "transform", before: { appState: { snapLines: [] }, document: { pages: { [o11]: { shapes: s11 } }, pageStates: { [o11]: { selectedIds: d10, hoveredId: void 0, editingId: void 0 } } } }, after: { appState: { snapLines: [] }, document: { pages: { [o11]: { shapes: a11 } }, pageStates: { [o11]: { selectedIds: i10, hoveredId: void 0, editingId: void 0 } } } } };
    });
    this.initialSelectedIds = [...this.app.selectedIds], this.app.rotationInfo.selectedIds = [...this.initialSelectedIds], this.initialShapes = v.getSelectedBranchSnapshot(this.app.state, this.app.currentPageId).filter((d10) => !d10.isLocked), this.initialShapeIds = this.initialShapes.map((d10) => d10.id), this.hasUnlockedShapes = this.initialShapes.length > 0, this.isAllAspectRatioLocked = this.initialShapes.every((d10) => d10.isAspectRatioLocked || v.getShapeUtil(d10).isAspectRatioLocked);
    let o10 = Object.fromEntries(this.initialShapes.map((d10) => [d10.id, v.getBounds(d10)])), s10 = Object.values(o10);
    this.initialCommonBounds = C$2.getCommonBounds(s10);
    let a10 = C$2.getBoundsFromPoints(s10.map(C$2.getBoundsCenter));
    this.shapeBounds = this.initialShapes.map((d10) => {
      let i10 = o10[d10.id], c10 = C$2.getBoundsCenter(i10), u10 = (c10[0] - a10.minX) / a10.width, p10 = (c10[1] - a10.minY) / a10.height;
      return { initialShape: d10, initialShapeBounds: i10, transformOrigin: [u10, p10] };
    });
  }
};
var Ki = class extends Ye {
  constructor(e10, t10, n10, o10 = false) {
    super(e10);
    l(this, "type", "transformSingle");
    l(this, "status", "transforming");
    l(this, "performanceMode");
    l(this, "transformType");
    l(this, "scaleX", 1);
    l(this, "scaleY", 1);
    l(this, "isCreate");
    l(this, "initialShape");
    l(this, "initialShapeBounds");
    l(this, "initialCommonBounds");
    l(this, "snapInfo", { state: "empty" });
    l(this, "prevPoint", [0, 0]);
    l(this, "speed", 1);
    l(this, "start", () => {
      this.snapInfo = { state: "ready", bounds: this.app.shapes.filter((e11) => e11.id !== this.initialShape.id).map((e11) => C$2.getBoundsWithCenter(v.getRotatedBounds(e11))) };
    });
    l(this, "update", () => {
      let { transformType: e11, initialShape: t11, initialShapeBounds: n11, app: { settings: { isSnapping: o11, showGrid: s11 }, currentPageId: a10, pageState: { camera: d10 }, viewport: i10, currentPoint: c10, previousPoint: u10, originPoint: p10, currentGrid: m10, shiftKey: h10, altKey: g10, metaKey: f10 } } = this;
      if (t11.isLocked) return;
      let T10 = {}, w10 = g10 ? e$3.mul(e$3.sub(c10, p10), 2) : e$3.sub(c10, p10), b10 = this.app.getShape(t11.id), y10 = v.getShapeUtil(b10), R10 = C$2.getTransformedBoundingBox(n11, e11, w10, b10.rotation, h10 || b10.isAspectRatioLocked || y10.isAspectRatioLocked);
      g10 && (R10 = S(S({}, R10), C$2.centerBounds(R10, C$2.getBoundsCenter(n11)))), s11 && (R10 = S(S({}, R10), C$2.snapBoundsToGrid(R10, m10)));
      let L10 = e$3.dist(c10, u10) - this.speed;
      this.speed = this.speed + L10 * (L10 > 1 ? 0.5 : 0.15);
      let k10 = [];
      if ((o11 && !f10 || !o11 && f10) && !t11.rotation && this.speed * d10.zoom < 10 && this.snapInfo.state === "ready") {
        let q10 = C$2.getSnapPoints(C$2.getBoundsWithCenter(R10), this.snapInfo.bounds.filter((de2) => C$2.boundsContain(i10, de2) || C$2.boundsCollide(i10, de2)), 5 / d10.zoom);
        q10 && (k10 = q10.snapLines, R10 = C$2.getTransformedBoundingBox(n11, e11, e$3.sub(w10, q10.offset), b10.rotation, h10 || b10.isAspectRatioLocked || y10.isAspectRatioLocked));
      }
      let I10 = v.getShapeUtil(b10).transformSingle(b10, R10, { initialShape: t11, type: this.transformType, scaleX: R10.scaleX, scaleY: R10.scaleY, transformOrigin: [0.5, 0.5] });
      return I10 && (T10[b10.id] = I10), s11 && I10 && I10.point && (I10.point = e$3.snap(I10.point, m10)), { appState: { snapLines: k10 }, document: { pages: { [a10]: { shapes: T10 } } } };
    });
    l(this, "cancel", () => {
      let { initialShape: e11, app: { currentPageId: t11 } } = this, n11 = {};
      return this.isCreate ? n11[e11.id] = void 0 : n11[e11.id] = e11, { appState: { snapLines: [] }, document: { pages: { [t11]: { shapes: n11 } }, pageStates: { [t11]: { selectedIds: this.isCreate ? [] : [e11.id] } } } };
    });
    l(this, "complete", () => {
      let { initialShape: e11, app: { currentPageId: t11 } } = this;
      if (e11.isLocked) return;
      if (this.isCreate && e$3.dist(this.app.originPoint, this.app.currentPoint) < 2) return this.cancel();
      let n11 = {}, o11 = {};
      return n11[e11.id] = this.isCreate ? void 0 : e11, o11[e11.id] = v.onSessionComplete(this.app.getShape(e11.id)), { id: "transform_single", before: { appState: { snapLines: [] }, document: { pages: { [t11]: { shapes: n11 } }, pageStates: { [t11]: { selectedIds: this.isCreate ? [] : [e11.id], editingId: void 0, hoveredId: void 0 } } } }, after: { appState: { snapLines: [] }, document: { pages: { [t11]: { shapes: o11 } }, pageStates: { [t11]: { selectedIds: [e11.id], editingId: void 0, hoveredId: void 0 } } } } };
    });
    this.isCreate = o10, this.transformType = n10;
    let s10 = this.app.getShape(t10);
    this.initialShape = s10, this.initialShapeBounds = v.getBounds(s10), this.initialCommonBounds = v.getRotatedBounds(s10), this.app.rotationInfo.selectedIds = [s10.id];
  }
};
var _i = class extends Ye {
  constructor(e10, t10 = false, n10 = false) {
    super(e10);
    l(this, "performanceMode");
    l(this, "type", "translate");
    l(this, "status", "translating");
    l(this, "delta", [0, 0]);
    l(this, "prev", [0, 0]);
    l(this, "prevPoint", [0, 0]);
    l(this, "speed", 1);
    l(this, "cloneInfo", { state: "empty" });
    l(this, "snapInfo", { state: "empty" });
    l(this, "snapLines", []);
    l(this, "isCloning", false);
    l(this, "isCreate");
    l(this, "link");
    l(this, "initialIds");
    l(this, "hasUnlockedShapes");
    l(this, "initialSelectedIds");
    l(this, "initialCommonBounds");
    l(this, "initialShapes");
    l(this, "initialParentChildren");
    l(this, "bindingsToDelete");
    l(this, "start", () => {
      let { bindingsToDelete: e11, initialIds: t11, app: { currentPageId: n11, page: o11 } } = this, s11 = [], a11 = [];
      if (Object.values(o11.shapes).forEach((c10) => {
        let u10 = C$2.getBoundsWithCenter(v.getRotatedBounds(c10));
        s11.push(u10), t11.has(c10.id) || a11.push(u10);
      }), this.snapInfo = { state: "ready", bounds: s11, others: a11 }, e11.length === 0) return;
      let d11 = {}, i11 = {};
      return e11.forEach((c10) => {
        d11[c10.id] = void 0;
        let u10 = this.app.getShape(c10.fromId);
        i11[c10.fromId] = { handles: x(S({}, u10.handles), { [c10.handleId]: x(S({}, u10.handles[c10.handleId]), { bindingId: void 0 }) }) };
      }), { document: { pages: { [n11]: { bindings: d11, shapes: i11 } } } };
    });
    l(this, "update", () => {
      let { initialParentChildren: e11, initialShapes: t11, initialCommonBounds: n11, bindingsToDelete: o11, app: { pageState: { camera: s11 }, settings: { isSnapping: a11, showGrid: d11 }, currentPageId: i11, viewport: c10, selectedIds: u10, currentPoint: p10, previousPoint: m10, originPoint: h10, altKey: g10, shiftKey: f10, metaKey: T10, currentGrid: w10 } } = this, b10 = {}, y10 = {}, R10 = {}, U10 = e$3.sub(p10, h10), L10 = false;
      this.isCreate || (g10 && !this.isCloning ? (this.isCloning = true, L10 = true) : !g10 && this.isCloning && (this.isCloning = false, L10 = true)), f10 && (Math.abs(U10[0]) < Math.abs(U10[1]) ? U10[0] = 0 : U10[1] = 0);
      let I10 = e$3.dist(p10, m10) - this.speed;
      if (this.speed = this.speed + I10 * (I10 > 1 ? 0.5 : 0.15), this.snapLines = [], (a11 && !T10 || !a11 && T10) && this.speed * s11.zoom < 10 && this.snapInfo.state === "ready") {
        let q10 = C$2.getSnapPoints(C$2.getBoundsWithCenter(d11 ? C$2.snapBoundsToGrid(C$2.translateBounds(n11, U10), w10) : C$2.translateBounds(n11, U10)), (this.isCloning ? this.snapInfo.bounds : this.snapInfo.others).filter((de2) => C$2.boundsContain(c10, de2) || C$2.boundsCollide(c10, de2)), 5 / s11.zoom);
        q10 && (this.snapLines = q10.snapLines, U10 = e$3.sub(U10, q10.offset));
      }
      if (this.prev = U10, this.isCloning) if (L10) {
        if (this.cloneInfo.state === "empty" && this.createCloneInfo(), this.cloneInfo.state === "empty") throw Error;
        let { clones: q10, clonedBindings: de2 } = this.cloneInfo;
        this.isCloning = true, o11.forEach((le2) => b10[le2.id] = le2), t11.forEach((le2) => y10[le2.id] = { point: le2.point }), q10.forEach((le2) => {
          var Ae;
          if (y10[le2.id] = S({}, le2), le2.parentId !== i11 && !u10.includes(le2.parentId)) {
            let Ce2 = ((Ae = y10[le2.parentId]) == null ? void 0 : Ae.children) || e11[le2.parentId];
            Ce2.includes(le2.id) || (y10[le2.parentId] = x(S({}, y10[le2.parentId]), { children: [...Ce2, le2.id] }));
          }
        });
        for (let le2 of de2) b10[le2.id] = le2;
        R10.selectedIds = q10.map((le2) => le2.id), q10.forEach((le2) => {
          y10[le2.id] = x(S({}, le2), { point: d11 ? e$3.snap(e$3.toFixed(e$3.add(le2.point, U10)), w10) : e$3.toFixed(e$3.add(le2.point, U10)) });
        });
      } else {
        if (this.cloneInfo.state === "empty") throw Error;
        let { clones: q10 } = this.cloneInfo;
        q10.forEach((de2) => {
          y10[de2.id] = { point: d11 ? e$3.snap(e$3.toFixed(e$3.add(de2.point, U10)), w10) : e$3.toFixed(e$3.add(de2.point, U10)) };
        });
      }
      else if (L10) {
        if (this.cloneInfo.state === "empty") throw Error;
        let { clones: q10, clonedBindings: de2 } = this.cloneInfo;
        this.isCloning = false, o11.forEach((le2) => b10[le2.id] = void 0), q10.forEach((le2) => {
          le2.parentId !== i11 && (y10[le2.parentId] = x(S({}, y10[le2.parentId]), { children: e11[le2.parentId] }));
        }), q10.forEach((le2) => y10[le2.id] = void 0), t11.forEach((le2) => {
          y10[le2.id] = { point: d11 ? e$3.snap(e$3.toFixed(e$3.add(le2.point, U10)), w10) : e$3.toFixed(e$3.add(le2.point, U10)) };
        });
        for (let le2 of de2) b10[le2.id] = void 0;
        R10.selectedIds = t11.map((le2) => le2.id);
      } else t11.forEach((q10) => {
        y10[q10.id] = { point: d11 ? e$3.snap(e$3.toFixed(e$3.add(q10.point, U10)), w10) : e$3.toFixed(e$3.add(q10.point, U10)) };
      });
      return { appState: { snapLines: this.snapLines }, document: { pages: { [i11]: { shapes: y10, bindings: b10 } }, pageStates: { [i11]: R10 } } };
    });
    l(this, "cancel", () => {
      let { initialShapes: e11, initialSelectedIds: t11, bindingsToDelete: n11, app: { currentPageId: o11 } } = this, s11 = {}, a11 = {}, d11 = { editingId: void 0, hoveredId: void 0 };
      if (this.isCreate ? (e11.forEach(({ id: i11 }) => a11[i11] = void 0), d11.selectedIds = []) : (e11.forEach(({ id: i11, point: c10, handles: u10 }) => a11[i11] = u10 ? x(S({}, a11[i11]), { point: c10, handles: u10 }) : x(S({}, a11[i11]), { point: c10 })), d11.selectedIds = t11, n11.forEach((i11) => {
        s11[i11.id] = i11;
      })), this.cloneInfo.state === "ready") {
        let { clones: i11, clonedBindings: c10 } = this.cloneInfo;
        i11.forEach((u10) => a11[u10.id] = void 0), c10.forEach((u10) => s11[u10.id] = void 0);
      }
      return { appState: { snapLines: [] }, document: { pages: { [o11]: { shapes: a11, bindings: s11 } }, pageStates: { [o11]: d11 } } };
    });
    l(this, "complete", () => {
      let { initialShapes: e11, initialParentChildren: t11, bindingsToDelete: n11, app: { currentPageId: o11 } } = this, s11 = {}, a11 = {}, d11 = {}, i11 = {};
      if (this.isCloning) {
        if (this.cloneInfo.state === "empty" && this.createCloneInfo(), this.cloneInfo.state !== "ready") throw Error;
        let { clones: c10, clonedBindings: u10 } = this.cloneInfo;
        c10.forEach((p10) => {
          a11[p10.id] = void 0, i11[p10.id] = this.app.getShape(p10.id), p10.parentId !== o11 && (a11[p10.parentId] = x(S({}, a11[p10.parentId]), { children: t11[p10.parentId] }), i11[p10.parentId] = x(S({}, i11[p10.parentId]), { children: this.app.getShape(p10.parentId).children }));
        }), u10.forEach((p10) => {
          s11[p10.id] = void 0, d11[p10.id] = this.app.getBinding(p10.id);
        });
      } else e11.forEach((c10) => {
        a11[c10.id] = this.isCreate ? void 0 : x(S({}, a11[c10.id]), { point: c10.point }), i11[c10.id] = S(S({}, i11[c10.id]), this.isCreate ? this.app.getShape(c10.id) : { point: this.app.getShape(c10.id).point });
      });
      return n11.forEach((c10) => {
        var u10, p10, m10, h10, g10;
        s11[c10.id] = c10, a11[c10.fromId] = x(S({}, a11[c10.fromId]), { id: c10.fromId, handles: x(S({}, (u10 = a11[c10.fromId]) == null ? void 0 : u10.handles), { [c10.handleId]: x(S({}, (m10 = (p10 = a11[c10.fromId]) == null ? void 0 : p10.handles) == null ? void 0 : m10[c10.handleId]), { bindingId: c10.id }) }) }), i11[c10.fromId] = x(S({}, i11[c10.fromId]), { id: c10.fromId, handles: x(S({}, i11[c10.fromId].handles), { [c10.handleId]: x(S({}, (g10 = (h10 = i11[c10.fromId]) == null ? void 0 : h10.handles) == null ? void 0 : g10[c10.handleId]), { bindingId: void 0 }) }) });
      }), n11.forEach((c10) => d11[c10.id] = void 0), { id: "translate", before: { appState: { snapLines: [] }, document: { pages: { [o11]: { shapes: a11, bindings: s11 } }, pageStates: { [o11]: { selectedIds: this.isCreate ? [] : [...this.initialSelectedIds] } } } }, after: { appState: { snapLines: [] }, document: { pages: { [o11]: { shapes: i11, bindings: d11 } }, pageStates: { [o11]: { selectedIds: [...this.app.selectedIds] } } } } };
    });
    l(this, "createCloneInfo", () => {
      let { initialShapes: e11, initialParentChildren: t11, app: { selectedIds: n11, currentPageId: o11, page: s11 } } = this, a11 = {}, d11 = {}, i11 = [], c10 = [];
      e11.forEach((p10) => {
        let m10 = C$2.uniqueId();
        t11[m10] = t11[p10.id], a11[p10.id] = m10;
        let h10 = x(S({}, C$2.deepClone(p10)), { id: m10, parentId: p10.parentId, childIndex: v.getChildIndexAbove(this.app.state, p10.id, o11) });
        if (h10.type === "video") {
          let g10 = document.getElementById(p10.id + "_video");
          g10 && (h10.currentTime = (g10.currentTime + 16) % g10.duration);
        }
        c10.push(h10);
      }), c10.forEach((p10) => {
        p10.children !== void 0 && (p10.children = p10.children.map((m10) => a11[m10]));
      }), c10.forEach((p10) => {
        n11.includes(p10.parentId) && (p10.parentId = a11[p10.parentId]);
      });
      let u10 = new Set(Object.keys(a11));
      Object.values(s11.bindings).filter((p10) => u10.has(p10.fromId) || u10.has(p10.toId)).forEach((p10) => {
        if (u10.has(p10.fromId) && u10.has(p10.toId)) {
          let m10 = C$2.uniqueId(), h10 = x(S({}, C$2.deepClone(p10)), { id: m10, fromId: a11[p10.fromId] || p10.fromId, toId: a11[p10.toId] || p10.toId });
          d11[p10.id] = m10, i11.push(h10);
        }
      }), c10.forEach((p10) => {
        if (p10.handles && p10.handles) for (let m10 in p10.handles) {
          let h10 = p10.handles[m10];
          h10.bindingId = h10.bindingId ? d11[h10.bindingId] : void 0;
        }
      }), c10.forEach((p10) => {
        if (s11.shapes[p10.id]) throw Error("uh oh, we didn't clone correctly");
      }), this.cloneInfo = { state: "ready", clones: c10, cloneMap: a11, clonedBindings: i11 };
    });
    this.isCreate = t10, this.link = n10;
    let { currentPageId: o10, selectedIds: s10, page: a10 } = this.app;
    this.initialSelectedIds = [...s10];
    let d10 = (n10 ? v.getLinkedShapeIds(this.app.state, o10, n10, false) : s10).map((c10) => this.app.getShape(c10)).filter((c10) => !c10.isLocked), i10 = new Set(d10.map((c10) => c10.id));
    this.hasUnlockedShapes = d10.length > 0, this.initialShapes = Array.from(new Set(d10.filter((c10) => !i10.has(c10.parentId)).flatMap((c10) => c10.children ? [c10, ...c10.children.map((u10) => this.app.getShape(u10))] : [c10])).values()), this.initialIds = new Set(this.initialShapes.map((c10) => c10.id)), this.bindingsToDelete = [], Object.values(a10.bindings).filter((c10) => this.initialIds.has(c10.fromId) || this.initialIds.has(c10.toId)).forEach((c10) => {
      this.initialIds.has(c10.fromId) && (this.initialIds.has(c10.toId) || this.bindingsToDelete.push(c10));
    }), this.initialParentChildren = {}, this.initialShapes.map((c10) => c10.parentId).filter((c10) => c10 !== a10.id).forEach((c10) => {
      this.initialParentChildren[c10] = this.app.getShape(c10).children;
    }), this.initialCommonBounds = C$2.getCommonBounds(this.initialShapes.map(v.getRotatedBounds)), this.app.rotationInfo.selectedIds = [...this.app.selectedIds];
  }
};
var Dpe = { ["arrow"]: zi, ["brush"]: Oi, ["draw"]: Fi, ["erase"]: Gi, ["handle"]: Ni, ["rotate"]: Wi, ["transform"]: Ui, ["transformSingle"]: Ki, ["translate"]: _i, ["grid"]: Vi, ["edit"]: ji }, dc = (r10) => Dpe[r10];
var nt = class extends ls {
  constructor(e10) {
    super();
    this.app = e10;
    l(this, "type", "select");
    l(this, "previous");
    l(this, "status", "idle");
    l(this, "setStatus", (e11) => {
      this.status = e11, this.app.setStatus(this.status);
    });
    l(this, "onEnter", () => {
      this.setStatus("idle");
    });
    l(this, "onExit", () => {
      this.setStatus("idle");
    });
    l(this, "onCancel", () => {
      this.status === "idle" ? this.app.selectTool("select") : this.setStatus("idle"), this.app.cancelSession();
    });
    l(this, "getNextChildIndex", () => {
      let { shapes: e11, appState: { currentPageId: t10 } } = this.app;
      return e11.length === 0 ? 1 : e11.filter((n10) => n10.parentId === t10).sort((n10, o10) => o10.childIndex - n10.childIndex)[0].childIndex + 1;
    });
    l(this, "onPinchStart", () => {
      this.app.cancelSession(), this.setStatus("pinching");
    });
    l(this, "onPinchEnd", () => {
      C$2.isMobileSafari() && this.app.undoSelect(), this.setStatus("idle");
    });
    l(this, "onPinch", (e11, t10) => {
      var n10;
      this.status === "pinching" && (isNaN(e11.delta[0]) || isNaN(e11.delta[1]) || (this.app.pinchZoom(e11.point, e11.delta, e11.delta[2]), (n10 = this.onPointerMove) == null || n10.call(this, e11, t10)));
    });
    l(this, "onKeyDown", (e11) => {
      if (e11 === "Escape") {
        this.onCancel();
        return;
      }
      if (e11 === "Meta" || e11 === "Control" || e11 === "Alt") {
        this.app.updateSession();
        return;
      }
    });
    l(this, "onKeyUp", (e11) => {
      if (e11 === "Meta" || e11 === "Control" || e11 === "Alt") {
        this.app.updateSession();
        return;
      }
    });
    l(this, "onPointerMove", () => {
      this.status === "creating" && this.app.updateSession();
    });
    l(this, "onPointerUp", () => {
      if (this.status === "creating") {
        this.app.completeSession();
        let { isToolLocked: e11 } = this.app.appState;
        e11 || this.app.selectTool("select");
      }
      this.setStatus("idle");
    });
  }
};
var er = class extends nt {
  constructor() {
    super(...arguments);
    l(this, "type", "arrow");
    l(this, "onPointerDown", () => {
      if (this.status !== "idle") return;
      let { currentPoint: e10, currentGrid: t10, settings: { showGrid: n10 }, appState: { currentPageId: o10, currentStyle: s10 } } = this.app, a10 = this.getNextChildIndex(), d10 = C$2.uniqueId(), i10 = Ko.create({ id: d10, parentId: o10, childIndex: a10, point: n10 ? p$4.snap(e10, t10) : e10, style: S({}, s10) });
      this.app.patchCreate([i10]), this.app.startSession("arrow", i10.id, "end", true), this.setStatus("creating");
    });
  }
};
var tr = class extends nt {
  constructor() {
    super(...arguments);
    l(this, "type", "draw");
    l(this, "lastShapeId");
    l(this, "onEnter", () => {
      this.lastShapeId = void 0;
    });
    l(this, "onCancel", () => {
      switch (this.status) {
        case "idle": {
          this.app.selectTool("select");
          break;
        }
        default: {
          this.setStatus("idle");
          break;
        }
      }
      this.app.cancelSession();
    });
    l(this, "onPointerDown", (e10) => {
      if (this.status !== "idle" || this.app.readOnly) return;
      let { currentPoint: t10, appState: { currentPageId: n10, currentStyle: o10 } } = this.app, s10 = this.lastShapeId && this.app.getShape(this.lastShapeId);
      if (e10.shiftKey && s10) this.app.startSession("draw", s10.id), this.setStatus("extending");
      else {
        let a10 = this.getNextChildIndex(), d10 = C$2.uniqueId(), i10 = fi.create({ id: d10, parentId: n10, childIndex: a10, point: t10, style: S({}, o10) });
        this.lastShapeId = d10, this.app.patchCreate([i10]), this.app.startSession("draw", d10), this.setStatus("creating");
      }
    });
    l(this, "onPointerMove", () => {
      if (!this.app.readOnly) switch (this.status) {
        case "extending":
        case "creating":
          this.app.updateSession();
      }
    });
    l(this, "onPointerUp", () => {
      this.app.completeSession(), this.setStatus("idle");
    });
  }
};
var nr = class extends nt {
  constructor() {
    super(...arguments);
    l(this, "type", "ellipse");
    l(this, "onPointerDown", () => {
      if (this.app.readOnly || this.status !== "idle") return;
      let { currentPoint: e10, currentGrid: t10, settings: { showGrid: n10 }, appState: { currentPageId: o10, currentStyle: s10 } } = this.app, a10 = this.getNextChildIndex(), d10 = C$2.uniqueId(), i10 = gi.create({ id: d10, parentId: o10, childIndex: a10, point: n10 ? p$4.snap(e10, t10) : e10, style: S({}, s10) });
      this.app.patchCreate([i10]), this.app.startSession("transformSingle", i10.id, He$1.BottomRight, true), this.setStatus("creating");
    });
  }
};
var or = class extends nt {
  constructor() {
    super(...arguments);
    l(this, "type", "erase");
    l(this, "status", "idle");
    l(this, "onPointerDown", () => {
      this.app.readOnly || this.status === "idle" && this.setStatus("pointing");
    });
    l(this, "onPointerMove", (e10) => {
      if (!this.app.readOnly) switch (this.status) {
        case "pointing": {
          p$4.dist(e10.origin, e10.point) > 3 && (this.app.startSession("erase"), this.app.updateSession(), this.setStatus("erasing"));
          break;
        }
        case "erasing":
          this.app.updateSession();
      }
    });
    l(this, "onPointerUp", () => {
      if (!this.app.readOnly) {
        switch (this.status) {
          case "pointing": {
            let e10 = this.app.shapes.filter((t10) => !t10.isLocked).filter((t10) => this.app.getShapeUtil(t10).hitTestPoint(t10, this.app.currentPoint)).flatMap((t10) => t10.children ? [t10.id, ...t10.children] : t10.id);
            this.app.delete(e10);
            break;
          }
          case "erasing":
            this.app.completeSession();
        }
        this.setStatus("idle");
      }
    });
    l(this, "onCancel", () => {
      this.status === "idle" ? this.previous ? this.app.selectTool(this.previous) : this.app.selectTool("select") : this.setStatus("idle"), this.app.cancelSession();
    });
  }
};
var rr = class extends nt {
  constructor() {
    super(...arguments);
    l(this, "type", "line");
    l(this, "onPointerDown", () => {
      if (this.app.readOnly || this.status !== "idle") return;
      let { currentPoint: e10, currentGrid: t10, settings: { showGrid: n10 }, appState: { currentPageId: o10, currentStyle: s10 } } = this.app, a10 = this.getNextChildIndex(), d10 = C$2.uniqueId(), i10 = Ko.create({ id: d10, parentId: o10, childIndex: a10, point: n10 ? p$4.snap(e10, t10) : e10, decorations: { start: void 0, end: void 0 }, style: S({}, s10) });
      this.app.patchCreate([i10]), this.app.startSession("arrow", i10.id, "end", true), this.setStatus("creating");
    });
  }
};
var sr = class extends nt {
  constructor() {
    super(...arguments);
    l(this, "type", "rectangle");
    l(this, "onPointerDown", () => {
      if (this.app.readOnly || this.status !== "idle") return;
      let { currentPoint: e10, currentGrid: t10, settings: { showGrid: n10 }, appState: { currentPageId: o10, currentStyle: s10 } } = this.app, a10 = this.getNextChildIndex(), d10 = C$2.uniqueId(), i10 = hi.create({ id: d10, parentId: o10, childIndex: a10, point: n10 ? p$4.snap(e10, t10) : e10, style: S({}, s10) });
      this.app.patchCreate([i10]), this.app.startSession("transformSingle", i10.id, He$1.BottomRight, true), this.setStatus("creating");
    });
  }
};
var ar = class extends nt {
  constructor() {
    super(...arguments);
    l(this, "type", "select");
    l(this, "pointedId");
    l(this, "selectedGroupId");
    l(this, "pointedHandleId");
    l(this, "pointedBoundsHandle");
    l(this, "pointedLinkHandleId");
    l(this, "onEnter", () => {
      this.setStatus("idle");
    });
    l(this, "onExit", () => {
      this.setStatus("idle");
    });
    l(this, "clonePaint", (e10) => {
      if (this.app.selectedIds.length === 0) return;
      let t10 = this.app.selectedIds.map((c10) => this.app.getShape(c10)), n10 = C$2.expandBounds(C$2.getCommonBounds(t10.map(v.getBounds)), 16), o10 = C$2.getBoundsCenter(n10), s10 = [n10.width, n10.height], a10 = [o10[0] + s10[0] * Math.floor((e10[0] + s10[0] / 2 - o10[0]) / s10[0]), o10[1] + s10[1] * Math.floor((e10[1] + s10[1] / 2 - o10[1]) / s10[1])], d10 = C$2.centerBounds(n10, a10);
      this.app.shapes.some((c10) => v.getShapeUtil(c10).hitTestBounds(c10, d10)) || this.app.duplicate(this.app.selectedIds, a10);
    });
    l(this, "getShapeClone", (e10, t10) => {
      let n10 = this.app.getShape(e10), o10 = v.getShapeUtil(n10);
      if (o10.canClone) {
        let s10 = o10.getBounds(n10), a10 = o10.getCenter(n10), d10 = { top: [s10.minX, s10.minY - (s10.height + 32)], right: [s10.maxX + 32, s10.minY], bottom: [s10.minX, s10.maxY + 32], left: [s10.minX - (s10.width + 32), s10.minY], topLeft: [s10.minX - (s10.width + 32), s10.minY - (s10.height + 32)], topRight: [s10.maxX + 32, s10.minY - (s10.height + 32)], bottomLeft: [s10.minX - (s10.width + 32), s10.maxY + 32], bottomRight: [s10.maxX + 32, s10.maxY + 32] }[t10];
        if (n10.rotation !== 0) {
          let u10 = p$4.add(d10, [s10.width / 2, s10.height / 2]), p10 = p$4.rotWith(u10, a10, n10.rotation || 0);
          d10 = p$4.sub(p10, [s10.width / 2, s10.height / 2]);
        }
        let i10 = C$2.uniqueId(), c10 = x(S({}, n10), { id: i10, point: d10 });
        return c10.type === "sticky" && (c10.text = ""), c10;
      }
    });
    l(this, "onCancel", () => {
      this.app.session ? this.app.cancelSession() : this.selectNone(), this.setStatus("idle");
    });
    l(this, "onKeyDown", (e10, t10, n10) => {
      switch (e10) {
        case "Escape": {
          this.onCancel();
          break;
        }
        case "Tab": {
          if (this.app.readOnly) return;
          if (!this.app.pageState.editingId && this.status === "idle" && this.app.selectedIds.length === 1) {
            let [o10] = this.app.selectedIds, s10 = this.getShapeClone(o10, "right");
            s10 && (this.app.createShapes(s10), this.setStatus("idle"), s10.type === "sticky" && (this.app.select(s10.id), this.app.setEditingId(s10.id)));
          }
          break;
        }
        case "Meta":
        case "Control":
        case "Alt": {
          this.app.updateSession();
          break;
        }
        case "Enter": {
          if (this.app.readOnly) return;
          let { pageState: o10 } = this.app;
          o10.selectedIds.length === 1 && !o10.editingId && (this.app.setEditingId(o10.selectedIds[0]), n10.preventDefault());
        }
      }
    });
    l(this, "onKeyUp", (e10, t10) => {
      if (this.status === "clonePainting" && !(t10.altKey && t10.shiftKey)) {
        this.setStatus("idle");
        return;
      }
      if (e10 === "Meta" || e10 === "Control" || e10 === "Alt") {
        this.app.updateSession();
        return;
      }
    });
    l(this, "onPointerMove", () => {
      let { originPoint: e10, currentPoint: t10 } = this.app;
      if (this.app.readOnly && this.app.isPointing) {
        this.app.session ? this.app.updateSession() : p$4.dist(e10, t10) > 3 && (this.app.startSession("brush"), this.setStatus("brushing"));
        return;
      }
      switch (this.status) {
        case "pointingBoundsHandle": {
          if (!this.pointedBoundsHandle) throw Error("No pointed bounds handle");
          if (p$4.dist(e10, t10) > 3) {
            if (this.pointedBoundsHandle === "rotate") this.setStatus("rotating"), this.app.startSession("rotate");
            else if (this.pointedBoundsHandle === "center" || this.pointedBoundsHandle === "left" || this.pointedBoundsHandle === "right") this.setStatus("translating"), this.app.startSession("translate", false, this.pointedBoundsHandle);
            else {
              this.setStatus("transforming");
              let n10 = this.app.selectedIds.flatMap((o10) => v.getDocumentBranch(this.app.state, o10, this.app.currentPageId));
              n10.length === 1 ? this.app.startSession("transformSingle", n10[0], this.pointedBoundsHandle) : this.app.startSession("transform", this.pointedBoundsHandle);
            }
            this.app.updateSession();
          }
          break;
        }
        case "pointingCanvas": {
          p$4.dist(e10, t10) > 3 && (this.app.startSession("brush"), this.setStatus("brushing"));
          break;
        }
        case "pointingClone": {
          p$4.dist(e10, t10) > 3 && (this.setStatus("translatingClone"), this.app.startSession("translate"), this.app.updateSession());
          break;
        }
        case "pointingBounds": {
          p$4.dist(e10, t10) > 3 && (this.setStatus("translating"), this.app.startSession("translate"), this.app.updateSession());
          break;
        }
        case "pointingHandle": {
          if (!this.pointedHandleId) throw Error("No pointed handle");
          if (p$4.dist(e10, t10) > 3) {
            this.setStatus("translatingHandle");
            let n10 = this.app.getShape(this.app.selectedIds[0]);
            n10 && (this.pointedHandleId === "bend" ? (this.app.startSession("handle", n10.id, this.pointedHandleId), this.app.updateSession()) : (this.app.startSession("arrow", n10.id, this.pointedHandleId, false), this.app.updateSession()));
          }
          break;
        }
        case "clonePainting": {
          this.clonePaint(t10);
          break;
        }
        default:
          if (this.app.session) {
            this.app.updateSession();
            break;
          }
      }
    });
    l(this, "onPointerDown", (e10, t10) => {
      if (e10.target === "canvas" && this.status === "idle") {
        let { currentPoint: n10 } = this.app;
        if (e10.spaceKey && t10.buttons === 1) return;
        if (this.status === "idle" && e10.altKey && e10.shiftKey) {
          this.setStatus("clonePainting"), this.clonePaint(n10);
          return;
        }
        if (!e10.shiftKey) {
          if (this.app.onShapeBlur(), e10.altKey && this.app.selectedIds.length > 0) {
            this.app.duplicate(this.app.selectedIds, n10);
            return;
          }
          this.selectNone();
        }
        this.setStatus("pointingCanvas");
      }
    });
    l(this, "onPointerUp", (e10) => {
      var t10;
      if (this.status === "translatingClone" || this.status === "pointingClone") {
        this.pointedId && (this.app.completeSession(), this.app.setEditingId(this.pointedId)), this.setStatus("idle"), this.pointedId = void 0;
        return;
      }
      if (this.status === "pointingBounds") {
        if (e10.target === "bounds") this.selectNone();
        else if (this.app.isSelected(e10.target)) e10.shiftKey ? this.pointedId !== e10.target && this.deselect(e10.target) : this.pointedId !== e10.target && this.app.selectedIds.length > 1 && this.select(e10.target);
        else if (this.pointedId === e10.target) {
          if (this.app.getShape(e10.target).isLocked) return;
          e10.shiftKey ? this.pushSelect(e10.target) : this.select(e10.target);
        }
      }
      this.setStatus("idle"), this.pointedBoundsHandle = void 0, this.pointedHandleId = void 0, this.pointedId = void 0, ((t10 = this.app.session) == null ? void 0 : t10.type) !== "edit" && this.app.completeSession();
    });
    l(this, "onDoubleClickCanvas", () => {
      !this.app.readOnly;
    });
    l(this, "onPointShape", (e10, t10) => {
      if (e10.spaceKey && t10.buttons === 1 || this.app.getShape(e10.target).isLocked) return;
      let { editingId: n10, hoveredId: o10 } = this.app.pageState;
      if (n10 && e10.target !== n10 && this.app.onShapeBlur(), (this.status === "idle" || this.status === "pointingBounds") && e10.metaKey && e10.shiftKey && o10) {
        this.pointedId = o10, this.app.isSelected(o10) ? this.deselect(o10) : (this.pushSelect(o10), this.setStatus("pointingBounds"));
        return;
      }
      if (this.status === "pointingBounds") {
        let { parentId: s10 } = this.app.getShape(e10.target);
        this.pointedId = s10 === this.app.currentPageId ? e10.target : s10;
        return;
      }
      if (this.status === "idle") {
        if (this.setStatus("pointingBounds"), e10.metaKey) {
          e10.shiftKey || this.selectNone(), this.app.startSession("brush"), this.setStatus("brushing");
          return;
        }
        let s10, { parentId: a10 } = this.app.getShape(e10.target);
        a10 === this.app.currentPageId ? (s10 = e10.target, this.selectedGroupId = void 0) : a10 === this.selectedGroupId ? s10 = e10.target : (s10 = a10, this.selectedGroupId = void 0), this.app.isSelected(s10) || (this.pointedId = s10, e10.shiftKey ? this.pushSelect(s10) : this.select(s10));
      }
    });
    l(this, "onDoubleClickShape", (e10) => {
      if (this.app.readOnly) return;
      let t10 = this.app.getShape(e10.target);
      if (t10.isLocked) {
        this.app.select(e10.target);
        return;
      }
      v.getShapeUtil(t10.type).canEdit && (t10.parentId === this.app.currentPageId || t10.parentId === this.selectedGroupId) && this.app.setEditingId(e10.target), t10.parentId !== this.app.currentPageId && (this.selectedGroupId = t10.parentId), this.app.select(e10.target);
    });
    l(this, "onRightPointShape", (e10) => {
      this.app.isSelected(e10.target) || this.app.select(e10.target);
    });
    l(this, "onHoverShape", (e10) => {
      this.app.setHoveredId(e10.target);
    });
    l(this, "onUnhoverShape", (e10) => {
      let { currentPageId: t10 } = this.app;
      requestAnimationFrame(() => {
        t10 === this.app.currentPageId && this.app.pageState.hoveredId === e10.target && this.app.setHoveredId(void 0);
      });
    });
    l(this, "onPointBounds", (e10) => {
      if (e10.metaKey) {
        e10.shiftKey || this.selectNone(), this.app.startSession("brush"), this.setStatus("brushing");
        return;
      }
      this.setStatus("pointingBounds");
    });
    l(this, "onRightPointBounds", (e10, t10) => {
      t10.stopPropagation();
    });
    l(this, "onReleaseBounds", () => {
      (this.status === "translating" || this.status === "brushing") && this.app.completeSession(), this.setStatus("idle");
    });
    l(this, "onPointBoundsHandle", (e10) => {
      this.pointedBoundsHandle = e10.target, this.setStatus("pointingBoundsHandle");
    });
    l(this, "onDoubleClickBoundsHandle", (e10) => {
      switch (e10.target) {
        case "center":
        case "left":
        case "right": {
          this.app.select(...v.getLinkedShapeIds(this.app.state, this.app.currentPageId, e10.target, e10.shiftKey));
          break;
        }
        default:
          if (this.app.selectedIds.length === 1) {
            this.app.resetBounds(this.app.selectedIds);
            let t10 = this.app.getShape(this.app.selectedIds[0]);
            "label" in t10 && this.app.setEditingId(t10.id);
          }
      }
    });
    l(this, "onReleaseBoundsHandle", () => {
      this.setStatus("idle");
    });
    l(this, "onPointHandle", (e10) => {
      this.pointedHandleId = e10.target, this.setStatus("pointingHandle");
    });
    l(this, "onDoubleClickHandle", (e10) => {
      if (e10.target === "bend") {
        let { selectedIds: t10 } = this.app;
        if (t10.length !== 1) return;
        let n10 = this.app.getShape(t10[0]);
        v.getShapeUtil(n10.type).canEdit && (n10.parentId === this.app.currentPageId || n10.parentId === this.selectedGroupId) && this.app.setEditingId(n10.id);
        return;
      }
      this.app.toggleDecoration(e10.target);
    });
    l(this, "onReleaseHandle", () => {
      this.setStatus("idle");
    });
    l(this, "onShapeClone", (e10) => {
      let t10 = this.app.selectedIds[0], n10 = this.getShapeClone(t10, e10.target);
      e10.target === "left" || e10.target === "right" || e10.target === "top" || e10.target === "bottom" ? n10 && (this.app.createShapes(n10), this.pointedId = n10.id, this.setStatus("pointingClone")) : (this.setStatus("gridCloning"), this.app.startSession("grid", t10));
    });
  }
  deselect(e10) {
    this.app.select(...this.app.selectedIds.filter((t10) => t10 !== e10));
  }
  select(e10) {
    this.app.select(e10);
  }
  pushSelect(e10) {
    let t10 = this.app.getShape(e10);
    this.app.select(...this.app.selectedIds.filter((n10) => n10 !== t10.parentId), e10);
  }
  selectNone() {
    this.app.selectNone();
  }
};
var lr = class extends nt {
  constructor() {
    super(...arguments);
    l(this, "type", "sticky");
    l(this, "shapeId");
    l(this, "onPointerDown", () => {
      if (!this.app.readOnly) {
        if (this.status === "creating") {
          this.setStatus("idle"), this.app.appState.isToolLocked || this.app.selectTool("select");
          return;
        }
        if (this.status === "idle") {
          let { currentPoint: e10, currentGrid: t10, settings: { showGrid: n10 }, appState: { currentPageId: o10, currentStyle: s10 } } = this.app, a10 = this.getNextChildIndex(), d10 = C$2.uniqueId();
          this.shapeId = d10;
          let i10 = Yr.create({ id: d10, parentId: o10, childIndex: a10, point: n10 ? p$4.snap(e10, t10) : e10, style: S({}, s10) }), c10 = Yr.getBounds(i10);
          i10.point = p$4.sub(i10.point, [c10.width / 2, c10.height / 2]), this.app.patchCreate([i10]), this.app.startSession("translate"), this.setStatus("creating");
        }
      }
    });
    l(this, "onPointerUp", () => {
      this.app.readOnly || this.status === "creating" && (this.setStatus("idle"), this.app.completeSession(), this.app.selectTool("select"), this.app.setEditingId(this.shapeId));
    });
  }
};
var dr = class extends nt {
  constructor() {
    super(...arguments);
    l(this, "type", "text");
    l(this, "stopEditingShape", () => {
      this.setStatus("idle"), this.app.appState.isToolLocked || this.app.selectTool("select");
    });
    l(this, "onKeyUp", () => {
    });
    l(this, "onKeyDown", () => {
    });
    l(this, "onPointerDown", () => {
      if (this.status === "creating") {
        this.stopEditingShape();
        return;
      }
      if (this.status === "idle") {
        let { currentPoint: e10, currentGrid: t10, settings: { showGrid: n10 } } = this.app;
        this.app.createTextShapeAtPoint(n10 ? p$4.snap(e10, t10) : e10, void 0, true), this.setStatus("creating");
        return;
      }
    });
    l(this, "onPointerUp", () => {
    });
    l(this, "onPointShape", (e10) => {
      if (this.app.readOnly) return;
      let t10 = this.app.getShape(e10.target);
      t10.type === "text" && (this.setStatus("idle"), this.app.setEditingId(t10.id));
    });
    l(this, "onShapeBlur", () => {
      this.app.readOnly || this.stopEditingShape();
    });
  }
};
var cr = class extends nt {
  constructor() {
    super(...arguments);
    l(this, "type", "triangle");
    l(this, "onPointerDown", () => {
      if (this.app.readOnly || this.status !== "idle") return;
      let { currentPoint: e10, currentGrid: t10, settings: { showGrid: n10 }, appState: { currentPageId: o10, currentStyle: s10 } } = this.app, a10 = this.getNextChildIndex(), d10 = C$2.uniqueId(), i10 = mi.create({ id: d10, parentId: o10, childIndex: a10, point: n10 ? p$4.snap(e10, t10) : e10, style: S({}, s10) });
      this.app.patchCreate([i10]), this.app.startSession("transformSingle", i10.id, He$1.BottomRight, true), this.setStatus("creating");
    });
  }
};
var Yi = C$2.uniqueId(), lt = class extends yi {
  constructor(e10, t10 = {}) {
    super(lt.defaultState, e10, lt.version, (n10, o10, s10) => Sn(x(S({}, o10), { document: x(S(S({}, o10.document), n10.document), { version: s10 }) }), lt.version));
    l(this, "callbacks", {});
    l(this, "tools", { select: new ar(this), erase: new or(this), ["text"]: new dr(this), ["draw"]: new tr(this), ["ellipse"]: new nr(this), ["rectangle"]: new sr(this), ["triangle"]: new cr(this), ["line"]: new rr(this), ["arrow"]: new er(this), ["sticky"]: new lr(this) });
    l(this, "currentTool", this.tools.select);
    l(this, "session");
    l(this, "readOnly", false);
    l(this, "isDirty", false);
    l(this, "isCreating", false);
    l(this, "originPoint", [0, 0]);
    l(this, "currentPoint", [0, 0]);
    l(this, "previousPoint", [0, 0]);
    l(this, "shiftKey", false);
    l(this, "altKey", false);
    l(this, "metaKey", false);
    l(this, "ctrlKey", false);
    l(this, "spaceKey", false);
    l(this, "isPointing", false);
    l(this, "isForcePanning", false);
    l(this, "isErasingWithPen", false);
    l(this, "isPastePrevented", false);
    l(this, "editingStartTime", -1);
    l(this, "fileSystemHandle", null);
    l(this, "viewport", C$2.getBoundsFromPoints([[0, 0], [100, 100]]));
    l(this, "rendererBounds", C$2.getBoundsFromPoints([[0, 0], [100, 100]]));
    l(this, "selectHistory", { stack: [[]], pointer: 0 });
    l(this, "clipboard");
    l(this, "rotationInfo", { selectedIds: [], center: [0, 0] });
    l(this, "migrate", (e11) => Sn(e11, lt.version));
    l(this, "onReady", () => {
      var e11, t11;
      this.loadDocument(this.document), Pi().then((n10) => {
        this.fileSystemHandle = n10;
      });
      try {
        this.patchState(x(S({}, Sn(this.state, lt.version)), { appState: { status: "idle" } }));
      } catch (n10) {
        console.error("The data appears to be corrupted. Resetting!", n10), localStorage.setItem(this.document.id + "_corrupted", JSON.stringify(this.document)), this.patchState(x(S({}, lt.defaultState), { appState: x(S({}, lt.defaultState.appState), { status: "idle" }) }));
      }
      (t11 = (e11 = this.callbacks).onMount) == null || t11.call(e11, this);
    });
    l(this, "cleanup", (e11, t11) => {
      var a10;
      let n10 = S({}, e11);
      n10.document !== t11.document && Object.entries(n10.document.pages).forEach(([d10, i10]) => {
        if (i10 === void 0) {
          delete n10.document.pages[d10], delete n10.document.pageStates[d10];
          return;
        }
        let c10 = t11.document.pages[d10], u10 = {};
        if (!c10 || i10.shapes !== c10.shapes || i10.bindings !== c10.bindings) {
          i10.shapes = S({}, i10.shapes), i10.bindings = S({}, i10.bindings);
          let m10 = /* @__PURE__ */ new Set();
          Object.entries(i10.shapes).forEach(([f10, T10]) => {
            var b10;
            let w10;
            T10 ? w10 = T10.parentId : (w10 = (b10 = c10 == null ? void 0 : c10.shapes[f10]) == null ? void 0 : b10.parentId, delete i10.shapes[f10]), i10.id === n10.appState.currentPageId && (c10 == null ? void 0 : c10.shapes[f10]) !== T10 && (u10[f10] = T10), w10 && w10 !== d10 && i10.shapes[w10] !== void 0 && m10.add(i10.shapes[w10]);
          }), Object.keys(i10.bindings).forEach((f10) => {
            i10.bindings[f10] || delete i10.bindings[f10];
          }), n10.document.pages[d10] = i10;
          let h10 = v.getRelatedBindings(n10, Object.keys(u10), d10), g10 = /* @__PURE__ */ new Set();
          h10.forEach((f10) => {
            if (!i10.bindings[f10.id]) return;
            let T10 = i10.shapes[f10.toId], w10 = i10.shapes[f10.fromId];
            if (!(T10 && w10)) {
              delete n10.document.pages[d10].bindings[f10.id];
              return;
            }
            if (g10.has(w10)) return;
            let b10 = v.updateArrowBindings(i10, w10);
            if (g10.add(w10), b10) {
              let y10 = S(S({}, w10), b10);
              i10.shapes[w10.id] = y10;
            }
          }), m10.forEach((f10) => {
            if (!f10) throw Error("no group!");
            let T10 = f10.children.filter((b10) => i10.shapes[b10] !== void 0), w10 = C$2.getCommonBounds(T10.map((b10) => i10.shapes[b10]).filter(Boolean).map((b10) => v.getRotatedBounds(b10)));
            i10.shapes[f10.id] = x(S({}, f10), { point: [w10.minX, w10.minY], size: [w10.width, w10.height], children: T10 });
          });
        }
        let p10 = S({}, n10.document.pageStates[d10]);
        p10.brush || delete p10.brush, p10.hoveredId && !i10.shapes[p10.hoveredId] && delete p10.hoveredId, p10.bindingId && !i10.bindings[p10.bindingId] && (v.warn(`Could not find the binding of ${d10}`), delete p10.bindingId), p10.editingId && !i10.shapes[p10.editingId] && (v.warn("Could not find the editing shape!"), delete p10.editingId), n10.document.pageStates[d10] = p10;
      }), Object.keys((a10 = n10.document.assets) != null ? a10 : {}).forEach((d10) => {
        var i10, c10;
        ((i10 = n10.document.assets) == null ? void 0 : i10[d10]) || (c10 = n10.document.assets) == null || delete c10[d10];
      });
      let o10 = n10.appState.currentPageId, s10 = n10.document.pageStates[o10];
      if (n10.room && n10.room !== t11.room) {
        let d10 = x(S({}, n10.room), { users: S({}, n10.room.users) });
        t11.room && Object.values(t11.room.users).filter(Boolean).forEach((i10) => {
          d10.users[i10.id] === void 0 && delete d10.users[i10.id];
        }), n10.room = d10;
      }
      return n10.room && (n10.room.users[n10.room.userId] = x(S({}, n10.room.users[n10.room.userId]), { point: this.currentPoint, selectedIds: s10.selectedIds })), this.readOnly && (n10.document.pages = t11.document.pages), n10;
    });
    l(this, "broadcastPatch", (e11, t11) => {
      var c10, u10, p10, m10, h10, g10, f10, T10, w10;
      let n10 = {}, o10 = {}, s10 = {}, a10 = (p10 = (u10 = (c10 = e11 == null ? void 0 : e11.document) == null ? void 0 : c10.pages) == null ? void 0 : u10[this.currentPageId]) == null ? void 0 : p10.shapes, d10 = (g10 = (h10 = (m10 = e11 == null ? void 0 : e11.document) == null ? void 0 : m10.pages) == null ? void 0 : h10[this.currentPageId]) == null ? void 0 : g10.bindings, i10 = (f10 = e11 == null ? void 0 : e11.document) == null ? void 0 : f10.assets;
      a10 && Object.keys(a10).forEach((b10) => {
        n10[b10] = this.getShape(b10, this.currentPageId);
      }), d10 && Object.keys(d10).forEach((b10) => {
        o10[b10] = this.getBinding(b10, this.currentPageId);
      }), i10 && Object.keys(i10).forEach((b10) => {
        s10[b10] = this.document.assets[b10];
      }), (w10 = (T10 = this.callbacks).onChangePage) == null || w10.call(T10, this, n10, o10, s10, t11);
    });
    l(this, "onPatch", (e11, t11, n10) => {
      var o10, s10, a10, d10, i10, c10;
      (this.callbacks.onChangePage && ((s10 = (o10 = t11 == null ? void 0 : t11.document) == null ? void 0 : o10.pages) == null ? void 0 : s10[this.currentPageId]) || ((a10 = t11 == null ? void 0 : t11.document) == null ? void 0 : a10.assets)) && (((d10 = t11 == null ? void 0 : t11.document) == null ? void 0 : d10.assets) || this.session && this.session.type !== "brush" && this.session.type !== "erase" && this.session.type !== "draw") && this.broadcastPatch(t11, false), (c10 = (i10 = this.callbacks).onPatch) == null || c10.call(i10, this, t11, n10);
    });
    l(this, "onCommand", (e11, t11, n10) => {
      var o10, s10;
      this.clearSelectHistory(), this.isDirty = true, (s10 = (o10 = this.callbacks).onCommand) == null || s10.call(o10, this, t11, n10);
    });
    l(this, "onReplace", () => {
      this.clearSelectHistory(), this.isDirty = false;
    });
    l(this, "onUndo", () => {
      var e11, t11;
      this.rotationInfo.selectedIds = [...this.selectedIds], (t11 = (e11 = this.callbacks).onUndo) == null || t11.call(e11, this);
    });
    l(this, "onRedo", () => {
      var e11, t11;
      this.rotationInfo.selectedIds = [...this.selectedIds], (t11 = (e11 = this.callbacks).onRedo) == null || t11.call(e11, this);
    });
    l(this, "onPersist", (e11, t11) => {
      var n10, o10;
      (o10 = (n10 = this.callbacks).onPersist) == null || o10.call(n10, this), this.broadcastPatch(t11, true);
    });
    l(this, "prevSelectedIds", this.selectedIds);
    l(this, "onStateDidChange", (e11, t11) => {
      var n10, o10, s10, a10;
      (o10 = (n10 = this.callbacks).onChange) == null || o10.call(n10, this, t11), this.room && this.selectedIds !== this.prevSelectedIds && ((a10 = (s10 = this.callbacks).onChangePresence) == null || a10.call(s10, this, x(S({}, this.room.users[this.room.userId]), { selectedIds: this.selectedIds, session: !!this.session })), this.prevSelectedIds = this.selectedIds);
    });
    l(this, "preventPaste", () => {
      if (this.isPastePrevented) return;
      let e11 = (n10) => n10.stopImmediatePropagation(), t11 = () => {
        setTimeout(() => {
          document.removeEventListener("paste", e11, { capture: true }), this.isPastePrevented = false;
        }, 50);
      };
      document.addEventListener("paste", e11, { capture: true }), window.addEventListener("pointerup", t11, { once: true }), this.isPastePrevented = true;
    });
    l(this, "justSent", false);
    l(this, "getReservedContent", (e11, t11 = this.currentPageId) => {
      let { bindings: n10 } = this.document.pages[t11], o10 = {}, s10 = {}, a10 = Object.values(n10), d10 = new Map(a10.map((h10) => [h10.toId, h10])), i10 = new Map(a10.map((h10) => [h10.fromId, h10])), c10 = [d10, i10], u10 = [];
      this.session && e11.forEach((h10) => u10.push(h10)), this.pageState.editingId && u10.push(this.pageState.editingId);
      let p10 = new Set(u10), m10 = /* @__PURE__ */ new Set();
      for (; u10.length > 0; ) {
        let h10 = u10.pop();
        if (!h10) break;
        if (m10.has(h10)) continue;
        m10.add(h10);
        let g10 = this.getShape(h10);
        o10[h10] = g10, g10.parentId !== t11 && u10.push(g10.parentId), g10.children && u10.push(...g10.children), c10.map((f10) => f10.get(g10.id)).filter(Boolean).forEach((f10) => {
          s10[f10.id] = f10, u10.push(f10.toId, f10.fromId);
        });
      }
      return { reservedShapes: o10, reservedBindings: s10, strongReservedShapeIds: p10 };
    });
    l(this, "replacePageContent", (e11, t11, n10, o10 = this.currentPageId) => {
      if (this.justSent) return this.justSent = false, this;
      let s10 = this.document.pages[this.currentPageId];
      return Object.values(e11).forEach((a10) => {
        a10.parentId !== o10 && !(s10.shapes[a10.parentId] || e11[a10.parentId]) && (console.warn("Added a shape without a parent on the page"), a10.parentId = o10);
      }), this.useStore.setState((a10) => {
        let { hoveredId: d10, editingId: i10, bindingId: c10, selectedIds: u10 } = a10.document.pageStates[o10], p10 = [...u10], m10 = i10 && a10.document.pages[this.currentPageId].shapes[i10];
        m10 && p10.push(m10.id);
        let { reservedShapes: h10, reservedBindings: g10, strongReservedShapeIds: f10 } = this.getReservedContent(p10, this.currentPageId);
        Object.values(h10).filter((k10) => !("text" in k10)).forEach((k10) => {
          let I10 = e11[k10.id];
          if (!!I10) {
            if (!(k10.type === "arrow" || f10.has(k10.id))) {
              e11[k10.id] = I10;
              return;
            }
            "decorations" in I10 && "decorations" in k10 && (e11[k10.id] = x(S({}, k10), { decorations: I10.decorations })), k10.style = I10.style;
          }
        });
        let T10 = S(S({}, e11), h10);
        m10 && (T10[m10.id] = m10);
        let w10 = S(S({}, t11), g10), b10 = S({}, n10), y10 = x(S({}, a10), { document: x(S({}, a10.document), { pages: { [o10]: x(S({}, a10.document.pages[o10]), { shapes: T10, bindings: w10 }) }, assets: b10, pageStates: x(S({}, a10.document.pageStates), { [o10]: x(S({}, a10.document.pageStates[o10]), { selectedIds: u10.filter((k10) => T10[k10] !== void 0), hoveredId: d10 ? T10[d10] === void 0 ? void 0 : d10 : void 0, editingId: i10, bindingId: c10 ? w10[c10] === void 0 ? void 0 : c10 : void 0 }) }) }) }), R10 = y10.document.pages[o10], U10 = v.getRelatedBindings(y10, Object.keys(T10), o10), L10 = /* @__PURE__ */ new Set();
        return U10.forEach((k10) => {
          if (!R10.bindings[k10.id]) return;
          let I10 = R10.shapes[k10.fromId];
          if (L10.has(I10)) return;
          let q10 = v.updateArrowBindings(R10, I10);
          if (L10.add(I10), q10) {
            let de2 = S(S({}, I10), q10);
            R10.shapes[I10.id] = de2;
          }
        }), Object.values(T10).forEach((k10) => {
          if (k10.type !== "group") return;
          let I10 = k10.children.filter((de2) => R10.shapes[de2] !== void 0), q10 = C$2.getCommonBounds(I10.map((de2) => R10.shapes[de2]).filter(Boolean).map((de2) => v.getRotatedBounds(de2)));
          R10.shapes[k10.id] = x(S({}, k10), { point: [q10.minX, q10.minY], size: [q10.width, q10.height], children: I10 });
        }), this.state.document = y10.document, y10;
      }, true), this;
    });
    l(this, "updateBounds", (e11) => {
      this.rendererBounds = e11;
      let { point: t11, zoom: n10 } = this.camera;
      this.updateViewport(t11, n10), !this.readOnly && this.session && this.session.update();
    });
    l(this, "updateViewport", (e11, t11) => {
      let { width: n10, height: o10 } = this.rendererBounds, [s10, a10] = e$3.sub(e$3.div([0, 0], t11), e11), [d10, i10] = e$3.sub(e$3.div([n10, o10], t11), e11);
      this.viewport = { minX: s10, minY: a10, maxX: d10, maxY: i10, width: d10 - s10, height: i10 - a10 };
    });
    l(this, "setEditingId", (e11, t11 = false) => {
      if (!this.readOnly) {
        if (e11) this.startSession("edit", e11, t11);
        else {
          if (!this.pageState.editingId) return;
          this.completeSession();
        }
        this.editingStartTime = performance.now(), this.patchState({ document: { pageStates: { [this.currentPageId]: { editingId: e11 } } } }, "set_editing_id");
      }
    });
    l(this, "setHoveredId", (e11) => {
      this.patchState({ document: { pageStates: { [this.currentPageId]: { hoveredId: e11 } } } }, "set_hovered_id");
    });
    l(this, "setSetting", (e11, t11) => {
      if (this.session) return this;
      let n10 = { settings: { [e11]: typeof t11 == "function" ? t11(this.settings[e11]) : t11 } };
      return this.patchState(n10, `settings:${e11}`), this.persist(n10), this;
    });
    l(this, "toggleFocusMode", () => {
      if (this.session) return this;
      let e11 = { settings: { isFocusMode: !this.settings.isFocusMode } };
      return this.patchState(e11, "settings:toggled_focus_mode"), this.persist(e11), this;
    });
    l(this, "togglePenMode", () => {
      if (this.session) return this;
      let e11 = { settings: { isPenMode: !this.settings.isPenMode } };
      return this.patchState(e11, "settings:toggled_pen_mode"), this.persist(e11), this;
    });
    l(this, "toggleDarkMode", () => {
      if (this.session) return this;
      let e11 = { settings: { isDarkMode: !this.settings.isDarkMode } };
      return this.patchState(e11, "settings:toggled_dark_mode"), this.persist(e11), this;
    });
    l(this, "toggleZoomSnap", () => {
      if (this.session) return this;
      let e11 = { settings: { isZoomSnap: !this.settings.isZoomSnap } };
      return this.patchState(e11, "settings:toggled_zoom_snap"), this.persist(e11), this;
    });
    l(this, "toggleDebugMode", () => {
      if (this.session) return this;
      let e11 = { settings: { isDebugMode: !this.settings.isDebugMode } };
      return this.patchState(e11, "settings:toggled_debug"), this.persist(e11), this;
    });
    l(this, "setMenuOpen", (e11) => {
      let t11 = { appState: { isMenuOpen: e11 } };
      return this.patchState(t11, "ui:toggled_menu_opened"), this.persist(t11), this;
    });
    l(this, "setIsLoading", (e11) => {
      let t11 = { appState: { isLoading: e11 } };
      return this.patchState(t11, "ui:toggled_is_loading"), this.persist(t11), this;
    });
    l(this, "setDisableAssets", (e11) => (this.patchState({ appState: { disableAssets: e11 } }, "ui:toggled_disable_images"), this));
    l(this, "toggleGrid", () => {
      if (this.session) return this;
      let e11 = { settings: { showGrid: !this.settings.showGrid } };
      return this.patchState(e11, "settings:toggled_grid"), this.persist(e11), this;
    });
    l(this, "selectTool", (e11) => {
      if (this.readOnly || this.session) return this;
      this.isPointing = false;
      let t11 = this.tools[e11];
      return t11 === this.currentTool ? (this.patchState({ appState: { isToolLocked: false } }), this) : (this.currentTool.onExit(), t11.previous = this.currentTool.type, this.currentTool = t11, this.currentTool.onEnter(), this.patchState({ appState: { activeTool: e11, isToolLocked: false } }, `selected_tool:${e11}`));
    });
    l(this, "toggleToolLock", () => this.session ? this : this.patchState({ appState: { isToolLocked: !this.appState.isToolLocked } }, "toggled_tool_lock"));
    l(this, "resetDocument", () => {
      if (this.session) return this;
      this.session = void 0, this.currentTool = this.tools.select;
      let e11 = lt.defaultDocument;
      return e11.pages.page.name = "Page 1", this.resetHistory().clearSelectHistory().loadDocument(lt.defaultDocument).persist({}), this;
    });
    l(this, "updateUsers", (e11, t11 = false) => {
      this.patchState({ room: { users: Object.fromEntries(e11.map((n10) => [n10.id, n10])) } }, t11 ? "room:self:update" : "room:user:update");
    });
    l(this, "removeUser", (e11) => {
      this.patchState({ room: { users: { [e11]: void 0 } } });
    });
    l(this, "mergeDocument", (e11) => {
      if (this.document.id !== e11.id) return this.replaceState(x(S({}, Sn(x(S({}, this.state), { document: e11 }), lt.version)), { appState: x(S({}, this.appState), { currentPageId: Object.keys(e11.pages)[0] }) })), this;
      let t11 = S({}, this.document.pageStates), n10 = x(S({}, this.appState), { currentPageId: e11.pages[this.currentPageId] ? this.currentPageId : Object.keys(e11.pages)[0], pages: Object.values(e11.pages).map((s10, a10) => ({ id: s10.id, name: s10.name, childIndex: s10.childIndex || a10 })) });
      this.resetHistory(), Object.keys(this.document.pages).forEach((s10) => {
        e11.pages[s10] || (s10 === this.appState.currentPageId && (this.cancelSession(), this.selectNone()), t11[s10] = void 0);
      }), this.session && this.selectedIds.filter((s10) => !e11.pages[this.currentPageId].shapes[s10]).forEach((s10) => e11.pages[this.currentPageId].shapes[s10] = this.page.shapes[s10]), Object.entries(t11).forEach(([s10, a10]) => {
        a10.selectedIds = a10.selectedIds.filter((d10) => !!e11.pages[s10].shapes[d10]);
      });
      let { editingId: o10 } = this.pageState;
      return o10 && (e11.pages[this.currentPageId].shapes[o10] = this.page.shapes[o10], t11[this.currentPageId].selectedIds = [o10]), this.replaceState(x(S({}, Sn(x(S({}, this.state), { document: x(S({}, e11), { pageStates: t11 }) }), lt.version)), { appState: n10 }), "merge");
    });
    l(this, "updateDocument", (e11, t11 = "updated_document") => {
      let n10 = this.state, o10 = x(S({}, n10), { document: x(S({}, n10.document), { assets: e11.assets }) });
      e11.pages[this.currentPageId] || (o10.appState = x(S({}, n10.appState), { currentPageId: Object.keys(e11.pages)[0] }));
      let s10 = 1;
      for (let a10 of Object.values(e11.pages)) a10 !== n10.document.pages[a10.id] && (o10.document.pages[a10.id] = a10, a10.name || (o10.document.pages[a10.id].name = `Page ${s10 + 1}`, s10++));
      for (let a10 of Object.values(e11.pageStates)) if (a10 !== n10.document.pageStates[a10.id]) {
        o10.document.pageStates[a10.id] = a10;
        let d10 = e11.pages[a10.id], i10 = ["bindingId", "editingId", "hoveredId", "pointedId"];
        for (let c10 of i10) d10.shapes[c10] || (a10[c10] = void 0);
        a10.selectedIds = a10.selectedIds.filter((c10) => !!e11.pages[d10.id].shapes[c10]);
      }
      return this.replaceState(Sn(o10, o10.document.version || 0), `${t11}:${e11.id}`);
    });
    l(this, "loadRoom", (e11) => (this.patchState({ room: { id: e11, userId: Yi, users: { [Yi]: { id: Yi, color: $s[Math.floor(Math.random() * $s.length)], point: [100, 100], selectedIds: [], activeShapes: [] } } } }), this));
    l(this, "loadDocument", (e11) => {
      this.setIsLoading(true), this.selectNone(), this.resetHistory(), this.clearSelectHistory(), this.session = void 0;
      let t11 = x(S({}, lt.defaultState), { settings: S({}, this.state.settings), document: e11, appState: x(S(S({}, lt.defaultState.appState), this.state.appState), { currentPageId: Object.keys(e11.pages)[0], disableAssets: this.disableAssets }) });
      this.replaceState(Sn(t11, lt.version), "loaded_document");
      let { point: n10, zoom: o10 } = this.camera;
      return this.updateViewport(n10, o10), this.setIsLoading(false), this;
    });
    l(this, "loadPageFromURL", (e11, t11) => {
      let n10 = e11.id, o10 = x(S({}, this.state.document), { pageStates: x(S({}, this.state.document.pageStates), { [n10]: t11 }), pages: x(S({}, this.document.pages), { [n10]: e11 }) });
      this.loadDocument(o10), this.persist({});
    });
    l(this, "newProject", () => {
      !this.isLocal || (this.fileSystemHandle = null, this.resetDocument());
    });
    l(this, "saveProject", () => pe(this, null, function* () {
      if (this.readOnly) return;
      let e11 = yield es(Sn(this.state, lt.version).document, this.fileSystemHandle);
      return this.fileSystemHandle = e11, this.persist({}), this.isDirty = false, this;
    }));
    l(this, "saveProjectAs", (e11) => pe(this, null, function* () {
      try {
        let t11 = yield es(this.document, null, e11);
        this.fileSystemHandle = t11, this.persist({}), this.isDirty = false;
      } catch (t11) {
        console.error(t11.message);
      }
      return this;
    }));
    l(this, "openProject", () => pe(this, null, function* () {
      if (!!this.isLocal) try {
        let e11 = yield Ei();
        if (!e11) throw Error();
        let { fileHandle: t11, document: n10 } = e11;
        this.loadDocument(n10), this.fileSystemHandle = t11, this.zoomToFit(), this.persist({});
      } catch (e11) {
        console.error(e11);
      } finally {
        this.persist({});
      }
    }));
    l(this, "openAsset", () => pe(this, null, function* () {
      if (!this.disableAssets) try {
        let e11 = yield Bi();
        if (Array.isArray(e11)) this.addMediaFromFiles(e11, this.centerPoint);
        else {
          if (!e11) return;
          this.addMediaFromFiles([e11]);
        }
      } catch (e11) {
        console.error(e11);
      } finally {
        this.persist({});
      }
    }));
    l(this, "signOut", () => {
    });
    l(this, "getAppState", () => this.appState);
    l(this, "getPage", (e11 = this.currentPageId) => v.getPage(this.state, e11 || this.currentPageId));
    l(this, "getShapes", (e11 = this.currentPageId) => v.getShapes(this.state, e11 || this.currentPageId));
    l(this, "getBindings", (e11 = this.currentPageId) => v.getBindings(this.state, e11 || this.currentPageId));
    l(this, "getShape", (e11, t11 = this.currentPageId) => v.getShape(this.state, e11, t11));
    l(this, "getShapeBounds", (e11, t11 = this.currentPageId) => v.getBounds(this.getShape(e11, t11)));
    l(this, "getBinding", (e11, t11 = this.currentPageId) => v.getBinding(this.state, e11, t11));
    l(this, "getPageState", (e11 = this.currentPageId) => v.getPageState(this.state, e11 || this.currentPageId));
    l(this, "getPagePoint", (e11, t11 = this.currentPageId) => {
      let { camera: n10 } = this.getPageState(t11);
      return e$3.sub(e$3.div(e11, n10.zoom), n10.point);
    });
    l(this, "createPage", (e11, t11) => {
      if (this.readOnly) return this;
      let { width: n10, height: o10 } = this.rendererBounds;
      return this.setState(Hd(this, [-n10 / 2, -o10 / 2], e11, t11));
    });
    l(this, "changePage", (e11) => this.setState(Rd(this, e11)));
    l(this, "movePage", (e11, t11) => this.readOnly ? this : this.setState(Wd(this, e11, t11)));
    l(this, "renamePage", (e11, t11) => this.readOnly ? this : this.setState(Ud(this, e11, t11)));
    l(this, "duplicatePage", (e11) => this.readOnly ? this : this.setState(jd(this, e11)));
    l(this, "deletePage", (e11) => this.readOnly ? this : Object.values(this.document.pages).length <= 1 ? this : this.setState(zd(this, e11 || this.currentPageId)));
    l(this, "cut", (e11 = this.selectedIds, t11) => (t11 == null || t11.preventDefault(), this.copy(e11, t11), this.readOnly || this.delete(e11), this));
    l(this, "copy", (e11 = this.selectedIds, t11) => {
      var s10;
      t11 == null || t11.preventDefault(), this.clipboard = this.getContent(e11);
      let o10 = `<tldraw>${JSON.stringify(S({ type: "tldr/clipboard", shapes: [], assets: [], bindings: [] }, this.clipboard))}</tldraw>`;
      return Md(o10), t11 && ((s10 = t11.clipboardData) == null || s10.setData("text/html", o10)), navigator.clipboard && window.ClipboardItem && navigator.clipboard.write([new ClipboardItem({ "text/html": new Blob([o10], { type: "text/html" }) })]), this;
    });
    l(this, "paste", (e11, t11) => pe(this, null, function* () {
      var c10, u10;
      if (this.readOnly) return;
      let n10 = [], o10 = [], s10, a10 = (p10) => pe(this, null, function* () {
        let m10 = document.createElement("div");
        m10.innerHTML = p10;
        let h10 = m10.firstChild;
        h10.style.setProperty("background-color", "transparent");
        let g10 = yield v.getImageForSvg(h10, "svg", { scale: 1, quality: 1 });
        if (g10) {
          let f10 = new File([g10], "image.svg");
          n10.push(f10);
        } else d10(p10);
      }), d10 = (p10) => {
        let m10 = this.getPagePoint(e11 != null ? e11 : this.centerPoint, this.currentPageId), h10 = p10.includes(`
`);
        o10.push(v.getShapeUtil("text").getShape({ id: C$2.uniqueId(), type: "text", parentId: this.appState.currentPageId, text: v.normalizeText(p10.trim()), point: m10, style: x(S({}, this.appState.currentStyle), { textAlign: h10 ? "start" : this.appState.currentStyle.textAlign }) }));
      }, i10 = (p10) => {
        var m10;
        try {
          let h10 = (m10 = p10.match(/<tldraw>(.*)<\/tldraw>/)) == null ? void 0 : m10[1];
          if (!h10) return;
          let g10 = JSON.parse(h10);
          if (g10.type === "tldr/clipboard") {
            s10 = g10;
            return;
          } else throw Error("Not tldraw data!");
        } catch (h10) {
          d10(p10);
        }
      };
      if (t11 !== void 0) {
        let p10 = Array.from((u10 = (c10 = t11.clipboardData) == null ? void 0 : c10.items) != null ? u10 : []);
        yield Promise.all(p10.map((m10) => pe(this, null, function* () {
          var f10;
          let { type: h10, kind: g10 } = m10;
          switch (g10) {
            case "string": {
              let T10 = yield new Promise((w10) => m10.getAsString(w10));
              switch (h10) {
                case "text/html": {
                  if ((f10 = T10.match(/<tldraw>(.*)<\/tldraw>/)) == null ? void 0 : f10[1]) {
                    i10(T10);
                    return;
                  }
                  break;
                }
                case "text/plain": {
                  T10.startsWith("<svg") ? yield a10(T10) : d10(T10);
                  break;
                }
              }
              break;
            }
            case "file": {
              let T10 = m10.getAsFile();
              T10 && n10.push(T10);
              break;
            }
          }
        })));
      }
      if (s10) return this.insertContent(s10, { point: e11, select: true }), this;
      if (n10.length) return this.addMediaFromFiles(n10, e11), this;
      if (o10.length) {
        let p10 = this.getPagePoint(e11 != null ? e11 : this.centerPoint, this.currentPageId), m10 = e$3.add(p10, [0, 0]);
        return o10.forEach((h10, g10) => {
          let f10 = v.getBounds(h10);
          g10 === 0 && (m10[0] -= f10.width / 2, m10[1] -= f10.height / 2), h10.point = [...m10], m10[0] += f10.width;
        }), this.createShapes(...o10), this;
      }
      return this.clipboard ? this.insertContent(this.clipboard) : Pd().then((p10) => {
        p10 && i10(p10);
      }), this;
    }));
    l(this, "getSvg", (...n10) => pe(this, [...n10], function* (e11 = this.selectedIds.length ? this.selectedIds : Object.keys(this.page.shapes), t11 = {}) {
      if (e11.length === 0) return;
      let o10 = document.createElementNS("http://www.w3.org/2000/svg", "svg"), s10 = document.createElementNS("http://www.w3.org/2000/svg", "defs"), a10 = document.createElementNS("http://www.w3.org/2000/svg", "style");
      if (typeof window != "undefined" && window.focus(), t11.includeFonts) try {
        let { fonts: h10 } = yield fetch(lt.assetSrc, { mode: "no-cors" }).then((g10) => g10.json());
        a10.textContent = `
          @font-face {
            font-family: 'Caveat Brush';
            src: url(data:application/x-font-woff;charset=utf-8;base64,${h10.caveat}) format('woff');
            font-weight: 500;
            font-style: normal;
          }
          @font-face {
            font-family: 'Source Code Pro';
            src: url(data:application/x-font-woff;charset=utf-8;base64,${h10.source_code_pro}) format('woff');
            font-weight: 500;
            font-style: normal;
          }
          @font-face {
            font-family: 'Source Sans Pro';
            src: url(data:application/x-font-woff;charset=utf-8;base64,${h10.source_sans_pro}) format('woff');
            font-weight: 500;
            font-style: normal;
          }
          @font-face {
            font-family: 'Crimson Pro';
            src: url(data:application/x-font-woff;charset=utf-8;base64,${h10.crimson_pro}) format('woff');
            font-weight: 500;
            font-style: normal;
          }
          `;
      } catch (h10) {
        v.warn("Could not find tldraw-assets.json file.");
      }
      else a10.textContent = "@import url('https://fonts.googleapis.com/css2?family=Caveat+Brush&family=Source+Code+Pro&family=Source+Sans+Pro&family=Crimson+Pro&display=block');";
      s10.append(a10), o10.append(s10);
      let d10 = e11.map((h10) => this.getShape(h10, this.currentPageId)).sort((h10, g10) => h10.childIndex - g10.childIndex), i10 = C$2.getCommonBounds(d10.map(v.getRotatedBounds)), c10 = (h10) => {
        let g10 = v.getShapeUtil(h10), f10 = g10.getBounds(h10), T10 = g10.getSvgElement(h10, this.settings.isDarkMode);
        if (!!T10) return h10.type === "image" ? T10.setAttribute("xlink:href", this.document.assets[h10.assetId].src) : h10.type === "video" && T10.setAttribute("xlink:href", this.serializeVideo(h10.id)), T10.setAttribute("transform", `translate(${(16 + h10.point[0] - i10.minX).toFixed(2)}, ${(16 + h10.point[1] - i10.minY).toFixed(2)}) rotate(${((h10.rotation || 0) * 180 / Math.PI).toFixed(2)}, ${(f10.width / 2).toFixed(2)}, ${(f10.height / 2).toFixed(2)})`), T10;
      };
      d10.forEach((h10) => {
        var f10;
        if ((f10 = h10.children) == null ? void 0 : f10.length) {
          let T10 = document.createElementNS("http://www.w3.org/2000/svg", "g");
          h10.children.forEach((w10) => {
            let b10 = this.getShape(w10, this.currentPageId), y10 = c10(b10);
            y10 && T10.append(y10);
          }), o10.append(T10);
          return;
        }
        let g10 = c10(h10);
        g10 && o10.append(g10);
      }), o10.setAttribute("viewBox", [0, 0, i10.width + 16 * 2, i10.height + 16 * 2].join(" ")), o10.setAttribute("width", (i10.width + 16 * 2).toString()), o10.setAttribute("height", (i10.height + 16 * 2).toString());
      let u10 = this.settings.exportBackground, p10 = "#212529", m10 = "rgb(248, 249, 250)";
      switch (u10) {
        case "auto": {
          o10.style.setProperty("background-color", this.settings.isDarkMode ? p10 : m10);
          break;
        }
        case "dark": {
          o10.style.setProperty("background-color", p10);
          break;
        }
        case "light": {
          o10.style.setProperty("background-color", m10);
          break;
        }
        case "transparent":
        default: {
          o10.style.setProperty("background-color", "transparent");
          break;
        }
      }
      return o10.querySelectorAll(".tl-fill-hitarea, .tl-stroke-hitarea, .tl-binding-indicator").forEach((h10) => h10.remove()), o10;
    }));
    l(this, "copySvg", (...t11) => pe(this, [...t11], function* (e11 = this.selectedIds.length ? this.selectedIds : Object.keys(this.page.shapes)) {
      if (e11.length === 0) return;
      let n10 = yield this.getSvg(e11);
      if (!n10) return;
      let o10 = v.getSvgString(n10, 1);
      this.clipboard = this.getContent(e11);
      let s10 = JSON.stringify(S({ type: "tldr/clipboard", shapes: [], assets: [], bindings: [] }, this.clipboard));
      return navigator.clipboard && window.ClipboardItem && navigator.clipboard.write([new ClipboardItem({ "text/html": new Blob([s10], { type: "text/html" }), "text/plain": new Blob([o10], { type: "text/plain" }) })]), o10;
    }));
    l(this, "getContent", (e11) => {
      let t11 = this.getPage(this.currentPageId);
      if (e11 && e11.length === 0 || (e11 || (e11 = this.selectedIds), e11.length === 0 && (e11 = Object.keys(t11.shapes)), e11.length === 0)) return;
      let n10 = e11.map((d10) => t11.shapes[d10]).flatMap((d10) => {
        var i10;
        return [d10, ...((i10 = d10.children) != null ? i10 : []).map((c10) => t11.shapes[c10])];
      }).map(St), o10 = new Set(n10.map((d10) => d10.id));
      n10.forEach((d10) => {
        d10.parentId === this.currentPageId && (d10.parentId = "currentPageId");
      });
      let s10 = Object.values(t11.bindings).filter((d10) => {
        if (o10.has(d10.fromId) || o10.has(d10.toId)) return true;
        if (o10.has(d10.fromId)) {
          let c10 = n10.find((u10) => u10.id === d10.fromId).handles;
          c10 && Object.values(c10).forEach((u10) => {
            u10.bindingId === d10.id && (u10.bindingId = void 0);
          });
        }
        if (o10.has(d10.toId)) {
          let c10 = n10.find((u10) => u10.id === d10.toId).handles;
          c10 && Object.values(c10).forEach((u10) => {
            u10.bindingId === d10.id && (u10.bindingId = void 0);
          });
        }
        return false;
      }).map(St), a10 = [...new Set(n10.map((d10) => {
        if (!!d10.assetId) return this.document.assets[d10.assetId];
      }).filter(Boolean).map(St))];
      return { shapes: n10, bindings: s10, assets: a10 };
    });
    l(this, "copyJson", (e11 = this.selectedIds) => {
      let t11 = this.getContent(e11);
      return t11 && v.copyStringToClipboard(JSON.stringify(t11)), this;
    });
    l(this, "exportJson", (e11 = this.selectedIds) => {
      let t11 = this.getContent(e11);
      if (t11) {
        let n10 = new Blob([JSON.stringify(t11)], { type: "application/json" }), o10 = URL.createObjectURL(n10), s10 = document.createElement("a");
        s10.href = o10, s10.download = "export.json", s10.click();
      }
      return this;
    });
    l(this, "insertContent", (e11, t11 = {}) => this.setState(nc(this, e11, t11), "insert_content"));
    l(this, "getImage", (...n10) => pe(this, [...n10], function* (e11 = "png", t11 = {}) {
      let { ids: o10 = this.selectedIds.length ? this.selectedIds : Object.keys(this.page.shapes) } = t11, s10 = yield this.getSvg(o10, { includeFonts: e11 !== "svg" });
      if (!s10) return;
      if (e11 === "svg") {
        let d10 = v.getSvgString(s10, 1);
        return new Blob([d10], { type: "image/svg+xml" });
      }
      let a10 = yield v.getImageForSvg(s10, e11, t11);
      if (!!a10) return a10;
    }));
    l(this, "copyImage", (...n10) => pe(this, [...n10], function* (e11 = "png", t11 = {}) {
      if (e11 === "svg") {
        this.copySvg(t11.ids);
        return;
      }
      if (!(navigator.clipboard && window.ClipboardItem)) {
        console.warn("Sorry, your browser does not support copying images.");
        return;
      }
      let o10 = yield this.getImage(e11, t11);
      !o10 || navigator.clipboard.write([new ClipboardItem({ [o10.type]: o10 })]);
    }));
    l(this, "exportImage", (...n10) => pe(this, [...n10], function* (e11 = "png", t11 = {}) {
      var d10;
      let { pageId: o10 = this.currentPageId } = t11, s10 = yield this.getImage(e11, t11);
      if (!s10) return;
      let a10 = (d10 = this.document.pages[o10].name) != null ? d10 : "export";
      if (this.callbacks.onExport) this.callbacks.onExport(this, { name: a10, type: e11, blob: s10 });
      else {
        let i10 = URL.createObjectURL(s10), c10 = document.createElement("a");
        c10.href = i10, c10.download = `${a10}.${e11}`, c10.click();
      }
    }));
    l(this, "setCamera", (e11, t11, n10) => (this.updateViewport(e11, t11), this.patchState({ document: { pageStates: { [this.currentPageId]: { camera: { point: e11, zoom: t11 } } } } }, n10), this));
    l(this, "resetCamera", () => this.setCamera(this.centerPoint, 1, "reset_camera"));
    l(this, "pan", (e11) => {
      let { camera: t11 } = this.pageState;
      return this.setCamera(e$3.toFixed(e$3.sub(t11.point, e11)), t11.zoom, "panned");
    });
    l(this, "pinchZoom", (e11, t11, n10) => {
      let { camera: o10 } = this.pageState, s10 = e$3.sub(o10.point, e$3.div(t11, o10.zoom)), a10 = n10, d10 = e$3.sub(e$3.div(e11, o10.zoom), s10), i10 = e$3.sub(e$3.div(e11, a10), s10);
      return this.setCamera(e$3.toFixed(e$3.add(s10, e$3.sub(i10, d10))), a10, "pinch_zoomed");
    });
    l(this, "zoomTo", (e11, t11 = this.centerPoint) => {
      let { zoom: n10, point: o10 } = this.camera, s10 = e$3.sub(e$3.div(t11, n10), o10), a10 = e$3.sub(e$3.div(t11, e11), o10);
      return this.setCamera(e$3.toFixed(e$3.add(o10, e$3.sub(a10, s10))), e11, "zoomed_camera");
    });
    l(this, "zoomIn", () => {
      let e11 = Math.round(this.camera.zoom * 100 / 25), t11 = v.getCameraZoom((e11 + 1) * 0.25);
      return this.zoomTo(t11);
    });
    l(this, "zoomOut", () => {
      let e11 = Math.round(this.camera.zoom * 100 / 25), t11 = v.getCameraZoom((e11 - 1) * 0.25);
      return this.zoomTo(t11);
    });
    l(this, "zoomToFit", () => {
      let { shapes: e11, pageState: { camera: t11 } } = this;
      if (e11.length === 0) return this;
      let { rendererBounds: n10 } = this, o10 = C$2.getCommonBounds(e11.map(v.getBounds)), s10 = v.getCameraZoom(Math.min((n10.width - 128) / o10.width, (n10.height - 128) / o10.height));
      s10 = t11.zoom === s10 || t11.zoom < 1 ? Math.min(1, s10) : s10;
      let a10 = (n10.width - o10.width * s10) / 2 / s10, d10 = (n10.height - o10.height * s10) / 2 / s10;
      return this.setCamera(e$3.toFixed(e$3.sub([a10, d10], [o10.minX, o10.minY])), s10, "zoomed_to_fit");
    });
    l(this, "zoomToSelection", () => {
      if (this.selectedIds.length === 0) return this;
      let { rendererBounds: e11 } = this, t11 = v.getSelectedBounds(this.state), n10 = v.getCameraZoom(Math.min((e11.width - 128) / t11.width, (e11.height - 128) / t11.height));
      n10 = this.camera.zoom === n10 || this.camera.zoom < 1 ? Math.min(1, n10) : n10;
      let o10 = (e11.width - t11.width * n10) / 2 / n10, s10 = (e11.height - t11.height * n10) / 2 / n10;
      return this.setCamera(e$3.toFixed(e$3.sub([o10, s10], [t11.minX, t11.minY])), n10, "zoomed_to_selection");
    });
    l(this, "zoomToContent", () => {
      let e11 = this.shapes, t11 = this.pageState;
      if (e11.length === 0) return this;
      let { rendererBounds: n10 } = this, { zoom: o10 } = t11.camera, s10 = C$2.getCommonBounds(e11.map(v.getBounds)), a10 = (n10.width - s10.width * o10) / 2 / o10, d10 = (n10.height - s10.height * o10) / 2 / o10;
      return this.setCamera(e$3.toFixed(e$3.sub([a10, d10], [s10.minX, s10.minY])), this.camera.zoom, "zoomed_to_content");
    });
    l(this, "resetZoom", () => this.zoomTo(1));
    l(this, "zoomBy", C$2.throttle((e11, t11) => {
      let { zoom: n10 } = this.camera, o10 = v.getCameraZoom(n10 - e11 * n10);
      return this.zoomTo(o10, t11);
    }, 16));
    l(this, "clearSelectHistory", () => (this.selectHistory.pointer = 0, this.selectHistory.stack = [this.selectedIds], this));
    l(this, "addToSelectHistory", (e11) => (this.selectHistory.pointer < this.selectHistory.stack.length && (this.selectHistory.stack = this.selectHistory.stack.slice(0, this.selectHistory.pointer + 1)), this.selectHistory.pointer++, this.selectHistory.stack.push(e11), this));
    l(this, "setSelectedIds", (e11, t11 = false) => {
      let n10 = t11 ? [...this.pageState.selectedIds, ...e11] : [...e11];
      return this.patchState({ appState: { activeTool: "select" }, document: { pageStates: { [this.currentPageId]: { selectedIds: n10 } } } }, "selected");
    });
    l(this, "undoSelect", () => (this.selectHistory.pointer > 0 && (this.selectHistory.pointer--, this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer])), this));
    l(this, "redoSelect", () => (this.selectHistory.pointer < this.selectHistory.stack.length - 1 && (this.selectHistory.pointer++, this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer])), this));
    l(this, "select", (...e11) => (e11.forEach((t11) => {
      if (!this.page.shapes[t11]) throw Error(`That shape does not exist on page ${this.currentPageId}`);
    }), this.setSelectedIds(e11), this.addToSelectHistory(e11), this));
    l(this, "selectAll", (e11 = this.currentPageId) => this.session ? this : (this.setSelectedIds(Object.values(this.document.pages[e11].shapes).filter((t11) => t11.parentId === e11).map((t11) => t11.id)), this.addToSelectHistory(this.selectedIds), this.selectTool("select"), this));
    l(this, "selectNone", () => (this.setSelectedIds([]), this.addToSelectHistory(this.selectedIds), this));
    l(this, "startSession", (e11, ...t11) => {
      var s10, a10;
      if (this.readOnly && e11 !== "brush") return this;
      this.session && (v.warn(`Already in a session! (${this.session.constructor.name})`), this.cancelSession());
      let n10 = dc(e11);
      this.session = new n10(this, ...t11);
      let o10 = this.session.start();
      return o10 && this.patchState(o10, `session:start_${this.session.constructor.name}`), (a10 = (s10 = this.callbacks).onSessionStart) == null || a10.call(s10, this, this.session.constructor.name), this;
    });
    l(this, "updateSession", () => {
      let { session: e11 } = this;
      if (!e11) return this;
      let t11 = e11.update();
      return t11 ? this.patchState(t11, `session:${e11 == null ? void 0 : e11.constructor.name}`) : this;
    });
    l(this, "cancelSession", () => {
      var n10, o10;
      let { session: e11 } = this;
      if (!e11) return this;
      this.session = void 0;
      let t11 = e11.cancel();
      return t11 && this.patchState(t11, `session:cancel:${e11.constructor.name}`), this.setEditingId(), (o10 = (n10 = this.callbacks).onSessionEnd) == null || o10.call(n10, this, e11.constructor.name), this;
    });
    l(this, "completeSession", () => {
      var n10, o10, s10, a10, d10, i10, c10, u10, p10;
      let { session: e11 } = this;
      if (!e11) return this;
      this.session = void 0;
      let t11 = e11.complete();
      if (t11 === void 0) this.isCreating = false, this.patchState({ appState: { status: "idle" }, document: { pageStates: { [this.currentPageId]: { editingId: void 0, bindingId: void 0, hoveredId: void 0 } } } }, `session:complete:${e11.constructor.name}`);
      else if ("after" in t11) {
        if (this.isCreating) {
          if (t11.before = { appState: x(S({}, t11.before.appState), { status: "idle" }), document: { pages: { [this.currentPageId]: { shapes: Object.fromEntries(this.selectedIds.map((m10) => [m10, void 0])) } }, pageStates: { [this.currentPageId]: { selectedIds: [], editingId: null, bindingId: null, hoveredId: null } } } }, this.appState.isToolLocked) {
            let m10 = ((s10 = (o10 = (n10 = t11.after) == null ? void 0 : n10.document) == null ? void 0 : o10.pageStates) == null ? void 0 : s10[this.currentPageId]) || {};
            m10.selectedIds = [];
          }
          this.isCreating = false;
        }
        t11.after.appState = x(S({}, t11.after.appState), { status: "idle" }), t11.after.document = x(S({}, t11.after.document), { pageStates: x(S({}, (a10 = t11.after.document) == null ? void 0 : a10.pageStates), { [this.currentPageId]: x(S({}, (((d10 = t11.after.document) == null ? void 0 : d10.pageStates) || {})[this.currentPageId]), { editingId: null }) }) }), this.setState(t11, `session:complete:${e11.constructor.name}`);
      } else this.patchState(x(S({}, t11), { appState: x(S({}, t11.appState), { status: "idle" }), document: x(S({}, t11.document), { pageStates: { [this.currentPageId]: x(S({}, (c10 = (i10 = t11.document) == null ? void 0 : i10.pageStates) == null ? void 0 : c10[this.currentPageId]), { editingId: null }) } }) }), `session:complete:${e11.constructor.name}`);
      return (p10 = (u10 = this.callbacks).onSessionEnd) == null || p10.call(u10, this, e11.constructor.name), this;
    });
    l(this, "createShapes", (...e11) => e11.length === 0 ? this : this.create(e11.map((t11) => v.getShapeUtil(t11.type).create(S({ parentId: this.currentPageId }, t11)))));
    l(this, "updateShapes", (...e11) => {
      let t11 = this.document.pages[this.currentPageId].shapes, n10 = e11.filter((o10) => t11[o10.id]);
      return n10.length === 0 ? this : this.setState(Di(this, n10, this.currentPageId), "updated_shapes");
    });
    l(this, "create", (e11 = [], t11 = []) => e11.length === 0 ? this : this.setState(wi(this, e11, t11)));
    l(this, "patchCreate", (e11 = [], t11 = []) => e11.length === 0 ? this : this.patchState(wi(this, e11, t11).after));
    l(this, "delete", (e11 = this.selectedIds) => {
      var n10, o10;
      if (e11.length === 0) return this;
      if (this.session) return this;
      let t11 = xi(this, e11);
      if (this.callbacks.onAssetDelete && ((n10 = t11.before.document) == null ? void 0 : n10.assets) && ((o10 = t11.after.document) == null ? void 0 : o10.assets)) {
        let s10 = Object.keys(t11.before.document.assets).filter((i10) => !!t11.before.document.assets[i10]), a10 = Object.keys(t11.after.document.assets).filter((i10) => !!t11.after.document.assets[i10]);
        s10.filter((i10) => !a10.includes(i10)).forEach((i10) => this.callbacks.onAssetDelete(this, i10));
      }
      return this.setState(t11);
    });
    l(this, "deleteAll", () => (this.selectAll(), this.delete(), this));
    l(this, "style", (e11, t11 = this.selectedIds) => this.setState(Xd(this, t11, e11)));
    l(this, "align", (e11, t11 = this.selectedIds) => t11.length < 2 ? this : this.setState(Bd(this, t11, e11)));
    l(this, "distribute", (e11, t11 = this.selectedIds) => t11.length < 3 ? this : this.setState(Fd(this, t11, e11)));
    l(this, "stretch", (e11, t11 = this.selectedIds) => t11.length < 2 ? this : this.setState(Zd(this, t11, e11)));
    l(this, "flipHorizontal", (e11 = this.selectedIds) => e11.length === 0 ? this : this.setState(vi(this, e11, "horizontal")));
    l(this, "flipVertical", (e11 = this.selectedIds) => e11.length === 0 ? this : this.setState(vi(this, e11, "vertical")));
    l(this, "moveToPage", (e11, t11 = this.currentPageId, n10 = this.selectedIds) => {
      if (n10.length === 0) return this;
      let { rendererBounds: o10 } = this;
      return this.setState(Nd(this, n10, o10, t11, e11)), this;
    });
    l(this, "moveToBack", (e11 = this.selectedIds) => e11.length === 0 ? this : this.setState(qo(this, e11, "toBack")));
    l(this, "moveBackward", (e11 = this.selectedIds) => e11.length === 0 ? this : this.setState(qo(this, e11, "backward")));
    l(this, "moveForward", (e11 = this.selectedIds) => e11.length === 0 ? this : this.setState(qo(this, e11, "forward")));
    l(this, "moveToFront", (e11 = this.selectedIds) => e11.length === 0 ? this : this.setState(qo(this, e11, "toFront")));
    l(this, "nudge", (e11, t11 = false, n10 = this.selectedIds) => {
      if (n10.length === 0) return this;
      let o10 = t11 ? this.settings.showGrid ? this.currentGrid * 4 : 10 : this.settings.showGrid ? this.currentGrid : 1;
      return this.setState(Qd(this, n10, e$3.mul(e11, o10)));
    });
    l(this, "duplicate", (e11 = this.selectedIds, t11) => this.readOnly ? this : e11.length === 0 ? this : this.setState(Gd(this, e11, t11)));
    l(this, "resetBounds", (e11 = this.selectedIds) => {
      let t11 = Ii(this, e11, this.currentPageId);
      return this.setState(Ii(this, e11, this.currentPageId), t11.id);
    });
    l(this, "toggleHidden", (e11 = this.selectedIds) => e11.length === 0 ? this : this.setState(Qr(this, e11, "isHidden")));
    l(this, "toggleLocked", (e11 = this.selectedIds) => e11.length === 0 ? this : this.setState(Qr(this, e11, "isLocked")));
    l(this, "toggleAspectRatioLocked", (e11 = this.selectedIds) => e11.length === 0 ? this : this.setState(Qr(this, e11, "isAspectRatioLocked")));
    l(this, "toggleDecoration", (e11, t11 = this.selectedIds) => t11.length === 0 || !(e11 === "start" || e11 === "end") ? this : this.setState(qd(this, t11, e11)));
    l(this, "setShapeProps", (e11, t11 = this.selectedIds) => this.setState(tc(this, t11, e11)));
    l(this, "rotate", (e11 = Math.PI * -0.5, t11 = this.selectedIds) => {
      if (t11.length === 0) return this;
      let n10 = _d(this, t11, e11);
      return n10 ? this.setState(n10) : this;
    });
    l(this, "group", (e11 = this.selectedIds, t11 = C$2.uniqueId(), n10 = this.currentPageId) => {
      if (this.readOnly) return this;
      if (e11.length === 1 && this.getShape(e11[0], n10).type === "group") return this.ungroup(e11, n10);
      if (e11.length < 2) return this;
      let o10 = Vd(this, e11, t11, n10);
      return o10 ? this.setState(o10) : this;
    });
    l(this, "ungroup", (e11 = this.selectedIds, t11 = this.currentPageId) => {
      if (this.readOnly) return this;
      let n10 = e11.map((s10) => this.getShape(s10, t11)).filter((s10) => s10.type === "group");
      if (n10.length === 0) return this;
      let o10 = ec(this, e11, n10, t11);
      return o10 ? this.setState(o10) : this;
    });
    l(this, "cancel", () => {
      var e11, t11;
      return (t11 = (e11 = this.currentTool).onCancel) == null || t11.call(e11), this;
    });
    l(this, "addMediaFromFiles", (n10, ...o10) => pe(this, [n10, ...o10], function* (e11, t11 = this.centerPoint) {
      this.setIsLoading(true);
      let s10 = [], a10 = this.getPagePoint(t11);
      for (let d10 of e11) {
        let i10 = C$2.uniqueId(), c10 = d10.name.match(/\.[0-9a-z]+$/i);
        if (!c10) throw Error("No extension");
        let u10 = Or.includes(c10[0].toLowerCase()), p10 = Fr.includes(c10[0].toLowerCase());
        if (!(u10 || p10)) throw Error("Wrong extension");
        let m10 = u10 ? "image" : "video", h10 = u10 ? "image" : "video", g10;
        try {
          if (this.callbacks.onAssetCreate) {
            let f10 = yield this.callbacks.onAssetCreate(this, d10, i10);
            if (!f10) throw Error("Asset creation callback returned false");
            g10 = f10;
          } else g10 = yield Ri(d10);
          if (typeof g10 == "string") {
            let f10 = [0, 0];
            if (u10) {
              if (c10[0] == ".svg") {
                let b10, y10 = yield Ai(d10), R10 = this.getViewboxFromSVG(y10);
                R10 && (b10 = R10.split(" "), f10[0] = parseFloat(b10[2]), f10[1] = parseFloat(b10[3]));
              }
              e$3.isEqual(f10, [0, 0]) && (f10 = yield Li(g10));
            } else f10 = yield Hi(g10);
            let T10 = Object.values(this.document.assets).find((b10) => b10.type === h10 && b10.src === g10), w10;
            if (T10) w10 = T10.id;
            else {
              w10 = i10;
              let b10 = { id: w10, type: h10, name: d10.name, src: g10, size: f10 };
              this.patchState({ document: { assets: { [w10]: b10 } } });
            }
            s10.push(this.getImageOrVideoShapeAtPoint(i10, m10, t11, f10, w10));
          }
        } catch (f10) {
          console.warn(f10);
        }
      }
      if (s10.length) {
        let d10 = e$3.add(a10, [0, 0]);
        s10.forEach((c10, u10) => {
          let p10 = v.getBounds(c10);
          u10 === 0 && (d10[0] -= p10.width / 2, d10[1] -= p10.height / 2), c10.point = [...d10], d10[0] += p10.width;
        });
        let i10 = C$2.getCommonBounds(s10.map(v.getBounds));
        this.createShapes(...s10), C$2.boundsContain(this.viewport, i10) || (this.zoomToSelection(), this.zoom > 1 && this.resetZoom());
      }
      return this.setIsLoading(false), this;
    }));
    l(this, "getViewboxFromSVG", (e11) => {
      let t11 = /.*?viewBox=["'](-?[\d.]+[, ]+-?[\d.]+[, ][\d.]+[, ][\d.]+)["']/;
      if (typeof e11 == "string") {
        let n10 = e11.match(t11);
        return n10 && n10.length >= 2 ? n10[1] : null;
      }
      return this.setIsLoading(false), null;
    });
    l(this, "onKeyDown", (e11, t11, n10) => {
      var o10, s10;
      switch (n10.key) {
        case "/": {
          if (this.status === "idle" && !this.pageState.editingId) {
            let { shiftKey: a10, metaKey: d10, altKey: i10, ctrlKey: c10, spaceKey: u10 } = this;
            this.onPointerDown({ target: "canvas", pointerId: 0, origin: t11.point, point: t11.point, delta: [0, 0], pressure: 0.5, shiftKey: a10, ctrlKey: c10, metaKey: d10, altKey: i10, spaceKey: u10 }, { shiftKey: a10, altKey: i10, ctrlKey: c10, pointerId: 0, clientX: t11.point[0], clientY: t11.point[1] });
          }
          break;
        }
        case "Escape": {
          this.cancel();
          break;
        }
        case "Meta": {
          this.metaKey = true;
          break;
        }
        case "Alt": {
          this.altKey = true;
          break;
        }
        case "Control": {
          this.ctrlKey = true;
          break;
        }
        case " ": {
          this.isForcePanning = true, this.spaceKey = true;
          break;
        }
      }
      return (s10 = (o10 = this.currentTool).onKeyDown) == null || s10.call(o10, e11, t11, n10), this;
    });
    l(this, "onKeyUp", (e11, t11, n10) => {
      var o10, s10;
      if (!!t11) {
        switch (n10.key) {
          case "/": {
            let { currentPoint: a10, shiftKey: d10, metaKey: i10, altKey: c10, ctrlKey: u10, spaceKey: p10 } = this;
            this.onPointerUp({ target: "canvas", pointerId: 0, origin: a10, point: a10, delta: [0, 0], pressure: 0.5, shiftKey: d10, ctrlKey: u10, metaKey: i10, altKey: c10, spaceKey: p10 }, { shiftKey: d10, altKey: c10, ctrlKey: u10, pointerId: 0, clientX: a10[0], clientY: a10[1] });
            break;
          }
          case "Meta": {
            this.metaKey = false;
            break;
          }
          case "Alt": {
            this.altKey = false;
            break;
          }
          case "Control": {
            this.ctrlKey = false;
            break;
          }
          case " ": {
            this.isForcePanning = false, this.spaceKey = false;
            break;
          }
        }
        (s10 = (o10 = this.currentTool).onKeyUp) == null || s10.call(o10, e11, t11, n10);
      }
    });
    l(this, "refreshBoundingBoxes", () => {
      let e11 = this.shapes.map((n10) => [n10.id, S({ point: [...n10.point] }, "label" in n10 && { label: "" })]), t11 = this.shapes.map((n10) => [n10.id, S({ point: [...n10.point] }, "label" in n10 && { label: n10.label })]);
      fl(), this.patchState({ document: { pages: { [this.currentPageId]: { shapes: Object.fromEntries(e11) } } } }), this.patchState({ document: { pages: { [this.currentPageId]: { shapes: Object.fromEntries(t11) } } } });
    });
    l(this, "onDragOver", (e11) => {
      e11.preventDefault();
    });
    l(this, "onDrop", (e11) => pe(this, null, function* () {
      var t11;
      return e11.preventDefault(), this.disableAssets ? this : (((t11 = e11.dataTransfer.files) == null ? void 0 : t11.length) && this.addMediaFromFiles(Object.values(e11.dataTransfer.files), [e11.clientX, e11.clientY]), this);
    }));
    l(this, "onPinchStart", (e11, t11) => {
      var n10, o10;
      (o10 = (n10 = this.currentTool).onPinchStart) == null || o10.call(n10, e11, t11);
    });
    l(this, "onPinchEnd", (e11, t11) => {
      var n10, o10;
      return (o10 = (n10 = this.currentTool).onPinchEnd) == null ? void 0 : o10.call(n10, e11, t11);
    });
    l(this, "onPinch", (e11, t11) => {
      var n10, o10;
      return (o10 = (n10 = this.currentTool).onPinch) == null ? void 0 : o10.call(n10, e11, t11);
    });
    l(this, "onPan", (e11, t11) => {
      if (this.appState.status === "pinching") return;
      let n10 = e$3.div(e11.delta, this.camera.zoom), o10 = this.camera.point, s10 = e$3.sub(o10, n10);
      e$3.isEqual(s10, o10) || (this.pan(n10), this.isForcePanning || this.onPointerMove(e11, t11), ul && this.isForcePanning && this.preventPaste());
    });
    l(this, "onZoom", (e11, t11) => {
      if (this.state.appState.status !== "idle") return;
      let n10 = e11.delta[2] / 50;
      this.zoomBy(n10, e11.point), this.onPointerMove(e11, t11);
    });
    l(this, "updateInputs", (e11) => {
      this.currentPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.shiftKey = e11.shiftKey, this.altKey = e11.altKey, this.ctrlKey = e11.ctrlKey, this.metaKey = e11.metaKey;
    });
    l(this, "onPointerMove", (e11, t11) => {
      var n10, o10, s10, a10, d10;
      if (this.previousPoint = this.currentPoint, this.updateInputs(e11, t11), this.isForcePanning && this.isPointing) {
        (n10 = this.onPan) == null || n10.call(this, x(S({}, e11), { delta: e$3.neg(e11.delta) }), t11);
        return;
      }
      if ((s10 = (o10 = this.currentTool).onPointerMove) == null || s10.call(o10, e11, t11), this.state.room) {
        let { users: i10, userId: c10 } = this.state.room;
        (d10 = (a10 = this.callbacks).onChangePresence) == null || d10.call(a10, this, x(S({}, i10[c10]), { point: this.getPagePoint(e11.point), session: !!this.session }));
      }
    });
    l(this, "onPointerDown", (e11, t11) => {
      var n10, o10;
      if (t11.buttons === 4) this.isForcePanning = true;
      else if (this.isPointing) return;
      this.isPointing = true, this.originPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.updateInputs(e11, t11), !this.isForcePanning && (this.currentTool.type === "draw" && t11.pointerType === "pen" && t11.button === 5 && (this.selectTool("erase"), this.isErasingWithPen = true), (o10 = (n10 = this.currentTool).onPointerDown) == null || o10.call(n10, e11, t11));
    });
    l(this, "onPointerUp", (e11, t11) => {
      var n10, o10;
      this.isPointing = false, this.shiftKey || (this.isForcePanning = false), this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onPointerUp) == null || o10.call(n10, e11, t11), this.isErasingWithPen && t11.pointerType === "pen" && t11.button === 5 && (this.selectTool("draw"), this.isErasingWithPen = false);
    });
    l(this, "onPointCanvas", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onPointCanvas) == null || o10.call(n10, e11, t11);
    });
    l(this, "onDoubleClickCanvas", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onDoubleClickCanvas) == null || o10.call(n10, e11, t11);
    });
    l(this, "onRightPointCanvas", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onRightPointCanvas) == null || o10.call(n10, e11, t11);
    });
    l(this, "onDragCanvas", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onDragCanvas) == null || o10.call(n10, e11, t11);
    });
    l(this, "onReleaseCanvas", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onReleaseCanvas) == null || o10.call(n10, e11, t11);
    });
    l(this, "onPointShape", (e11, t11) => {
      var n10, o10;
      this.originPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onPointShape) == null || o10.call(n10, e11, t11);
    });
    l(this, "onReleaseShape", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onReleaseShape) == null || o10.call(n10, e11, t11);
    });
    l(this, "onDoubleClickShape", (e11, t11) => {
      var n10, o10;
      this.originPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onDoubleClickShape) == null || o10.call(n10, e11, t11);
    });
    l(this, "onRightPointShape", (e11, t11) => {
      var n10, o10;
      this.originPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onRightPointShape) == null || o10.call(n10, e11, t11);
    });
    l(this, "onDragShape", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onDragShape) == null || o10.call(n10, e11, t11);
    });
    l(this, "onHoverShape", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onHoverShape) == null || o10.call(n10, e11, t11);
    });
    l(this, "onUnhoverShape", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onUnhoverShape) == null || o10.call(n10, e11, t11);
    });
    l(this, "onPointBounds", (e11, t11) => {
      var n10, o10;
      this.originPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onPointBounds) == null || o10.call(n10, e11, t11);
    });
    l(this, "onDoubleClickBounds", (e11, t11) => {
      var n10, o10;
      this.originPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onDoubleClickBounds) == null || o10.call(n10, e11, t11);
    });
    l(this, "onRightPointBounds", (e11, t11) => {
      var n10, o10;
      this.originPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onRightPointBounds) == null || o10.call(n10, e11, t11);
    });
    l(this, "onDragBounds", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onDragBounds) == null || o10.call(n10, e11, t11);
    });
    l(this, "onHoverBounds", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onHoverBounds) == null || o10.call(n10, e11, t11);
    });
    l(this, "onUnhoverBounds", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onUnhoverBounds) == null || o10.call(n10, e11, t11);
    });
    l(this, "onReleaseBounds", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onReleaseBounds) == null || o10.call(n10, e11, t11);
    });
    l(this, "onPointBoundsHandle", (e11, t11) => {
      var n10, o10;
      this.originPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onPointBoundsHandle) == null || o10.call(n10, e11, t11);
    });
    l(this, "onDoubleClickBoundsHandle", (e11, t11) => {
      var o10, s10;
      if (this.originPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.updateInputs(e11, t11), (s10 = (o10 = this.currentTool).onDoubleClickBoundsHandle) == null || s10.call(o10, e11, t11), this.selectedIds.length !== 1) return;
      let n10 = this.getShape(this.selectedIds[0]);
      if (n10.type === "image" || n10.type === "video") {
        let a10 = this.document.assets[n10.assetId], d10 = v.getShapeUtil(n10), i10 = d10.getCenter(n10), c10 = d10.getCenter(x(S({}, n10), { size: a10.size })), u10 = e$3.sub(c10, i10);
        this.updateShapes({ id: n10.id, point: e$3.sub(n10.point, u10), size: a10.size });
      }
    });
    l(this, "onRightPointBoundsHandle", (e11, t11) => {
      var n10, o10;
      this.originPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onRightPointBoundsHandle) == null || o10.call(n10, e11, t11);
    });
    l(this, "onDragBoundsHandle", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onDragBoundsHandle) == null || o10.call(n10, e11, t11);
    });
    l(this, "onHoverBoundsHandle", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onHoverBoundsHandle) == null || o10.call(n10, e11, t11);
    });
    l(this, "onUnhoverBoundsHandle", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onUnhoverBoundsHandle) == null || o10.call(n10, e11, t11);
    });
    l(this, "onReleaseBoundsHandle", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onReleaseBoundsHandle) == null || o10.call(n10, e11, t11);
    });
    l(this, "onPointHandle", (e11, t11) => {
      var n10, o10;
      this.originPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onPointHandle) == null || o10.call(n10, e11, t11);
    });
    l(this, "onDoubleClickHandle", (e11, t11) => {
      var n10, o10;
      this.originPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onDoubleClickHandle) == null || o10.call(n10, e11, t11);
    });
    l(this, "onRightPointHandle", (e11, t11) => {
      var n10, o10;
      this.originPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onRightPointHandle) == null || o10.call(n10, e11, t11);
    });
    l(this, "onDragHandle", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onDragHandle) == null || o10.call(n10, e11, t11);
    });
    l(this, "onHoverHandle", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onHoverHandle) == null || o10.call(n10, e11, t11);
    });
    l(this, "onUnhoverHandle", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onUnhoverHandle) == null || o10.call(n10, e11, t11);
    });
    l(this, "onReleaseHandle", (e11, t11) => {
      var n10, o10;
      this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onReleaseHandle) == null || o10.call(n10, e11, t11);
    });
    l(this, "onShapeChange", (e11) => {
      let t11 = this.document.pages[this.currentPageId].shapes, n10 = S(S({}, t11[e11.id]), e11), o10 = Di(this, [n10], this.currentPageId).after;
      return this.patchState(o10, "patched_shapes");
    });
    l(this, "onShapeBlur", () => {
      var n10, o10;
      if (performance.now() - this.editingStartTime < 50) return;
      let { editingId: e11 } = this.pageState, { isToolLocked: t11 } = this.getAppState();
      if (e11) {
        let s10 = this.getShape(e11);
        this.setEditingId(), s10.type === "text" && (s10.text.trim().length <= 0 ? this.patchState(xi(this, [e11]).after, "delete_empty_text") : t11 || this.select(e11));
      }
      (o10 = (n10 = this.currentTool).onShapeBlur) == null || o10.call(n10);
    });
    l(this, "onShapeClone", (e11, t11) => {
      var n10, o10;
      this.originPoint = this.getPagePoint(e11.point).concat(e11.pressure), this.updateInputs(e11, t11), (o10 = (n10 = this.currentTool).onShapeClone) == null || o10.call(n10, e11, t11);
    });
    l(this, "onRenderCountChange", (e11) => {
      let t11 = this.getAppState();
      t11.isEmptyCanvas && e11.length > 0 ? this.patchState({ appState: { isEmptyCanvas: false } }, "empty_canvas:false") : !t11.isEmptyCanvas && e11.length <= 0 && this.patchState({ appState: { isEmptyCanvas: true } }, "empty_canvas:true");
    });
    l(this, "onError", () => {
    });
    l(this, "getShapeUtil", v.getShapeUtil);
    this.callbacks = t10;
  }
  setStatus(e10) {
    return this.patchState({ appState: { status: e10 } }, `set_status:${e10}`);
  }
  get isMenuOpen() {
    return this.appState.isMenuOpen;
  }
  get isLoading() {
    return this.appState.isLoading;
  }
  get disableAssets() {
    return this.appState.disableAssets;
  }
  get history() {
    return this.stack.slice(0, this.pointer + 1);
  }
  set history(e10) {
    this.replaceHistory(e10);
  }
  get document() {
    return this.state.document;
  }
  get settings() {
    return this.state.settings;
  }
  get appState() {
    return this.state.appState;
  }
  get currentPageId() {
    return this.state.appState.currentPageId;
  }
  get page() {
    return this.state.document.pages[this.currentPageId];
  }
  get shapes() {
    return Object.values(this.page.shapes);
  }
  get bindings() {
    return Object.values(this.page.bindings);
  }
  get assets() {
    return Object.values(this.document.assets);
  }
  get pageState() {
    return this.state.document.pageStates[this.currentPageId];
  }
  get camera() {
    return this.pageState.camera;
  }
  get zoom() {
    return this.pageState.camera.zoom;
  }
  get selectedIds() {
    return this.pageState.selectedIds;
  }
  createTextShapeAtPoint(e10, t10, n10) {
    let { shapes: o10, appState: { currentPageId: s10, currentStyle: a10 } } = this, d10 = o10.length === 0 ? 1 : o10.filter((p10) => p10.parentId === s10).sort((p10, m10) => m10.childIndex - p10.childIndex)[0].childIndex + 1, i10 = En["text"], c10 = i10.create({ id: t10 || C$2.uniqueId(), parentId: s10, childIndex: d10, point: e10, style: S({}, a10) }), u10 = i10.getBounds(c10);
    return c10.point = e$3.sub(c10.point, [u10.width / 2, u10.height / 2]), n10 ? this.patchCreate([v.getShapeUtil(c10.type).create(c10)]) : this.createShapes(c10), this.setEditingId(c10.id, true), this;
  }
  getImageOrVideoShapeAtPoint(e10, t10, n10, o10, s10) {
    let { shapes: a10, appState: { currentPageId: d10, currentStyle: i10 } } = this, c10 = a10.length === 0 ? 1 : a10.filter((m10) => m10.parentId === d10).sort((m10, h10) => h10.childIndex - m10.childIndex)[0].childIndex + 1, u10 = En[t10];
    if (o10[0] > this.viewport.width) {
      let m10 = o10[1] / o10[0];
      o10[0] = this.viewport.width - 128 / this.camera.zoom * 2, o10[1] = o10[0] * m10, (o10[1] < 32 || o10[1] < 32) && (o10[1] = 32, o10[0] = o10[1] / m10);
    } else if (o10[1] > this.viewport.height) {
      let m10 = o10[0] / o10[1];
      o10[1] = this.viewport.height - 128 / this.camera.zoom * 2, o10[0] = o10[1] * m10, (o10[1] < 32 || o10[1] < 32) && (o10[0] = 32, o10[1] = o10[0] / m10);
    }
    return u10.create({ id: e10, parentId: d10, childIndex: c10, point: n10, size: o10, style: S({}, i10), assetId: s10 });
  }
  isSelected(e10) {
    return this.selectedIds.includes(e10);
  }
  serializeVideo(e10) {
    let t10 = document.getElementById(e10 + "_video");
    if (t10) {
      let n10 = document.createElement("canvas");
      return n10.width = t10.videoWidth, n10.height = t10.videoHeight, n10.getContext("2d").drawImage(t10, 0, 0), n10.toDataURL("image/png");
    } else throw new Error("Video with id " + e10 + " not found");
  }
  serializeImage(e10) {
    let t10 = document.getElementById(e10 + "_image");
    if (t10) {
      let n10 = document.createElement("canvas");
      return n10.width = t10.width, n10.height = t10.height, n10.getContext("2d").drawImage(t10, 0, 0), n10.toDataURL("image/png");
    } else throw new Error("Image with id " + e10 + " not found");
  }
  patchAssets(e10) {
    this.document.assets = S(S({}, this.document.assets), e10);
  }
  get room() {
    return this.state.room;
  }
  get isLocal() {
    return this.state.room === void 0 || this.state.room.id === "local";
  }
  get status() {
    return this.appState.status;
  }
  get currentUser() {
    if (!!this.state.room) return this.state.room.users[this.state.room.userId];
  }
  get centerPoint() {
    let { width: e10, height: t10 } = this.rendererBounds;
    return e$3.toFixed([e10 / 2, t10 / 2]);
  }
  get currentGrid() {
    let { zoom: e10 } = this.camera;
    return e10 < 0.15 ? 8 * 16 : e10 < 1 ? 8 * 4 : 8 * 1;
  }
}, An = lt;
l(An, "version", 15.5), l(An, "defaultDocument", { id: "doc", name: "New Document", version: lt.version, pages: { page: { id: "page", name: "Page 1", childIndex: 1, shapes: {}, bindings: {} } }, pageStates: { page: { id: "page", selectedIds: [], camera: { point: [0, 0], zoom: 1 } } }, assets: {} }), l(An, "defaultState", { settings: { isCadSelectMode: false, isPenMode: false, isDarkMode: false, isZoomSnap: false, isFocusMode: false, isSnapping: false, isDebugMode: false, isReadonlyMode: false, keepStyleMenuOpen: false, nudgeDistanceLarge: 16, nudgeDistanceSmall: 1, showRotateHandles: true, showBindingHandles: true, showCloneHandles: false, showGrid: false, language: "en", dockPosition: "bottom", exportBackground: "transparent" }, appState: { status: "idle", activeTool: "select", hoveredId: void 0, currentPageId: "page", currentStyle: ct, isToolLocked: false, isMenuOpen: false, isEmptyCanvas: false, eraseLine: [], snapLines: [], isLoading: false, disableAssets: false }, document: lt.defaultDocument }), l(An, "assetSrc", "tldraw-assets.json");
var Zpe = ErrorBoundary, Xpe = window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)").matches : false;
function AAe({ id: r10, document: e10, currentPageId: t10, autofocus: n10 = true, showMenu: o10 = true, showMultiplayerMenu: s10 = true, showPages: a10 = true, showTools: d10 = true, showZoom: i10 = true, showStyles: c10 = true, showUI: u10 = true, readOnly: p10 = false, disableAssets: m10 = false, darkMode: h10 = Xpe, components: g10, onMount: f10, onChange: T10, onChangePresence: w10, onNewProject: b10, onSaveProject: y10, onSaveProjectAs: R10, onOpenProject: U10, onOpenMedia: L10, onUndo: k10, onRedo: I10, onPersist: q10, onPatch: de2, onCommand: le2, onChangePage: Ae, onAssetCreate: Ce2, onAssetDelete: De2, onAssetUpload: Ve, onSessionStart: $e, onSessionEnd: jt, onExport: on2, hideCursors: Lo }) {
  let [co, ur] = reactExports.useState(r10), [Ne, hr] = reactExports.useState(() => new An(r10, { onMount: f10, onChange: T10, onChangePresence: w10, onNewProject: b10, onSaveProject: y10, onSaveProjectAs: R10, onOpenProject: U10, onOpenMedia: L10, onUndo: k10, onRedo: I10, onPersist: q10, onPatch: de2, onCommand: le2, onChangePage: Ae, onAssetDelete: De2, onAssetCreate: Ce2, onAssetUpload: Ve, onSessionStart: $e, onSessionEnd: jt })), [Ln2, ns] = reactExports.useState(null), [Hn2, Ho] = reactExports.useState(null), [zo, pc] = reactExports.useState(null), [uc, Zi] = reactExports.useState(null), hc = reactExports.useCallback((eo, mr, mc, gc) => {
    Zi(() => eo), ns(() => gc), Ho(() => mr), pc(() => mc);
  }, []);
  return reactExports.useLayoutEffect(() => {
    if (r10 === co) return;
    let eo = new An(r10, { onMount: f10, onChange: T10, onChangePresence: w10, onNewProject: b10, onSaveProject: y10, onSaveProjectAs: R10, onOpenProject: U10, onOpenMedia: L10, onUndo: k10, onRedo: I10, onPersist: q10, onPatch: de2, onCommand: le2, onChangePage: Ae, onAssetDelete: De2, onAssetCreate: Ce2, onAssetUpload: Ve, onExport: on2, onSessionStart: $e, onSessionEnd: jt });
    ur(r10), hr(eo);
  }, [co, r10]), reactExports.useEffect(() => {
    !e10 || (e10.id === Ne.document.id ? Ne.updateDocument(e10) : Ne.loadDocument(e10));
  }, [e10, Ne]), reactExports.useEffect(() => {
    Ne.setDisableAssets(m10);
  }, [Ne, m10]), reactExports.useEffect(() => {
    !t10 || Ne.changePage(t10);
  }, [t10, Ne]), reactExports.useEffect(() => {
    Ne.readOnly = p10, p10 || (Ne.selectNone(), Ne.cancelSession(), Ne.setEditingId());
  }, [Ne, p10]), reactExports.useEffect(() => {
    h10 !== Ne.settings.isDarkMode && Ne.toggleDarkMode();
  }, [Ne, h10]), reactExports.useEffect(() => {
    Ne.callbacks = { onMount: f10, onChange: T10, onChangePresence: w10, onNewProject: b10, onSaveProject: y10, onSaveProjectAs: R10, onOpenProject: U10, onOpenMedia: L10, onUndo: k10, onRedo: I10, onPersist: q10, onPatch: de2, onCommand: le2, onChangePage: Ae, onAssetDelete: De2, onAssetCreate: Ce2, onAssetUpload: Ve, onExport: on2, onSessionStart: $e, onSessionEnd: jt };
  }, [f10, T10, w10, b10, y10, R10, U10, L10, k10, I10, q10, de2, le2, Ae, De2, Ce2, Ve, on2, $e, jt]), reactExports.useLayoutEffect(() => {
    var mr;
    if (typeof window == "undefined" || !((mr = window.document) == null ? void 0 : mr.fonts)) return;
    function eo() {
      Ne.refreshBoundingBoxes();
    }
    return window.document.fonts.addEventListener("loadingdone", eo), () => {
      window.document.fonts.removeEventListener("loadingdone", eo);
    };
  }, [Ne]), reactExports.createElement(hs.Provider, { value: Ne }, reactExports.createElement(gs.Provider, { value: { onYes: Hn2, onCancel: Ln2, onNo: zo, dialogState: uc, setDialogState: Zi, openDialog: hc } }, reactExports.createElement(qpe, { key: co || "Tldraw", id: co, autofocus: n10, showPages: a10, showMenu: o10, showMultiplayerMenu: s10, showStyles: c10, showZoom: i10, showTools: d10, showUI: u10, readOnly: p10, components: g10, hideCursors: Lo })));
}
var qpe = reactExports.memo(function({ id: e10, autofocus: t10, showPages: n10, showMenu: o10, showMultiplayerMenu: s10, showZoom: a10, showStyles: d10, showTools: i10, readOnly: c10, showUI: u10, components: p10, hideCursors: m10 }) {
  var Ne, hr;
  let h10 = me(), [g10, f10] = reactExports.useState(null), T10 = reactExports.useRef(null), w10 = h10.useStore(), { document: b10, settings: y10, appState: R10, room: U10 } = w10, L10 = w10.appState.activeTool === "select", k10 = b10.pages[R10.currentPageId], I10 = b10.pageStates[k10.id], q10 = b10.assets, { selectedIds: de2 } = I10, le2 = de2.length === 1 && k10.shapes[de2[0]] && v.getShapeUtil(k10.shapes[de2[0]].type).hideBounds, Ae = de2.length === 1 && k10.shapes[de2[0]] && v.getShapeUtil(k10.shapes[de2[0]].type).hideResizeHandles, Ce2 = reactExports.useMemo(() => ({ isDarkMode: y10.isDarkMode }), [y10.isDarkMode]), De2 = y10.isCadSelectMode ? !R10.selectByContain : R10.selectByContain, Ve = reactExports.useMemo(() => {
    let { selectByContain: Ln2 } = R10, { isDarkMode: ns, isCadSelectMode: Hn2 } = y10;
    if (ns) {
      let zo = Hn2 ? Ln2 ? "69, 155, 255" : "105, 209, 73" : "180, 180, 180";
      return { brushFill: `rgba(${zo}, ${Hn2 ? 0.08 : 0.05})`, brushStroke: `rgba(${zo}, ${Hn2 ? 0.5 : 0.25})`, brushDashStroke: `rgba(${zo}, .6)`, selected: "rgba(38, 150, 255, 1.000)", selectFill: "rgba(38, 150, 255, 0.05)", background: "#212529", foreground: "#49555f" };
    }
    let Ho = Hn2 ? Ln2 ? "0, 89, 242" : "51, 163, 23" : "0,0,0";
    return { brushFill: `rgba(${Ho}, ${Hn2 ? 0.08 : 0.05})`, brushStroke: `rgba(${Ho}, ${Hn2 ? 0.4 : 0.25})`, brushDashStroke: `rgba(${Ho}, .6)` };
  }, [y10.isDarkMode, y10.isCadSelectMode, R10.selectByContain]), $e = h10.session !== void 0, jt = $e && ((Ne = h10.session) == null ? void 0 : Ne.constructor.name) !== "BrushSession" || !L10 || le2 || !!I10.editingId, on2 = $e || !L10, Lo = $e && w10.appState.status !== "brushing" || !L10, co = $e || !L10 || I10.camera.zoom < 0.2, ur = Ea(y10.language);
  return reactExports.useLayoutEffect(() => {
    let Ln2 = T10.current;
    !Ln2 || (y10.isDarkMode ? Ln2.classList.add(is) : Ln2.classList.remove(is));
  }, [y10.isDarkMode]), Cd(T10), reactExports.createElement(ms.Provider, { value: T10 }, reactExports.createElement(IntlProvider, { locale: ur.locale, messages: ur.messages }, reactExports.createElement(Ha, { container: g10 }), reactExports.createElement(Qpe, { ref: T10, tabIndex: -0 }, reactExports.createElement(Ts, null), reactExports.createElement(Jpe, { focusableRef: T10, autofocus: t10 }), reactExports.createElement(Ba, null, reactExports.createElement(Zpe, { FallbackComponent: Ra }, reactExports.createElement(ks, { id: e10, containerRef: T10, shapeUtils: En, page: k10, pageState: I10, assets: q10, snapLines: R10.snapLines, eraseLine: R10.eraseLine, grid: 8, users: U10 == null ? void 0 : U10.users, userId: U10 == null ? void 0 : U10.userId, theme: Ve, meta: Ce2, components: p10, hideCursors: m10, hideBounds: jt, hideHandles: on2, hideResizeHandles: Ae, hideIndicators: Lo, hideBindingHandles: !y10.showBindingHandles, hideCloneHandles: co, hideRotateHandles: !y10.showRotateHandles, hideGrid: !y10.showGrid, showDashedBrush: De2, performanceMode: (hr = h10.session) == null ? void 0 : hr.performanceMode, onPinchStart: h10.onPinchStart, onPinchEnd: h10.onPinchEnd, onPinch: h10.onPinch, onPan: h10.onPan, onZoom: h10.onZoom, onPointerDown: h10.onPointerDown, onPointerMove: h10.onPointerMove, onPointerUp: h10.onPointerUp, onPointCanvas: h10.onPointCanvas, onDoubleClickCanvas: h10.onDoubleClickCanvas, onRightPointCanvas: h10.onRightPointCanvas, onDragCanvas: h10.onDragCanvas, onReleaseCanvas: h10.onReleaseCanvas, onPointShape: h10.onPointShape, onDoubleClickShape: h10.onDoubleClickShape, onRightPointShape: h10.onRightPointShape, onDragShape: h10.onDragShape, onHoverShape: h10.onHoverShape, onUnhoverShape: h10.onUnhoverShape, onReleaseShape: h10.onReleaseShape, onPointBounds: h10.onPointBounds, onDoubleClickBounds: h10.onDoubleClickBounds, onRightPointBounds: h10.onRightPointBounds, onDragBounds: h10.onDragBounds, onHoverBounds: h10.onHoverBounds, onUnhoverBounds: h10.onUnhoverBounds, onReleaseBounds: h10.onReleaseBounds, onPointBoundsHandle: h10.onPointBoundsHandle, onDoubleClickBoundsHandle: h10.onDoubleClickBoundsHandle, onRightPointBoundsHandle: h10.onRightPointBoundsHandle, onDragBoundsHandle: h10.onDragBoundsHandle, onHoverBoundsHandle: h10.onHoverBoundsHandle, onUnhoverBoundsHandle: h10.onUnhoverBoundsHandle, onReleaseBoundsHandle: h10.onReleaseBoundsHandle, onPointHandle: h10.onPointHandle, onDoubleClickHandle: h10.onDoubleClickHandle, onRightPointHandle: h10.onRightPointHandle, onDragHandle: h10.onDragHandle, onHoverHandle: h10.onHoverHandle, onUnhoverHandle: h10.onUnhoverHandle, onReleaseHandle: h10.onReleaseHandle, onError: h10.onError, onRenderCountChange: h10.onRenderCountChange, onShapeChange: h10.onShapeChange, onShapeBlur: h10.onShapeBlur, onShapeClone: h10.onShapeClone, onBoundsChange: h10.updateBounds, onKeyDown: h10.onKeyDown, onKeyUp: h10.onKeyUp, onDragOver: h10.onDragOver, onDrop: h10.onDrop }))), u10 && reactExports.createElement(eue, { ref: f10 }, y10.isFocusMode ? reactExports.createElement(Aa, { onSelect: h10.toggleFocusMode }) : reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Id, { readOnly: c10, showPages: n10, showMenu: o10, showMultiplayerMenu: s10, showStyles: d10, showZoom: a10 }), reactExports.createElement(tue, null), i10 && !c10 && reactExports.createElement(il, null))))));
}), Jpe = reactExports.memo(function({ focusableRef: e10, autofocus: t10 }) {
  return Ji(e10), reactExports.useEffect(() => {
    var n10;
    t10 && ((n10 = e10.current) == null || n10.focus());
  }, [t10]), null;
}), Qpe = H2("div", { position: "absolute", height: "100%", width: "100%", minHeight: 0, minWidth: 0, maxHeight: "100%", maxWidth: "100%", overflow: "hidden", boxSizing: "border-box", outline: "none", userSelect: "none", WebkitUserSelect: "none", "& .tl-container": { position: "absolute", top: 0, left: 0, height: "100%", width: "100%", zIndex: 1 }, "& input, textarea, button, select, label, button": { webkitTouchCallout: "none", webkitUserSelect: "none", "-webkit-tap-highlight-color": "transparent", "tap-highlight-color": "transparent" } }), eue = H2("div", { position: "absolute", top: 0, left: 0, height: "100%", width: "100%", padding: "8px 8px 0 8px", display: "flex", alignItems: "flex-start", justifyContent: "flex-start", pointerEvents: "none", zIndex: 2, "& > *": { pointerEvents: "all" } }), tue = H2("div", { flexGrow: 2 });
clientExports.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(AAe, { showMultiplayerMenu: false })
